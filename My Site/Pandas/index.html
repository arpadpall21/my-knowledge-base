<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title> Pandas </title>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../Assets/stylesPages.css">
    <script src="../Assets/scriptPages.js"></script>
  </head>

  <body>
    <h1> Pandas </h1>
    <p> Updated: ( 2026-01-02 ) </p>
    <p class="sitenav"> <a href="../index.html" title="home">MySite></a> Pandas </p>

    <table class="table">
      <tr>
        <th style="width:30%;"> Method / Property </th>
        <th> Description </th>
      </tr>
      <tr>
        <td>
          <lit>pd</lit>.DataFrame(<optval class="openable">data<div>
              <p> - 2d array </p>
              <p> - list of lists </p>
              <p> - dictionary of arrays/lists (the keys will be used as column labels and the values will be used as column data) </p>
              <p> - Series </p>
              <p> - another DataFrame </p>
            </div></optval>, <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html" target="_blank">args</a>)
        </td>
        <td>
          - creates and returns a <reqval>df</reqval> (DataFrame) which is a two-dimensional, size-mutable, potentially heterogeneous (mixed data types) tabular data<br>
        </td>
      </tr>
      <tr>
        <td>
          <lit>pd</lit>.Series(<optval class="openable">data<div>
              <p> - 1d array </p>
              <p> - list </p>
              <p> - dictionary (the keys will be used as index labels and the values will be used as data) </p>
              <p> - scalar value (the value will be repeated to fill the Series) </p>
            </div></optval>, <a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.html" target="_blank">args</a>)
        </td>
        <td>
          - creates and returns a <reqval>ser</reqval> (Series)which is a one-dimensional labeled array capable of holding any data type <br>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <reqval>df|ser</reqval>.info() </td>
        <td> - prints a summary of the DataFrame or Series, including the index dtype and columns, non-null values and memory usage </td>
      </tr>
      <tr>
        <td> <reqval>df|ser</reqval>.shape </td>
        <td> - returns a tuple representing the dimensionality of the DataFrame or Series </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <reqval>df</reqval>.head(<optval>n:int</optval>) </td>
        <td> - returns first rows (Default: 5) as a new <reqval>df</reqval> </td>
      </tr>
      <tr>
        <td> <reqval>df</reqval>.tail(<optval>n:int</optval>) </td>
        <td> - returns rows (Default: 5) as a new <reqval>df</reqval> </td>
      </tr>
      <tr>
        <td> <reqval>df</reqval>.sample(<optval>n:int</optval>) </td>
        <td> - returns one random record (feature) from the <reqval>df</reqval> as a new <reqval>df</reqval> </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <reqval>df|res</reqval>.copy() </td>
        <td> - creates and returns a deep copy of the <reqval>df</reqval> or <reqval>res</reqval> </td>
      </tr>
    </table>
    <h2 class="headerSection"> Notes : </h2>

    <h2 class="headerSection"> Useful Links : </h2>

    <h2 class="headerSection"> Remember This : </h2>
    <p> - Accessing data by label the last member is included (ex: <mark><reqval>df</reqval>.loc[0:4]</mark> returns 5 rows) VS accessing data by index the last index is excluded (ex: <mark><reqval>df</reqval>.iloc[0:4]</mark> returns 4 rows) </p>
    <h2 class="headerSection"> Description and Demonstration : </h2>
    <p> - Pandas is a library designed for inmemory data manipulation and analysis, optimized for all kinds of data operations (filtering, grouping, aggregating, merging, reshaping, etc.) </p>
    <hr>
    <!--------------------------------------------------------------------------------------------------->
    <h2 class="header"> Column Labels and Indices </h2>
    <p> - Data in both DataFrames and Series can be labeled, on the X axis we call them <mark class="mark">column labes</mark> and on the Y axis we call them <mark class="mark">index</mark> (row labels) </p>
    <p> - Data can be accessed by both labels and integer positions (index positions) </p>
    <pre class="syntax">
    <reqval>df|ser</reqval>.index          // returns an <a href="https:\/\/pandas.pydata.org/docs/reference/indexing.html" target="_blank">index object</a> of the DataFrame's rows or of the Series
    <reqval>df</reqval>.columns           // returns an <a href="https:\/\/pandas.pydata.org/docs/reference/indexing.html" target="_blank">index object</a> of the DataFrame's columns
    
    <reqval>df|ser</reqval>.rename(<opt class="openable">columns=<optval>val</optval><div>
        <p> - dictionary mapping old column labels to new column labels </p>
      </div></opt>, <small class="openable">index=<optval>val</optval><div>
        <p> - dictionary mapping old index labels to new index labels </p>
      </div></small>, <opt class="openable">inplace=<optval>bool</optval><div>
          <p> - if True, modifies the original DataFrame </p>
      </div></opt>, <a href="https:\/\/pandas.pydata.org/docs/reference/api/pandas.DataFrame.rename.html" target="_blank">args</a>)     // renames columns and indices (returns a new <reqval>df</reqval>)
    <reqval>df</reqval>.set_index(<reqval>col:str|list[val:any]</reqval>, <opt class="openable">inplace=<optval>bool</optval><div>
          <p> - if True, modifies the original DataFrame </p>
      </div></opt>, <a href="https:\/\/pandas.pydata.org/docs/reference/api/pandas.DataFrame.set_index.html" target="_blank">args</a>)   // sets indices (row labels) (returns a new <reqval>df</reqval>)
    <reqval>df</reqval>.reset_index(<opt class="openable">inplace=<optval>bool</optval><div>
          <p> - if True, modifies the original DataFrame </p>
      </div></opt>, <a href="https:\/\/pandas.pydata.org/docs/reference/api/pandas.DataFrame.reset_index.html" target="_blank">args</a>)  // resets indices to default (restores the specified index as a regular column and resets the index to default integer index) (returns a new <reqval>df</reqval>)
    </pre>
    <details class="example">
      <summary> Example : </summary>
      <pre>
    coffe_shop = pd.DataFrame({
        'Day': ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'],    // column labes
        'Coffee': ['Latte', 'Espresso', 'Cappuccino', 'Americano', 'Mocha'],
        'Units Sold': [120, 150, 200, 180, 220]},
        index=["mon", "tue", "wed", "thu", "fri"]                         // custom index labels for rows
    )
    
    coffe_shop.columns                          // -> Index(['Day', 'Coffee', 'Units Sold'], dtype='object')
    coffe_shop.index                            // -> Index(['mon', 'tue', 'wed', 'thu', 'fri'], dtype='object')
    
    coffe_shop.rename(                          // rename columns and indices
        columns={"Day": "Weekday", "Units Sold": "Sold"}, 
        index={"mon": "MO", "tue": "TU", "wed": "WE", "thu": "TH", "fri": "FR"}, 
        inplace=True, 
    )                                           
    coffe_shop.columns                         // -> Index(['Weekday', 'Coffee', 'Sold'], dtype='object') 
    coffe_shop.index                           // -> Index(['MO', 'TU', 'WE', 'TH', 'FR'], dtype='object')
    
    coffe_shop.set_index(["Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi"], inplace=True)   // set indices
    coffe_shop.index                            // -> Index(['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi'], dtype='object')
    
    coffe_shop.set_index("Day", inplace=True)   // set 'Day' column as the new index 
    coffe_shop.shape                            // -! ->  (5, 2) this removes the "Day" column and makes it the new index
    coffe_shop.index                            // -> Index(['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'], dtype='object') indices are now the values from the "Day" column
    
    coffe_shop.reset_index(inplace=True)        // reset indices to default (restores the "Day" column as a regular column and resets the index to default integer index)
    coffe_shop.shape                            // -> (5, 3) 
    coffe_shop.index                            // -> RangeIndex(start=0, stop=7, step=1)
      </pre>
    </details>
    <hr>
    <!--------------------------------------------------------------------------------------------------->
    <h2 class="header"> Add/Remove Columns & Rows </h2>
    <pre class="syntax">
    <reqval>df</reqval>[<reqval>col:str</reqval>] = <reqval>list[val:any]|ser</reqval>    // sets an existing or adds a new column to the <reqval>df</reqval>
    
    <lit>pd</lit>.concat([<reqval>df, df, ...</reqval>], <a href="https:\/\/pandas.pydata.org/docs/reference/api/pandas.concat.html" target="_blank">args</a>)  // concatenates two or more DataFrames along a particular axis (rows or columns) and returns a new <reqval>df</reqval>
    <reqval>df|ser</reqval>.drop(<opt class="openable">index=<optval>val</optval><div>
          <p> - single label or list of labels </p>
        </div></opt>, <small class="openable">columns=<optval>val</optval><div>
          <p> - single label or list of labels </p>
        </div></small>, <opt class="openable">inplace=<optval>bool</optval><div>
            <p> - if True, modifies the original DataFrame </p>
        </div></opt>, <a href="https:\/\/pandas.pydata.org/docs/reference/api/pandas.DataFrame.drop.html" target="_blank">args</a>)     // removes columns and/or rows by the specified labels and/or indices (returns a new <reqval>df</reqval>)
    </pre>
    <details class="example">
      <summary> Example : </summary>
      <pre>
    coffe_shop = pd.DataFrame({
        'Day': ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'],    // column labes
        'Coffee': ['Latte', 'Espresso', 'Cappuccino', 'Americano', 'Mocha'],
        'Units Sold': [120, 150, 200, 180, 220]},
        index=["mon", "tue", "wed", "thu", "fri"]                         // custom index labels for rows
    )
    
// add columns and rows -----------------------------------
  // column -------------------
    coffe_shop["Units Sold After Close"] = [12, 15, 20, 18, 22, 16, 14]                    // adds a new column with specified values
    coffe_shop["Total Units Sold"] = (                                                     // adds a new column based on calculation using existing columns
        coffe_shop["Units Sold"] + coffe_shop["Units Sold After Close"]
    )
    
  // row ----------------------
    weekend_sales = pd.DataFrame({
        "Day": ["Saturday", "Sunday"],
        "Coffee": ["Flat White", "Macchiato"],
        "Units Sold": [160, 140]
    })
    coffe_shop = pd.concat([coffe_shop, weekend_sales], ignore_index=True)            // concatenates two DataFrames into one, resetting the index
    
    coffe_shop.loc[len(coffe_shop)] = ["Saturday", "Flat White", 160]           // adds a new row to DataFrame by assigning values to the next index position 
    
// drop columns and indices --------------------------------
    coffe_shop.drop(columns=["Units Sold"], index=["thu", "fri"], inplace=True)  // drop the "Units Sold" column and the rows with indices "thu" and "fri"
      </pre>
      <h4 class="header"> Advanced <mark>concat()</mark> example </h4>
      <pre>
    import pandas as pd
    
    olympic_data_short = pd.read_excel("olympics-data.xlsx")
    
    hun_athletes = olympic_data_short[olympic_data_short["born_country"] == "HUN"]      // filter to only include athletes born in Hungary
    rou_athletes = olympic_data_short[olympic_data_short["born_country"] == "ROU"]      // filter to only include athletes born in Romania
    
    hun_rou_athletes = pd.concat([hun_athletes, rou_athletes], ignore_index=True)       // concatenate two DataFrames into one
      </pre>
    </details>
    <hr>
    <!--------------------------------------------------------------------------------------------------->
    <h2 class="header"> Accessing & Setting Records (features) </h2>
    <pre class="syntax">
    <reqval>df</reqval>[<strong>col:str</strong>] <optval>= list[val:any]|ser</optval>    // gets or sets column (existing or new)
    <reqval>df</reqval>[[<strong>col:str, ...</strong>]<optval>...</optval>] <optval>= list[list[val:any]]|df</optval>    // gets or sets multiple columns (existing or new)
    
    <reqval>df</reqval>.loc[<strong class="openable">row_index<div>
        <p> - single label </p>
        <p> - list of labels (ex: [0, 1, 2]) </p>
        <p> - slice of labels (ex: 0:4) </p>
    </div></strong>, <optval class="openable">col_label<div>
        <p> - single label </p>
        <p> - list of labels (ex: ["col1", "col2"]) </p>
        <p> - slice of labels (ex: "col1":"col3") </p>
    </div></optval>] <optval>= list[val:any]|ser | list[list[val:any]]|df</optval>  // gets or sets values by label (get/set <reqval>ser</reqval> or <reqval>df</reqval> depending on the input)
    <reqval>df</reqval>.iloc[<strong class="openable">row_pos<div>
        <p> - single integer position </p>
        <p> - list of integer positions (ex: [0, 1, 2]) </p>
        <p> - slice of integer positions (ex: 0:4) </p>
    </div></strong>, <optval class="openable">col_pos<div>
        <p> - single integer position </p>
        <p> - list of integer positions (ex: [0, 1]) </p>
        <p> - slice of integer positions (ex: 0:2) </div></optval>] <optval>= list[val:any]|ser | list[list[val:any]]|df</optval >  // gets or sets values by index position (get/set <reqval>ser</reqval> or <reqval>df</reqval> depending on the input)
    
    <reqval>df</reqval>.apply(<strong class="openable">func<div>
      <p> - argument is a <reqval>ser</reqval> representing a row (if axis=1) or a column (if axis=0) </p>
      <p> - must return a single value that is assigned to the corresponding row or column in the resulting <reqval>ser</reqval> </p>
    </div></strong>, <opt class="openable">axis=<optval>0|1</optval><div>
      <p> - <mark>0</mark> = column (Default) </p>
      <p> - <mark>1</mark> = row </p>
    </div></opt>, <a href="https:\/\/pandas.pydata.org/docs/reference/api/pandas.DataFrame.apply.html" target="_blank">args</a>)  // applies a function along the <opt>axis</opt> and returns a new <reqval>ser</reqval> (with the applied values)
    </pre>
    <details class="example">
      <summary> Example : </summary>
      <h4 class="header"> Accessing Data </h4>
      <pre>
    import pandas as pd
    
    coffe_shop = pd.DataFrame({                                                                           
        'Day': ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'],
        'Coffee': ['Latte', 'Espresso', 'Cappuccino', 'Americano', 'Mocha', 'Flat White', 'Macchiato'],
        'Units Sold': [120, 150, 200, 180, 220, 160, 140],
    })
    
// Accessing by label -----------------------
    coffe_shop["Units Sold"]                      // -> returns the 'Units Sold' column as a Series
    coffe_shop[["Day", "Coffee"]]                 // -> returns the 'Day' and 'Coffee' columns as a DataFrame
    
    // -! indices also can be used as labels
    coffe_shop.loc[0]                             // -> returns the 1st row as a Series
    coffe_shop.loc[0:4]                           // -> returns the 1st to 5th rows as a DataFrame
    coffe_shop.loc[[2, 3]]                        // -> returns the 3rd and 4th rows as a DataFrame
    
    coffe_shop.loc[0, ["Day"]]                    // -> returns the value of the 'Day' column for the 1st row
    coffe_shop.loc[0:2, ["Day", "Units Sold"]]    // -> returns the 'Day' and 'Units Sold' columns for the 1st to 3rd rows as a DataFrame (slicing data by label)
    
    coffe_shop.rename(                                // rename indices
        index={0: "mon", 1: "tue", 2: "wed", 3: "thu", 4: "fri", 5: "sat", 6: "sun"},
        inplace=True,
    )
    coffe_shop.loc["mon":"fri", ["Day", "Coffee"]]              // -> targeting renamed indices 
    
// Accessing by index position -----------------------
    coffe_shop.iloc[0]                                // -> returns the 1st row as a Series
    coffe_shop.iloc[0:5]                              // -> returns the 1st to 5th rows as a DataFrame
    coffe_shop.iloc[[2, 3]]                           // -> returns the 3rd and 4th rows as a DataFrame
    
    coffe_shop.iloc[0, 0]                              // -> returns the value of the 1st row and 1st column
    coffe_shop.iloc[0:2, 0:2]                          // -> returns the values of the 1st to 2nd rows and 1st to 2nd columns as a DataFrame (slicing data by index position)
    coffe_shop.iloc[[0, 2], [0, 2]]                    // -> returns the values of the 1st and 3rd rows and 1st and 3rd columns as a DataFrame
      </pre>
      <h4 class="header"> Setting Data </h4>
      <pre>
    import pandas as pd
    
    coffe_shop = pd.DataFrame({
        'Day': ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'],
        'Coffee': ['Latte', 'Espresso', 'Cappuccino', 'Americano', 'Mocha', 'Flat White', 'Macchiato'],
        'Units Sold': [120, 150, 200, 180, 220, 160, 140],
    })
    
    coffe_shop.loc[6, "Units Sold"] = 145                       // sets a specific value
    
    coffe_shop.loc[6] = ["SUNDAY", "MACCHIATO", 145]            // sets an entire row
    coffe_shop.loc[1] = coffe_shop.loc[0]                       // sets an entire row by copying values from another row
    
    coffe_shop["Units Sold"] = coffe_shop["Units Sold"] + 10    // modify an entire column by applying an operation to it
    coffe_shop[["Day", "Coffee"]] = [                           // sets multiple columns
        ["MONDAY", "LATTE"],
        ["TUESDAY", "ESPRESSO"],
        ["WEDNESDAY", "CAPPUCCINO"],
        ["THURSDAY", "AMERICANO"],
        ["FRIDAY", "MOCHA"],
        ["SATURDAY", "FLAT WHITE"],
        ["SUNDAY", "MACCHIATO"]
    ]
    
    coffe_shop.loc[[5, 6], ["Day", "Coffee"]] = (               // sets a specific area
        [["SATURDAY", "FLAT WHITE"], ["SUNDAY", "MACCHIATO"]]
    )    
    coffe_shop.loc[[0, 1], ["Day", "Coffee"]] = (               // sets a specific area by assigning a DataFrame
        pd.DataFrame([["MONDAY", "LATTE"], ["TUESDAY", "ESPRESSO"]], columns=["Day", "Coffee"])
    )
      </pre>
      <h4 class="header"> Setting Data with <mark>apply()</mark> </h4>
      <pre>
    import pandas as pd
    
    coffe_shop = pd.DataFrame({
        'Day': ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'],
        'Open': [True, True, True, True, True, False, False],
        'Coffee': ['Latte', 'Espresso', 'Cappuccino', 'Americano', 'Mocha', 'Flat White', 'Macchiato'],
        'Units Sold': [120, 150, 200, 180, 220, 160, 140],
    })
    
    def close_on_weekend(col):                              // function executed on each row
    if col["Day"] in ["Saturday", "Sunday"]:
        return False
    return col["Open"]
    
    result = coffe_shop.apply(close_on_weekend, axis=1)     // returns a series with the result of applying the function to each row
    coffe_shop["Open"] = result                             // assigns the result to the "Open" column
      </pre>
    </details>
    <hr>
    <!--------------------------------------------------------------------------------------------------->
    <h2 class="header"> Dealing with Missing Data </h2>
    <pre class="syntax">
    <reqval>df|ser</reqval>.isna()                          // returns a new <reqval>df|ser</reqval> of the same shape with boolean values indicating presence of null values (ex: [[False, False, True], [False, False, False], ...])
    
    <reqval>df</reqval>.dropna(<opt class="openable">subset=<optval>list[str]</optval><div>
        <p> - only drops rows where the specified columns have null values </p>
    </div></opt>, <small class="openable">inplace=<optval>bool</optval><div>
        <p> - if <mark>True</mark>, modifies the original Series (Default: <mark>False</mark>)</p>
    </div></small>)                                           // drops rows having any null values (returns a new <reqval>df|ser</reqval>)
    <reqval>ser</reqval>.dropna(<opt class="openable">inplace=<optval>bool</optval><div>
        <p> - if <mark>True</mark>, modifies the original Series (Default: <mark>False</mark>)</p>
    </div></opt>)                               // drops null values (returns a new <reqval>ser</reqval>)
    
    <reqval>df|ser</reqval>.fillna(<reqval>val:any</reqval>, <opt class="openable">inplace=<optval>bool</optval><div>
        <p> - if <mark>True</mark>, modifies the original Series (Default: <mark>False</mark>)</p>
    </div></opt>)                               // fills all null values with a specified value (returns a new <reqval>df|ser</reqval>)
    </pre>
    <details class="example">
      <summary> Example : </summary>
      <pre>
    import pandas as pd
    
// DataFrame --------------------------
    coffe_shop = pd.DataFrame({
      'Day': ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', None],
      'Coffee': ['Latte', 'Espresso', 'Cappuccino', 'Americano', 'Mocha', None, 'Macchiato'],
      'Units Sold': [None, 150, 200, 180, None, 160, 140],
    })
    
    coffe_shop.isna()                                 // -> returns a new DataFrame of the same shape with boolean values indicating presence of null values ([[False, False, True], [False, False, False], ...]])
    coffe_shop.isna().sum()                           // -> counts the number of null values in each column, returns the result in a Series ([Day: 1, Coffee: 1, Units Sold: 2])
    
    coffe_shop.dropna()                               // -> drops rows having any null values (returns a new DataFrame)
    coffe_shop.dropna(subset=["Units Sold"])          // -> only drops rows where 'Units Sold' has null values (returns a new DataFrame)
    
    coffe_shop.fillna("Unknown")                      // -> fills all null values with a specified value (returns a new DataFrame)
    
// Serries --------------------------
    sold_units = pd.Series([120, 150, None, 180, None, 160, 140])
    
    sold_units.isna()                               // -> returns a new Series with boolean values indicating presence of null values ([False, False, True, False, True, False, False])
    sold_units.isna().sum()                         // -> counts the number of null values (returns an integer)
    
    sold_units.dropna()                             // -> drops null values (returns a new Series)
    sold_units.fillna(0)                            // -> fills null values with a specified value (returns a new Series)
      </pre>
    </details>
    <hr>
    <!--------------------------------------------------------------------------------------------------->
    <h2 class="header"> Sorting & Filtering </h2>
    <pre class="syntax">
// Sorting --------------------------------
    <reqval>df</reqval>.sort_values(<opt class="openable">by=<optval>col</optval><div>
      <p> - column label or list of column labels to sort by </p>
    </div></opt>, <small class="openable">ascending=<optval>bool</optval><div>
      <p> - sort ascending vs. descending (default: <mark>True</mark>)</p>
    </div></small>, <opt class="openable">inplace=<optval>bool</optval><div>
      <p> - if <mark>True</mark>, modifies the original DataFrame (default: <mark>False</mark>)</p>
    </div></opt>)     // sorts the DataFrame by the specified column(s) (returns a new <reqval>df</reqval>)
    <reqval>ser</reqval>.sort_values(<opt class="openable">ascending=<optval>bool</optval><div>
      <p> - sort ascending vs. descending (default: <mark>True</mark>)</p>
    </div></opt>, <small class="openable">inplace=<optval>bool</optval><div>
      <p> - if <mark>True</mark>, modifies the original Series (default: <mark>False</mark>)</p>
    </div></small>)     // sorts the Series by its values (returns a new <reqval>ser</reqval>)
    
// Filtering --------------------------------
    <reqval>df</reqval>[<strong class="openable">cond<div>
      <p> - single condition (ex: <mark>df["col"] > 5</mark>) </p>
      <p> - multiple condtions (& for AND, | for OR, ~ for NOT) (ex: <mark>(df["col1"] > 5) & (df["col2"] == "value")</mark>) </p>
    </div></strong>]    // filters the <reqval>df</reqval> on <reqval>cond</reqval> (returns a new <reqval>df</reqval>)
    
    <reqval>df</reqval>.query(<reqval class="openable">cond:str<div>
      <p> EX: <mark>
      <p> <mark>col > 5</mark> </p>
      <p> <mark>col1 > 5 and col2 == "value"</mark></p>
      <p> <mark>col1 > 5 or col2 == "value"</mark></p>
    </div></reqval>, <a href="https:\/\/pandas.pydata.org/docs/reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query" target="_blank">args</a>)   // filters the <reqval>df</reqval> using a query string (returns a new <reqval>df</reqval>)
    </pre>
    <details class="example">
      <summary> Example : </summary>
      <h4 class="header"> Sorting </h4>
      <pre>
    import pandas as pd
    
// DataFrame ----------------------------
    df = pd.DataFrame({
        'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Eve', 'Frank', 'Grace', 'Hannah', 'Ivy', 'Jack'],
        'Department': ['HR', 'Finance', 'HR', 'Finance', 'IT', 'HR', 'IT', 'Finance', 'HR', 'IT'],
        'Salary': [50000, 60000, 45000, 70000, 80000, 55000, 75000, 65000, 52000, 72000],
        'Age': [25, 30, 28, 35, 40, 32, 29, 38, 27, 36]
    })
    
    df.sort_values(by='Salary', ascending=False)              // -> sort by Salary in descending order (biggest 1st) (returns a new DataFrame)
    
    df.sort_values(by=['Department', 'Salary'], ascending=[True, False])    // -> sort by Department in ascending order and then by Salary in descending order within each department (returns a new DataFrame)
    
// Series --------------------------------
    ser = pd.Series(['Alice', 'Bob', 'Charlie', 'David', 'Eve', 'Frank', 'Grace', 'Hannah', 'Ivy', 'Jack'])
    
    ser.sort_values()                     // -> sorts alphabetically (returns a new Series)
    </pre>
    <h4 class="header"> Filtering </h4>
    <pre>
    import pandas as pd
    
    df = pd.DataFrame({
        'Name': ['Alice Widel', 'Bob', 'Charlie', 'David', 'Alice Freitz', 'Frank', 'Grace', 'Hannah', 'Ivy', 'Jack'],
        'Department': ['HR', 'Finance', 'HR', 'Finance', 'IT', 'HR', 'IT', 'Finance', 'HR', 'IT'],
        'Salary': [50000, 60000, 45000, 70000, 80000, 55000, 75000, 65000, 62000, 72000],
        'Age': [25, 30, 28, 35, 40, 32, 29, 38, 27, 36]
    })
    
    df[df['Salary'] >= 60000]                                   // -> filters records where 'Salary' is greater than or equal to 60000 (returns a new DataFrame)
    df[(df['Department'] == 'HR') & (df['Salary'] >= 60000)]    // -> multiple filter conditions
    
    df.query('Department == "HR" and Salary >= 60000')          // -> using query() (does the same as above)
    
    df.loc[df["Name"].str.contains("Alice", case=False)]        // -> regular expression filter (returns a new DataFrame)
    </pre>
    </details>
    <hr>
    <!--------------------------------------------------------------------------------------------------->
    <h2 class="header"> Merge, Aggregation and Grouping </h2>
    <pre class="syntax">
    <lit>pd</lit>.merge(<reqval>left:df</reqval>, <reqval>right:df</reqval>, <opt class="openable">how=<optval>str</optval><div>
      <p> - <mark>left</mark> all records from the left <mark>df</mark> and matching records from the right <mark>df</mark> (Default) </p>
      <p> - <mark>right</mark> all records from the right <mark>df</mark> and matching records from the left <mark>df</mark> </p>
      <p> - <mark>inner</mark> only records with matching values in both <mark>df</mark>s </p>
      <p> - <mark>outer</mark> all records from both <mark>df</mark>s </p>
    </div></opt>, <a href="https:\/\/pandas.pydata.org/docs/reference/api/pandas.DataFrame.merge.html" target="_blank">args</a>)   // merges two <strong>df</strong>s based on the specified columns (SQL style joins) (returns a new <strong>df</strong>)
    
    
    
    </pre>

    <details class="example" open>
      <summary> Example : </summary>
      <h4 class="header"> Merge </h4>
      <pre>
    import pandas as pd
    
    comp_1 = pd.DataFrame({
        'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Eve'],
        'Departement': ['HR', 'IT', 'HR', 'Finance', 'IT'],
    })
    
    comp_2 = pd.DataFrame({
        'Name': ['Johon', 'Betty', 'Maggie', 'Jeny'],
        "DP": ['HR', 'Finance', 'Accounting', 'HR'],
    })
    
    // all records from the left DataFrame (comp_1) and matching records from the right DataFrame (comp_2)
    pd.merge(comp_1, comp_2, left_on="Departement", right_on="DP", how="left")            // -> returns a new DataFrame with the results
    
    // all records from the right DataFrame (comp_2) and matching records from the left DataFrame (comp_1)
    pd.merge(comp_1, comp_2, left_on="Departement", right_on="DP", how="right")           // -> returns a new DataFrame with the results
    
    // only records with matching values in both DataFrames (comp_1 and comp_2)
    pd.merge(comp_1, comp_2, left_on="Departement", right_on="DP", how="inner")           // -> returns a new DataFrame with the results
  
    // all records from both DataFrames
    pd.merge(comp_1, comp_2, left_on="Departement", right_on="DP", how="outer")           // -> returns a new DataFrame with the results
      </pre>
      <h4 class="header"> Grouping </h4>





    </details>


    <!--
    - Index and Labels
    - CRUD Operations
    - Dealing with Missing Data
    - Sorting and Filtering



    - Merge & Aggregation
    
    
    
    - Read and Write files stuff

-->

    <!--
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
stage 1: high level overview 
    - read through 
    - create notes 
    - deciede what exactly will you document down 
    - UNDERSTAND AND WRITE DOWN THE CONCEPTS!!!
    
stage 2:  low level overview
    - deeper understanding of all what you've taken down in stage 1
    
stage 3 : 
    - organize and document down everything 
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------

?????????????????????????????????????????????????????????????????????????????????????????????
WRITE DOWN WHAT YOU DON'T UNDERSTAD OR MUST BE TESTED AS QUESTIONS HERE
?????????????????????????????????????????????????????????????????????????????????????????????
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    pd.read_csv(<reqval>filepath_or_buffer:str</reqval>, https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html#pandas.read_csv)
        - reads a CSV file into a DataFrame
    .. other read functions
    
    
    
    
    
    
    pd.sort_values(<reqval>by:str or list</reqval>, https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_values.html#pandas.DataFrame.sort_values)
        - sorts the DataFrame by the specified column(s)
        - returns a new DataFrame sorted by the specified column(s) in ascending order by default
        - original DataFrame remains unchanged unless inplace=True is specified
    
    df.dropna(<optval>axis:int</optval>, <optval>how:str</optval>, https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.dropna.html#pandas.DataFrame.dropna)
        - removes missing values (NaN) from the DataFrame
    
    
    
---------------------------------------------
    - Series 
        - a one-dimensional labeled array capable of holding any data type (integers, strings, floating point numbers, Python objects, etc.)
        - can be created from a list, dictionary, or scalar value
        - each element in a Series has an associated label (index)
        - https://pandas.pydata.org/docs/reference/series.html
        - Series(<optval>data:array-like</optval>, https://pandas.pydata.org/docs/reference/api/pandas.Series.html#pandas.Series)
    
    series.unique()
        - returns the unique values in the Series as a NumPy array
    


########################################################################
### TODO ###
########################################################################
    - clarify indexing
        - DONE

    - how to add, remove, rename rows?
        - DONE

-->

    <!--
    
    
    
    
    
    df.copy(https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.copy.html)
        - creates a deep copy of the DataFrame
    
    
    
    
    
    
    df.head(<optval>n:int</optval>) 
        - returns the first n rows of the DataFrame (Default: 5)
    df.tail(<optval>n:int</optval>) 
        - returns the last n rows of the DataFrame (Default: 5)
    df.sample(<optval>n:int</optval> https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sample.html)
        - returns a random sample of n rows from the DataFrame

    
    df['column_label', | ['col1', 'col2', ...]] 
        - returns the specified column as a Series
        - or multiple columns as a DataFrame if a list of column labels is provided


    df.loc[<reqval>idx:any</reqval>]
    df.loc[<reqval>idx:any</reqval><optval>:idx</optval>]                 # range
    df.loc[[<reqval>idx1</reqval>, <reqval>idx2</reqval>, ...]]           # list of indexes
        - accesses a group of rows and columns by index and labels 
        - return the resutl as a DataFrame or Series depending on the input
        - upper index is inclusive
    
    df.iloc[<reqval>pos</reqval>]             # index acces
    
    df.loc|iloc[...] = val                    # modifies one or more values in the DataFrame    
    
    
    
    df.reset_index(drop=True)

    - IndexObject.tolist() 
        - converts the Index object to a standard Python lis
    - other methods https://pandas.pydata.org/docs/reference/indexing.html


    df.index 
        - returns the index (row labels) of the DataFrame as an Index object
    df.columns 
        - returns the column labels of the DataFrame as an Index object

    df.info() 
        - prints a concise summary of the DataFrame, including the index dtype and columns, non-null values and memory usage
    df.shape 
        - returns a tuple representing the dimensionality of the DataFrame (number of rows, number of columns)
 



    - in pandas a data table is called DataFrame
        - the DataFrame contains tabular data (rows and columns) where columns are labeled and rows are indexed
        - rows can be accessed by their label index or by their integer position
    
    pd.DataFrame(<optval>data:iterable</optval>, https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html#pandas.DataFrame)


-->

    <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
    <hr>
    <hr>
    <hr>
    <hr>
    <hr>

    <h2 class="headerExtra"><u> Title 1 </u></h2>
    <h2 class="header"> Title 1.1 </h2>
    <h3 class="header"> Title 1.1.1 </h3>
    <h4 class="header"> Title 1.1.1.1 </h4>
    <p> - stuff to learn <mark>syntax or command (or some tchnical stuff)</mark> bla bla bla </p>
    <p> - stuff to learn <mark class="mark">highlights like file names and other things</mark> bla bla bla </p>
    <p style="text-decoration:underline;"> - important information is underlined </p>
    <p style="color:yellow;"> - very important information is written with yellow colors </p>
    <p style="background-color:yellow;"> - highly important information has yellow background color </p>
    <div style="background-color:red;">
      <p> - red background block means not learned or not tested information! </p>
      <p> - </p>
    </div>

    <pre class="syntax">
    <reqval>required value </reqval>
    <optval>optional value </optval>
    <lit>literally used </lit>
    <opt>optionally used </opt>
  
    <prot style="color:#049500;">prototype chain</prot>
        
    <span class="openable"> this is an openable element<div>
        <p> - openable elements listed here in paragraphs </p>
        <p> - </p>
    </div></span>
    </pre>

    <details class="example">
      <summary> DEMO (can be pseudocode) </summary>
      <pre>
    examples of the current lessons 
    
// -----------------------------------------

// -----------------------------------------
    </pre>
    </details>

    <pre class="cmd">
    command line demo 
    </pre>
    <pre class="formula">
    formula code (like conversion meter...)
    </pre>
    <details class="example">
      <summary> Example : </summary>
      <h4 style="color:darkblue;"><u> example title </u></h4>
      <p> - live tests will come here </p>
      <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
    copy of the exaple code 
        </pre>
      </details>
    </details>
    <!---------------------------------------------------------------------------------------------------------------------------------->
    <hr>

    <h2 class="test" style><a href="TEST/index.html"> TEST > </a></h2>

    <br><br>
  </body>

</html>