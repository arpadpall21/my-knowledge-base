<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title> Docker </title>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../Assets/stylesPages.css">
    <script src="../Assets/scriptPages.js"></script>
  </head>

  <body>
    <h1> Docker </h1>
    <p> Updated: ( 2021-10-27 / 2025-03-19 )</p>
    <nav class="sitenav">
      <a href="../index.html">MySite > </a> Docker
    </nav>
    <p class="subSite"><a href="Dockerfile & .dockerignore/index.html"> Building Docker images (<mark>Dockerfile</mark> and <mark>.dockerignore</mark> files) > </a></p>
    <p class="subSite"><a href="Docker-Compose/index.html"> Docker-Compose > </a></p>
    <table class="table">
      <tr>
        <th style="width:30%;"> CMD </th>
        <th> Description </th>
      </tr>
      <tr>
        <td>
          docker version
        </td>
        <td>
          - returns version informations (client, server)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2">
          Registries
        </td>
      </tr>
      <tr>
        <td>
          cat ~/.docker/config.json
        </td>
        <td>
          - file's <mark>auth</mark> object contains all logged in registry servers' credentials
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          docker login <i>repoServerUrl</i>
        </td>
        <td>
          - (without <i>repoServerUrl</i>) logs in to DockerHub <br>
          - (with <i>repoServerUrl</i>) logs in to the specified docker repo server
        </td>
      </tr>
      <tr>
        <td>
          docker logout <i>repoServerUrl</i>
        </td>
        <td>
          - (without <i>repoServerUrl</i>) logs out from DockerHub <br>
          - (with <i>repoServerUrl</i>) logs out from the specified docker repo server
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          docker pull <small>[options]</small> <strong>image</strong><i>:tag</i>
        </td>
        <td>
          - pulls the image from the docker repo server <u class="openable">(the <strong>image</strong> name defines which repo server to pull the image from)<div>
              <h5><u> DockerHub </u></h5>
              <p> <mark>$ docker pull arpadpall21/dev/test:v1</mark> (pulls the <mark>arpadpall21/dev/test:v1</mark> images from DockerHub) </p>
              <hr>
              <h5><u> custom docker repo server </u></h5>
              <p> <mark>$ docker pull localhost:5000/dev/test:v1</mark> (pulls the <mark>localhost:5000/dev/test:v1</mark> images from <mark>localhost:5000</mark> local repo server) </p>
              <p> <mark>$ docker pull hub.myreposerver/dev/test:v1</mark> (pulls the <mark>hub.myreposerver/dev/test:v1</mark> images from <mark>hub.myreposerver</mark> remote repo server) </p>
            </div></u><br>
          - DockerHub public images can be pulled without being logged in <br>
          <small>[options]</small><br>
          - (<small>-a</small>) all <strong>image</strong> regardless of the tag
        </td>
      </tr>
      <tr>
        <td>
          docker push <small>[options]</small> <strong>image</strong><i>:tag</i>
        </td>
        <td>
          - pushes up the image in the docker repo server <u class="openable">(the <strong>image</strong> name defines which repo server to push the image)<div>
              <h5><u> DockerHub </u></h5>
              <p> <mark>$ docker push arpadpall21/dev/test:v1</mark> (pushes the <mark>arpadpall21/dev/test:v1</mark> images to DockerHub) </p>
              <hr>
              <h5><u> custom docker repo server </u></h5>
              <p> <mark>$ docker push localhost:5000/dev/test:v1</mark> (pushes the <mark>localhost:5000/dev/test:v1</mark> images to <mark>localhost:5000</mark> local repo server) </p>
              <p> <mark>$ docker push hub.myreposerver/dev/test:v1</mark> (pushes the <mark>push hub.myreposerver/dev/test:v1</mark> images to <mark>hub.myreposerver</mark> remote repo server) </p>
            </div></u> <br>
          <small>[options]</small><br>
          - (<small>-a</small>) all <strong>image</strong> regardless of the tag
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2">
          Images
        </td>
      </tr>
      <tr>
        <td>
          docker images
        </td>
        <td>
          - list the available docker images
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          docker build <small>[options]</small> <strong>DockerfileDirPath</strong>
        </td>
        <td>
          - builds a Docker Image (Repo) from the specified <mark>Dockerfile</mark> <br>
          <small>[options]</small><br>
          - (<small>-f <i>customDockerfile</i></small>) specifies a custom Dockerfile name (ex: <mark>-f buildImage.v1</mark> docker will look for the <mark>buildImage.v1</mark> file to build the image) <br>
          - (<small>--build-arg <i>var</i>=<i>val</i></small>) overrides an existing <mark>ARG</mark> build-time variable which are not persisted in the final images <u>(cannot set new <mark>ARG</mark> (outputs a warning))</u> <br>
          - (<small>-t <i>imgName</i>[:<i>tag</i>]</small>) sets the image name and tag (default: <i>tag</i> = <mark>latest</mark>)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          docker rmi <small>[options]</small> <strong>image<i>:tag</i> ...</strong> <br>
          docker image rm <strong>image<i>:tag</i> ...</strong>
        </td>
        <td>
          - removes the specified docker image(s) <br>
          <small>[options]</small><br>
          - (<small>-f</small>) force remove
        </td>
      </tr>
      <tr>
        <td>
          docker image prune <small>[options]</small>
        </td>
        <td>
          - remove all <span class="openable">dangling images<div>
              <p> - images that have no relationship to any tagged images (they only consume disk space) </p>
            </div></span> from the docker daemon <br>
          <small>[options]</small><br>
          - (<small>-a</small>) remove all images without at least once container associated to them <br>
          - (<opt>--force</opt>) force remove
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          docker image history <small>[options]</small> <strong>image<i>:tag</i></strong>
        </td>
        <td>
          - lists the build history of the image (how this <strong>dockerImage</strong> was build by the <mark>Dockerfile</mark>) <br>
          <small>[options]</small><br>
          - (<small>--no-trunc</small>) fully displays informations (does not truncate)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          docker tag <strong>image<i>:tag</i></strong> <strong>newImage<i>:tag</i></strong>
        </td>
        <td>
          - creates a new image by copying the original (remember images are like hard-links, they reference the same underlying data)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          docker save <strong>image</strong><i>:tag</i> -o <strong class="openable">filePath.tar<div>
              <p> - should be expoorted as a <mark>.tar</mark> (linux archive) file (ex: <mark>/tmp/mynewimage.tar</mark>) </p>
            </div></strong>
        </td>
        <td>
          - exports the Docker Image into a <mark>.tar</mark> file
        </td>
      </tr>
      <tr>
        <td>
          docker load -i <strong class="openable">filePath.tar<div>
              <p> - should be imported from a <mark>.tar</mark> (linux archive) file (ex: <mark>/tmp/mynewimage.tar</mark>) </p>
            </div></strong>
        </td>
        <td>
          - import a Docker Image in the current Docker host from a <mark>.tar</mark> file
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          docker scan <strong>image<i>:tag</i></strong>
        </td>
        <td>
          - scans the docker image for vulnerabilities (scans with Sync (some company))
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2">
          Containers
        </td>
      </tr>
      <tr>
        <td>
          docker ps <small>[options]</small>
        </td>
        <td>
          - lists running docker containers <br>
          <small>[options]</small><br>
          - (<small>-a</small>) all containers (non running containers included) <br>
          - (<small>-s</small>) size included <br>
          - (<small>--no-trunc</small>) fully displays informations (does not truncate)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          docker run <small>[options]</small> <strong>image<i>:tag</i></strong> <i class="openable">cmd<div>
              <p> - overrides the <mark>CMD</mark> instruction in the Dockerfile </p>
              <p> - this command is passed in executable form (ex: <mark>docker run -d <strong>image</strong> echo test</mark> will override the CMD instruction as <mark>CMD ['echo', 'test']</mark>) </p>
            </div></i>
        </td>
        <td>
          - builds a contaier from the specified Docker image and runs it <br>
          <small>[options]</small><br>
          - (<small>--name <i>contName</i></small>) specifies a name for the container <br>
          - (<small>-d</small>) runs the container in the background (detached mode) <br>
          - (<small>-i</small>) keeps the STDIN open <br>
          - (<small>-t</small>) allocates a TTY (terminal) <br>
          - (<small>--rm</small>) removes the container when the container exits (also removes anonymus volumes used by the container) <br>
          - (<small>--env</small> <i>key</i>=<i>val</i>) sets (or overrides an existing <mark>ENV</mark>) environment variable which are persisted inside the container <br>
          - (<small class="openable">-v <i>vol|outPath</i>:<i>inPath</i>[:ro]<div>
              <h5><u> Mounting volumes </u></h5>
              <p> <mark>-v <i>volName</i>:<strong>containerPath</strong></mark> </p>
              <p> - mounts the specified volume inside the contaier (if volume is not passed an anonymus volume is created) </p>
              <p> ex: <mark>-v vol1:/home/volStorage</mark> - <mark>vol1</mark> volume is mounted as <mark>/home/volStorage</mark> inside the container </p>
              <hr>
              <h5><u> Bind mounts </u></h5>
              <p> <mark>-v <strong>hostPath</strong>:<strong>containerPath</strong></mark> </p>
              <p> - mounts the host machine's path directly inside the container </p>
              <p> ex: <mark>-v /home/someUser:/home/someUser</mark> - path mounted directly inside the container </p>
            </div></small>) mounts a volume or bind mount inside the container (<mark>:ro</mark> read-only) <br>
          - (<small class="openable">--tmpfs <i>inPath</i>
            <div>
              <p> <mark>--tmpfs <strong>containerPath</strong></mark> </p>
              <p> - mounts a temporary fs inside the contaier (files are written only in memory) </p>
              <p> ex: <mark>--tmpfs /tempDir</mark> - mount a tmpfs as <mark>/tempDir</mark> inside the container </p>
            </div>
          </small>) mounts a temporary fs (memory fs) inside the container <br>
          - (<small>-p <i>[hostIp:]hostPort</i>:<i>contPort</i>[/tcp|udp]</small>) routes the traffic (host <mark><strong>hostIp:hostPort</strong></mark> - <mark><strong>container</strong>:<strong>contPort</strong></mark>) (defaults: <i>hostIp</i> = <mark>0.0.0.0</mark> / <small>tcp|udp</small> = <mark>tcp</mark>) <br>
          - (<small>-P</small>) routes the <mark>Dockerfile</mark> <mark>EXPOSE</mark> port to the host <mark>0.0.0.0:<strong>randomPort</strong></mark> address <br>
          - (<small>--ip <i>ipAddress</i></small>) statically assigns the <i>ipAddress</i> to the container on which is the contaier will connect to the network <br>
          - (<small>--network <i>networkName</i></small>) connects the container to the specified network (<mark>bridge</mark>(default)|<strong>user-defined-bridge</strong>|<mark>host</mark>|<mark>none</mark>) (<mark>--network host</mark> gives full host network access from the container)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          docker rm <small>[options]</small> <strong>container</strong>
        </td>
        <td>
          - deletes the specified Docker Container from the host <br>
          <small>[options]</small><br>
          - (<small>-f</small>) force remove
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          docker rename <strong>contaier</strong> <strong>newName</strong>
        </td>
        <td>
          - renames the specified container
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          docker commit <strong>container</strong> <i>image:tag</i>
        </td>
        <td>
          - commints the <u>current state (current fs)</u> of the container into a new Docker Image
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          docker start <strong>container</strong>
        </td>
        <td>
          - starts the specified Docker Contianer <u>(cannot start paused containers, use <mark>docker unpause</mark> instead)</u>
        </td>
      </tr>
      <tr>
        <td>
          docker stop <strong>container</strong> <i>...</i>
        </td>
        <td>
          - stops the specified Docker Contianer(s) <br>
          - sends the <mark>SIGTERM</mark> signal to the container's main process, then after a grace period sends <mark>SIGKILL</mark>
        </td>
      </tr>
      <tr>
        <td>
          docker pause <strong>container ...</strong>
        </td>
        <td>
          - pauses all processes within the container(s)
        </td>
      </tr>
      <tr>
        <td>
          docker unpuase <strong>container</strong> <i>...</i>
        </td>
        <td>
          - unpauses paused container(s) <u>(<mark>docker start</mark> does not start paused containers)</u>
        </td>
      </tr>
      <tr>
        <td>
          docker restart <strong>container ...</strong>
        </td>
        <td>
          - restarts the specified container(s)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          docker cp <reqval>hostPath</reqval> <reqval>container</reqval>:<reqval>contPath</reqval> <br>
          docker cp <reqval>container</reqval>:<reqval>contPath</reqval> <reqval>hostPath</reqval>
        </td>
        <td>
          - copy files/folders between the container and the local system (and vice versa) (<mark><reqval>container</reqval>:<reqval>contPath</reqval></mark> must be an absolute path)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          docker exec <small>[options]</small> <strong>container</strong> <strong class="openable">cmd|executable<div>
              <p> Examples: </p>
              <p> <mark>docker exec -it <strong>contaier</strong> bash</mark> - opens bash inside the container </p>
              <p> <mark>docker exec -it <strong>contaier</strong> "echo a && echo b"</mark> - won't work because quotes are not allowed directly </p>
              <p> <mark>docker exec -it <strong>contaier</strong> sh -c "echo a && echo b"</mark> - works because directly after the container there's no qouted command </p>
            </div></strong>
        </td>
        <td>
          - runs a commnad on a running container <br>
          <small>[options]</small><br>
          - (<small>-i</small>) keeps the STDIN open <br>
          - (<small>-t</small>) allocates a TTY (terminal) <br>
          - (<small>-e <i>KEY=val</i></small>) specifies an environment variable <u>for this command</u>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          docker inspect <strong>contaier</strong>
        </td>
        <td>
          - returns informations about the contianer (state, volume, network, etc..) (in JSON Array)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2">
          Volumes
        </td>
      </tr>
      <tr>
        <td>
          docker volume create <i>volName</i>
        </td>
        <td>
          - (no opttion) creates an anonymus volume <br>
          - (<i>volName</i>) names the newly created volume
        </td>
      </tr>
      <tr>
        <td>
          docker volume ls
        </td>
        <td>
          - lists all docker volumes on the host
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          docker volume rm <small>[options]</small> <strong>volName</strong>
        </td>
        <td>
          - removes the specified volume <br>
          <small>[options]</small><br>
          - (<small>-f</small>) force remove
        </td>
      </tr>
      <tr>
        <td>
          docker volume prune
        </td>
        <td>
          - removes all volumes that are not used by any container (does not remove volumes that are used by stopped containers)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          docker volume inspect <strong>volName</strong>
        </td>
        <td>
          - returns detailed informations about the volume (in JSON Array)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2">
          Networks
        </td>
      </tr>
      <tr>
        <td>
          docker network create <small>[options]</small> <strong>networkName</strong>
        </td>
        <td>
          - creates a new network <br>
          <small>[options]</small><br>
          - (<small>-d <i>driver</i></small>) specifies a network driver (<mark>bridge</mark> (default) or <mark>overlay</mark>), (with the <mark>-o parent=<strong>parentNetInterface</strong></mark> flag we also can specify <mark>macvlan</mark> or <mark>ipvlan</mark>) <br>
          - (<small>--subnet <strong class="openable">CIDR_notation<div>
                <p> ex: <mark>172.0.0.0/16</mark> </p>
              </div></strong></small>) specifies the allocated ips for the network <br>
          - (<small>--gateway <strong>ip</strong></small>) specifies the gateway addresss <br>
          - (<small>--ip-range <strong class="openable">CIDR_notation<div>
                <p> ex: <mark>172.0.0.0/16</mark> </p>
              </div></strong></small>) ip range where containers will be connected by DHCP <br>
        </td>
      </tr>
      <tr>
        <td>
          docker network ls <small>[options]</small>
        </td>
        <td>
          - list all the daemon knows about <br>
          <small>[options]</small><br>
          - (<small>--no-trunc</small>) fully displays informations (does not truncate)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          docker network rm <strong>network</strong> <i>...</i>
        </td>
        <td>
          - removes the specified network(s)
        </td>
      </tr>
      <tr>
        <td>
          docker network prune
        </td>
        <td>
          - removes all unused networks (empty networks where no containers are connected at all)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          docker network connect <small>[options]</small> <strong>network</strong> <strong>cont</strong>
        </td>
        <td>
          - connects the container to the network <br>
          <small>[options]</small><br>
          - (<small>--ip <i>ip</i></small>) assigns an IP address the container uses on the network
        </td>
      </tr>
      <tr>
        <td>
          docker network disconnect <strong>network</strong> <strong>cont</strong>
        </td>
        <td>
          - disconnects the container from the network
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          docker network inspect <strong>network</strong> <i>...</i>
        </td>
        <td>
          - return information about the specified docker network(s) in JSON format <u>(also list connected containers)</u>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          docker port <strong>container</strong>
        </td>
        <td>
          - returns the routed ports between the container and the host machine (host network)
        </td>
      </tr>
    </table>
    <br>
    
    <h2 class="headerSection"> Useful Links : </h2>
    <p><a href="https://docs.docker.com/" target="_blanc">Docker Docs (docs.docker.com)</a></p>
    <h2 class="headerSection"> Remember This : </h2>
    <p> - a Docker Container keeps running only if something keeps it alive (like a server or <mark>tail -f /dev/nul</mark>) </p>
    <p> - the Docker daemon never uses shell's environment variables (use the <mark>--env</mark> flag or the <mark>ENV</mark> or <mark>ARG</mark> in the <mark class="mark">Dockerfile</mark> for passing values) </p>
    <h2 class="headerSection"> Description and Demonstration : </h2>
    <p> - Docker is an tool which runs application in an isolated environment, it has a client-server (daemon) architecture which allows the Docker daemon to be controled even on a remote machine </p>
    <p> - Docker is not a Virtual Machine (it does not run its own OS), instead it uses the <u>host Operating System kernel</u> but it manages its own file system (AuFS) and network </p>
    <p> - so each Docker container is running on top of the host system kernel </p>
    <p style="text-indent:20px;"> - on Linux can run Linux App containers </p>
    <p style="text-indent:20px;"> - on Windows can run both Linux and Windows App containers (because Windows is shipped with a Linux kernel from Windows 10) </p>
    <p style="text-indent:20px;"> - on Mac can run Linux App containers (because Docker uses a lightweight VM on MacOs to run Linux) </p>
    <h4 class="header"> Docker Image (Repository) </h4>
    <p> - a Docker Image is basically a Repo a 'blueprint' for a Docker Container', it's a package containing the application code, libraries, tools, dependencies and other files needed to make an application</p>
    <p> - Docker uses Docker images to spin up Docker containers, a Docker images is created by <mark>Dockerfile</mark> </p>
    <p> - Docker Images or Repos are tagged <mark>image:[tag]</mark> </p>
    <h4 class="header"> Docker Container </h4>
    <p> - a Docker Container is a special kind of isolated process running an application, managed by the Docker daemon </p>
    <p> - each Docker Container has its own OS distribution running on top of the host's kernel, and file system (where we can save changes) </p>
    <h4 class="header"> Docker Registries </h4>
    <p> - we don't distribute Docker Containers, we distribute Docker Images (Repos) </p>
    <p> - we can use the DockerHub but also any custom repo server as distribution platform </p>
    <p> - we can also save and load Docker images in <mark>*.tar</mark> (linux archive) files (<mark>docker save</mark> & <mark>docker load</mark> commands)</p>
    <img src="architecture.svg" height="350">
    <details class="example">
      <summary> Example : </summary>
      <h4 class="header"> <mark>save</mark> / <mark>load</mark> TEST </h4>
      <pre class="cmd">
    $ docker save testImage:v1 -o testCont.tar                                         // saves the <mark>testImage:v1</mark> image into a <mark>testCont.tar</mark> file    
    
    $ docker load -i testCont.tar                                                      // loads the previously saved container into the current docker hosts    
    </pre>
    </details>
    <hr>
    <!--------------------------------------------------------------------------------------------->
    <h2 class="headerExtra"><u> Using Docker Registries </u></h2>
    <p> - Docker allows us to use other registries than the DockerHub, we can be logged in into multiple registries at the same time </p>
    <p> - we can check our login status in the <mark>~/.docker/config.js</mark> file (<mark>auth</mark> object contains the logged in servers) </p>
    <p> - the Docker image's name <u>first segment should be the server name (ex: <mark>harbor.techteamer.com/facekom-devel/vuer_oss</mark>)</u>, this is were docker knows where to push/pull images (exept for DockerHub) </p>
    <p> - we can pull public images from DockerHub without being logged in to DockerHub </p>
    <pre class="syntax">
<span style='color:darkgray'>// docker image -----------------------------------------------------------------------</span>
    <strong>dockerHubRepo</strong>/<strong>repo</strong><small>/</small><i>...<small>:</small>tag</i>                                                         // image pushed/pulled to/from DockerHub (ex: <mark>arpadpall21/test:v1</mark>)     
    
    <strong>repoServerUrl</strong>/<strong>repo</strong><small>/</small><i>...<small>:</small>tag</i>                                                         // image pushed/pulled to/from a custom docker repo registry server (ex: <mark>localhost:5000/test:v1</mark>)     
    </pre>
    <details class="example">
      <summary> DEMO : </summary>
      <pre class='cmd'>
// login / logout ---------------------------------------------------------------------
    $ login                                                                            // logging in to DockerHub 
    $ login myrepo.com                                                                 // logging in to a custom docker registry    
    
    $ logout                                                                           // same deal to log out 
    $ logout my.personalrepo.com
    
    $ cat ~/.docker/config.js                                                          // file's <mark>auth</mark> object contains the credentials for the logged in docker registry servers   
    
// push / pull ------------------------------------------------------------------------
    $ docker push arpadpall21/test:v1                                                  // pushing the <mark>arpadpall21/test:v1</mark> image to DockerHub   
    $ docker push my.personalrepo.com/test:v1                                          // pushing the <mark>my.personalrepo.com/test:v1</mark> image to my.personalrepo.com repo server    
                                                                                         // -! from the image's name docker knows which docker registry to push
    
    $ docker pull arpadpall21/test:v1                                                  // same deal when pulling    
    $ docker pull my.personalrepo.com/test:v1   
    </pre>
    </details>
    <hr>
    <!--------------------------------------------------------------------------------------------->
    <h2 class="headerExtra"><u> Docker file-system </u></h2>
    <img src="types-of-mounts.png" height="220">
    <p> - each container has its own file system (a union fs = isolated part within the host's fs), stored data is lost once the container stops </p>
    <p> - we can use different external storages (volumes, mounts and tmpfs) and mount them inside the container (regardless of the mount type the data looks the same inside the container) </p>
    <p> - externally mounted storages obscures (hides) the cotainer's fs (files stored in the container layer will be kept in background) </p>
    <h3 class="header"> Volumes </h3>
    <p> - volumes are storage packages on the host's fs managed by docker, they are kept in an isolated area (Default: <mark>/va/lib/docker/volumes</mark>) </p>
    <p> - from the host machine we can see and access the volumes' data, just like the container do on the mounted path </p>
    <p> - multiple containers can use the same volume </p>
    <details class="example">
      <summary> DEMO : </summary>
      <pre class='cmd'>
// docker volume create ---------------------------------------------------------------
    $ docker volume create vol1                                                        // creates the specified volume 
    $ docker volume create vol2
    $ docker volume create                                                             // creates an anonymous volume    
    
// docker volume ls -------------------------------------------------------------------
    $ docker volume ls                                                                 // prints all volumes   
        DRIVER    VOLUME NAME
        local        25adf35e0f92de22fcb579eeafd25d307d578cbd5d437e7ffbbd7e86e564a133  // anonymus volume 
        local     vol1
        local     vol2
    
// docker volume rm -------------------------------------------------------------------
    $ docker volume rm vol2                                                            // removes 'vol2'    
    
// docker volume inspect --------------------------------------------------------------
    $ docker volume inspect vol1                                                       // returns details about 'vol1' volume   
        [
            {
                "CreatedAt": "2021-12-06T19:54:25+01:00",
                "Driver": "local",
                "Labels": {},
                "Mountpoint": "/var/lib/docker/volumes/vol1/_data",
                "Name": "vol1",
                "Options": {},
                "Scope": "local"
            }
        ]
    
// docker volume prune ----------------------------------------------------------------
    $ docker volume prune                                                              // removes all volumes that are not used by any container (does not remove volumes that are used by any stopped contaier)    
    </pre>
      <pre class="cmd">
    $ docker run -d -v vol1:/testDir testImg:v1                                        // 'vol1' volume is mounted as '/testDir' inside the container 
                                                                                         // if 'vol1' volume does not exist it will be created 
    
    $ docker run -d -v vol1:/testDir:ro testImg:v1                                     // the mounted volume (vol1) is read-only   
    
    // -------------------------------------------
    $ docker run -d -v :/testDir test:v1                                               // creates an anonymous volume and mounts it as '/testDir' inside the container   
    </pre>
    </details>
    <h3 class="header"> Bind Mounts </h3>
    <p> - the host's specified directory structure is mounted directly inside the container (the host's data is accessible within the container) </p>
    <details class="example">
      <summary> DEMO : </summary>
      <pre class="cmd">
    $ docker run -d -v /home:/home test:v1                                             // the host's machine '/home' directory is mounted insed the contaier as '/home'   // -! this obscures the container's '/home' directory   
    
    $ docker run -d -v /home:/home:ro test:v1                                          // the bound directory is read only     
    
    $ docker run -d -v /home:/hostHome test:v1                                         // the host's machine '/home' directory is mounted insed the contaier as '/hostHome' (this way the contaier's /home directory is not obsucred)     
    </pre>
    </details>
    <h3 class="header"> Tmpfs (Linux Only) </h3>
    <p> - temporary file-system mounts are stored only in memoy (data is not written on disk and lost <u>when the container stops</u>) </p>
    <details class="example">
      <summary> DEMO : </summary>
      <pre class="cmd">
    $ docker run -d --tmpfs /tempDir test:v1                                           // a tmpfs directory is mounted as '/tempDir' 
                                                                                       // -! data stored in /tempDir inside the container is sotred only in the host's memory and lost when the container stops 
    </pre>
    </details>
    <hr>
    <!--------------------------------------------------------------------------------------------->
    <h2 class="headerExtra"><u> Docker network </u></h2>
    <p> - docker containers are (sort of) isolated systems, so they need to be connected to some kind of network in order to coummunicate with other nodes on the network </p>
    <p> - docker offers sereral network solutions (docker network types) </p>
    <p> - only container connected on the same network can communicate with each other, a container can be connected to multiple networks (just like a normal host) </p>
    <!--------------------------------------------------------------------------------------------->
    <h3 class="header"> host network </h3>
    <p> - the docker container is directly routed to one of the host machine's ip address and port </p>
    <p> - we route the traffic <mark><strong>container:port</strong> -> <strong>hostIp:port</strong></mark> (ex: <mark><strong>container</strong>:3000 -> 196.168.0.3:5000</mark>, the traffict is routed from host <mark>196.168.0.3:3000</mark> to <mark><strong>container</strong>:5000</mark>) </p>
    <p> - the host network does not conflict with the bridge network, so the container can be connected on the bridge network but also routed to the host machine's specified ip address and port </p>
    <p> - the docker host network is a way to route the traffic host to container, so it isn't real a network layer <u>therefore it cannot be created</u> </p>
    <details class="example">
      <summary> DEMO : </summary>
      <pre class="cmd">
    $ docker run -d --name testcont -p 80:3000 testimg                                 // testcont container will be routed host 0.0.0.0:80 to container :3000   
    $ docker port testcont
      3000/tcp -> 0.0.0.0:80
      3000/tcp -> :::80
    
    
    $ docker run -d --name testcont2 -p 192.168.100.183:81:3000 testimg                // testcont2 container will be routed host 192.168.100.183:81 to container :3000   
    $ docker port testcont2
      3000/tcp -> 192.168.100.183:81
    
    
    $ docker run -d --name testcont3 -P testimg2                                       // the <mark>Dockerfile</mark> which the testimg2 is build from contains a fileld <mark>EXPOSE 3000</mark>  
    $ docker port testcont3                                                            // when starting the container with the -P flag the exposed port (3000) will be routed to a random port on the host    
      3000/tcp -> 0.0.0.0:49155
      3000/tcp -> :::49155
    
    
    $ docker run -d --name testcont4 --network host testimg                            // the testcont4 will have full access to the host's network (just like we were on the host machine)
    $ docker port testcont4                                                            // -! nothing visible here 
      // doesn't return anything 
    </pre>
    </details>
    <!--------------------------------------------------------------------------------------------->
    <h3 class="header"> bridge network </h3>
    <p> - the bridge network is a virtual subnetwork where containers are connected together, it has its own gateway dhcp etc.. (a fully featured network) </p>
    <p> - the host machine itself is also part of bride networks (gateway usually) <u>therefore bridge networks are also visible in the list of network interfaces</u></p>
    <p> - there are 2 types of bridge networks: <mark class="mark">default</mark> and <mark class="mark">user-defined</mark> </p>
    <p style="text-indent:20px"> - the <mark class="mark">default bridge network (<mark>docker0</mark>)</mark> is automatically created and cannot be removed </p>
    <p style="text-indent:45px"> - newly created containers are connected to it (by default) </p>
    <p style="text-indent:45px"> - does not support DNS lookup, so containers on this network has to be referred by <mark><strong>ip</strong>:<strong>port</strong></mark> address</p>
    <p style="text-indent:20px"> - <mark class="mark">user-defined bridge networks</mark> are manually created/removed, containers has to be explicitly connected to it </p>
    <p style="text-indent:45px"> - supports DNS lookup, so containers on this network can be referred by container name</p>
    <details class="example">
      <summary> DEMO : </summary>
      <pre class="cmd">
// docker network ls / docker network inspect -----------------------------------------
    $ docker network ls                                                                // prints all networks the docker daemon knows about   
        NETWORK ID     NAME      DRIVER    SCOPE
        0ca6c1ad5b65   bridge    bridge    local
        ced286202f44   host      host      local
        a6b1b3ae76ab   my-net    bridge    local                                       // custom bridge network    
        3f4ea7b810e8   none      null      local
    
    $ docker network inspect my-net                                                    // informations about the my-net bridge network    
        ]{
            "Name": "my-net",
            "Id": "a6b1b3ae76ab7694fd349ef374f4267aaa1aa5dffcbd03a69f1c6a29df45e470",
        // ...
    
// docker network create --------------------------------------------------------------
    $ docker network create my-net                                                     // creates a custom bridge network with default settings (supnet ip is 172.17.0.0/16)
    
    $ docker network create \ 
      --subnet 10.0.0.0/8 \                                                            // specifies the subnet 
      --gateway 10.0.0.1 \
      --ip-range 10.0.0.100/30 \                                                       // only 4 ips are usable (10.0.0.100/29 would be 8 ips / 11.0.0.100/28 would be 16 ips)
      my-ne2                                                                           // network name   
    
// docker network rm / docker network prune -------------------------------------------
    $ docker network rm my-net                                                         // removes the my-net network    
    
    $ docker network prune                                                             // removes all unsuded networks (empty networks where no conntainers are connected at all)    
    
// docker network connect / docker network disconnect ---------------------------------
    $ docker network disconnect bridge testcont                                        // disconnects the testcont container from the bridge network (default network)  
    
    $ docker network connect my-net testcont                                           // connects the testcont container to the my-net network   
    $ docker network connect --ip 10.0.0.254 my-net testcont                           // the test container uses the 10.0.0.254 IP on the my-net network    
    
// docker port ------------------------------------------------------------------------
    $ docker port testcont                                                             // returns the coutnainer's all routed ports 
      3000/tcp -> 0.0.0.0:49155                                                        // container:3000 is routed to host 0.0.0.0:49155   
      3000/tcp -> :::49155
    </pre>
      <pre class="cmd">
    $ docker network ls
      NETWORK ID     NAME      DRIVER    SCOPE
      85ef8f12dec6   bridge    bridge    local                                         // default bridge network   
      ced286202f44   host      host      local
      30dbc5a2d0b5   my-net    bridge    local                                         // user-defined bridge network   
      3f4ea7b810e8   none      null      local
    
// ------------------------------------------------------------------------------------
    $ docker run -d --name testcont testimg                                            // by default starting containers are connected to the default bridge network   
    $ docker run -d --name testcont2 testimg
    
    $ network inspect bridge 
      [{
        "Name": "bridge",
        // ...
        "Containers": {
            "3b68f7532db74f62ce3f92a0daf915be6e0f3e8e32e400e0016475a555ffc8a8": {
                "Name": "testcont2",
                "EndpointID": "263fb7d6c23970b099c486eb8172df2aa416884bcec0dc919703150f19304764",
                "MacAddress": "02:42:ac:11:00:03",
                "IPv4Address": "172.17.0.3/16",
                "IPv6Address": ""
            },
            "cd5446a8d9853cf2b92cf67580681063a6391d7c5f434e3587699bfce71e78b5": {
                "Name": "testcont",
                "EndpointID": "0f422916aaaf0f04edde509277267990458f90407bbed6f46f897936f1009fac",
                "MacAddress": "02:42:ac:11:00:02",
                "IPv4Address": "172.17.0.2/16",
                "IPv6Address": ""
            }
        // ...
        }]
    
// ------------------------------------------------------------------------------------
    $ docker run -d --name testcont --network my-net testimg                           // connects the starting containers to the user defined my-net bridge network   
    $ docker run -d --name testcont2 --network my-net testimg
    
    $ docker network inspect my-net
      [{
        "Name": "my-net",
        // ...
        "Containers": {
            "36f36fca8fc9aa8da582c77a2bd60b7d9c88a47843a0ca323873faff715016c1": {
                "Name": "testcont2",
                "EndpointID": "02869e10dde5af62af8e135ee129d51501089da18e24e475bbcd7663dabd1e8a",
                "MacAddress": "02:42:0a:00:00:03",
                "IPv4Address": "10.0.0.3/16",
                "IPv6Address": ""
            },
            "53493cdb0f818559255f5f458d969092d4850a3e8d02b9668f2416711ea862ea": {
                "Name": "testcont",
                "EndpointID": "c0d4cdc0342d64234182fa0b36fe9de70d32e8fda6a1c193611944c58873bdeb",
                "MacAddress": "02:42:0a:00:00:02",
                "IPv4Address": "10.0.0.2/16",
                "IPv6Address": ""
            }
        // ...
        }]
    </pre>
    </details>
    <!--------------------------------------------------------------------------------------------->
    <h3 class="header"> none network </h3>
    <p> - containers connected on the <mark class="mark">none</mark> network are prevented to have any network connections, so they are completely isolated </p>
    <details class="example">
      <summary> DEMO : </summary>
      <pre class="cmd">
    $ docker run -d --name testcont --network none testimg                             // connects the testcont container to the none network on startup   
    
    $ docker network connect none testcont2                                            // connects the testcont2 container to the none network (possible if the container is not part of any network)    
    </pre>
    </details>
    <!--------------------------------------------------------------------------------------------->
    <h3 class="header"> macvlan and ipvlan networks </h3>
    <p> - connects the container directly on the physical network of the host machine (<mark class="mark">macvlan</mark> the container has its own ip and mac addres VS <mark class="mark">ipvlan</mark> container does not have its own mac address) </p>
    <details class="example">
      <summary> DEMO : </summary>
      <pre class="cmd">
    // -! the created ipvlan or macvlan interface is not visible on the host machine 
    // !! for some reason the <mark>macvlan</mark> network did not worked when I tested this (some network protection maybe, but it should work the same way as the ipvlan did in the example below)     
    
    $ docker network create --driver ipvlan /                                            // network driver ipvlan 
        --subnet 192.168.0.0/24 /                                                        // host's network
        --gateway 192.168.0.1 /                                                          // host's gateway 
        --ip-range 192.168.0.100/32 /                                                    // docker dhcp can assign only one ip address (this is for avoiding ip assign conflicts on the subnetwork)    
        -o parent=wlp0s20f3 /                                                            // parent interface (the network where we are connecting)    
        myipvlan                                                                         // docker network name    
    
    $ docker run -d --name testcont --network myipvlan testimg                           // the test container is attached to the ipvlan network (reachable form the pysical network of the host)    
                                                                                         // we can ping it from the pysical network (ex: <mark>ping 192.168.0.100</mark>)
    
    $ docker run -d --name testcont --ip 192.168.0.101 --network myipvlan testimg2       // we can connect multiple containers to the <mark cass="mark">myipvlan</mark> network assigning static ip address to the container (<mark>--ip 192.168.0.101</mark>)
    </pre>
    </details>
    <!--------------------------------------------------------------------------------------------->
    <h3 class="header"> overlay network </h3>
    <p> - communication between docker daemons (NOT TESTED)</p>

    <br><br>
  </body>

</html>