<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title> Eloquen JavaScript </title>    
	<link rel="stylesheet" type="text/css" href="styles.css">
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="Project Module/main.js"></script>
</head>
<body>
<h1> Eloquent JavaScript Practices </h1>
	<p> Updated ( 2018-06-27 / 2018-08-08 / 2018-08-14 )</p>
    <p class="sitenav"> <a href="../index.html">back></a>
    </p>
<h1 style="color:yellow;"><u> There are a bunch of tests see the code! </u></h1>
<h2><u> Chapter 2 </u></h2>
<h3><u> Exercise : </u></h3>
<h4><u> Looping Triangle </u></h4>
<script>
// this function makes and prints a triangle
    var triangle = function() {
        var addItem = ""
        for(let i = 0; i < 7; i++) {
            addItem += "#";
            document.write( addItem + "<br>" );
        }
    }
    triangle();
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
// this function makes and prints a triangle
    var triangle = function() {
        var addItem = ""
        for(let i = 0; i &lt; 7; i++) {
            addItem += "#";
            document.write( addItem + "&lt;br&gt;" );
        }
    }
    triangle();
&lt;/script&gt;
        </pre>
        </details>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>
<h4><u> FizzBuzz </u></h4>
<script>
// this function counts form 1 to 100, numbers dividable by 3 replaced with Fizz and number dividable by 5 replaced with Buzz
    var FizzBuzz = function() {
        for(let i = 1; i <= 100; i++) {
            if(i % 3 == 0) {
                document.write("Fizz" + " ");
            }
            else if(i % 5 == 0) {
                document.write("Buzz" + " ");
            }
            else {
                document.write(i + " ");
            }
        }
    }
    FizzBuzz();

// this function counts form 1 to 100, numbers dividable by 3 and 5 replaced with FizzBuzz
    document.write("<br>" + "<br>");
    var FizzBuzz_2 = function() {
        for(let i = 1; i <= 100; i++) {
            if(i % 3 == 0 && i % 5 == 0) {
                document.write("FizzBuzz" + " ");
            }
            else {
                document.write(i + " ");
            }
        }
    }
    FizzBuzz_2();
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
// this function counts form 1 to 100, numbers dividable by 3 replaced with Fizz and number dividable by 5 replaced with Buzz
    var FizzBuzz = function() {
        for(let i = 1; i &lt;= 100; i++) {
            if(i % 3 == 0) {
                document.write("Fizz" + " ");
            }
            else if(i % 5 == 0) {
                document.write("Buzz" + " ");
            }
            else {
                document.write(i + " ");
            }
        }
    }
    FizzBuzz();

// this function counts form 1 to 100, numbers dividable by 3 and 5 replaced with FizzBuzz
    document.write("&lt;br&gt;" + "&lt;br&gt;");
    var FizzBuzz_2 = function() {
        for(let i = 1; i &lt;= 100; i++) {
            if(i % 3 == 0 &amp;&amp; i % 5 == 0) {
                document.write("FizzBuzz" + " ");
            }
            else {
                document.write(i + " ");
            }
        }
    }
    FizzBuzz_2();
&lt;/script&gt;
        </pre>
        </details>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>
<h2><u> Chapter 3 </u></h2>    
<h3><u> Exercises : </u></h3>
<h4><u> Recursion 1 </u></h4>
<script>
// this function returns the formula how a number reached only by added 5 or multiplied by 3 itslef 
    function findSolution(target) {
        function find(current, history) {
            if (current == target) {
                return history;
            } 
            else if (current > target) {
                return null;
            } 
            else {
                return find(current + 5, `(${history} + 5)`) || find(current * 3, `(${history} * 3)`);  
            }
      }
      return find(1, "1");
    }

    document.write(findSolution(24));  
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
// this function returns the formula how a number reached only by added 5 or multiplied by 3 itslef 
    function findSolution(target) {
        function find(current, history) {
            if (current == target) {
                return history;
            } 
            else if (current > target) {
                return null;
            } 
            else {
                return find(current + 5, `(${history} + 5)`) || find(current * 3, `(${history} * 3)`);  
            }
      }
      return find(1, "1");
    }

    document.write(findSolution(24));  
&lt;/script&gt;
        </pre>
        </details>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>    
<h4><u> Minimum </u></h4>
<script>
// this function takes two argument numbers and returns the smallest    
    var min = function(a, b) {
        if(a < b) {
            return a;
        }    
        else {
            return b;
        }
    }
    document.write( min(41, 72) );
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
// this function takes two argument numbers and returns the smallest    
    var min = function(a, b) {
        if(a &lt; b) {
            return a;
        }    
        else {
            return b;
        }
    }
    document.write( min(41, 72) );
&lt;/script&gt;
        </pre>
        </details>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>    
<h4><u> Recursion "stack blow" </u></h4>
<script>
// this function returns "true" for even, returns "false" for odd numbers and blows the stack if other thing is given
    var isEven = function(a) {
        if(a % 2 == 0) {
            return true;
        }
        else if(a % 2 == 1) {
            return false;
        }
        else {
            return isEven(a);
        }
        
    }
    
    document.writeln( isEven(0) );
    document.writeln( isEven(4477342) );
    // document.writeln( isEven(-1) );           // this "blows the stack"
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
// this function returns "true" for even, returns "false" for odd numbers and blows the stack if other thing is given
    var isEven = function(a) {
        if(a % 2 == 0) {
            return true;
        }
        else if(a % 2 == 1) {
            return false;
        }
        else {
            return isEven(a);
        }
        
    }
    
    document.writeln( isEven(0) );
    document.writeln( isEven(4477342) );
    //document.writeln( isEven(-1) );           // this "blows the stack"
&lt;/script&gt;
        </pre>
        </details>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>
<h4><u> Beat Counting </u></h4>    
<script>
// this function counts all "B"'s in a string and returns a number
    var countBs = function(a) {
        var counter = 0;
        for(let i = 0; i < a.length; i++) {
            if(a[i] == "B") {
                counter++;
            }
        }
        return counter;
    }
    document.writeln( countBs("TadaddBdaaBdd") );
    
// this function counts all "specified characters" in a string and returns a number
    var countChar = function(a, b) {
        var counter = 0;
        for(let i = 0; i < a.length; i++) {
            if(a[i] == b) {
                counter++;
            }
        }
        return counter;
    }
    document.writeln( countChar("TadadaaaadBdaaBdd", "a") );
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
// this function counts all "B"'s in a string and returns a number
    var countBs = function(a) {
        var counter = 0;
        for(let i = 0; i &lt; a.length; i++) {
            if(a[i] == "B") {
                counter++;
            }
        }
        return counter;
    }
    document.writeln( countBs("TadaddBdaaBdd") );
    
// this function counts all "specified characters" in a string and returns a number
    var countChar = function(a, b) {
        var counter = 0;
        for(let i = 0; i &lt; a.length; i++) {
            if(a[i] == b) {
                counter++;
            }
        }
        return counter;
    }
    document.writeln( countChar("TadadaaaadBdaaBdd", "a") );
&lt;/script&gt;
        </pre>
        </details>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>
<h2><u> Chapter 4 </u></h2>     
<h3><u> Exercise : </u></h3>
<h4><u> Sum Of a Range </u></h4>
<script>
// this funciton return the full range between two numbers in one array
    function range(a, b) {
        var cont = [];
        for(let i = a; i <= b; i++){
            cont.push(i);
        }
        return cont;
    }
    
// this function takes one array as argument and adds all itmes together
    var sum = function(a) {
        var addCont = 0;
        for(let i = 0; i < a.length; i++) {
            addCont = addCont + a[i];
        }
        return addCont;
    };
// print
    document.write( sum(range(1, 10)) );
    document.write( "<br>" );
    
// this function return the full range between two numbers in one array, but thakes a 3rd argument which specifies the step (default step is 1), accepts also negative step conter to count reversely
    var range_2 = function(a, b, c = 1) {
        var stepOptional = String(c);
        if(stepOptional == 0) {
            return "Invalid counter!"
        }
        var cont = [];
        for(let i = a; i <= b; i = i + Math.abs(c)) {
            cont.push(i);
        }
        if(stepOptional[0] == "-") {
            cont.reverse();
        }
        
        return cont;
    }
// print
    document.write( range_2(1, 40, -10) );
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
// this funciton return the full range between two numbers in one array
    function range(a, b) {
        var cont = [];
        for(let i = a; i &lt;= b; i++){
            cont.push(i);
        }
        return cont;
    }
    
// this function takes one array as argument and adds all itmes together
    var sum = function(a) {
        var addCont = 0;
        for(let i = 0; i &lt; a.length; i++) {
            addCont = addCont + a[i];
        }
        return addCont;
    };
// print
    document.write( sum(range(1, 10)) );
    document.write( "&lt;br&gt;" );
    
// this function return the full range between two numbers in one array, but thakes a 3rd argument which specifies the step (default step is 1), accepts also negative step conter to count reversely
    var range_2 = function(a, b, c = 1) {
        var stepOptional = String(c);
        if(stepOptional == 0) {
            return "Invalid counter!"
        }
        var cont = [];
        for(let i = a; i &lt;= b; i = i + Math.abs(c)) {
            cont.push(i);
        }
        if(stepOptional[0] == "-") {
            cont.reverse();
        }
        
        return cont;
    }
// print
    document.write( range_2(1, 40, -10) );
&lt;/script&gt;
        </pre>
        </details>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>
<h4><u> Array revers custom function </u></h4>
<script>
    var myArray_r = ["egy", "ketto", "harom", "negy"];
// this function reverses an array like the built in .reverse() method and returns a new array
    var reverseArray = function(a) {
        var array = [];
        for(let i = a.length; i > 0; i--) {
            array.push(a[i - 1]);
        }
        return array;
    }
// print
    document.write( reverseArray(myArray_r) );
    document.write( "<br>" );
    
// this function reverses an array and returns the original array // (what a mess but work!)
    var reverseArrayInPlace = function(a){
        var array = [];
        var length = a.length;
        for(let i = length; i > 0; i--) {
            array.push(a[i - 1]);
        }
        for(let i = length; i > 0; i--) {
            delete a[i - 1];
        }
        for(let i = 0; i < length; i++) {
            a.shift();
            a.push(array[i]);
        }
        return a;
    }
// print
    document.write( reverseArrayInPlace(myArray_r) );
    
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
    var myArray_r = ["egy", "ketto", "harom", "negy"];
// this function reverses an array like the built in .reverse() method and returns a new array
    var reverseArray = function(a) {
        var array = [];
        for(let i = a.length; i > 0; i--) {
            array.push(a[i - 1]);
        }
        return array;
    }
// print
    document.write( reverseArray(myArray_r) );
    document.write( "&lt;br&gt;" );
    
// this function reverses an array and returns the original array // (what a mess but work!)
    var reverseArrayInPlace = function(a){
        var array = [];
        var length = a.length;
        for(let i = length; i &gt; 0; i--) {
            array.push(a[i - 1]);
        }
        for(let i = length; i &gt; 0; i--) {
            delete a[i - 1];
        }
        for(let i = 0; i &lt; length; i++) {
            a.shift();
            a.push(array[i]);
        }
        return a;
    }
// print
    document.write( reverseArrayInPlace(myArray_r) );
    
&lt;/script&gt;
        </pre>
        </details>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>
<h4><u> a List </u></h4>
<script>
// this function takes an array with and returns an Object list like  "let list = {value:1, rest:{value:2, rest:{value:3, rest:null}}}; "
    let myArray = [1, 2, 3];
    function arrayToList(array) { 
        let list = null;
        for (let i = array.length -1; i >= 0; i--) {    // this is some Crazy Brilliant stuff!!! :D
            list = {value: array[i], rest: list};       // this code is added after the "list" variable each time 
        }                                               // elements are inserted 
        return list;
    }
// bind the returned object as a property of the global scope  
    let list = arrayToList(myArray);  
    
// here is the explanation of the above loop which is freaking awesome!!!
    let list_2;                         // we declare "undefined"
    list_2 = {value:3, rest:list_2};    // when we redeclare the id "list_2" the above "list_2" will BECOME the "rest" identifier's value here!
    list_2 = {value:2, rest:list_2};    // this happens again here all stuff contained by "list_2" BECOME the "rest" id's value
    list_2 = {value:1, rest:list_2};    // last iteration does the same
    
// here is the heart of this mechanism
    let duck = "kacsa";
    let myTestObj = {navieProp:21, nestObj:{inheritedProp:duck}}    
        // the "duck" identifier is defined as "inherigedProp" identifier's value here 
        // at this time my mistake was that nested properties or objects do not have their scopes!
        // this all declaration is happening within a scope which is perfectly fine!
    
// ---------------------------------------------------------------------------------------------------------------------
// this function extracts the values form the above created object list types
    function listToArray(list) {
        let array = [];
        for (let node = list; node; node = node.rest) {
            array.push(node.value);
        }
            // for loop runs the first statement = binds the passed object to the "node" identifier
            // second step = object evaluated "true" = for loop runs a pass 
            // block is executed the first "value" identifiers value is pushed in the array
            // the 3rd statement is executed in the for loop = redefines the node by the original object's "rest" property 
                // which is the nested object 
            // this process is repeated 3 times 
            // the last iteration the "rest" value is "null" so that ends the loop!
        return array;
    }
    
    document.write(listToArray(list));
    
// ---------------------------------------------------------------------------------------------------------------------
// this functin creates an objet list element each time is called, 
    // the beauti is that it can be stacked in order to create a full Object list type like above
    function prepend(value, list = {}) {
        return {value, rest: list};
    }
    
    let stackedList = prepend(1, prepend(2, prepend(3)));
        // this acctually created the same list as the first function in this chapter
    
// ---------------------------------------------------------------------------------------------------------------------
// this function returns the list value's on a specified level, 0 = first level, 1 second and so on
    function nth(list, n) {
        if (!list) return undefined;
        else if (n == 0) return list.value;
        else return nth(list.rest, n - 1);
    }
        // if the number is above 0 function recurses (passes the element at that level) as many times as specified,
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
// this function takes an array with and returns an Object list like  "let list = {value:1, rest:{value:2, rest:{value:3, rest:null}}}; "
    let myArray = [1, 2, 3];
    function arrayToList(array) { 
        let list = null;
        for (let i = array.length -1; i >= 0; i--) {    // this is some Crazy Brilliant stuff!!! :D
            list = {value: array[i], rest: list};       // this code is added after the "list" variable each time 
        }                                               // elements are inserted 
        return list;
    }
// bind the returned object as a property of the global scope  
    let list = arrayToList(myArray);  
    
// here is the explanation of the above loop which is freaking awesome!!!
    let list_2;                         // we declare "undefined"
    list_2 = {value:3, rest:list_2};    // when we redeclare the id "list_2" the above "list_2" will BECOME the "rest" identifier's value here!
    list_2 = {value:2, rest:list_2};    // this happens again here all stuff contained by "list_2" BECOME the "rest" id's value
    list_2 = {value:1, rest:list_2};    // last iteration does the same
    
// here is the heart of this mechanism
    let duck = "kacsa";
    let myTestObj = {navieProp:21, nestObj:{inheritedProp:duck}}    
        // the "duck" identifier is defined as "inherigedProp" identifier's value here 
        // at this time my mistake was that nested properties or objects do not have their scopes!
        // this all declaration is happening within a scope which is perfectly fine!
    
// ---------------------------------------------------------------------------------------------------------------------
// this function extracts the values form the above created object list types
    function listToArray(list) {
        let array = [];
        for (let node = list; node; node = node.rest) {
            array.push(node.value);
        }
            // for loop runs the first statement = binds the passed object to the "node" identifier
            // second step = object evaluated "true" = for loop runs a pass 
            // block is executed the first "value" identifiers value is pushed in the array
            // the 3rd statement is executed in the for loop = redefines the node by the original object's "rest" property 
                // which is the nested object 
            // this process is repeated 3 times 
            // the last iteration the "rest" value is "null" so that ends the loop!
        return array;
    }
    
    document.write(listToArray(list));
    
// ---------------------------------------------------------------------------------------------------------------------
// this functin creates an objet list element each time is called, 
    // the beauti is that it can be stacked in order to create a full Object list type like above
    function prepend(value, list = {}) {
        return {value, rest: list};
    }
    
    let stackedList = prepend(1, prepend(2, prepend(3)));
        // this acctually created the same list as the first function in this chapter
    
// ---------------------------------------------------------------------------------------------------------------------
// this function returns the list value's on a specified level, 0 = first level, 1 second and so on
    function nth(list, n) {
        if (!list) return undefined;
        else if (n == 0) return list.value;
        else return nth(list.rest, n - 1);
    }
        // if the number is above 0 function recurses (passes the element at that level) as many times as specified,
&lt;/script&gt;
        </pre>
        </details>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>
<h4><u> Deep Comparison </u></h4>
<script>
// this function compares two values object together and returns "true" if values or all object's properties are the same
    function deepEqual(a, b) {
        if (a === b) return true;
  
        if (a == null || typeof a != "object" ||
            b == null || typeof b != "object") return false;    

        let keysA = Object.keys(a), keysB = Object.keys(b);

        if (keysA.length != keysB.length) return false;         // if the number of properties are not equal 

        for (let key of keysA) {
        if (!keysB.includes(key) || !deepEqual(a[key], b[key])) return false;
        }
            // the second part of the OR logical operator recurses nested objects what an awesome algorithm!
    return true;
    }
    
    var objA = {prop_1:"myString", prop_2:41, prop_3:{propNest:77}};
    var objB = {prop_1:"myString", prop_2:41, prop_3:{propNest:77}};
    
   document.write( deepEqual(objA, objB) );
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
// this function compares two values object together and returns "true" if values or all object's properties are the same
    function deepEqual(a, b) {
        if (a === b) return true;
  
        if (a == null || typeof a != "object" ||
            b == null || typeof b != "object") return false;    

        let keysA = Object.keys(a), keysB = Object.keys(b);

        if (keysA.length != keysB.length) return false;         // if the number of properties are not equal 

        for (let key of keysA) {
        if (!keysB.includes(key) || !deepEqual(a[key], b[key])) return false;
        }
            // the second part of the OR logical operator recurses nested objects what an awesome algorithm!
    return true;
    }
    
    var objA = {prop_1:"myString", prop_2:41, prop_3:{propNest:77}};
    var objB = {prop_1:"myString", prop_2:41, prop_3:{propNest:77}};
    
    document.write( deepEqual(objA, objB) );
&lt;/script&gt;
        </pre>
        </details>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>    
<h2><u> Chapter 5 (Higher order functions) </u></h2>
<script>
    let cars = [];
    
    function repeatAction(nr, action) {
        for(let i = 0; i < nr; i++) {
            action(i);                          // this is where "addArr_items" function executed a number of times the loop calls it
        }                                       // the value is passed by the "repeatAction" function ! 
    }
    
    function addArr_items(i) {                  // this is a simple function which pushes a new item in the targeted array
        cars.push("Car" + (i + 1));
    }
    repeatAction(4, addArr_items);              // call the parent functions, the second value is the nested function
                                                    // 4 new items are added to the array
    
    repeatAction(4, (i) => {cars.push("Car" + (i + 1));});
                                                // we do the same thing here but on the spot with an arrow function 
    
// this is a simple closure    
// ------------------------------------------------------------------------------
    function greaterThan(n) {
        return m => m > n;
    }
    let greaterThan10 = greaterThan(10);
// the "greaterThan10" is the higher order function here
    
// under the same identifier we can call and pass arguments to the nested functions
//-------------------------------------------------------------------------------  
    function firstLev() {
        return (a, b) => a + b;
    }
    firstLev()(4, 4);              // returns 8
     // --------------------------------------------------------------------------
    
    function noisy(f) {
        return (...args) => {                           // arguments spreaded in here
            console.log("calling with", args);          // first pring the passed argument of the nested function
            let result = f(...args);                    // the "f" refferst to the "Math.min" here 
                                                        // the "(...args)" spreads the passed value and executes 
                                                        // at this point the basicallay "Math.min(3, 2, 1)" is executed and bound
            console.log("called with", args, ", returned", result);
            return result;                              // then we just print in console and return to the parent (higher order) function
        }
    }
    
    noisy(Math.min)(3, 2, 1, 0);    // this beauty calls immediately the nested function what is in the return part of the higher order function
    
// controling flow (if argument false fire function)
//-------------------------------------------------------------------------------
    function unless(test, then) {
        if (!test) then();
    }
    // unless(0, () => {alert("false value passed")});    // fires alert window
    
// 3 nested higher order functions (that's crazy stuff!)
//-------------------------------------------------------------------------------                                       
// this function repeats an action a number of defined times just like above
    let repeat = function(n, action) {
        for(let i = 0; i < n; i++){
            action(i);
        }
    }
// this function test a value if it is false fires its second argument
    function unleSS(test, then) {
        if (!test) then();
    }
    
    repeat(3, n => {                            // the repeat function is callend and repeats 3 times its for loop and returns 1, 2, 3
                                    
        unleSS(n % 2 == 1, () =>                // the "unleSS" executes 3 times, each iteration retunrs a number form 1 to 3
                                                // thes returned number are evaluated on the spot and transformed into a boolean value
                                                // if evaluation is false the "unless" function's second argument fires 
                                                // the second argument passed as a value it fired by the "unleSS function
            { console.log(n, "is even"); })
    });
</script>
<script>
var SCRIPTS = [
  {
    name: "Adlam",
    ranges: [[125184, 125259], [125264, 125274], [125278, 125280]],
    direction: "rtl",
    year: 1987,
    living: true,
    link: "https://en.wikipedia.org/wiki/Fula_alphabets#Adlam_alphabet"
  },
  {
    name: "Caucasian Albanian",
    ranges: [[66864, 66916], [66927, 66928]],
    direction: "ltr",
    year: 420,
    living: false,
    link: "https://en.wikipedia.org/wiki/Caucasian_Albanian_alphabet"
  },
  {
    name: "Ahom",
    ranges: [[71424, 71450], [71453, 71468], [71472, 71488]],
    direction: "ltr",
    year: 1250,
    living: false,
    link: "https://en.wikipedia.org/wiki/Ahom_alphabet"
  },
  {
    name: "Arabic",
    ranges: [[1536, 1541], [1542, 1548], [1549, 1563], [1564, 1565], [1566, 1567], [1568, 1600], [1601, 1611], [1622, 1648], [1649, 1757], [1758, 1792], [1872, 1920], [2208, 2229], [2230, 2238], [2260, 2274], [2275, 2304], [64336, 64450], [64467, 64830], [64848, 64912], [64914, 64968], [65008, 65022], [65136, 65141], [65142, 65277], [69216, 69247], [126464, 126468], [126469, 126496], [126497, 126499], [126500, 126501], [126503, 126504], [126505, 126515], [126516, 126520], [126521, 126522], [126523, 126524], [126530, 126531], [126535, 126536], [126537, 126538], [126539, 126540], [126541, 126544], [126545, 126547], [126548, 126549], [126551, 126552], [126553, 126554], [126555, 126556], [126557, 126558], [126559, 126560], [126561, 126563], [126564, 126565], [126567, 126571], [126572, 126579], [126580, 126584], [126585, 126589], [126590, 126591], [126592, 126602], [126603, 126620], [126625, 126628], [126629, 126634], [126635, 126652], [126704, 126706]],
    direction: "rtl",
    year: 400,
    living: true,
    link: "https://en.wikipedia.org/wiki/Arabic_script"
  },
  {
    name: "Imperial Aramaic",
    ranges: [[67648, 67670], [67671, 67680]],
    direction: "rtl",
    year: 800,
    living: false,
    link: "https://en.wikipedia.org/wiki/Aramaic_alphabet"
  },
  {
    name: "Armenian",
    ranges: [[1329, 1367], [1369, 1376], [1377, 1416], [1418, 1419], [1421, 1424], [64275, 64280]],
    direction: "ltr",
    year: 405,
    living: true,
    link: "https://en.wikipedia.org/wiki/Armenian_alphabet"
  },
  {
    name: "Avestan",
    ranges: [[68352, 68406], [68409, 68416]],
    direction: "rtl",
    year: 400,
    living: false,
    link: "https://en.wikipedia.org/wiki/Avestan_alphabet"
  },
  {
    name: "Balinese",
    ranges: [[6912, 6988], [6992, 7037]],
    direction: "ltr",
    year: 1000,
    living: true,
    link: "https://en.wikipedia.org/wiki/Balinese_script"
  },
  {
    name: "Bamum",
    ranges: [[42656, 42744], [92160, 92729]],
    direction: "ltr",
    year: 1896,
    living: true,
    link: "https://en.wikipedia.org/wiki/Bamum_script"
  },
  {
    name: "Bassa Vah",
    ranges: [[92880, 92910], [92912, 92918]],
    direction: "ltr",
    year: 1950,
    living: false,
    link: "https://en.wikipedia.org/wiki/Bassa_alphabet"
  },
  {
    name: "Batak",
    ranges: [[7104, 7156], [7164, 7168]],
    direction: "ltr",
    year: 1300,
    living: true,
    link: "https://en.wikipedia.org/wiki/Batak_alphabet"
  },
  {
    name: "Bengali",
    ranges: [[2432, 2436], [2437, 2445], [2447, 2449], [2451, 2473], [2474, 2481], [2482, 2483], [2486, 2490], [2492, 2501], [2503, 2505], [2507, 2511], [2519, 2520], [2524, 2526], [2527, 2532], [2534, 2558]],
    direction: "ltr",
    year: 1050,
    living: true,
    link: "https://en.wikipedia.org/wiki/Bengali_alphabet"
  },
  {
    name: "Bhaiksuki",
    ranges: [[72704, 72713], [72714, 72759], [72760, 72774], [72784, 72813]],
    direction: "ltr",
    year: 1050,
    living: false,
    link: "https://en.wikipedia.org/wiki/Bhaiksuki_alphabet"
  },
  {
    name: "Bopomofo",
    ranges: [[746, 748], [12549, 12591], [12704, 12731]],
    direction: "ltr",
    year: 1918,
    living: true,
    link: "https://en.wikipedia.org/wiki/Bopomofo"
  },
  {
    name: "Brahmi",
    ranges: [[69632, 69710], [69714, 69744], [69759, 69760]],
    direction: "ltr",
    year: -250,
    living: false,
    link: "https://en.wikipedia.org/wiki/Brahmi_script"
  },
  {
    name: "Braille",
    ranges: [[10240, 10496]],
    direction: "ltr",
    year: 1824,
    living: true,
    link: "https://en.wikipedia.org/wiki/Braille"
  },
  {
    name: "Buginese",
    ranges: [[6656, 6684], [6686, 6688]],
    direction: "ltr",
    year: 1650,
    living: true,
    link: "https://en.wikipedia.org/wiki/Lontara_script"
  },
  {
    name: "Buhid",
    ranges: [[5952, 5972]],
    direction: "ltr",
    year: 1300,
    living: true,
    link: "https://en.wikipedia.org/wiki/Buhid_alphabet"
  },
  {
    name: "Chakma",
    ranges: [[69888, 69941], [69942, 69956]],
    direction: "ltr",
    year: 1050,
    living: true,
    link: "https://en.wikipedia.org/wiki/Chakma_alphabet"
  },
  {
    name: "Canadian Aboriginal",
    ranges: [[5120, 5760], [6320, 6390]],
    direction: "ltr",
    year: 1840,
    living: true,
    link: "https://en.wikipedia.org/wiki/Canadian_Aboriginal_syllabics"
  },
  {
    name: "Carian",
    ranges: [[66208, 66257]],
    direction: "ltr",
    year: -650,
    living: false,
    link: "https://en.wikipedia.org/wiki/Carian_alphabets"
  },
  {
    name: "Cham",
    ranges: [[43520, 43575], [43584, 43598], [43600, 43610], [43612, 43616]],
    direction: "ltr",
    year: 750,
    living: true,
    link: "https://en.wikipedia.org/wiki/Cham_alphabet"
  },
  {
    name: "Cherokee",
    ranges: [[5024, 5110], [5112, 5118], [43888, 43968]],
    direction: "ltr",
    year: 1820,
    living: true,
    link: "https://en.wikipedia.org/wiki/Cherokee_syllabary"
  },
  {
    name: "Coptic",
    ranges: [[994, 1008], [11392, 11508], [11513, 11520]],
    direction: "ltr",
    year: -200,
    living: false,
    link: "https://en.wikipedia.org/wiki/Coptic_alphabet"
  },
  {
    name: "Cypriot",
    ranges: [[67584, 67590], [67592, 67593], [67594, 67638], [67639, 67641], [67644, 67645], [67647, 67648]],
    direction: "rtl",
    year: -1100,
    living: false,
    link: "https://en.wikipedia.org/wiki/Cypriot_syllabary"
  },
  {
    name: "Cyrillic",
    ranges: [[1024, 1157], [1159, 1328], [7296, 7305], [7467, 7468], [7544, 7545], [11744, 11776], [42560, 42656], [65070, 65072]],
    direction: "ltr",
    year: 950,
    living: true,
    link: "https://en.wikipedia.org/wiki/Cyrillic_script"
  },
  {
    name: "Devanagari",
    ranges: [[2304, 2385], [2387, 2404], [2406, 2432], [43232, 43262]],
    direction: "ltr",
    year: 100,
    living: true,
    link: "https://en.wikipedia.org/wiki/Devanagari"
  },
  {
    name: "Deseret",
    ranges: [[66560, 66640]],
    direction: "ltr",
    year: 1854,
    living: true,
    link: "https://en.wikipedia.org/wiki/Deseret_alphabet"
  },
  {
    name: "Duployan",
    ranges: [[113664, 113771], [113776, 113789], [113792, 113801], [113808, 113818], [113820, 113824]],
    direction: "ltr",
    year: 1860,
    living: true,
    link: "https://en.wikipedia.org/wiki/Duployan_shorthand"
  },
  {
    name: "Egyptian Hieroglyphs",
    ranges: [[77824, 78895]],
    direction: "ltr",
    year: -3200,
    living: false,
    link: "https://en.wikipedia.org/wiki/Egyptian_hieroglyphs"
  },
  {
    name: "Elbasan",
    ranges: [[66816, 66856]],
    direction: "ltr",
    year: 1750,
    living: false,
    link: "https://en.wikipedia.org/wiki/Elbasan_alphabet"
  },
  {
    name: "Ethiopic",
    ranges: [[4608, 4681], [4682, 4686], [4688, 4695], [4696, 4697], [4698, 4702], [4704, 4745], [4746, 4750], [4752, 4785], [4786, 4790], [4792, 4799], [4800, 4801], [4802, 4806], [4808, 4823], [4824, 4881], [4882, 4886], [4888, 4955], [4957, 4989], [4992, 5018], [11648, 11671], [11680, 11687], [11688, 11695], [11696, 11703], [11704, 11711], [11712, 11719], [11720, 11727], [11728, 11735], [11736, 11743], [43777, 43783], [43785, 43791], [43793, 43799], [43808, 43815], [43816, 43823]],
    direction: "ltr",
    year: -900,
    living: true,
    link: "https://en.wikipedia.org/wiki/Ge%27ez_script"
  },
  {
    name: "Georgian",
    ranges: [[4256, 4294], [4295, 4296], [4301, 4302], [4304, 4347], [4348, 4352], [11520, 11558], [11559, 11560], [11565, 11566]],
    direction: "ltr",
    year: 430,
    living: true,
    link: "https://en.wikipedia.org/wiki/Georgian_scripts"
  },
  {
    name: "Glagolitic",
    ranges: [[11264, 11311], [11312, 11359], [122880, 122887], [122888, 122905], [122907, 122914], [122915, 122917], [122918, 122923]],
    direction: "ltr",
    year: 862,
    living: false,
    link: "https://en.wikipedia.org/wiki/Glagolitic_script"
  },
  {
    name: "Masaram Gondi",
    ranges: [[72960, 72967], [72968, 72970], [72971, 73015], [73018, 73019], [73020, 73022], [73023, 73032], [73040, 73050]],
    direction: "ltr",
    year: 1918,
    living: true,
    link: "https://en.wikipedia.org/wiki/Gondi_writing#Masaram"
  },
  {
    name: "Gothic",
    ranges: [[66352, 66379]],
    direction: "ltr",
    year: 350,
    living: false,
    link: "https://en.wikipedia.org/wiki/Gothic_alphabet"
  },
  {
    name: "Grantha",
    ranges: [[70400, 70404], [70405, 70413], [70415, 70417], [70419, 70441], [70442, 70449], [70450, 70452], [70453, 70458], [70460, 70469], [70471, 70473], [70475, 70478], [70480, 70481], [70487, 70488], [70493, 70500], [70502, 70509], [70512, 70517]],
    direction: "ltr",
    year: 550,
    living: false,
    link: "https://en.wikipedia.org/wiki/Grantha_alphabet"
  },
  {
    name: "Greek",
    ranges: [[880, 884], [885, 888], [890, 894], [895, 896], [900, 901], [902, 903], [904, 907], [908, 909], [910, 930], [931, 994], [1008, 1024], [7462, 7467], [7517, 7522], [7526, 7531], [7615, 7616], [7936, 7958], [7960, 7966], [7968, 8006], [8008, 8014], [8016, 8024], [8025, 8026], [8027, 8028], [8029, 8030], [8031, 8062], [8064, 8117], [8118, 8133], [8134, 8148], [8150, 8156], [8157, 8176], [8178, 8181], [8182, 8191], [8486, 8487], [43877, 43878], [65856, 65935], [65952, 65953], [119296, 119366]],
    direction: "ltr",
    year: -800,
    living: true,
    link: "https://en.wikipedia.org/wiki/Greek_alphabet"
  },
  {
    name: "Gujarati",
    ranges: [[2689, 2692], [2693, 2702], [2703, 2706], [2707, 2729], [2730, 2737], [2738, 2740], [2741, 2746], [2748, 2758], [2759, 2762], [2763, 2766], [2768, 2769], [2784, 2788], [2790, 2802], [2809, 2816]],
    direction: "ltr",
    year: 1592,
    living: true,
    link: "https://en.wikipedia.org/wiki/Gujarati_alphabet"
  },
  {
    name: "Gurmukhi",
    ranges: [[2561, 2564], [2565, 2571], [2575, 2577], [2579, 2601], [2602, 2609], [2610, 2612], [2613, 2615], [2616, 2618], [2620, 2621], [2622, 2627], [2631, 2633], [2635, 2638], [2641, 2642], [2649, 2653], [2654, 2655], [2662, 2678]],
    direction: "ltr",
    year: 1550,
    living: true,
    link: "https://en.wikipedia.org/wiki/Gurmukh%C4%AB_alphabet"
  },
  {
    name: "Hangul",
    ranges: [[4352, 4608], [12334, 12336], [12593, 12687], [12800, 12831], [12896, 12927], [43360, 43389], [44032, 55204], [55216, 55239], [55243, 55292], [65440, 65471], [65474, 65480], [65482, 65488], [65490, 65496], [65498, 65501]],
    direction: "ltr",
    year: 1443,
    living: true,
    link: "https://en.wikipedia.org/wiki/Hangul"
  },
  {
    name: "Han",
    ranges: [[11904, 11930], [11931, 12020], [12032, 12246], [12293, 12294], [12295, 12296], [12321, 12330], [12344, 12348], [13312, 19894], [19968, 40939], [63744, 64110], [64112, 64218], [131072, 173783], [173824, 177973], [177984, 178206], [178208, 183970], [183984, 191457], [194560, 195102]],
    direction: "ltr",
    year: -1100,
    living: true,
    link: "https://en.wikipedia.org/wiki/Chinese_characters"
  },
  {
    name: "Hanunoo",
    ranges: [[5920, 5941]],
    direction: "ltr",
    year: 1300,
    living: true,
    link: "https://en.wikipedia.org/wiki/Hanun%C3%B3%27o_alphabet"
  },
  {
    name: "Hatran",
    ranges: [[67808, 67827], [67828, 67830], [67835, 67840]],
    direction: "rtl",
    year: -40,
    living: false,
    link: "https://en.wikipedia.org/wiki/Hatran_alphabet"
  },
  {
    name: "Hebrew",
    ranges: [[1425, 1480], [1488, 1515], [1520, 1525], [64285, 64311], [64312, 64317], [64318, 64319], [64320, 64322], [64323, 64325], [64326, 64336]],
    direction: "rtl",
    year: -100,
    living: true,
    link: "https://en.wikipedia.org/wiki/Hebrew_alphabet"
  },
  {
    name: "Hiragana",
    ranges: [[12353, 12439], [12445, 12448], [110593, 110879], [127488, 127489]],
    direction: "ltr",
    year: 800,
    living: true,
    link: "https://en.wikipedia.org/wiki/Hiragana"
  },
  {
    name: "Anatolian Hieroglyphs",
    ranges: [[82944, 83527]],
    direction: "ltr",
    year: -1400,
    living: false,
    link: "https://en.wikipedia.org/wiki/Anatolian_hieroglyphs"
  },
  {
    name: "Pahawh Hmong",
    ranges: [[92928, 92998], [93008, 93018], [93019, 93026], [93027, 93048], [93053, 93072]],
    direction: "ltr",
    year: 1959,
    living: true,
    link: "https://en.wikipedia.org/wiki/Pahawh_Hmong"
  },
  {
    name: "Old Hungarian",
    ranges: [[68736, 68787], [68800, 68851], [68858, 68864]],
    direction: "rtl",
    year: 1150,
    living: false,
    link: "https://en.wikipedia.org/wiki/Old_Hungarian_alphabet"
  },
  {
    name: "Old Italic",
    ranges: [[66304, 66340], [66349, 66352]],
    direction: "ltr",
    year: -750,
    living: false,
    link: "https://en.wikipedia.org/wiki/Old_Italic_script"
  },
  {
    name: "Javanese",
    ranges: [[43392, 43470], [43472, 43482], [43486, 43488]],
    direction: "ltr",
    year: 1250,
    living: true,
    link: "https://en.wikipedia.org/wiki/Javanese_script"
  },
  {
    name: "Kayah Li",
    ranges: [[43264, 43310], [43311, 43312]],
    direction: "ltr",
    year: 1962,
    living: true,
    link: "https://en.wikipedia.org/wiki/Kayah_Li_alphabet"
  },
  {
    name: "Katakana",
    ranges: [[12449, 12539], [12541, 12544], [12784, 12800], [13008, 13055], [13056, 13144], [65382, 65392], [65393, 65438], [110592, 110593]],
    direction: "ltr",
    year: 800,
    living: true,
    link: "https://en.wikipedia.org/wiki/Katakana"
  },
  {
    name: "Kharoshthi",
    ranges: [[68096, 68100], [68101, 68103], [68108, 68116], [68117, 68120], [68121, 68148], [68152, 68155], [68159, 68168], [68176, 68185]],
    direction: "rtl",
    year: -400,
    living: false,
    link: "https://en.wikipedia.org/wiki/Kharosthi"
  },
  {
    name: "Khmer",
    ranges: [[6016, 6110], [6112, 6122], [6128, 6138], [6624, 6656]],
    direction: "ltr",
    year: 611,
    living: true,
    link: "https://en.wikipedia.org/wiki/Khmer_alphabet"
  },
  {
    name: "Khojki",
    ranges: [[70144, 70162], [70163, 70207]],
    direction: "ltr",
    year: 1520,
    living: false,
    link: "https://en.wikipedia.org/wiki/Khojki_script"
  },
  {
    name: "Kannada",
    ranges: [[3200, 3204], [3205, 3213], [3214, 3217], [3218, 3241], [3242, 3252], [3253, 3258], [3260, 3269], [3270, 3273], [3274, 3278], [3285, 3287], [3294, 3295], [3296, 3300], [3302, 3312], [3313, 3315]],
    direction: "ltr",
    year: 450,
    living: true,
    link: "https://en.wikipedia.org/wiki/Kannada_alphabet"
  },
  {
    name: "Kaithi",
    ranges: [[69760, 69826]],
    direction: "ltr",
    year: 1550,
    living: false,
    link: "https://en.wikipedia.org/wiki/Kaithi"
  },
  {
    name: "Tai Tham",
    ranges: [[6688, 6751], [6752, 6781], [6783, 6794], [6800, 6810], [6816, 6830]],
    direction: "ltr",
    year: 1300,
    living: true,
    link: "https://en.wikipedia.org/wiki/Tai_Tham_alphabet"
  },
  {
    name: "Lao",
    ranges: [[3713, 3715], [3716, 3717], [3719, 3721], [3722, 3723], [3725, 3726], [3732, 3736], [3737, 3744], [3745, 3748], [3749, 3750], [3751, 3752], [3754, 3756], [3757, 3770], [3771, 3774], [3776, 3781], [3782, 3783], [3784, 3790], [3792, 3802], [3804, 3808]],
    direction: "ltr",
    year: 1350,
    living: true,
    link: "https://en.wikipedia.org/wiki/Lao_alphabet"
  },
  {
    name: "Latin",
    ranges: [[65, 91], [97, 123], [170, 171], [186, 187], [192, 215], [216, 247], [248, 697], [736, 741], [7424, 7462], [7468, 7517], [7522, 7526], [7531, 7544], [7545, 7615], [7680, 7936], [8305, 8306], [8319, 8320], [8336, 8349], [8490, 8492], [8498, 8499], [8526, 8527], [8544, 8585], [11360, 11392], [42786, 42888], [42891, 42927], [42928, 42936], [42999, 43008], [43824, 43867], [43868, 43877], [64256, 64263], [65313, 65339], [65345, 65371]],
    direction: "ltr",
    year: -700,
    living: false,
    link: "https://en.wikipedia.org/wiki/Latin_script"
  },
  {
    name: "Lepcha",
    ranges: [[7168, 7224], [7227, 7242], [7245, 7248]],
    direction: "ltr",
    year: 1700,
    living: true,
    link: "https://en.wikipedia.org/wiki/Lepcha_alphabet"
  },
  {
    name: "Limbu",
    ranges: [[6400, 6431], [6432, 6444], [6448, 6460], [6464, 6465], [6468, 6480]],
    direction: "ltr",
    year: 1740,
    living: true,
    link: "https://en.wikipedia.org/wiki/Limbu_alphabet"
  },
  {
    name: "Linear A",
    ranges: [[67072, 67383], [67392, 67414], [67424, 67432]],
    direction: "ltr",
    year: -2500,
    living: false,
    link: "https://en.wikipedia.org/wiki/Linear_A"
  },
  {
    name: "Linear B",
    ranges: [[65536, 65548], [65549, 65575], [65576, 65595], [65596, 65598], [65599, 65614], [65616, 65630], [65664, 65787]],
    direction: "ltr",
    year: -1450,
    living: false,
    link: "https://en.wikipedia.org/wiki/Linear_B"
  },
  {
    name: "Lisu",
    ranges: [[42192, 42240]],
    direction: "ltr",
    year: 1915,
    living: true,
    link: "https://en.wikipedia.org/wiki/Fraser_alphabet"
  },
  {
    name: "Lycian",
    ranges: [[66176, 66205]],
    direction: "ltr",
    year: -500,
    living: false,
    link: "https://en.wikipedia.org/wiki/Lycian_alphabet"
  },
  {
    name: "Lydian",
    ranges: [[67872, 67898], [67903, 67904]],
    direction: "rtl",
    year: -700,
    living: false,
    link: "https://en.wikipedia.org/wiki/Lydian_alphabet"
  },
  {
    name: "Mahajani",
    ranges: [[69968, 70007]],
    direction: "ltr",
    year: 1150,
    living: false,
    link: "https://en.wikipedia.org/wiki/Mahajani"
  },
  {
    name: "Mandaic",
    ranges: [[2112, 2140], [2142, 2143]],
    direction: "rtl",
    year: 200,
    living: true,
    link: "https://en.wikipedia.org/wiki/Mandaic_alphabet"
  },
  {
    name: "Manichaean",
    ranges: [[68288, 68327], [68331, 68343]],
    direction: "rtl",
    year: 250,
    living: false,
    link: "https://en.wikipedia.org/wiki/Manichaean_alphabet"
  },
  {
    name: "Marchen",
    ranges: [[72816, 72848], [72850, 72872], [72873, 72887]],
    direction: "ltr",
    year: 650,
    living: false,
    link: "https://en.wikipedia.org/wiki/Zhang-Zhung_language#Scripts"
  },
  {
    name: "Mende Kikakui",
    ranges: [[124928, 125125], [125127, 125143]],
    direction: "rtl",
    year: 1880,
    living: true,
    link: "https://en.wikipedia.org/wiki/Mende_Kikakui_script"
  },
  {
    name: "Meroitic Cursive",
    ranges: [[68000, 68024], [68028, 68048], [68050, 68096]],
    direction: "rtl",
    year: -300,
    living: false,
    link: "https://en.wikipedia.org/wiki/Meroitic_alphabet"
  },
  {
    name: "Meroitic Hieroglyphs",
    ranges: [[67968, 68000]],
    direction: "rtl",
    year: -300,
    living: false,
    link: "https://en.wikipedia.org/wiki/Meroitic_alphabet"
  },
  {
    name: "Malayalam",
    ranges: [[3328, 3332], [3333, 3341], [3342, 3345], [3346, 3397], [3398, 3401], [3402, 3408], [3412, 3428], [3430, 3456]],
    direction: "ltr",
    year: 830,
    living: true,
    link: "https://en.wikipedia.org/wiki/Malayalam_script"
  },
  {
    name: "Modi",
    ranges: [[71168, 71237], [71248, 71258]],
    direction: "ltr",
    year: 1200,
    living: false,
    link: "https://en.wikipedia.org/wiki/Modi_alphabet"
  },
  {
    name: "Mongolian",
    ranges: [[6144, 6146], [6148, 6149], [6150, 6159], [6160, 6170], [6176, 6264], [6272, 6315], [71264, 71277]],
    direction: "ttb",
    year: 1204,
    living: false,
    link: "https://en.wikipedia.org/wiki/Mongolian_script"
  },
  {
    name: "Mro",
    ranges: [[92736, 92767], [92768, 92778], [92782, 92784]],
    direction: "ltr",
    year: 1985,
    living: true,
    link: "https://en.wikipedia.org/wiki/Mru_language#Alphabet"
  },
  {
    name: "Meetei Mayek",
    ranges: [[43744, 43767], [43968, 44014], [44016, 44026]],
    direction: "ltr",
    year: 200,
    living: true,
    link: "https://en.wikipedia.org/wiki/Meitei_script"
  },
  {
    name: "Multani",
    ranges: [[70272, 70279], [70280, 70281], [70282, 70286], [70287, 70302], [70303, 70314]],
    direction: "ltr",
    year: 1750,
    living: false,
    link: "https://en.wikipedia.org/wiki/Multani_alphabet"
  },
  {
    name: "Myanmar",
    ranges: [[4096, 4256], [43488, 43519], [43616, 43648]],
    direction: "ltr",
    year: 984,
    living: true,
    link: "https://en.wikipedia.org/wiki/Burmese_alphabet"
  },
  {
    name: "Old North Arabian",
    ranges: [[68224, 68256]],
    direction: "rtl",
    year: 750,
    living: false,
    link: "https://en.wikipedia.org/wiki/Ancient_North_Arabian"
  },
  {
    name: "Nabataean",
    ranges: [[67712, 67743], [67751, 67760]],
    direction: "rtl",
    year: 150,
    living: false,
    link: "https://en.wikipedia.org/wiki/Nabataean_alphabet"
  },
  {
    name: "Newa",
    ranges: [[70656, 70746], [70747, 70748], [70749, 70750]],
    direction: "ltr",
    year: 1000,
    living: true,
    link: "https://en.wikipedia.org/wiki/Prachalit_Nepal_alphabet"
  },
  {
    name: "Nko",
    ranges: [[1984, 2043]],
    direction: "rtl",
    year: 1949,
    living: false,
    link: "https://en.wikipedia.org/wiki/N%27Ko_alphabet"
  },
  {
    name: "Nushu",
    ranges: [[94177, 94178], [110960, 111356]],
    direction: "ltr",
    year: 1500,
    living: true,
    link: "https://en.wikipedia.org/wiki/N%C3%BCshu_script"
  },
  {
    name: "Ogham",
    ranges: [[5760, 5789]],
    direction: "ltr",
    year: 350,
    living: false,
    link: "https://en.wikipedia.org/wiki/Ogham"
  },
  {
    name: "Ol Chiki",
    ranges: [[7248, 7296]],
    direction: "ltr",
    year: 1925,
    living: true,
    link: "https://en.wikipedia.org/wiki/Ol_Chiki_script"
  },
  {
    name: "Old Turkic",
    ranges: [[68608, 68681]],
    direction: "rtl",
    year: 750,
    living: false,
    link: "https://en.wikipedia.org/wiki/Old_Turkic_alphabet"
  },
  {
    name: "Oriya",
    ranges: [[2817, 2820], [2821, 2829], [2831, 2833], [2835, 2857], [2858, 2865], [2866, 2868], [2869, 2874], [2876, 2885], [2887, 2889], [2891, 2894], [2902, 2904], [2908, 2910], [2911, 2916], [2918, 2936]],
    direction: "ltr",
    year: 1060,
    living: true,
    link: "https://en.wikipedia.org/wiki/Odia_alphabet"
  },
  {
    name: "Osage",
    ranges: [[66736, 66772], [66776, 66812]],
    direction: "ltr",
    year: 2006,
    living: true,
    link: "https://en.wikipedia.org/wiki/Osage_alphabet"
  },
  {
    name: "Osmanya",
    ranges: [[66688, 66718], [66720, 66730]],
    direction: "ltr",
    year: 1920,
    living: true,
    link: "https://en.wikipedia.org/wiki/Osmanya_alphabet"
  },
  {
    name: "Palmyrene",
    ranges: [[67680, 67712]],
    direction: "rtl",
    year: -100,
    living: false,
    link: "https://en.wikipedia.org/wiki/Palmyrene_alphabet"
  },
  {
    name: "Pau Cin Hau",
    ranges: [[72384, 72441]],
    direction: "ltr",
    year: 1900,
    living: true,
    link: "https://en.wikipedia.org/wiki/Pau_Cin_Hau"
  },
  {
    name: "Old Permic",
    ranges: [[66384, 66427]],
    direction: "ltr",
    year: 1372,
    living: false,
    link: "https://en.wikipedia.org/wiki/Old_Permic_alphabet"
  },
  {
    name: "Phags-pa",
    ranges: [[43072, 43123], [43124, 43127]],
    direction: "ttb",
    year: 1269,
    living: false,
    link: "https://en.wikipedia.org/wiki/%27Phags-pa_script"
  },
  {
    name: "Inscriptional Pahlavi",
    ranges: [[68448, 68467], [68472, 68480]],
    direction: "rtl",
    year: -171,
    living: false,
    link: "https://en.wikipedia.org/wiki/Inscriptional_Pahlavi"
  },
  {
    name: "Psalter Pahlavi",
    ranges: [[68480, 68498], [68505, 68509], [68521, 68528]],
    direction: "rtl",
    year: 550,
    living: false,
    link: "https://en.wikipedia.org/wiki/Psalter_Pahlavi"
  },
  {
    name: "Phoenician",
    ranges: [[67840, 67868], [67871, 67872]],
    direction: "rtl",
    year: -1200,
    living: false,
    link: "https://en.wikipedia.org/wiki/Phoenician_alphabet"
  },
  {
    name: "Miao",
    ranges: [[93952, 94021], [94032, 94079], [94095, 94112]],
    direction: "ltr",
    year: 1936,
    living: true,
    link: "https://en.wikipedia.org/wiki/Pollard_script"
  },
  {
    name: "Inscriptional Parthian",
    ranges: [[68416, 68438], [68440, 68448]],
    direction: "rtl",
    year: -250,
    living: false,
    link: "https://en.wikipedia.org/wiki/Inscriptional_Parthian"
  },
  {
    name: "Rejang",
    ranges: [[43312, 43348], [43359, 43360]],
    direction: "ltr",
    year: 1750,
    living: true,
    link: "https://en.wikipedia.org/wiki/Rejang_script"
  },
  {
    name: "Runic",
    ranges: [[5792, 5867], [5870, 5881]],
    direction: "ltr",
    year: 150,
    living: false,
    link: "https://en.wikipedia.org/wiki/Runes"
  },
  {
    name: "Samaritan",
    ranges: [[2048, 2094], [2096, 2111]],
    direction: "rtl",
    year: -600,
    living: true,
    link: "https://en.wikipedia.org/wiki/Samaritan_alphabet"
  },
  {
    name: "Old South Arabian",
    ranges: [[68192, 68224]],
    direction: "rtl",
    year: -850,
    living: false,
    link: "https://en.wikipedia.org/wiki/Ancient_South_Arabian_script"
  },
  {
    name: "Saurashtra",
    ranges: [[43136, 43206], [43214, 43226]],
    direction: "ltr",
    year: 1920,
    living: true,
    link: "https://en.wikipedia.org/wiki/Saurashtra_alphabet"
  },
  {
    name: "SignWriting",
    ranges: [[120832, 121484], [121499, 121504], [121505, 121520]],
    direction: "ttb",
    year: 1974,
    living: true,
    link: "https://en.wikipedia.org/wiki/SignWriting"
  },
  {
    name: "Shavian",
    ranges: [[66640, 66688]],
    direction: "ltr",
    year: 1960,
    living: true,
    link: "https://en.wikipedia.org/wiki/Shavian_alphabet"
  },
  {
    name: "Sharada",
    ranges: [[70016, 70094], [70096, 70112]],
    direction: "ltr",
    year: 800,
    living: true,
    link: "https://en.wikipedia.org/wiki/%C5%9A%C4%81rad%C4%81_script"
  },
  {
    name: "Siddham",
    ranges: [[71040, 71094], [71096, 71134]],
    direction: "ltr",
    year: 550,
    living: false,
    link: "https://en.wikipedia.org/wiki/Siddha%E1%B9%83_script"
  },
  {
    name: "Khudawadi",
    ranges: [[70320, 70379], [70384, 70394]],
    direction: "ltr",
    year: 1550,
    living: true,
    link: "https://en.wikipedia.org/wiki/Khudabadi_script"
  },
  {
    name: "Sinhala",
    ranges: [[3458, 3460], [3461, 3479], [3482, 3506], [3507, 3516], [3517, 3518], [3520, 3527], [3530, 3531], [3535, 3541], [3542, 3543], [3544, 3552], [3558, 3568], [3570, 3573], [70113, 70133]],
    direction: "ltr",
    year: 700,
    living: true,
    link: "https://en.wikipedia.org/wiki/Sinhalese_alphabet"
  },
  {
    name: "Sora Sompeng",
    ranges: [[69840, 69865], [69872, 69882]],
    direction: "ltr",
    year: 1936,
    living: true,
    link: "https://en.wikipedia.org/wiki/Sorang_Sompeng_alphabet"
  },
  {
    name: "Soyombo",
    ranges: [[72272, 72324], [72326, 72349], [72350, 72355]],
    direction: "ltr",
    year: 1650,
    living: false,
    link: "https://en.wikipedia.org/wiki/Soyombo_alphabet"
  },
  {
    name: "Sundanese",
    ranges: [[7040, 7104], [7360, 7368]],
    direction: "ltr",
    year: 1350,
    living: true,
    link: "https://en.wikipedia.org/wiki/Sundanese_script"
  },
  {
    name: "Syloti Nagri",
    ranges: [[43008, 43052]],
    direction: "ltr",
    year: 1303,
    living: true,
    link: "https://en.wikipedia.org/wiki/Sylheti_Nagari"
  },
  {
    name: "Syriac",
    ranges: [[1792, 1806], [1807, 1867], [1869, 1872], [2144, 2155]],
    direction: "rtl",
    year: -200,
    living: true,
    link: "https://en.wikipedia.org/wiki/Syriac_alphabet"
  },
  {
    name: "Tagbanwa",
    ranges: [[5984, 5997], [5998, 6001], [6002, 6004]],
    direction: "ltr",
    year: 1300,
    living: true,
    link: "https://en.wikipedia.org/wiki/Tagbanwa_script"
  },
  {
    name: "Takri",
    ranges: [[71296, 71352], [71360, 71370]],
    direction: "ltr",
    year: 1550,
    living: true,
    link: "https://en.wikipedia.org/wiki/Takri_alphabet"
  },
  {
    name: "Tai Le",
    ranges: [[6480, 6510], [6512, 6517]],
    direction: "ltr",
    year: 1200,
    living: true,
    link: "https://en.wikipedia.org/wiki/Tai_Le_alphabet"
  },
  {
    name: "New Tai Lue",
    ranges: [[6528, 6572], [6576, 6602], [6608, 6619], [6622, 6624]],
    direction: "ltr",
    year: 1950,
    living: true,
    link: "https://en.wikipedia.org/wiki/New_Tai_Lue_alphabet"
  },
  {
    name: "Tamil",
    ranges: [[2946, 2948], [2949, 2955], [2958, 2961], [2962, 2966], [2969, 2971], [2972, 2973], [2974, 2976], [2979, 2981], [2984, 2987], [2990, 3002], [3006, 3011], [3014, 3017], [3018, 3022], [3024, 3025], [3031, 3032], [3046, 3067]],
    direction: "ltr",
    year: 700,
    living: true,
    link: "https://en.wikipedia.org/wiki/Tamil_script"
  },
  {
    name: "Tangut",
    ranges: [[94176, 94177], [94208, 100333], [100352, 101107]],
    direction: "ltr",
    year: 1036,
    living: false,
    link: "https://en.wikipedia.org/wiki/Tangut_script"
  },
  {
    name: "Tai Viet",
    ranges: [[43648, 43715], [43739, 43744]],
    direction: "ltr",
    year: 1200,
    living: true,
    link: "https://en.wikipedia.org/wiki/Tai_Dam_language#Writing_system"
  },
  {
    name: "Telugu",
    ranges: [[3072, 3076], [3077, 3085], [3086, 3089], [3090, 3113], [3114, 3130], [3133, 3141], [3142, 3145], [3146, 3150], [3157, 3159], [3160, 3163], [3168, 3172], [3174, 3184], [3192, 3200]],
    direction: "ltr",
    year: -900,
    living: true,
    link: "https://en.wikipedia.org/wiki/Telugu_script"
  },
  {
    name: "Tifinagh",
    ranges: [[11568, 11624], [11631, 11633], [11647, 11648]],
    direction: "ltr",
    year: -300,
    living: true,
    link: "https://en.wikipedia.org/wiki/Tifinagh"
  },
  {
    name: "Tagalog",
    ranges: [[5888, 5901], [5902, 5909]],
    direction: "ltr",
    year: 1250,
    living: true,
    link: "https://en.wikipedia.org/wiki/Baybayin"
  },
  {
    name: "Thaana",
    ranges: [[1920, 1970]],
    direction: "rtl",
    year: 1599,
    living: true,
    link: "https://en.wikipedia.org/wiki/Thaana"
  },
  {
    name: "Thai",
    ranges: [[3585, 3643], [3648, 3676]],
    direction: "ltr",
    year: 1283,
    living: true,
    link: "https://en.wikipedia.org/wiki/Thai_alphabet"
  },
  {
    name: "Tibetan",
    ranges: [[3840, 3912], [3913, 3949], [3953, 3992], [3993, 4029], [4030, 4045], [4046, 4053], [4057, 4059]],
    direction: "ltr",
    year: 650,
    living: false,
    link: "https://en.wikipedia.org/wiki/Tibetan_alphabet"
  },
  {
    name: "Tirhuta",
    ranges: [[70784, 70856], [70864, 70874]],
    direction: "ltr",
    year: 1450,
    living: true,
    link: "https://en.wikipedia.org/wiki/Tirhuta"
  },
  {
    name: "Ugaritic",
    ranges: [[66432, 66462], [66463, 66464]],
    direction: "ltr",
    year: -1400,
    living: false,
    link: "https://en.wikipedia.org/wiki/Ugaritic_alphabet"
  },
  {
    name: "Vai",
    ranges: [[42240, 42540]],
    direction: "ltr",
    year: 1830,
    living: true,
    link: "https://en.wikipedia.org/wiki/Vai_syllabary"
  },
  {
    name: "Warang Citi",
    ranges: [[71840, 71923], [71935, 71936]],
    direction: "ltr",
    year: 1946,
    living: true,
    link: "https://en.wikipedia.org/wiki/Warang_Citi"
  },
  {
    name: "Old Persian",
    ranges: [[66464, 66500], [66504, 66518]],
    direction: "ltr",
    year: -525,
    living: false,
    link: "https://en.wikipedia.org/wiki/Old_Persian_cuneiform"
  },
  {
    name: "Cuneiform",
    ranges: [[73728, 74650], [74752, 74863], [74864, 74869], [74880, 75076]],
    direction: "ltr",
    year: -3050,
    living: false,
    link: "https://en.wikipedia.org/wiki/Cuneiform_script"
  },
  {
    name: "Yi",
    ranges: [[40960, 42125], [42128, 42183]],
    direction: "ltr",
    year: 1450,
    living: true,
    link: "https://en.wikipedia.org/wiki/Yi_script"
  },
  {
    name: "Zanabazar Square",
    ranges: [[72192, 72264]],
    direction: "ltr",
    year: 1700,
    living: false,
    link: "https://en.wikipedia.org/wiki/Mongolian_writing_systems#Horizontal_square_script"
  }
];    
// the filter method explained
// ------------------------------------------------------------------------------
    function filter(array, test) {
        let passed = [];
        for (let element of array) {        // the for of loop runs a pass for each item (lauguage object in this case)
            if (test(element)) {            // the "element" is this language object 
                                            // the "a.living" reffers to thi language object's living property 
                passed.push(element);       // if condition is true that language object is pushed in the collector array
            }
        }
        return passed;                      // at the end of the process the collection array is returned
    }
    let livingLanguages = filter(SCRIPTS, a => a.living);
    
// the map method explained    
// ------------------------------------------------------------------------------
    function map(array, transform) {        // this function has an easy job it just returns a new array with the passed elements name identifiers' value
        let mapped = [];
        for (let element of array) {
            mapped.push(transform(element));
        }
        return mapped;
    }
    let rtlScripts = SCRIPTS.filter(s => s.direction == "rtl");     // native array "filter" method filters elements 
    
    let languageNames_rtl = map(rtlScripts, s => s.name);           // the maps a new array
    
// the reduce method explained 
// ------------------------------------------------------------------------------
    function reduce(array, combine, start) {
        let current = start;                        // each iteration accumulated value is collected 
        for (let element of array) {
            current = combine(current, element);    // combine is "currentArrayElement + 0/cumulated" each iteration
        } 
        return current;
    }
    let reduced = reduce([1, 2, 3, 4], (a, b) => a + b, 0);         // returns "10"
    
// this function returns the languages which has the most characters
// ------------------------------------------------------------------------------
// this function counts the characters of each language and returns them 
    function characterCount(script) {                           // "script" element given each time
        return script.ranges.reduce((count, [from, to]) => {    // "count" is the accumulator value
            return count + (to - from);                         // "to-from" gives the number of elements and accumuletes them in the "count" accumulator
        }, 0);
    }
    let mostChar = SCRIPTS.reduce((a, b) => {return characterCount(a) < characterCount(b) ? b : a;});
        // the "reduce" function runs for each element and will keep the one with the most characters
    
// this code does the same job as "reduce" method
// ------------------------------------------------------------------------------
    let biggest = null;
    for (let script of SCRIPTS) {
        if (biggest == null ||          // at first iteration this evaluation is "true" so if statement fires its code
        characterCount(biggest) < characterCount(script))   // after the first pass the comparison starts and the biggest returnded each time 
        {biggest = script;}             // at first iteration the "biggest" identifier is bound to he first element
    }                                   // after the first pass the highest number element is assigned to the "biggest" identifier
        // at the last pass both expressions will be "false" sot the "if" statement doesn't fier any more and the "biggest" identifier is left with the highest character element

// finds the average year of all languages
// ------------------------------------------------------------------------------
    function average(array) {
        return array.reduce((a, b) => a + b) / array.length;
    }
    let mostRecentLang = Math.round(average(SCRIPTS.filter(s => s.living).map(s => s.year)));
    let mostOldLang = Math.round(average(SCRIPTS.filter(s => !s.living).map(s => s.year)));

// this code does the same as above 
// ------------------------------------------------------------------------------    
    let total = 0, count = 0;           // the "count" is needed in order to calculate the average number later
    for (let script of SCRIPTS) {
        if (script.living) {            // only the living languages are computed
            total += script.year;       // years added up into an accumulator
            count += 1;
        }
    }
    let averateLangAge = Math.round(total / count);     
    
// finding a library (language) by refferencing to a character code
// ------------------------------------------------------------------------------    
    function characterScript(code) {
        for (let script of SCRIPTS) {
            if (script.ranges.some(([from, to]) => {    // the "some" built in array method gives its value which is the array of the character code range (awesome code dude!)
                return code >= from && code < to;       // !!! the operator precedence plays a big role here !!
                                                        // first the two expressions are evaluated on both side of the AND logical opeartor, than the logical operator kicks in!!
                                                        // the exact value is not searched here, we only need the information if it is present of the specified range
            })) {
                return script;
            }
        }
        return null;
    }
    let searchLang = characterScript(4571);             // returns the "Hangul" object language
   
// this function sorts elements depending on condition set by its second argument
// ------------------------------------------------------------------------------
    function countBy(itemsArr, groupName) {             // the 2nd argument expects a funtion which sets a group name
        let counts = [];
        for (let item of itemsArr) {           
            let name = groupName(item);                 // the "groupName" will be "true" or "false" depending on condition
            let known = counts.findIndex(c => c.name == name);  // every iteration when the "name" changed a new object is pushed into the "counts" collector array because this statement returns "-1"
            if (known == -1) {
                counts.push({name, count: 1});
            } 
            else {
                counts[known].count++;                  // once the new object is created we just increase its counter at ever iteration
            }
        }
        return counts;
    }
    let countIt = countBy([1, 2, 3, 4, 5], n => n > 2);
// → [{name: false, count: 2}, {name: true, count: 3}]
    console.log( countIt );
    
// this Magical function returns the proportional result of what language a text is written
// ------------------------------------------------------------------------------
    function textScripts(text) {
        let scripts = countBy(text, char => {                       // returns the name of the language which the character belongs to
                let script = characterScript(char.codePointAt(0));  // returns the corresponding language object
            return script ? script.name : "none";
        }).filter(({name}) => name != "none");

        let total = scripts.reduce((n, {count}) => n + count, 0);
        if (total == 0) return "No scripts found";
        
        return scripts.map(({name, count}) => {
            return `${Math.round(count * 100 / total)}% ${name}`;
        }).join(", ");
    }
    let textOrigin = textScripts('英国的狗说"woof", 俄罗斯的狗说"тяв"');
    // → 61% Han, 22% Latin, 17% Cyrillic
</script>
<!--------------------------------------------------------------------------------------------------------------------------->
<hr>
<h3><u> Exercise : </u></h3>
<h4><u> Flattering </u></h4>
<script>
    let arrays = [[1, 2, 3], [4, 5], [6]];
    var flatter = arrays.reduce((a, b) => { return a.concat(b) });          // returned → [1, 2, 3, 4, 5, 6]
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
    console.clear();
    let arrays = [[1, 2, 3], [4, 5], [6]];
    var flatter = arrays.reduce((a, b) => { return a.concat(b) });          // returned → [1, 2, 3, 4, 5, 6]
&lt;/script&gt;
        </pre>
        </details>
<!--------------------------------------------------------------------------------------------------------------------------->
<h4><u> You Own Loop </u></h4>
<script>
    function loop(value, test, updateF, bodyF) {
        if(test(value)) {                       // if test passed execute this block
            bodyF(value);                       // print the acutal value
            let newValue = updateF(value);
            loop(newValue, test, updateF, bodyF);
        }
         
    }
    loop(3, n => n > 0, n => n - 1, console.log);
    // → 3
    // → 2
    // → 1

// same thing achived with embeded "for" loop
    function loop(start, test, update, body) {
        for (let value = start; test(value); value = update(value)) {
            body(value);
        }
    }
    loop(3, n => n > 0, n => n - 1, console.log);
    // → 3
    // → 2
    // → 1
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
    function loop(value, test, updateF, bodyF) {
        if(test(value)) {                       // if test passed execute this block
            bodyF(value);                       // print the acutal value
            let newValue = updateF(value);
            loop(newValue, test, updateF, bodyF);
        }
         
    }
    loop(3, n =&gt; n &gt; 0, n =&gt; n - 1, console.log);
    // → 3
    // → 2
    // → 1

// same thing achived with embeded "for" loop
    function loop(start, test, update, body) {
        for (let value = start; test(value); value = update(value)) {
            body(value);
        }
    }
    loop(3, n =&gt; n &gt; 0, n =&gt; n - 1, console.log);
    // → 3
    // → 2
    // → 1
&lt;/script&gt;
        </pre>
        </details>
<!--------------------------------------------------------------------------------------------------------------------------->
<h4><u> Everything </u></h4>    
<script>
    function every(array, test) {
        for(i of array) {
            if(!test(i)) {return false;}
        }
        return true;
    }
// same thing with the some method, not the most logical stuff but thats a TEST :)
    var every2 = function(array, test) {
        let result = !array.some(value => !test(value));            // when the some method finds the "true" value it is filpped to "false" and returned ;)
        return result;
    }

    console.log(every([1, 3, 5], n => n < 10));
    // → true
    console.log(every([2, 4, 16], n => n < 10));
    // → false
    console.log(every([], n => n < 10));
    // → true
</script>    
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
    function every(array, test) {
        for(i of array) {
            if(!test(i)) {return false;}
        }
        return true;
    }
// same thing with the some method, not the most logical stuff but thats a TEST :)
    var every2 = function(array, test) {
        let result = !array.some(value => !test(value));            // when the some method finds the "true" value it is filpped to "false" and returned ;)
        return result;
    }

    console.log(every([1, 3, 5], n =&gt; n &lt; 10));
    // → true
    console.log(every([2, 4, 16], n =&gt; n &lt; 10));
    // → false
    console.log(every([], n =&gt; n &lt; 10));
    // → true
&lt;/script&gt;   
        </pre>
        </details>
<!--------------------------------------------------------------------------------------------------------------------------->
<h4><u> Dominant Writing Direction </u></h4>     
<script>
// this function returns the language (Object) of the character code
// ------------------------------------------------------------------------------------------------
    function charToLang(char) {
        for(let i of SCRIPTS) {
            let langLength = i.ranges.length;  
            for(let k = 0; k < langLength; k++) {
                let from = i.ranges[k][0];
                let to = i.ranges[k][1];
                rangeCheck = from <= char && char < to;
                if (rangeCheck) {
                    return i;
                }
            }
        }
    }
    
// this functions returns the dominant direction
// ------------------------------------------------------------------------------------------------    
    function dominantDirection(text) {    
        let langCollect = [];
        let counts = {};
        for(let i of text) {
            let langObj = charToLang(i.codePointAt(0));
            if (langObj != undefined) {
                langCollect.push(langObj.name)
            }
        }
        langCollect.forEach(function(x) { counts[x] = (counts[x] || 0)+1; });       // this is crazy Genius!!!
        
// this code returns the language Name which has the most characters in the string
        let biggerCount;
        let biggerName;
        for(let k in counts) {
            if(biggerCount == undefined) {
                biggerCount = counts[k];
                biggerName = k;
            }
            else {
                if(biggerCount < counts[k]) {
                    biggerCount = counts[k];
                    biggerName = k;
                } 
            }
           
        }
// this code gives the direction what we are looking for ;)
        for(let l of SCRIPTS) {
            if(l.name === biggerName) {
                return l.direction;
            }
        }
       
    }
 
    console.log(dominantDirection("Hello!"));
    // → ltr
    console.log(dominantDirection("Hey, مساء الخير"));
    // → rtl
</script>    
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
// this function returns the language (Object) of the character code
// ------------------------------------------------------------------------------------------------
    function charToLang(char) {
        for(let i of SCRIPTS) {
            let langLength = i.ranges.length;  
            for(let k = 0; k &lt; langLength; k++) {
                let from = i.ranges[k][0];
                let to = i.ranges[k][1];
                rangeCheck = from &lt;= char && char &lt; to;
                if (rangeCheck) {
                    return i;
                }
            }
        }
    }
    
// this functions returns the dominant direction
// ------------------------------------------------------------------------------------------------    
    function dominantDirection(text) {    
        let langCollect = [];
        let counts = {};
        for(let i of text) {
            let langObj = charToLang(i.codePointAt(0));
            if (langObj != undefined) {
                langCollect.push(langObj.name)
            }
        }
        langCollect.forEach(function(x) { counts[x] = (counts[x] || 0)+1; });       // this is crazy Genius!!!
        
// this code returns the language Name which has the most characters in the string
        let biggerCount;
        let biggerName;
        for(let k in counts) {
            if(biggerCount == undefined) {
                biggerCount = counts[k];
                biggerName = k;
            }
            else {
                if(biggerCount &lt; counts[k]) {
                    biggerCount = counts[k];
                    biggerName = k;
                } 
            }
           
        }
// this code gives the direction what we are looking for ;)
        for(let l of SCRIPTS) {
            if(l.name === biggerName) {
                return l.direction;
            }
        }
       
    }
 
    console.log(dominantDirection("Hello!"));
    // → ltr
    console.log(dominantDirection("Hey, مساء الخير"));
    // → rtl
&lt;/script&gt;    
        </pre>
        </details>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>
<h2><u> Chapter 6 (The Secret Life of Objects) </u></h2> 
<h4><u> inheritance Test </u></h4>
<script>
"use strict";
    class AA {
        constructor(a, defaulT) {
            this.a = a;
            this.defaulT = "default_VAL";
        }
        extp() {
            return this.a * this.a;
        }
    }
    class BB extends AA {};
    class CC extends BB {};
    let testObj_A = new CC(10);
    let testObj_B = new CC(10);
    testObj_A.defaulT = "native_VAL";           // creating native porperty/value
    
    testObj_A.defaulT;                          // "default_VAL"    <- no native property found so JS uses prototypes as "fallback"
    testObj_B.defaulT;                          // "native_VAL"     <- native property 
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
"use strict";
    class AA {
        constructor(a, defaulT) {
            this.a = a;
            this.defaulT = "default_VAL";
        }
        extp() {
            return this.a * this.a;
        }
    }
    class BB extends AA {};
    class CC extends BB {};
    let testObj_A = new CC(10);
    let testObj_B = new CC(10);
    testObj_A.defaulT = "native_VAL";           // creating native porperty/value
    
    testObj_A.defaulT;                          // "default_VAL"    &lt;- no native property found so JS uses prototypes as "fallback"
    testObj_B.defaulT;                          // "native_VAL"     &lt;- native property 
&lt;/script&gt;
        </pre>
        </details>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>
<h4><u> overwriting built-in method </u></h4>
<script>
    // Array.prototype.reduce = null;                  // built-in method Fucked-Up! :D
    try{
        let nrArray = [1, 2, 3, 4];
        let accumulate = nrArray.reduce((value_A, value_B) => value_A + value_B);       // returns "10" = reduced
    }
    catch (error) {
        console.log(error);                         // error thrown "TypeError: nrArray.reduce is not a function"
    }
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
    Array.prototype.reduce = null;                  // built-in method Fucked-Up! :D
    try{
        let nrArray = [1, 2, 3, 4];
        let accumulate = nrArray.reduce((value_A, value_B) => value_A + value_B);       // returns "10" = reduced
    }
    catch (error) {
        console.log(error);                         // error thrown "TypeError: nrArray.reduce is not a function"
    }
&lt;/script&gt;
        </pre>
        </details>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>
<h4><u> creating object without prototype </u></h4>    
<script>
    let noProtObj = Object.create(null);
    noProtObj.prop_A = 41;
    noProtObj.prop_B = 10;
    noProtObj.total = function() { return this.prop_A + this.prop_B; };
    
    window.noProtoObj;          // returns "undefined"
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
    let noProtObj = Object.create(null);
    noProtObj.prop_A = 41;
    noProtObj.prop_B = 10;
    noProtObj.total = function() { return this.prop_A + this.prop_B; };
    
    window.noProtoObj;          // returns "undefined"
&lt;/script&gt;
        </pre>
        </details>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>
<h4><u> Two Dimensional Array </u></h4>    
    <p> - creating 2 dimensional array = <u>0 based</u> table, than we can set and get items with methods created by the Constructor </p>
    <p> - tested this stuff but I've found useless except the 2 dimensional array part (2018-07-17) </p>
<script>
"use strict";
    class Matrix {
        constructor(width, height, element = (x, y) => undefined) {         // the 3rd argument sets all elements "undefined" (empty)
            this.width = width;
            this.height = height;
            this.content = [];
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    this.content[y * width + x] = element(x, y);
                }
            }
        }
        get(x, y) {
            return this.content[y * this.width + x];
        }
        set(x, y, value) {
            this.content[y * this.width + x] = value;
        }
    }
    var myTable = new Matrix(10, 10);
    myTable.set(1, 1, "54");                // setting a value in the 1st row and 1st line 
    myTable.set(15, 15, "value");           // this creates a larger table in order to accept the set item
    myTable.set(0, 0, "buu");
    myTable.get(15, 15);                    // returns "value"
    
// this class makes the matrix object iterable by using the "next()" (custom in this case method) (a can't see why this crap is usefull)
// ------------------
    class MatrixIterator {
        constructor(matrix) {
            this.x = 0;
            this.y = 0;
            this.matrix = matrix;
        }
        next() {
            if (this.y == this.matrix.height) return {done: true};
            let value = {x:this.x, y:this.y, value:this.matrix.get(this.x, this.y)};
            this.x++;
            if (this.x == this.matrix.width) {
                this.x = 0;
                this.y++;
            }
        return {value, done: false};
        }
    }
    var matIt = new MatrixIterator(myTable);
    
    Matrix.prototype[Symbol.iterator] = function() {
        return new MatrixIterator(this);
    };
    
    let matrix = new Matrix(10, 10, (x, y) => `value ${x},${y}`);
        for (let {x, y, value} of matrix) {
            console.log(x, y, value);
        }
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
"use strict";
    class Matrix {
        constructor(width, height, element = (x, y) => undefined) {         // the 3rd argument sets all elements "undefined" (empty)
            this.width = width;
            this.height = height;
            this.content = [];
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    this.content[y * width + x] = element(x, y);
                }
            }
        }
        get(x, y) {
            return this.content[y * this.width + x];
        }
        set(x, y, value) {
            this.content[y * this.width + x] = value;
        }
    }
    var myTable = new Matrix(10, 10);
    myTable.set(1, 1, "54");                // setting a value in the 1st row and 1st line 
    myTable.set(15, 15, "value");           // this creates a larger table in order to accept the set item
    myTable.set(0, 0, "buu");
    myTable.get(15, 15);                    // returns "value"
    
// this class makes the matrix object iterable by using the "next()" (custom in this case method) (a can't see why this crap is usefull)
// ------------------
    class MatrixIterator {
        constructor(matrix) {
            this.x = 0;
            this.y = 0;
            this.matrix = matrix;
        }
        next() {
            if (this.y == this.matrix.height) return {done: true};
            let value = {x:this.x, y:this.y, value:this.matrix.get(this.x, this.y)};
            this.x++;
            if (this.x == this.matrix.width) {
                this.x = 0;
                this.y++;
            }
        return {value, done: false};
        }
    }
    var matIt = new MatrixIterator(myTable);
    
    Matrix.prototype[Symbol.iterator] = function() {
        return new MatrixIterator(this);
    };
    
    let matrix = new Matrix(10, 10, (x, y) => `value ${x},${y}`);
        for (let {x, y, value} of matrix) {
            console.log(x, y, value);
        }
&lt;/script&gt;
        </pre>
        </details>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>    
<h4><u> Getters, Setters and Statics </u></h4>    
<script>
"use strict";
// using a property as getter 
    let update = {
        val:"",
        get get() {return this.val}         // the "get" keyword creates a "getter property" (property hiding a method behind)
    };
    
// getten and setter properties in a class
    class Car {
        constructor(carName) {
            this.carName = carName;
        }
        get fullData() {
            return "Car = " + this.carName + " data, data, data"
        };
        set setCarName(value) {             // <-- one parameter required only!
            this.carName = value
        };           
    }
    var mercedess = new Car("mercedess");
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
"use strict";
// using a property as getter 
    let update = {
        val:"",
        get get() {return this.val}         // the "get" keyword creates a "getter property" (property hiding a method behind)
    };
    
// getten and setter properties in a class
    class Car {
        constructor(carName) {
            this.carName = carName;
        }
        get fullData() {
            return "Car = " + this.carName + " data, data, data"
        };
        set setCarName(value) {             // &lt;-- one parameter required only!
            this.carName = value
        };           
    }
    var mercedess = new Car("mercedess");
&lt;/script&gt;
        </pre>
        </details>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>
<h4><u> Borrowing a Method </u></h4>
<script>
"use strict";
    let mappp = {one: true, two: true, hasOwnProperty: true};
    
    Object.prototype.hasOwnProperty.call(mappp, "one");         // I'm AWESOME!!!
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;>
"use strict";
    let mappp = {one: true, two: true, hasOwnProperty: true};
    
    Object.prototype.hasOwnProperty.call(mappp, "one");         // I'm AWESOME!!!
&lt;/script&gt;
        </pre>
        </details>
<h3><u> Exercise : </u></h3>  
<h4><u> Vector Type </u></h4>    
<script>
"use strict";
    class Vec {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
        plus(other){
            return new Vec(this.x + other.x, this.y + other.y);         // "this.x" referst to the object's x vaue
        }                                                               // "other.x" refers to the new Vec()'s value
        minus(other){
            return new Vec(this.x - other.x, this.y - other.y);
        }
        get length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
    }
    new Vec(2, 7).plus(new Vec(8, 3));          // returns "Vec {x: 10, y: 10}"
    new Vec(41, 24).minus(new Vec(31, 14));     // returns "Vec {x: 10, y: 10}"
    new Vec(3, 4).length;                       // returns "5"               
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
"use strict";
    class Vec {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
        plus(other){
            return new Vec(this.x + other.x, this.y + other.y);         // "this.x" referst to the object's x vaue
        }                                                               // "other.x" refers to the new Vec()'s value
        minus(other){
            return new Vec(this.x - other.x, this.y - other.y);
        }
        get length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
    }
    new Vec(2, 7).plus(new Vec(8, 3));          // returns "Vec {x: 10, y: 10}"
    new Vec(41, 24).minus(new Vec(31, 14));     // returns "Vec {x: 10, y: 10}"
    new Vec(3, 4).length;                       // returns "5"               
&lt;/script&gt;
        </pre>
        </details>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>    
<h4><u> Groups </u></h4>
<script>
"use strict";
    class Group {
        constructor() {
            this.members = [];
        }
        add(value) {
            if (!this.has(value)) {
                this.members.push(value);
            }
        }
        delete(value) {
            this.members = this.members.filter(v => v !== value);
        }
        has(value) {
            return this.members.includes(value);
        }
        static from(collection) {
            let group = new Group;
            for (let value of collection) {
                group.add(value);
            }
            return group;
        }
    }
    let group = Group.from([10, 20]);
    group.has(10);                  // returns "true"
    group.has(30);                  // returns "false"
    group.add(10);
    group.delete(10);
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
"use strict";
    class Group {
        constructor() {
            this.members = [];
        }
        add(value) {
            if (!this.has(value)) {
                this.members.push(value);
            }
        }
        delete(value) {
            this.members = this.members.filter(v => v !== value);
        }
        has(value) {
            return this.members.includes(value);
        }
        static from(collection) {
            let group = new Group;
            for (let value of collection) {
                group.add(value);
            }
            return group;
        }
    }
    let group = Group.from([10, 20]);
    group.has(10);                  // returns "true"
    group.has(30);                  // returns "false"
    group.add(10);
    group.delete(10);
&lt;/script&gt;
        </pre>
        </details>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>
<h2><u> Chapter 7 (Project: A Robot) </u></h2>    
<script>
"use strict";
    const roads = [
        "Alice's House-Bob's House",   "Alice's House-Cabin",
        "Alice's House-Post Office",   "Bob's House-Town Hall",
        "Daria's House-Ernie's House", "Daria's House-Town Hall",
        "Ernie's House-Grete's House", "Grete's House-Farm",
        "Grete's House-Shop",          "Marketplace-Farm",
        "Marketplace-Post Office",     "Marketplace-Shop",
        "Marketplace-Town Hall",       "Shop-Town Hall"
    ];
    
    function buildGraph(edges) {
        let graph = Object.create(null);
        function addEdge(from, to) {
            if (graph[from] == null) {      // checks if graph has the pased key
                graph[from] = [to];         // if no key found, new key created "from" and "to" element added to the collector Array
            } 
            else {
                graph[from].push(to);       // if there is already an existing key the "to" element is simply pushed to the collector                                    Array
            }
        }
        for (let [from, to] of edges.map(r => r.split("-"))) {      // all elements are split by two and passed to the "addEdge()"                                                                        function both ways
            addEdge(from, to);
            addEdge(to, from);
        }
        return graph;
    }
    const roadGraph = buildGraph(roads);        // contains all places associated with possible destination from that place
    
// the constructor updates the current place of the robot every time is called and filters the remaining parcel routes 
// ----------------------------------------------------------------------------------------------------------------------
    class VillageState {
        constructor(place, parcels) {
            this.place = place;
            this.parcels = parcels;                                 // array holding objects as items
        }
        move(destination) {
            if (!roadGraph[this.place].includes(destination)) {     // if there is a valid road to the destination it will fire the "else"                                                            statement, in no valid road the whole object is returned
                return this;
            } 
            else {
                let parcels = this.parcels.map(p =>{                
                                // p = whole object passed  
                    if (p.place != this.place) return p;            
                                // robot and box place must match, if not the "parcel" object is returned as it is
                    return {place: destination, address: p.address};    
                                // the current place will be te destination and the address won't change (new object returned but same)
                }).filter(p => p.place != p.address);               
                                // filter makes sure that only objects what have no equal place and destination is returned (other words it will filter the remainign available parcel deliveries)
            return new VillageState(destination, parcels);
                                // at the end a whole new object is created by using the same constructor but with all the newly processed paremeters
            }
        }
    }
    
    let first = new VillageState("Post Office", [{place: "Post Office", address: "Alice's House"}]);
                                // current position of the robot and position of the box and the delivery destination
    first.place;                // → "Post Office"  ->  current robot position  
    let next = first.move("Alice's House");
                                // we fire the robot acction after the move all newly returnded data is stored in the "next" object (other words the "next" object holds the state of the performed move)
    next.place;                 // → "Alice's House" this is the robot's current place (after the first delivery)
    next.parcels;               // → "[]"  ->  since we had 1 box to deliver and it is delivered the "parcels" array have no item any more
    
// Adding a Static Method to the VillageState constructor = this will generate parcels addresses at least 5 by default
// "Post Office" is used as starting point
// --------------------------------------------------------------------------------    
    VillageState.random = function(parcelCount = 5) {
        let parcels = [];
        for (let i = 0; i < parcelCount; i++) {
                                // loop fires at least 5 times (unles specified othewise)
            let address = randomPick(Object.keys(roadGraph));
                                // picking a random address
            let place;
            do {
                place = randomPick(Object.keys(roadGraph));
                                // picking a random "place"
            } while (place == address);
                                // the "while" part makes sure that the "palce" and the "address" is not the same (by misschance)
                                // if by misschance the "place" and the "address" are the same while loop fire again to pick a ne place
            parcels.push({place, address});
                                
        }
        return new VillageState("Post Office", parcels);
                                // the start state is returned with generated parcerls (parcels with the same parameters can be generated)
    };
    // runRobot(VillageState.random(), randomRobot);
                                // running the delivery (first argumet generates parcel routes, the second argumetn is the robot itself delivering them, raport is creted in the console )
                                // the randomRobot doesn't use memory here
    // var parcelRoutes20 = VillageState.random(20);
                                // this is how easy I can create parce routes
    
    
// Executed delivery from the given parcel routes and printing raport on the console
    // state = robot start location + delivery instructions
    // robot = the robot program which is programed to execute deliveries 
    // memory = is used by the robot (optionally) to follow preprogramed route plan
// ----------------------------------------------------------------------------------------------------------------------
    function runRobot(state, robot, memory) {
        for (var turn = 0;; turn++) {
            if (state.parcels.length == 0) {
                console.log(`Done in ${turn} turns`);
                break;
            }                   // check if there is any parcel to deliver if not will return the number of turns in a message
            let action = robot(state, memory);  // action object = {direction:*, memory:[]}
                                // defines the next direction for the robot ("memoroy" can be optional)
            state = state.move(action.direction);       //  <--  stores the new state (village stete)
                                // the "action.direction" is the next address given by the robot
                                // generate the new state after performing the delivery (current state updated [no new object as demod])
            memory = action.memory;                     //  <--  stores the memory state
            
            console.log(`Moved to ${action.direction}`);
        }
        return turn;
    }
        
// route plan, every destination reached 
// --------------------------------------------------------------------------------    
    const mailRoute = ["Alice's House", "Cabin", "Alice's House", "Bob's House", "Town Hall", "Daria's House", "Ernie's House", "Grete's House", "Shop", "Grete's House", "Farm", "Marketplace", "Post Office"];
    
// Random Robot pick random places  
// --------------------------------------------------------------------------------
    function randomPick(array) {
        let choice = Math.floor(Math.random() * array.length);
        return array[choice];
    }                           // generate random pick based on array length and returns an array call 
    function randomRobot(state) {
        return {direction: randomPick(roadGraph[state.place])};  
    }                           // the computation will tell this robot which direction to pick
                                // "state.place" is the current place where is the robot (state.parcers not called here )
                                // the "randomPick" is called to pick a random destination form these possible routes
                                // "{directions: target addres}" ojbect is returned by the randomRobot
    // runRobot(VillageState.random(), randomRobot);
    
// Route Robot, runs on predefined route twice
// --------------------------------------------------------------------------------        
    function routeRobot(state, memory) {
        if (memory.length == 0) {
            memory = mailRoute;
        }                       // empty memory updated with the route plan
        return {direction: memory[0], memory: memory.slice(1)};
                                // the first item is the direction
    }                           // the second item is the remaining route to do, every time the first item is dropped this makes sure that the robot never returns to the same address
    // runRobot(VillageState.random(), routeRobot, []);
    
// Goal Oriented Robot
// --------------------------------------------------------------------------------    
    function goalOrientedRobot({place, parcels}, route) { 
                                // the first argument is the same as "state" but this form makes possible to pass values to the routeFinder
        if (route.length == 0) {// if robot memory empty code fires
//--> this part might be better because the robot is not necesseraly closer to the first delivery start point
            let parcel = parcels[0];    //  <--  "parcel" object = "{place:*, address:*} this is the delivery route
                                // first delivery route is picked up
            if (parcel.place != place) {
                route = findRoute(roadGraph, place, parcel.place);
                                // if the current place is not equal to any parcel's location the "findRoute" function will compute where the robot should head to pick up the first parcel
            } 
            else {
                route = findRoute(roadGraph, place, parcel.address);
                                // if the current place equals to a parcel's location robot will be sent to the delivery address
            }  
        }
        return {direction: route[0], memory: route.slice(1)};
    }
    // runRobot(VillageState.random(), goalOrientedRobot, []);    
    
// route finder calculates the shortes possible road between two location and returns the plan in an Array, this "plan" is uses as robot memory to follow 
// --------------------------------------------------------------------------------
    function findRoute(graph, from, to) {   // "graph" is "roadGraph" = all possible roads
                                // form = the place where the robot is
                                // to = possible parcel locations (one string) or possible delivery locations
        let work = [{at: from, route: []}];
        for (let i = 0; i < work.length; i++) {
            let {at, route} = work[i]; 
                                // at = from
            for (let place of graph[at]) {
                                // runs through all possible routes from the robot's current location
                if (place == to) return route.concat(place);
                                // if the target location can be reached from the current place, the target location is returned 
                if (!work.some(w => w.at == place)) { 
                                // if current robot's place matches with any of the reachable places the next step is skiped
                                // if the current robot's place does not match with any of the reachable places a new object will be pushed into the array with the place 
                    work.push({at: place, route: route.concat(place)}); 
                }
            }
        }
    }
</script>
<h3><u> Exercise : </u></h3>
<h4><u> Measuring a Robot </u></h4>
<script>
// this is my custom way to solve this exercise, it acually turns out to be better thant the one in this book (I'm Awesome!)
"use strict";
    function compareRobots(robot1, memory1, robot2, memory2, robot3, memory3, robot4, memory4) {
        let task100 = VillageState.random();         
        var rob_1Steps = runRobot(task100, robot1, memory1);
        var rob_2Steps = runRobot(task100, robot2, memory2);
        if(robot3 != null) var rob_3Steps = runRobot(task100, robot3, memory3);
        if(robot4 != null) var rob_4Steps = runRobot(task100, robot4, memory4);
        
        console.log("Robot 1 makes " + rob_1Steps + " steps and "+ rob_1Steps / 100 + " steps per task");
        console.log("Robot 2 makes " + rob_2Steps + " steps and "+ rob_2Steps / 100 + " steps per task");
        if(rob_3Steps != null)  console.log("Robot 3 makes " + rob_3Steps + " steps and "+ rob_3Steps / 100 + " steps per task");
        if(rob_4Steps != null)console.log("Robot 4 makes " + rob_4Steps + " steps and "+ rob_4Steps / 100 + " steps per task");
    }
    // compareRobots(randomRobot, [], routeRobot, [], goalOrientedRobot, [], yourRobot, []);
        
    // Interesting thing is that if there are a few parcel to deliver the the goalOrientedRobot is faster
    // if there is a lot of parcel to deliver the routeRobot is faster
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
// this is my custom way to solve this exercise, it acually turns out to be better thant the one in this book (I'm Awesome!)
"use strict";
    function compareRobots(robot1, memory1, robot2, memory2) {
        let task100 = VillageState.random(100);         
                    console.log( task100 );
        var rob_1Steps = runRobot(task100, robot1, memory1);
        var rob_2Steps = runRobot(task100, robot2, memory2);
        
        console.log("Robot 1 makes " + rob_1Steps + " steps and "+ rob_1Steps / 100 + " steps per task");
        console.log("Robot 2 makes " + rob_2Steps + " steps and "+ rob_2Steps / 100 + " steps per task");
    }
    compareRobots(routeRobot, [], goalOrientedRobot, []);
        
    // Interesting thing is that if there are a few parcel to deliver the the goalOrientedRobot is faster
    // if there is a lot of parcel to deliver the routeRobot is faster
&lt;/script&gt;
        </pre>
        </details>
<!--------------------------------------------------------------------------------------------------------------------------->
<h4><u> Robot Efficiency </u></h4>    
<script>
"use strict";
    // this is my robot I've wrote by heart (2018-07-20)
    
    function yourRobot(state, memory) {
        let targAddresses = []; // target addresses what the robot must touch (filtered addresses are uniques!) 
        var roadPlan = [];      // holds a valid turn with the required places to go
    // creating an array with the target addresses (every address figures only once!)
        for(let i = 0; i < state.parcels.length; i++) {
            if(!targAddresses.includes(state.parcels[i].place || state.parcels[i].address)) {
                targAddresses.push(state.parcels[i].place);
                targAddresses.push(state.parcels[i].address);
            }
        }
        for(let k = 0; k < mailRoute.length; k++) {
            for(let l = 0; l < targAddresses.length; l++) {
                if(mailRoute[k] == targAddresses[l]) roadPlan.push(mailRoute[k]);
            } 
        }
// I used the Set Object to garantee that there is only one item in an array than returned all these items to the original array, that's a crapy solution but WORKS!
        var unique = new Set();
        for(let i = 0; i < roadPlan.length * 2; i++) {
            if(roadPlan[i] != undefined) unique.add(roadPlan[i]);
        }
        var roadPlan = [];      // redeclared the "roadPlan" in order to empty it
        for(let item of unique) {
            roadPlan.push(item);
        }
// so far I've popped out unnecessary destination by maintaining the mailRoute order
        var roadFinder = [];
        roadFinder.push(findRoute(roadGraph, "Post Office", roadPlan[0]));
        for(let i = 0; i < roadPlan.length; i++) {
            if(roadPlan[i + 1] != undefined) {
                roadFinder.push(findRoute(roadGraph, roadPlan[i], roadPlan[i + 1]));
            }
            else if(roadPlan[i] == "Post Office") {     // if the last item is already a "Post Office" the plan is Done! we stop the code
                break;    
            }
            else {
                roadFinder.push(findRoute(roadGraph, roadPlan[i], "Post Office"));
                                                        // this makes shure that the last item is "Post Office" 
            }
        }
    // Make Plain Array
        var roadPlan = [];      // and again we emptied this guy :)
        roadPlan = roadFinder.reduce((flat, current) => flat.concat(current));
                                // we are flattering the array here
    
    // Updating memory    
        if(memory.length == 0) {
            memory = roadPlan;
        }
        return {direction: memory[0], memory: memory.slice(1)};
    }
    
// Solution Given by Eloquent JS book for the exerciese
// --------------------------------------------------------------------------------    
    function lazyRobot({place, parcels}, route) {
        if (route.length == 0) {
                        // Describe a route for every parcel
            let routes = parcels.map(parcel => {
            if (parcel.place != place) {
                return {route: findRoute(roadGraph, place, parcel.place), pickUp: true};
            } 
            else {
                return {route: findRoute(roadGraph, place, parcel.address), pickUp: false};
            }
            });
                        // This determines the precedence a route gets when choosing.
                        // Route length counts negatively, routes that pick up a package
                        // get a small bonus.
            function score({route, pickUp}) {
                return (pickUp ? 0.5 : 0) - route.length;
            }
            route = routes.reduce((a, b) => score(a) > score(b) ? a : b).route;
        }
        return {direction: route[0], memory: route.slice(1)};
    }
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
"use strict";
    // this is my robot I've wrote by heart (2018-07-20)
    
    function yourRobot(state, memory) {
        let targAddresses = []; // target addresses what the robot must touch (filtered addresses are uniques!) 
        var roadPlan = [];      // holds a valid turn with the required places to go
    // creating an array with the target addresses (every address figures only once!)
        for(let i = 0; i &lt; state.parcels.length; i++) {
            if(!targAddresses.includes(state.parcels[i].place || state.parcels[i].address)) {
                targAddresses.push(state.parcels[i].place);
                targAddresses.push(state.parcels[i].address);
            }
        }
        for(let k = 0; k &lt; mailRoute.length; k++) {
            for(let l = 0; l &lt; targAddresses.length; l++) {
                if(mailRoute[k] == targAddresses[l]) roadPlan.push(mailRoute[k]);
            } 
        }
// I used the Set Object to garantee that there is only one item in an array than returned all these items to the original array, that's a crapy solution but WORKS!
        var unique = new Set();
        for(let i = 0; i &lt; roadPlan.length * 2; i++) {
            if(roadPlan[i] != undefined) unique.add(roadPlan[i]);
        }
        var roadPlan = [];      // redeclared the "roadPlan" in order to empty it
        for(let item of unique) {
            roadPlan.push(item);
        }
// so far I've popped out unnecessary destination by maintaining the mailRoute order
        var roadFinder = [];
        roadFinder.push(findRoute(roadGraph, "Post Office", roadPlan[0]));
        for(let i = 0; i &lt; roadPlan.length; i++) {
            if(roadPlan[i + 1] != undefined) {
                roadFinder.push(findRoute(roadGraph, roadPlan[i], roadPlan[i + 1]));
            }
            else if(roadPlan[i] == "Post Office") {     // if the last item is already a "Post Office" the plan is Done! we stop the code
                break;    
            }
            else {
                roadFinder.push(findRoute(roadGraph, roadPlan[i], "Post Office"));
                                                        // this makes shure that the last item is "Post Office" 
            }
        }
    // Make Plain Array
        var roadPlan = [];      // and again we emptied this guy :)
        roadPlan = roadFinder.reduce((flat, current) => flat.concat(current));
                                // we are flattering the array here
    
    // Updating memory    
        if(memory.length == 0) {
            memory = roadPlan;
        }
        return {direction: memory[0], memory: memory.slice(1)};
    }
    
// Solution Given by Eloquent JS book for the exerciese
// --------------------------------------------------------------------------------    
    function lazyRobot({place, parcels}, route) {
        if (route.length == 0) {
                        // Describe a route for every parcel
            let routes = parcels.map(parcel => {
            if (parcel.place != place) {
                return {route: findRoute(roadGraph, place, parcel.place), pickUp: true};
            } 
            else {
                return {route: findRoute(roadGraph, place, parcel.address), pickUp: false};
            }
            });
                        // This determines the precedence a route gets when choosing.
                        // Route length counts negatively, routes that pick up a package
                        // get a small bonus.
            function score({route, pickUp}) {
                return (pickUp ? 0.5 : 0) - route.length;
            }
            route = routes.reduce((a, b) => score(a) > score(b) ? a : b).route;
        }
        return {direction: route[0], memory: route.slice(1)};
    }
&lt;/script&gt;
        </pre>
        </details>
<!--------------------------------------------------------------------------------------------------------------------------->
<h4><u> Persistent Group </u></h4>     
<script>
"use strict";
    class PGroup {
        constructor(storage) {
            this.storage = storage;
        }
        add(val) {
            if(this.has(val)) return this;
            return new PGroup(this.storage.concat([val]));
        }
        delete(val) {
            if(!this.has(val)) return this;
            return new PGroup(this.storage.filter( m => m !== val));
        }
        has(val) {
            return this.storage.includes(val);
        }
        
        static get empty(){ return new PGroup([]) };
    }
    
let a = PGroup.empty.add("a");
let ab = a.add("b");
let b = ab.delete("a");

console.log(b.has("b"));
// → true
console.log(a.has("b"));
// → false
console.log(b.has("a"));
// → false
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
"use strict";
    class PGroup {
        constructor(storage) {
            this.storage = storage;
        }
        add(val) {
            if(this.has(val)) return this;
            return new PGroup(this.storage.concat([val]));
        }
        delete(val) {
            if(!this.has(val)) return this;
            return new PGroup(this.storage.filter( m => m !== val));
        }
        has(val) {
            return this.storage.includes(val);
        }
        
        static get empty(){ return new PGroup([]) };
    }
    
let a = PGroup.empty.add("a");
let ab = a.add("b");
let b = ab.delete("a");

console.log(b.has("b"));
// → true
console.log(a.has("b"));
// → false
console.log(b.has("a"));
// → false
&lt;/script&gt;
        </pre>
        </details>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>
<h2><u> Chapter 8 (Debugging) </u></h2>       
<script>
"use strict";
// program test if the inserted content is string
    function onlyString(body) {
        if (typeof body !== "string") return console.warn(body + " is not a string!");
        else return body;
    }
    
    onlyString("myString");         // returns the passed object
    onlyString(false);              // throws the exeption in the console!
</script>
<!---------------------------------------------------------------------------------------------------------------------------->
<script>
"use strict";
    function promptNumber(question) {
        let result = Number(prompt(question));
        if (Number.isNaN(result)) return null;
        else return result;
    }
    // console.log(promptNumber("How many trees do you see?"));
</script>
<!---------------------------------------------------------------------------------------------------------------------------->
<script>
"use strict";  
/*
    function promptDirection(question) {
        let result = prompt(question);
        if (result.toLowerCase() == "left") return "L";
        if (result.toLowerCase() == "right") return "R";
        throw new Error("Invalid direction: " + result);    // <- error returned to the caller directly "unwinding the stack"  
    }                                                       // it is also called raising an exeption (raises all the way up to the caller)

    function look() {                                       // <- function ignored uppon Error throw
        if (promptDirection("Which way?") == "L") {
            return "a house";
        } else {
            return "two angry bears";
        }
    }

    try {
        console.log("You see", look());
    } 
    catch (error) {
        console.log("Something went wrong: " + error);
    }
*/
</script>
<!---------------------------------------------------------------------------------------------------------------------------->
<script>
"use strict";
    const accounts = {a:100, b:0, c:20, d:400};

    function getAccount() {
        let accountName = prompt("Enter an account name");          // return the information in a prompt box
        if (!accounts.hasOwnProperty(accountName)) {                // checks for an account and throws an exeption if no such account exist
            throw new Error(`No such account: ${accountName}`);
        }
        return accountName;                                         // account is returned if is valid
    }

// transfer amount
    function transfer(from, amount) {                               
        if (accounts[from] < amount) return;                        // checks if there's enough money to transfert (no message?)
        accounts[from] -= amount;                                   // removes the amount from the source account <- BAD CODE money is removed before checking for a valid account!
        accounts[getAccount()] += amount;                           // adds the amount to the targeted account
    }
    
// using the finaly statement to retransfert the money if no such account exist 
    function transfer(from, amount) {
        if (accounts[from] < amount) return;
        let progress = 0;
        try {
            accounts[from] -= amount;                               // money removed
            progress = 1;
            accounts[getAccount()] += amount;                       // account check
            progress = 2;
        } 
        finally {                                                   // "finally" statement executes (does not give a fuck!)
            if (progress == 1) {                                    // if account check failed money is transfered back!
                accounts[from] += amount;                           
            }
        }
    }
</script> 
<!---------------------------------------------------------------------------------------------------------------------------->
<script>
"use strict";
/*
    function promptDirection(question) {
        let result = prompt(question);
        if (result.toLowerCase() == "left") return "L";
        if (result.toLowerCase() == "right") return "R";
        throw new InputError("Invalid direction: " + result);    // <- error returned to the caller directly "unwinding the stack"  
    } 
    for (;;) {
        try {
            let dir = promtDirection("Where?");             // ← typo! Error is trhrown from here directly to the "catch" statement 
            console.log("You chose ", dir);
            break;                                          // therefore this "break" statement has never chance to stop the loop!     
        } 
        catch (e) {
            console.log("Not a valid direction. Try again.");
            console.log(e);
            break;                                          // I put this here to prevent the infinite loop!
        }
    }
    
    class InputError extends Error {};
        
    for (;;) {
        try {
            let dir = promptDirection("Where?");
            console.log("You chose ", dir);
            break;
        } 
        catch (e) {
            console.log(e.constructor);
            if (e instanceof InputError) {                  // the "promptDirection()" function holds an exception which is derived from the Error constructor, so that's going to be true in this situation if it is thrown, otherwise "e" is goingt to be an instance of another Error object
                console.log("Not a valid direction. Try again.");
            } 
            else {
                throw e;
            }   
        }
    }
    
    console.warn('fired!');
*/
</script>
<!---------------------------------------------------------------------------------------------------------------------------->
<h3><u> Exercise : </u></h3>
<h4><u> Retry </u></h4>
<script>
"use strict";
    class MultiplicatorUnitFailure extends Error {}

    function primitiveMultiply(a, b) {
        if (Math.random() < 0.2) {
            return a * b;
        } 
        else {
            throw new MultiplicatorUnitFailure("Klunk");
        }
    }

    function reliableMultiply(a, b) {
        let counter = 0;
        for (;;) {                                  // loop keeps looping until the "try" statement does not throws the error
        counter ++;
            try {                           
                return primitiveMultiply(a, b) + " attempts = " + counter;                  
                break;                              // once the "try" statement does not throws the "MultiplicatorUnitFailure" Error this break statement breaks out of the loop
            }
            catch (err) {
                console.log(err); 
            }
        }
    }

    console.log(reliableMultiply(8, 8));
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
"use strict";
    class MultiplicatorUnitFailure extends Error {}

    function primitiveMultiply(a, b) {
        if (Math.random() &lt; 0.2) {
            return a * b;
        } 
        else {
            throw new MultiplicatorUnitFailure("Klunk");
        }
    }

    function reliableMultiply(a, b) {
        let counter = 0;
        for (;;) {                                  // loop keeps looping until the "try" statement does not throws the error
        counter ++;
            try {                           
                return primitiveMultiply(a, b) + " attempts = " + counter;                  
                break;                              // once the "try" statement does not throws the "MultiplicatorUnitFailure" Error this break statement breaks out of the loop
            }
            catch (err) {
                console.log(err); 
            }
        }
    }

    console.log(reliableMultiply(8, 8));
&lt;/script&gt;
        </pre>
        </details>
<h4><u> The Locked Box </u></h4>    
<script>
"use strict";
    const box = {
        locked:true,
        unlock() {this.locked = false},
        lock() {this.locked = true},
        _content: [],
        getContent() {
            if (this.locked) throw new Error("Locked!");
            return this._content;
        }
    }
    
    function withBoxUnlocked(body) {
        box.unlock();
        body();
    }
    
    withBoxUnlocked( function() {box._content.push("gold Piece")} );
    
    try {
        withBoxUnlocked( function() {throw new Error("Pirates on the Horizon Abort!")} )
    }
    catch(err) {
        console.log(`Error Raised : ${err}`);
    }
    box.locked = true;
    
    // that was a crap TEST!!!
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
console.clear();
    const box = {
        locked:true,
        unlock() {this.locked = false},
        lock() {this.locked = true},
        _content: [],
        getContent() {
            if (this.locked) throw new Error("Locked!");
            return this._content;
        }
    }
    
    function withBoxUnlocked(body) {
        box.unlock();
        body();
    }
    
    withBoxUnlocked( function() {box._content.push("gold Piece")} );
    
    try {
        withBoxUnlocked( function() {throw new Error("Pirates on the Horizon Abort!")} )
    }
    catch(err) {
        console.log(`Error Raised : ${err}`);
    }
    box.locked = true;
    
    // that was a crap TEST!!!
&lt;/script&gt;
        </pre>
        </details>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>
<h2><u> Chapter 9 (Regular Expressions) </u></h2>          
<script>
"use strict";
    let notBinary = /[^01]/;                            // test if there are other characters than "0" and "1"
    console.log(notBinary.test("1100100010100110"));
    // → false
    console.log(notBinary.test("1100100010200110"));
    // → true
    
// --------------------------------------------------------------------------------------------------------------------
    var other_than_Letters_and_numbers = /[^\d|^\w]/gi; // returns any other characters than word and digit characters
    var testStr = "5,694,043 articles-in-English";
    console.log( testStr.match(other_than_Letters_and_numbers) );
    // → [",", ",", " ", "-", "-"]
    
// --------------------------------------------------------------------------------------------------------------------
    var kicsiKutya = "kicsi kutya tarka";
    var otherThan_ = /^i/g;                             
    // → caret only works with brackets! 
    console.log(kicsiKutya.match(otherThan_));
    // → null
    
// --------------------------------------------------------------------------------------------------------------------
    function getDate(string) {
        let [_, month, day, year] = /(\d{1,2})-(\d{1,2})-(\d{4})/.exec(string);
            // -> smart code the "_" is the returned value which is the whole date entered, because the "exec" method return every matched element found in the parenteses this way we get the , month, day, year
        return new Date(year, month - 1, day);
    }
    console.log(getDate("1-30-2003"));
    // → Thu Jan 30 2003 00:00:00 GMT+0100 (CET)
    
// backtrack test
// --------------------------------------------------------------------------------------------------------------------
    let myTxt = "kicsi kutya tarka se fule se farka";
// --- replaceing groups of RegExps 
    document.write( myTxt.replace(/(\bk)(.{1,4})( )/g, "<span style='text-transform:uppercase;'>$1</span><span style='color:blue;'>$2</span><span style='background-color:white;'>$3</span>") );
        // -> groups form the regExp are represented by $1 $2 ... $9 or the $& represents the entire regular expression
    
// --- using function in a replacement operation
    document.write( "<br>" + myTxt.replace(/kutya/, replace) );
    function replace(target, position, str) {
        return "<span style='color:blue;'>" + target + "</span>";
    }
    
// -----------------------------------------------------
    let stock = "1 lemon, 2 cabbages, and 101 eggs";
    function minusOne(match, amount, unit) {
        amount = Number(amount) - 1;                            // take of 1 of every amount
        if (amount == 1) {                                      // only one left, remove the 's'
            unit = unit.slice(0, unit.length - 1);
        } 
        else if (amount == 0) {                                 // if no amount left replace with the word "no"
            amount = "no";
        }
        return amount + " " + unit;                             // return the new amount and unit at every match
    }
    console.log(stock.replace(/(\d+) (\w+)/g, minusOne));       // two groups in RegExp / global flag in order to match all values
    // → no lemon, 1 cabbage, and 100 eggs
    
// reading an .ini file and extracting information in Objects    
// -----------------------------------------------------    
    function parseINI(string) {
    // Start with an object to hold the top-level fields
        let result = {};
        let section = result;
        
        string.split(/\r?\n/).forEach(line => {                 // splitting lines 
            let match;            
            if (match = line.match(/^(\w+)=(.*)$/)) {           // if line contains a name=value pair
                // the "match" is the array returned by the "match()" method, 2nd, and 3rd items are the matches of RegExp groups
                section[match[1]] = match[2];
                    // section is the collector object, assign the key and the value as the extracted information
                    // since objects are mutable "result" will have the same key=value pairs assigned
            } 
            else if (match = line.match(/^\[(.*)\]$/)) {        // if line has information in [] 
                section = result[match[1]] = {};
                    // create a new obj nested in "result" but must importantly "section" will become this newly created obj 
                    // from this point everything is added to "section" will be added to the newly created nested object of "reulst" obj
            } 
            else if (!/^\s*(;.*)?$/.test(line)) {               // throw an Error if not an expected format found
                throw new Error("Line '" + line + "' is not valid.");
                
            } 
        });  
        return result;
    }
  
console.log(parseINI(`name=Vasilis
[address]
city=Tessaloniki`));
        // → {name: "Vasilis", address: {city: "Tessaloniki"}}

console.warn("-- above program demo --");
    let obj_A = {};                 // <- match
    let obj_B = obj_A;              // <- section

    obj_B["prop1"] = "val1";        // <- both objects are updated
    obj_B = obj_A["nest"] = {};     // <- "obj_B" becomes the newly created nested obj of "obj_A"
                                    // <- "obj_B" becomes empty because is basically the newly created obj what is empty
    obj_B.p1 = 1;                   // <- anything added to "obj_B" is directly added to the newly created nested obj of "obj_A"
    obj_B.p2 = 2;
</script>
<h3><u> Exercise : </u></h3>
<h4><u> RegExp Golf </u></h4>    
<script>
"use strict";
    var test1 = "car", test2 = "cat";
    var regExp1 = new RegExp("ca(t|r)");
    console.log(regExp1.test(test1));
    console.log(regExp1.test(test2));
//--------------------------------------
    var test3 = "pop", test4 ="prop";
    let regExp2 = /pr?op/
    console.log(regExp2.test(test3));
    console.log(regExp2.test(test4));
//--------------------------------------    
    let txt1 = "ferret", txt2 = "ferry", txt3 = "ferrari";
    let regExp3 = new RegExp(/ferr(et|y|ari)/);
    console.log(regExp3.test(txt1));
    console.log(regExp3.test(txt2));
    console.log(regExp3.test(txt3));
//--------------------------------------    
    // word ending "ious"
    let regExp4 = /ious\b/;
    console.log(regExp4.test("java lukoious"));
    console.log(regExp4.test("javaScript"));
//--------------------------------------
    // A whitespace character followed by a period, comma, colon, or semicolon
    let regExp5 = new RegExp(" (,|:|;|\\.)");       // period must be set escaped
    console.log(regExp5.test("kdse :"));
    console.log(regExp5.test("kdse ;"));
    console.log(regExp5.test("kdse .kdss "));
    console.log(regExp5.test("kdse ,"));
    console.log(regExp5.test("kd ds ^"));
//--------------------------------------    
    // A word longer than six letters
    let regExp6 = /\b\w{6,}\b/;
    console.log(regExp6.test("dksed sdf"));
    console.log(regExp6.test("dksed sdfsdf fjerueyh"));
//----------------------------------------------------------------
    // A word without the letter e (or E)
    let regExp7 = new RegExp(/^[^e]+/ig);
    console.log(/\b[^e]+\b/i.test("dksd"));
    console.log(/\b[^e]+\b/i.test("dksdsedf"));
    console.log(/\b[^e]+\b|[^ ]/i.exec("dssE sae fgegr"));
console.warn("---");    
    
//----------------------------------------------------------------
    verify(/ c/,                        // space must be followed by "c"
           ["my car", "bad cats"],
           ["camper", "high art"]);

    verify(/\s/,                        // must have white space
           ["pop culture", "mad props"],
           ["plop", "prrrop"]);

    verify(/rr[^u]/,                    // "rr" cannot be followed by "u"
           ["ferret", "ferry", "ferrari"],
           ["ferrum", "transfer A"]);

    verify(/\s/,                        // must have white space
           ["how delicious", "spacious room"],
           ["ruinous", "consciousness"]);

    verify(/\.$/,                       // str must end with "."
           ["bad punctuation ."],
           ["escape the period"]);

    verify(/\w{7,}/,                 // word must be at lest 7 characters ending by "n"
           ["hottentottententen"],
           ["no", "hotten totten tenten"]);

    // verify(/^[^leB]/,                   // strig cannot start with the set letters  
    verify(/\b[^\We]+\b/i,       
           ["red platypus", "wobbling nest"],   // 
           ["earth bed", "learning ape", "BEET"]);

    function verify(regexp, yes, no) {
      // Ignore unfinished exercises
        if (regexp.source == "...") return;
        for (let str of yes) if (!regexp.test(str)) {
            console.log(`Failure to match '${str}'`);
        }
        for (let str of no) if (regexp.test(str)) {
            console.log(`Unexpected match for '${str}'`);
        }
    }
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
"use strict";
    var test1 = "car", test2 = "cat";
    var regExp1 = new RegExp("ca(t|r)");
    console.log(regExp1.test(test1));
    console.log(regExp1.test(test2));
//--------------------------------------
    var test3 = "pop", test4 ="prop";
    let regExp2 = /pr?op/
    console.log(regExp2.test(test3));
    console.log(regExp2.test(test4));
//--------------------------------------    
    let txt1 = "ferret", txt2 = "ferry", txt3 = "ferrari";
    let regExp3 = new RegExp(/ferr(et|y|ari)/);
    console.log(regExp3.test(txt1));
    console.log(regExp3.test(txt2));
    console.log(regExp3.test(txt3));
//--------------------------------------    
    // word ending "ious"
    let regExp4 = /ious\b/;
    console.log(regExp4.test("java lukoious"));
    console.log(regExp4.test("javaScript"));
//--------------------------------------
    // A whitespace character followed by a period, comma, colon, or semicolon
    let regExp5 = new RegExp(" (,|:|;|\\.)");       // period must be set escaped
    console.log(regExp5.test("kdse :"));
    console.log(regExp5.test("kdse ;"));
    console.log(regExp5.test("kdse .kdss "));
    console.log(regExp5.test("kdse ,"));
    console.log(regExp5.test("kd ds ^"));
//--------------------------------------    
    // A word longer than six letters
    let regExp6 = /\b\w{6,}\b/;
    console.log(regExp6.test("dksed sdf"));
    console.log(regExp6.test("dksed sdfsdf fjerueyh"));
//----------------------------------------------------------------
    // A word without the letter e (or E)
    let regExp7 = new RegExp(/^[^e]+/ig);
    console.log(/\b[^e]+\b/i.test("dksd"));
    console.log(/\b[^e]+\b/i.test("dksdsedf"));
    console.log(/\b[^e]+\b|[^ ]/i.exec("dssE sae fgegr"));
console.warn("---");    
    
//----------------------------------------------------------------
    verify(/ c/,                        // space must be followed by "c"
           ["my car", "bad cats"],
           ["camper", "high art"]);

    verify(/\s/,                        // must have white space
           ["pop culture", "mad props"],
           ["plop", "prrrop"]);

    verify(/rr[^u]/,                    // "rr" cannot be followed by "u"
           ["ferret", "ferry", "ferrari"],
           ["ferrum", "transfer A"]);

    verify(/\s/,                        // must have white space
           ["how delicious", "spacious room"],
           ["ruinous", "consciousness"]);

    verify(/\.$/,                       // str must end with "."
           ["bad punctuation ."],
           ["escape the period"]);

    verify(/\w{7,}/,                 // word must be at lest 7 characters ending by "n"
           ["hottentottententen"],
           ["no", "hotten totten tenten"]);

    // verify(/^[^leB]/,                   // strig cannot start with the set letters  
    verify(/\b[^\We]+\b/i,       
           ["red platypus", "wobbling nest"],   // 
           ["earth bed", "learning ape", "BEET"]);

    function verify(regexp, yes, no) {
      // Ignore unfinished exercises
        if (regexp.source == "...") return;
        for (let str of yes) if (!regexp.test(str)) {
            console.log(`Failure to match '${str}'`);
        }
        for (let str of no) if (regexp.test(str)) {
            console.log(`Unexpected match for '${str}'`);
        }
    }
&lt;/script&gt;
        </pre>
        </details>
<!----------------------------------------------------------------------------------------------------------------------------->
<h4><u> Quoting Style </u></h4>
<script>
"use strict";
    let text = "'I'm the cook,' he said, 'it's my job.'";       // Not between two word characters

console.log(text.replace(/(\W)'|^'|'$/gi, "$1\""));             // cannot preceded by a word character or it starts or end the string
// -> solution by the book = /(^|\W)'|'(\W|$)/g, "$1"$2"
// → "I'm the cook," he said, "it's my job."
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
"use strict";
    let text = "'I'm the cook,' he said, 'it's my job.'";       // Not between two word characters

console.log(text.replace(/(\W)'|^'|'$/gi, "$1\""));             // cannot preceded by a word character or it starts or end the string
// -> solution by the book = /(^|\W)'|'(\W|$)/g, "$1"$2"
// → "I'm the cook," he said, "it's my job."
&lt;/script&gt;
        </pre>
        </details>
<!----------------------------------------------------------------------------------------------------------------------------->
<h4><u> Numbers Again </u></h4>    
<script>
"use strict";
    // Fill in this regular expression.                                            
    // let number = /^(\+|\-|\.)?\d+((\.\d)?[eE]([+-])?\d+|\.|\.\d+|[eE](\+|\-|\d)?)?$|^[^\.]$|^[^\.]$/;
              
    let number = /^(\-|\+)?\d+$|^\.\d+$|^\d+\.$|^\d+\.\d+$|^\d+[eE](\-|\+)\d*$|^\d+\.\d+[eE]\d*$/;           
        // -> my solution was modular testing, systematically type in formats 1 by 1 which are accepted = WORKED (took 2 hours of work)
    
    // Tests:
    for (let str of ["1", "-1", "+15", "1.55", ".5", "5.", "1.3e2", "1E-4", "1e+12"]) {
        if (!number.test(str)) {
            console.log(`Failed to match '${str}'`);
        }
    }
    for (let str of ["1a", "+-1", "1.2.3", "1+1", "1e4.5",".5.", "1f5", "."]) {
        if (number.test(str)) {
            console.log(`Incorrectly accepted '${str}'`);
        }
    }
</script>  
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;script&gt;
"use strict";
    // Fill in this regular expression.                                            
    // let number = /^(\+|\-|\.)?\d+((\.\d)?[eE]([+-])?\d+|\.|\.\d+|[eE](\+|\-|\d)?)?$|^[^\.]$|^[^\.]$/;
              
    let number = /^(\-|\+)?\d+$|^\.\d+$|^\d+\.$|^\d+\.\d+$|^\d+[eE](\-|\+)\d*$|^\d+\.\d+[eE]\d*$/;           
        // -> my solution was modular testing, systematically type in formats 1 by 1 which are accepted = WORKED (took 2 hours of work)
    
    // Tests:
    for (let str of ["1", "-1", "+15", "1.55", ".5", "5.", "1.3e2", "1E-4", "1e+12"]) {
        if (!number.test(str)) {
            console.log(`Failed to match '${str}'`);
        }
    }
    for (let str of ["1a", "+-1", "1.2.3", "1+1", "1e4.5",".5.", "1f5", "."]) {
        if (number.test(str)) {
            console.log(`Incorrectly accepted '${str}'`);
        }
    }
&lt;/script&gt;  
        </pre>
        </details>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>
<h2><u> Chapter 10 (Modules) </u></h2>      
<script>
"use strict";
    const weekDay = function() {
        const names = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
        return {name(number) { return names[number]; },
                number(name) { return names.indexOf(name); }
      };
    }();

    console.log(weekDay.name(weekDay.number("Wednesday")));
    // → Sunday
    
    // Modules will be taught at Node.js
    
</script>    
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>
<h2><u> Chapter 11 (Asyncronous Programing ) </u></h2>  
<script>
"use strict";
    class Timeout extends Error {}

    function request(nest, target, type, content) {
        return new Promise((resolve, reject) => {
            let done = false;
            function attempt(n) {
                nest.send(target, type, content, (failed, value) => {
                    done = true;
                    if (failed) reject(failed);
                    else resolve(value);
                });
                  setTimeout(() => {
                    if (done) return;
                    else if (n < 3) attempt(n + 1);
                    else reject(new Timeout("Timed out"));
                }, 250);
            }
            attempt(1);
        });
    }
    
// get you call stack size
// -------------------------------------------------------------------------------------------------------------
    function computeMaxCallStackSize() {
        try {
            return 1 + computeMaxCallStackSize();
        } catch (e) {
            // Call stack overflow
            return 1;
        }
    }
    
    console.log(
        computeMaxCallStackSize()
    );
</script>
<h3><u> Exercise : </u></h3>
<h4><u> Promise.all </u></h4>     
<script>
"use strict";   
    /*
    function Promise_all(promises) {
        return new Promise((resolve, reject) => {
            let results = [];
            let pending = promises.length;
            for (let i = 0; i < promises.length; i++) {
                promises[i].then(result => {
                    results[i] = result;
                    pending--;
                    if (pending == 0) resolve(results);
                }).catch(reject);
            }
            if (promises.length == 0) resolve(results);
        });
    }

    
// Test code.
    Promise_all([]).then(array => {
        console.log("This should be []:", array);
    });
    
    function soon(val) {
        return new Promise(resolve => {
            setTimeout(() => resolve(val), Math.random() * 500);
        });
    }
    
    Promise_all([soon(1), soon(2), soon(3)]).then(array => {
        console.log("This should be [1, 2, 3]:", array);
    });
    
    Promise_all([soon(1), Promise.reject("X"), soon(3)])
        .then(array => {
            console.log("We should not get here");
        })
        .catch(error => {
            if (error != "X") {
                console.log("Unexpected failure:", error);
            }
        });
    */
</script>    
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
    function Promise_all(promises) {
        return new Promise((resolve, reject) =&gt; {
            let results = [];
            let pending = promises.length;
            for (let i = 0; i &lt; promises.length; i++) {
                promises[i].then(result =&gt; {
                    results[i] = result;
                    pending--;
                    if (pending == 0) resolve(results);
                }).catch(reject);
            }
            if (promises.length == 0) resolve(results);
        });
    }

    
// Test code.
    Promise_all([]).then(array =&gt; {
        console.log("This should be []:", array);
    });
    
    function soon(val) {
        return new Promise(resolve =&gt; {
            setTimeout(() =&gt; resolve(val), Math.random() * 500);
        });
    }
    
    Promise_all([soon(1), soon(2), soon(3)]).then(array =&gt; {
        console.log("This should be [1, 2, 3]:", array);
    });
    
    Promise_all([soon(1), Promise.reject("X"), soon(3)])
        .then(array =&gt; {
            console.log("We should not get here");
        })
        .catch(error => {
            if (error != "X") {
                console.log("Unexpected failure:", error);
            }
        });
        </pre>
        </details>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>
<h2><u> Chapter 12 (Project : Programing Language) </u></h2>      
<script>
"use strict";
    
    function parseExpression(program) {
        program = skipSpace(program);
        let match, expr;
        if (match = /^"([^"]*)"/.exec(program)) {
            expr = {type: "value", value: match[1]};
        } else if (match = /^\d+\b/.exec(program)) {
            expr = {type: "value", value: Number(match[0])};
        } else if (match = /^[^\s(),#"]+/.exec(program)) {
            expr = {type: "word", name: match[0]};
        } else {
            throw new SyntaxError("Unexpected syntax: " + program);
        }

        return parseApply(expr, program.slice(match[0].length));    
                                // we chopped off the used part and the remaining part is passed to the "parseApply()" function
    }
    
// this fuction makes sure that the string starts with a valid character
    function skipSpace(string) {                            
        let first = string.search(/\S/);
        if (first == -1) return "";
        return string.slice(first);
    }
    
// this function checks and handles aplication of our "Egg" program    
    function parseApply(expr, program) {
        program = skipSpace(program);
        if (program[0] != "(") {
                                // checks if the next part is an application of our "Egg" program
            return {expr: expr, rest: program};
        }
        program = skipSpace(program.slice(1));
                                // skip the "(" 
        expr = {type: "apply", operator: expr, args: []};
        while (program[0] != ")") {
            let arg = parseExpression(program);
            expr.args.push(arg.expr);
            program = skipSpace(arg.rest);
            if (program[0] == ",") {
                program = skipSpace(program.slice(1));
            } else if (program[0] != ")") {
                throw new SyntaxError("Expected ',' or ')'");
            }
        }
        return parseApply(expr, program.slice(1));
    }
</script>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>
<h2><u> Chapter 14 (DOM) </u></h2>    
    <blockquote id="quote"> No book can ever be finished. While working on it we learn just enough to find it immature the moment we turn away from it. </blockquote>
<script>
"use strict";
    function elt(type, ...children) {
        let node = document.createElement(type);
        for (let child of children) {
            if (typeof child != "string") node.appendChild(child);
            else node.appendChild(document.createTextNode(child));
        }
        return node;
    }

    document.getElementById("quote").appendChild(
        elt("footer", "—",
            elt("strong", "Karl Popper"),
            ", preface to the second editon of ",
            elt("em", "The Open Society and Its Enemies"),
            ", 1950")
    );
</script>    
<h3><u> Exercise : </u></h3>
<h4><u> Build a Table </u></h4> 
    <div id="mountains"></div>
<script>
"use strict";
    const MOUNTAINS = [
        {name: "Kilimanjaro", height: 5895, place: "Tanzania"},
        {name: "Everest", height: 8848, place: "Nepal"},
        {name: "Mount Fuji", height: 3776, place: "Japan"},
        {name: "Vaalserberg", height: 323, place: "Netherlands"},
        {name: "Denali", height: 6168, place: "United States"},
        {name: "Popocatepetl", height: 5465, place: "Mexico"},
        {name: "Mont Blanc", height: 4808, place: "Italy/France"}
    ];
    
// generates a table row with the given data   
    function generateRow(name, height, place) {
        var row = document.createElement("tr");
        var nameLm = document.createElement("td")
            var nameNode = document.createTextNode(name);
            nameLm.appendChild(nameNode);
                row.appendChild(nameLm);
        var heightLm = document.createElement("td")
            var heightNode = document.createTextNode(height);
            heightLm.appendChild(heightNode);
                row.appendChild(heightLm);
        var placeLm = document.createElement("td")
            var placeNode = document.createTextNode(place);
            placeLm.appendChild(placeNode);
                row.appendChild(placeLm);
        return row;
    }
    
// generates the header of the table    
    function generateHeader() {
        var row = document.createElement("tr");
        var nameLm = document.createElement("th")
            var nameNode = document.createTextNode("name");
            nameLm.appendChild(nameNode);
                row.appendChild(nameLm);
        var heightLm = document.createElement("th")
            var heightNode = document.createTextNode("height");
            heightLm.appendChild(heightNode);
                row.appendChild(heightLm);
        var placeLm = document.createElement("th")
            var placeNode = document.createTextNode("place");
            placeLm.appendChild(placeNode);
                row.appendChild(placeLm);
        return row;
    }
    
    function generateTable(arr) {
        var table = document.createElement("table");
        var ln = arr.length;
        table.appendChild(generateHeader());
        for(let i = 0; i < ln; i++) {
            let obj = arr[i];
            table.appendChild(generateRow(obj.name, obj.height, obj.place));
        }
        return table;
    }

    document.getElementById('mountains').appendChild(generateTable(MOUNTAINS));
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
    &lt;div id="mountains"&gt;&lt;/div&gt;
&lt;script&gt;
"use strict";
    const MOUNTAINS = [
        {name: "Kilimanjaro", height: 5895, place: "Tanzania"},
        {name: "Everest", height: 8848, place: "Nepal"},
        {name: "Mount Fuji", height: 3776, place: "Japan"},
        {name: "Vaalserberg", height: 323, place: "Netherlands"},
        {name: "Denali", height: 6168, place: "United States"},
        {name: "Popocatepetl", height: 5465, place: "Mexico"},
        {name: "Mont Blanc", height: 4808, place: "Italy/France"}
    ];
    
// generates a table row with the given data   
    function generateRow(name, height, place) {
        var row = document.createElement("tr");
        var nameLm = document.createElement("td")
            var nameNode = document.createTextNode(name);
            nameLm.appendChild(nameNode);
                row.appendChild(nameLm);
        var heightLm = document.createElement("td")
            var heightNode = document.createTextNode(height);
            heightLm.appendChild(heightNode);
                row.appendChild(heightLm);
        var placeLm = document.createElement("td")
            var placeNode = document.createTextNode(place);
            placeLm.appendChild(placeNode);
                row.appendChild(placeLm);
        return row;
    }
    
// generates the header of the table    
    function generateHeader() {
        var row = document.createElement("tr");
        var nameLm = document.createElement("th")
            var nameNode = document.createTextNode("name");
            nameLm.appendChild(nameNode);
                row.appendChild(nameLm);
        var heightLm = document.createElement("th")
            var heightNode = document.createTextNode("height");
            heightLm.appendChild(heightNode);
                row.appendChild(heightLm);
        var placeLm = document.createElement("th")
            var placeNode = document.createTextNode("place");
            placeLm.appendChild(placeNode);
                row.appendChild(placeLm);
        return row;
    }
    
    function generateTable(arr) {
        var table = document.createElement("table");
        var ln = arr.length;
        table.appendChild(generateHeader());
        for(let i = 0; i &lt; ln; i++) {
            let obj = arr[i];
            table.appendChild(generateRow(obj.name, obj.height, obj.place));
        }
        return table;
    }

    document.getElementById('mountains').appendChild(generateTable(MOUNTAINS));
&lt;/script&gt;    
        </pre>
        </details>
<h4><u> Elements by Tag Name </u></h4>
<h1>Heading with a <span>span</span> element.</h1>
<p id="demoMe">A paragraph with <span>one</span>, <span>two</span> spans.</p>
<script>
"use strict";
    function byTagName(node, tagName) {
        var arr = [];
        var collect = node.getElementsByTagName(tagName);
        for(let i = 0; i < collect.length; i++) {
            arr.push(collect[i])
        }
        return arr;
    }

    console.log(byTagName(document.body, "h1").length);
        // → 1
    console.log(byTagName(document.body, "span").length);
        // → 3
    let para = document.querySelector("#demoMe");
    console.log(byTagName(para, "span").length);
        // → 2
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
&lt;1&gt;Heading with a &lt;span&gt;span&lt;/span&gt; element.&lt;/h1&gt;
&lt;p id="demoMe"&gt;A paragraph with &lt;span&gt;one&lt;/span&gt;, &lt;span&gt;two&lt;/span&gt; spans.&lt;/p&gt;
&lt;script&gt;
"use strict";
console.clear();
    function byTagName(node, tagName) {
        var arr = [];
        var collect = node.getElementsByTagName(tagName);
        for(let i = 0; i &lt; collect.length; i++) {
            arr.push(collect[i])
        }
        return arr;
    }

    console.log(byTagName(document.body, "h1").length);
        // → 1
    console.log(byTagName(document.body, "span").length);
        // → 3
    let para = document.querySelector("#demoMe");
    console.log(byTagName(para, "span").length);
        // → 2
&lt;/script&gt;        
        </pre>
        </details>
<h4><u> The Cat's Hat </u></h4>    
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>
<h2><u> Chapter 14 (Handling Events) </u></h2>
<h4><u> debouncing mouse position update program </u></h4>    
    <p id="mousePosition"> - </p>
<script>
    let scheduled = null;
    window.addEventListener("mousemove", event => {
        if (!scheduled) {                           // when the "scheduled" is null the set timeout fires 
            setTimeout(() => {
                document.getElementById('mousePosition').innerHTML = `Mouse at ${scheduled.pageX}, ${scheduled.pageY}`;
                scheduled = null;                   // at every call the "scheduled" set to "null"
            }, 250);
        }
        scheduled = event;                          // once the mouse finishes moving the "scheduled" is bound to the "event" object, therefore the "if(){}" statement receives a false value 
                                                    // the magic here when the mouse doesn't the "if(){}" statement doesn't fire AWESOME
    });
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
    &lt;p id="mousePosition"&gt; - &lt;/p&gt;
&lt;script&gt;
    let scheduled = null;
    window.addEventListener("mousemove", event => {
        if (!scheduled) {                           // when the "scheduled" is null the set timeout fires 
            setTimeout(() => {
                document.getElementById('mousePosition').innerHTML = `Mouse at ${scheduled.pageX}, ${scheduled.pageY}`;
                scheduled = null;                   // at every call the "scheduled" set to "null"
            }, 250);
        }
        scheduled = event;                          // once the mouse finishes moving the "scheduled" is bound to the "event" object, therefore the "if(){}" statement receives a false value 
                                                    // the magic here when the mouse doesn't the "if(){}" statement doesn't fire AWESOME
    });
&lt;/script&gt;    
        </pre>
        </details>
<h3><u> Exercise : </u></h3>
<h4><u> Balloon </u></h4>    
    <p > Klick on the Ballon and use up and down keys will inflate/deflate the ballon <u>page scroll disabled until ballon focus</u> [if more 10% inflation ballon explodes and cannot be deflated/inflated any more])  </p>
    <p id="balloon" style="font-size:30px;"> 🎈 </p>
    <button id="inflationReady"> Enable balloon Inflation/Deflation </button>
    <button id="disableInflation"> Disable balloon Inflation/Deflation </button>
    <p> [Blow Status = <span id="baloonStatus" style="color:yellow; font-weight:bold;">STAND BY</span>] </p>
<script>
"use strict";
    document.getElementById('inflationReady').addEventListener('keydown', balloonOperation);
    document.getElementById('disableInflation').removeEventListener('keydown', balloonOperation);
    
    var currentSize = 30;                        // store current scale size
    
    function balloonOperation(event) {
        event.preventDefault();                 // default behaviour prevented = page won't scroll whit listener active ("I'm awesome");
        
        if (event.code == "ArrowUp") {
            currentSize += 3;
            document.getElementById("balloon").style.fontSize = `${currentSize}px`;       
        } else if (event.code == "ArrowDown") {
            currentSize -= 3;
            document.getElementById("balloon").style.fontSize = `${currentSize}px`;
        }
        
    // size check
        if (currentSize <= 30) {
            currentSize = 30;                   // this makes sure that the balloon cannot be smaller than 30px;
            document.getElementById("balloon").style.fontSize = `${currentSize}px`;
        } else if (currentSize >= 60) {         // balloon explodes if it gets bigger than 60px and listener removed
            document.getElementById("balloon").textContent = "💥";
            document.getElementById('inflationReady').removeEventListener('keydown', balloonOperation);
                document.getElementById("baloonStatus").textContent = "BOOOOOM = balloon exploded no operation can be performed on it any more!";
        }
    }
    
// notify the user if the balloon operation is ready
    document.getElementById('inflationReady').onmousedown = function() {
        document.getElementById("baloonStatus").textContent = "READY to inflate (up/down keys) => Keyboard Operations Disabled!";
        document.getElementById("baloonStatus").style.color = "red";
    }
    
    document.getElementById('disableInflation').onmousedown = function() {
        document.getElementById("baloonStatus").textContent = "STAND BY";
        document.getElementById("baloonStatus").style.color = "yellow";
    }
</script>    
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
    &lt;p id="balloon" style="font-size:30px;"&gt; 🎈 &lt;/p&gt;
    &lt;button id="inflationReady"&gt; Enable balloon Inflation/Deflation &lt;/button&gt;
    &lt;button id="disableInflation"&gt; Disable balloon Inflation/Deflation &lt;/button&gt;
    &lt;p&gt; [Blow Status = &lt;span id="baloonStatus" style="color:yellow; font-weight:bold;"&gt;STAND BY&lt;/span&gt;] &lt;/p&gt;
&lt;script&gt;
"use strict";
    document.getElementById('inflationReady').addEventListener('keydown', balloonOperation);
    document.getElementById('disableInflation').removeEventListener('keydown', balloonOperation);
    
    var currentSize = 30;                        // store current scale size
    
    function balloonOperation(event) {
        event.preventDefault();                 // default behaviour prevented = page won't scroll whit listener active ("I'm awesome");
        
        if (event.code == "ArrowUp") {
            currentSize += 3;
            document.getElementById("balloon").style.fontSize = `${currentSize}px`;       
        } else if (event.code == "ArrowDown") {
            currentSize -= 3;
            document.getElementById("balloon").style.fontSize = `${currentSize}px`;
        }
        
    // size check
        if (currentSize &lt;= 30) {
            currentSize = 30;                   // this makes sure that the balloon cannot be smaller than 30px;
            document.getElementById("balloon").style.fontSize = `${currentSize}px`;
        } else if (currentSize &gt;= 60) {         // balloon explodes if it gets bigger than 60px and listener removed
            document.getElementById("balloon").textContent = "💥";
            document.getElementById('inflationReady').removeEventListener('keydown', balloonOperation);
                document.getElementById("baloonStatus").textContent = "BOOOOOM = balloon exploded no operation can be performed on it any more!";
        }
    }
    
// notify the user if the balloon operation is ready
    document.getElementById('inflationReady').onmousedown = function() {
        document.getElementById("baloonStatus").textContent = "READY to inflate (up/down keys) => Keyboard Operations Disabled!";
        document.getElementById("baloonStatus").style.color = "red";
    }
    
    document.getElementById('disableInflation').onmousedown = function() {
        document.getElementById("baloonStatus").textContent = "STAND BY";
        document.getElementById("baloonStatus").style.color = "yellow";
    }
&lt;/script&gt;       
        </pre>
        </details>
<h4><u> Mouse Trail </u></h4>    
    <button id="trailMouse"> Trail Mouse </button>
    <button id="stopMouseTrail"> Stop Mouse Trail </button>
    <span> Mouse Trail = <span id="trailFeedback" style="color:green;">Deactivated</span></span>
    <p style='color:yellow'> - this project has been abandoned because I couldn't figure out how to propagate the click event under the trailing element (even the eloquentJavascript code prevent this behaviour!!!) (2018-10-18) </p>
<script> 
$("document").ready(function(){
 
    var cursorTracker = $("body").append("<div id='tracker' style='display:none;'>"); 
                                                        // mouse tracked created and hidden when page loads
    $("#tracker").click(function(event){
        event.preventDefault();
        console.log(event.isDefaultPrevented());
        
    })
    
// start trailing    
    $("#trailMouse").on("mouseup", function(event){
        $("#trailFeedback").text("Activated").css("color", "yellow");
        $("body").on("mousemove", function(event){
            var clientX = event.clientX;
            var clientY = event.clientY;
            $("#tracker").css({display:"block", width:"40px", height:"40px", borderRadius:"40px", position:"fixed", backgroundColor:"yellow", left:`${1 + clientX}px`, top:`${1 + clientY}px`, transform:"translate(-20px,-20px)", pointerElements:"none"});     
                                                        // tracker follows the cursor 
            
            // console.log( event );
            
            
        });
    });
    
// end trailing    
    $("#stopMouseTrail").on("mouseup", function(event){
        $("#trailFeedback").text("Deactivated").css("color", "green");
        $("body").off("mousemove");
        $("#tracker").css("display", "none");           // remove the mouse tracker
    });
    
    
    
    
    
    
    /*
    document.addEventListener("click", function(event) {
        // event.target.firstElementChild.click();
        
        console.log(event.target);
    },true);
    */
});


/*    
<script>
// my code is right what I've written but I have the same problem here, usec cannot click throug the newly created element    
  let dots = [];
  for (let i = 0; i < 12; i++) {
    let node = document.createElement("div");
    node.className = "trail";
    document.body.appendChild(node);
    dots.push(node);
  }
  let currentDot = 0;
  
  window.addEventListener("mousemove", event => {
    let dot = dots[currentDot];
    dot.style.left = (event.pageX - 3) + "px";
    dot.style.top = (event.pageY - 3) + "px";
    currentDot = (currentDot + 1) % dots.length;            // interesting way to keep the currentDot  between 0-11
  });
*/    
</script>  
<h4><u> Tabs </u></h4>   
    <tab-panel>
        <div data-tabname="one">Tab one</div>
        <div data-tabname="two">Tab two</div>
        <div data-tabname="three">Tab three</div>
        <div data-tabname="four">Tab four</div>
        <div data-tabname="five">Tab five</div>
        <div data-tabname="six">Tab six</div>
    </tab-panel>
<script>
    function asTabs(node) {
    // parent interface created    
        node.setAttribute("style", "background-color:grey; border:outset 2px green; display:block; height:200px;");
        
    // get child elements and create tabs
        var child = node.getElementsByTagName("div");
        for(let i = 0; i < child.length; i++) {
            child[i].setAttribute("style", "display:none;");
            let tabButton = document.createElement("button");
            tabButton.textContent = child[i].getAttribute("data-tabname");
            node.appendChild(tabButton);
        // register click event listener on every button in order to display the element's content
            tabButton.addEventListener("click", function(event){
                var displayInterface = document.createElement("p");
                var content = child[i].textContent;
                displayInterface.textContent = content;
                node.appendChild(displayInterface);
            // conditional statement replaces the existing interface (we cannot keep appending child because they accumulate, so we create one than replace it every button click)
                if(node.getElementsByTagName("p")) {
                    node.replaceChild(displayInterface, node.getElementsByTagName("p")[0]);
                }
            // selected button state 
                for (let i = 0; i < node.getElementsByTagName("button").length; i++) {
                    node.getElementsByTagName("button")[i].style.backgroundColor = "lightgray";
                }
                event.target.style.backgroundColor = "gray";
            });
        }
        node.getElementsByTagName("button").item(0).click();        // this ensures that the first element is clicked when the code loads
    }   
    
    asTabs(document.querySelector("tab-panel"));
</script>
        <details>
        <summary class="exampleCode"> CODE : </summary>
        <pre>
    &lt;tab-panel&gt;
        &lt;div data-tabname="one"&gt;Tab one&lt;/div&gt;
        &lt;div data-tabname="two"&gt;Tab two&lt;/div&gt;
        &lt;div data-tabname="three"&gt;Tab three&lt;/div&gt;
        &lt;div data-tabname="four"&gt;Tab four&lt;/div&gt;
        &lt;div data-tabname="five"&gt;Tab five&lt;/div&gt;
        &lt;div data-tabname="six"&gt;Tab six&lt;/div&gt;
    &lt;/tab-panel&gt;
&lt;script&gt;
    function asTabs(node) {
    // parent interface created    
        node.setAttribute("style", "background-color:grey; border:outset 2px green; display:block; height:200px;");
        
    // get child elements and create tabs
        var child = node.getElementsByTagName("div");
        for(let i = 0; i &lt; child.length; i++) {
            child[i].setAttribute("style", "display:none;");
            let tabButton = document.createElement("button");
            tabButton.textContent = child[i].getAttribute("data-tabname");
            node.appendChild(tabButton);
        // register click event listener on every button in order to display the element's content
            tabButton.addEventListener("click", function(event){
                var displayInterface = document.createElement("p");
                var content = child[i].textContent;
                displayInterface.textContent = content;
                node.appendChild(displayInterface);
            // conditional statement replaces the existing interface (we cannot keep appending child because they accumulate, so we create one than replace it every button click)
                if(node.getElementsByTagName("p")) {
                    node.replaceChild(displayInterface, node.getElementsByTagName("p")[0]);
                }
            // selected button state 
                for (let i = 0; i &lt; node.getElementsByTagName("button").length; i++) {
                    node.getElementsByTagName("button")[i].style.backgroundColor = "lightgray";
                }
                event.target.style.backgroundColor = "gray";
            });
        }
        node.getElementsByTagName("button").item(0).click();        // this ensures that the first element is clicked when the code loads
    }   
    
    asTabs(document.querySelector("tab-panel"));
&lt;/script&gt;    
        </pre>
        </details>
<!---------------------------------------------------------------------------------------------------------------------------->
<hr>
<h2><u><a href="Chapter 16 (Project - Platform Game)/index.html"> Chapter 16 (Project : Platform Game) [link] > </a></u></h2>    
<h2><u><a href="Chapter 17 (Drawing on Canvas - Game)/index.html"> Chapter 17 (Drawing on Canvas) [link] > </a></u></h2>    
<h2><u><a href="Chapter 18 (Forms and Local Storage)/index.html"> Chapter 18 (Forms and Local Storage) [link] > </a></u></h2> 
<h2><u><a href="Chapter 19 (Projcet - Pixel Art Editor)/index.html"> Chapter 19 (Project : Pixel Art Editor) [link] > </a></u></h2>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
<script>
$(document).ready(function(){
    $("u:contains(Exercise :)").css("color", "yellow");
    
});    
</script> 

</body>
</html>