<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title> NGINX </title>
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <link rel="stylesheet" href="../Assets/stylesPages.css">
  <script src="../Assets/scriptPages.js"></script>
</head>

<body>
  <h1> NGINX </h1>
  <p> Updated: 2023-07-15 / 2023-11-14 </p>
  <p class="sitenav"> <a href="../index.html">MySite></a> NGINX
  <table class="table">
    <caption>
      commands
      <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
    </caption>
    <tr>
      <th style="width:30%;"> Command </th>
      <th> Description </th>
    </tr>
    <tr class="05.01">
      <td>
        nginx <small>[options]</small>
      </td>
      <td>
        - launches the NGINX daemon <br>
        <small>[options]</small><br>
        - (<small>-c <i>absoluteFilePath</i></small>) launches with config file <i>absoluteFilePath</i> <br>
        - (<small>-v</small>) prints the version <br>
        - (<small>-V</small>) prints full NGINX infor (version, compiled modules, etc..) <br>
        - (<small>-t</small>) checks the syntax validity of the <u>default config file</u> and prints its location <br>
        - (<small>-s reload</small>) reloads the currently used configs without interupting nginx <br>
        <p class="indent-lv1 no-margin">- if reloading fails (like config has syntax error) nginx will keep running with the old configs <u>BUT DOES NOT PRINT ANY ERRORS</u></p>
        - (<small>-s quit</small>) gracefull stop (wait for all worker processes to finish their current request) <br>
        - (<small>-s stop</small>) immediatley kills all nginx processes 
      </td>
    </tr>
    <tr class="10.01">
      <td>
        htpasswd <small>[options]</small> <strong>pathTo.htpasswd</strong> <strong>user</strong>
      </td>
      <td>
        - adds the <strong>user</strong> to the targeted <mark>.htpasswd</mark> file (the <mark>htpasswd</mark> utility creates user files for basic authentication) <br>
        - (<small>-c</small>) creates the file
      </td>
    </tr>
  </table>
  <br>
  <table class="table">
    <caption>
      directives
      <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
    </caption>
    <tr>
      <th style="width:25%;"> Directive </th>
      <th style="width:15%;"> Available in Context </th>
      <th> Description </th>
    </tr>
    <tr class="01.01">
      <td>
        <a href="http://nginx.org/en/docs/dirindex.html" target="_blank">All directives</a>
      </td>
      <td>
        
      </td>
      <td>
        - all directives
      </td>
    </tr>
    <tr class="05.01">
      <td>
        listen <i>host:</i><strong>port</strong>|<strong>domainSocketPath</strong>
      </td>
      <td>
        server
      </td>
      <td>
        - sets the host:port or domain socket on which the server listens (creates the domain socket if doesn't exist) <a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#listen" target="_blank">[link]</a> <br>
        - Default: <mark>*:80 | *:8000</mark>
      </td>
    </tr>
    <tr class="05.02">
      <td>
        server_name <strong>hostName:str|regEx|wildcard</strong> <i>...</i>
      </td>
      <td>
        server
      </td>
      <td>
        - this virtual server will respond to requests having the <mark>Host</mark> header with this value
      </td>
    </tr>
    <tr class="07.01">
      <td>
        root <strong>dirPath</strong>
      </td>
      <td>
        http / server / location / if in location
      </td>
      <td>
        - sets the root directory <br>
        - the requested path will be resolved on the host as <mark><strong>dirPath</strong> + <strong>requestPath</strong></mark>
      </td>
    </tr>
    <tr class="07.02">
      <td>
        alias <strong>dirPath</strong>
      </td>
      <td>
        location
      </td>
      <td>
        - in the current <mark>location</mark> context <span class="openable">replaces the <mark>location</mark> context's path with <strong>dirPath</strong><div>
        <pre>
http {
    server {
        listen 3000;
        
        location /site {      # request <mark>localhost:3000/site/index.html</mark> resolved on the host as <mark>/var/www/site/index.html</mark>   
            alias /var/www;   # <mark>/site</mark> replaced by <mark>/var/www</mark>
        }
    }
}
        </pre></div></span> to resolve the resource on the host <br>
        - overrides the <mark>root</mark> directive
      </td>
    </tr>
    <tr class="10.01">
      <td>
        index <strong>file</strong> <i>...</i>
      </td>
      <td>
        http / server / location
      </td>
      <td>
        - specifies the file lookup (on direcotry request) (Default: <mark>index index.html</mark>)
      </td>
    </tr>
    <tr class="10.02">
      <td>
        try_files <strong>filePath</strong> <i>...</i> <i>fallback:=httpCode|@namedLocation</i>
      </td>
      <td>
        server / location
      </td>
      <td>
        - tries files on <strong>filePath</strong>, the first found (leftmost) file is served, the fallback can be a http response code or a named location <br>
        - the path to file is constructed as <mark>root|alias</mark> + <strong>filePath</strong>
      </td>
    </tr>
    <tr class="10.03">
      <td>
        error_page <strong>httpCode</strong> <i>...</i> <small>=<i>responseHttpCode</i></small> <strong>uri</strong>
      </td>
      <td>
        http / server / location / if in location
      </td>
      <td>
        - redirects the traffic to <strong>uri</strong> when NGINX responds with <strong>httpCode</strong> <i>...</i> <br>
        - if <strong>uri</strong> points to an external link (ex: <mark>http://localhost:3001</mark>) we get a <mark>302</mark> response 
      </td>
    </tr>
    <tr class="10.04">
      <td>
        internal;
      </td>
      <td>
        location 
      </td>
      <td>
        - the current location can be reached internally only
      </td>
    </tr>
    <tr class="15.01">
      <td>
        add_header <strong>headerKey</strong> <strong>headerVal</strong> <small>[always]</small>
      </td>
      <td>
        http / server / location / if in location
      </td>
      <td>
        - adds a header to the response (only for responses 200, 201, 204, 206, 301, 302, 303, 304, 307, 308) <br>
        - <small>always</small> for all responses (regardless of the response code)
      </td>
    </tr>
    <tr class="15.02">
      <td>
        gzip
      </td>
      <td>
        http / server / location / if in location
      </td>
      <td>
        - enables / disables gzip compression responses
      </td>
    </tr>
    <tr class="15.03">
      <td>
        gzip types <span class="openable"><strong>mimeType</strong> <i>...</i>|*<div>
            <p> - <mark>*</mark> all mime types </p>
        </div></span>
      </td>
      <td>
        http / server / location
      </td>
      <td>
        - for the <mark>gzip</mark> directive specifies for which mime types enable the gzip compression (Default: <mark>text/html</mark>) <br>
      </td>
    </tr>
    <tr class="20.01">
      <td>
        limit_except <strong>httpMethod</strong> <i>...</i> { }
      </td>
      <td>
        http / server / location / if in location
      </td>
      <td>
        - (context) allows only the wite listed http method(s), other methods will get a <mark>405</mark> response <br>
        - in the block we can use <mark>allow</mark> and <mark>deny</mark> to white / black addresses
      </td>
    </tr>
    <tr class="20.02">
      <td>
        deny <strong>ip</strong>|unix:<strong>domainSocketPath</strong>|all
      </td>
      <td>
        http / server / location / limit_except
      </td>
      <td>
        - blacklist the specified address <br>
        - <u>restricts file access only! this does not work for <mark>return</mark> statement (WTF) <u>
      </td>
    </tr>
    <tr class="20.03">
      <td>
        allow <strong>ip</strong>|unix:<strong>domainSocketPath</strong>|all
      </td>
      <td>
        http / server / location / limit_except
      </td>
      <td>
        - whitelist the specified address <br>
        - <u>restricts file access only! this does not work for <mark>return</mark> statement (WTF) <u>
      </td>
    </tr>
    <tr class="25.01">
      <td>
        worker_processes <strong>nr</strong>|auto
      </td>
      <td>
        main
      </td>
      <td>
        - controls how many worker processes NGINX uses (Default: <mark>1</mark>)
      </td>
    </tr>
    <tr class="25.02">
      <td>
        worker_connections <strong>nr</strong>
      </td>
      <td>
        events
      </td>
      <td>
        - controls how many simultaneous connections are allowed <u>per worker processes</u> (Default: <mark>512</mark>)
      </td>
    </tr>
    <tr class="30.01">
      <td>
        access_log <strong>filePath</strong> <i><a href="https://nginx.org/en/docs/http/ngx_http_log_module.html#access_log">other configs</a></i>
      </td>
      <td>
        http / server / location / if in location / limit_except
      </td>
      <td>
        - sets the access log path, format, etc... (creates the file if not exist)
      </td>
    </tr>
    <tr class="30.02">
      <td>
        error_log <strong>filePath</strong> <i class="openable">level<div>
            <p> <mark>debug</mark> </p>
            <p> <mark>info</mark> </p>
            <p> <mark>notice</mark> </p>
            <p> <mark>warn</mark> </p>
            <p> <mark>error</mark> (Default) </p>
            <p> <mark>crit</mark> </p>
            <p> <mark>alert</mark> </p>
            <p> <mark>emerg</mark> </p>
        </div></i>
      </td>
      <td>
        main / http / mail / stream / server / location
      </td>
      <td>
        - sets the error log path and level (creates the file if not exist)
      </td>
    </tr>
  </table>
  <br>
  <details class="example" id="notes">
    <summary> Notes & Tips :</summary>
    <!-- <p> - paragraph removes the 'empty' message from the detail TAG -->
  </details>
  <h2 class="headerSection"> Useful Links : </h2>
  <p><a href="https://gist.github.com/carlessanagustin/9509d0d31414804da03b" target="_blank">NGINX cheatsheet (GitHub) </a></p>
  <p><a href="http://nginx.org/en/docs/varindex.html" target="_blank">NGINX Alphabeticaly index of variables (nginx.org)</a></p>
  <p><a href="http://nginx.org/en/docs/dirindex.html" target="_blank">NGINX all eirectives (nginx.org)</a></p>
  <h2 class="headerSection"> Remember This : </h2>
    <p> - nginx doesn't show the currently used config file (what a carap), to see which config file is used run the <mark>ps aux | grep nginx</mark> command </p>
  <h2 class="headerSection"> Description and Demonstration : </h2>
    <p> - NGINX is an open software originally deisgned for high performance web serving (to solve the famous <mark class="mark">C10K</mark> 10000 concurrent request problem), however there is also a paid version with enhanced capabilities <mark class="mark">NGINX Plus</mark></p>
    <p> - can be installed by package managers (like: <mark>brew</mark>), but we can also download the source code configure compile and install for a fine grained install <a href="https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/#compiling-and-installing-from-source
" target="_blank">[link]</a></p>
    <p> - but NGINX is also: <mark class="mark">static web server or mail server</mark>, <mark class="mark">redirect & rewrite URLs</mark>, 
<mark class="mark">reverse proxy</mark>, <mark class="mark">load balancer</mark>, <mark class="mark">SSL termination point</mark>, <mark class="mark">distiribute traffic to specific services</mark>, <mark class="mark">handles caching</mark>, <mark class="mark">offers security features (such as authentication, DDOS protection, rate limiting, WAF, blacklisting etc...)</mark> </p>
    <p> - NGINX runs as daemon/service but can be controled from the foreground with the <mark>nginx</mark> command, essentially reads a config file (default: <mark>/etc/nginx/nginx.conf</mark>) </p>
    <p> - NGINX has a master process and serveral worker processes that follow the asynchronous event driven architecture </p>
    <p> - the master process evaluates the configuration and maintains the worker processes, worker processes are responsible to serve the actual request </p>
    <p> - NGINX Concepts: </p>
    <p class="indent-lv1"> - <mark class="mark">context</mark> : essentially a config scope (scope works just like in programmig languages (child scope inherit directives from higher levels but can be overriden in the current scope)) </p>
    <p class="indent-lv1"> - <mark class="mark">directive</mark> : key/value pair (can have multiple values) describing config instructions in the curren context </p>
    <p class="indent-lv1"> - <mark class="mark">zone</mark> : shared memory space </p>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <h4 class="header"> Simplest possible server </h4>
    <pre>
    http {
        server {
            listen 3000;
            
            return 200 "Hello World!";
        }
    }
    
    events {}
    </pre>
    <h4 class="header"> Routing traffic based on request path </h4>
    <pre>
    http {
        server {
            listen 3000;
            root /var/www;
            
            location / {                      # main route
                index main.html;
            }
            
            location ~ \.(jpe?g|bmp|gif)$ {   # serves files from /var/www/images (when path ends with regex)
                root /var/www/images;
            }
        }
    }
    
    events {}
    </pre>
    <h4 class="header"> White listing </h4>
    <pre>
    http {
        geo $client_allowed {
            default       0;
            127.0.0.1     1;
        }
        
        server {
            listen 3000;
            
            if ($client_allowed = 0) {            # client address check
                return 403 "You're not allowed!";
            }
            
            location / {
                return 200 "Hello World!";
            }
        }
    }
    
    events {}
    </pre>
  </details>
  <!-------------------------------------------------------------------------------------------->
  <hr>
    <h2 class="header"> NGINX Contexts <mark>http</mark> / <mark>server</mark> / <mark>location</mark> / <mark>events</mark> </h2>
    <p> - a context executes from top to bottom, the <mark>return</mark> statement can break further execution </p>
    <p> - nested directives override directives that are inherited from the parent context (just like scoping works in 
    <pre class="syntax">
                                          // (top level) used to define core configs (like logs, etc...)
    http {                                // nests all http related configs and virtual servers
        server {                          // virtual server (or vhost) is basically a server namespace containing configs and routes 
            location <strong class="openable"><i>modifier</i> path<div>
                <p> - location with the highest precedence will be matched <u>no matter the declaration order</u></p>
                <p> - declaration order matters on same precedence </p> 
                <p> --- precedence 1 --- </p>
                <p> <mark>= <strong>path:str</strong></mark> -> exact route </p>
                <p> --- precedence 2 --- </p>
                <p> <mark>^~ <strong>path:str</strong></mark> -> preferential match (any path prefixed with <strong>path</strong>)</p>
                <p> --- precedence 3 --- </p>
                <p> <mark>~ <strong>path:regEx</strong></mark> -> case-sensitive regular expression</p>
                <p> <mark>~* <strong>path:regEx</strong></mark> -> case-insensitive regular expression</p>
                <p> --- precedence 4 --- </p>
                <p> <mark><strong>path:str</strong></mark> -> any path prefixed with <strong>path</strong> </p>
            </div></strong> { }   // contains configs for a specified location (url path)    
            location @<strong>namedLocation</strong> { }   // (named location) don't match any request paths, they are used in directives to redirect the traffic (like: <mark>error_page</mark>, <mark>try_files</mark>)
            <i>...</i>
        }
        <i>...</i>
    }
    
    events { }                            // contains global options for connection processing
    
    
<span style="color:gray;">// Context execution & inheritance -----------------------------------</span>
    <strong>ctx</strong> {
        set $<strong>someVar</strong> <strong>valA</strong>;
        
        <strong>ctx</strong> {
            set $<strong>someVar</strong> <strong>valB</strong>;            // override parent variable (in the local scope)
            
            return <strong>httpCode str</strong>;          // breaks further exectution 
        }
    }
    
    </pre>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <h4 class="header"> <mark>loation</mark> context </h4>
    <pre>
    http {
        server {
            listen 3000;
            
            location /login {                     // different configs for different routes 
                return 200 "Login response";
            }
            
            location /content {
                return 200 "Content response";
            }
        }
    }
    
    events {}
    </pre>
    <h4 class="header"> <mark>loation</mark> context route matching precedence </h4>
    <pre>
    http {
        server {
            listen 3000;
            
            location ~ /login {
                return 200 "Login response";
            }
            
            location ~ /login {                   # route never reached because both locations have the same precedence level (so declaration order matters here)  
                return 200 "Content response";
            }
        }
    }
    
    events { }
    </pre>
    <pre>
    http {
        server {
            listen 3000;
            
            location ~ /test {
                return 200 "Regex match";           # matches 3rd (precedence 3)
            }
            
            location ^~ /test {
                return 200 "Preferential match";    # matches 2nd (precedence 2)
            }
            
            location = /test {                      # this will take effect (because it has the highest precedence) (precedence 1)
                return 200 "Exact match";
            }
        }
    }
    
    events {}
    </pre>
    <pre>
    http {
        server {
            listen 3000;
            
            location ^~ /images/ {
                // config for path prefixed with <mark>/images/</mark>
            }
            
            location ~* \.(gif|jpg|jpeg)$ {
                // config for path that ends with matching regex <mark>\.(gif|jpg|jpeg)$</mark> (when the path doesn't start with <mark>/images/</mark>)    
            }
            
            location / {
                // fallback path configs
            }
        }
    }
    
    events {}
    </pre>
    <h4 class="header"> <mark>location</mark> used as named location </h4>
    <pre>
    http {
        upstream backup_server {
            server localhost:3004;
        }
        
        server {
            listen 3000;
            
            location / {
                try_files invalid/route @fallback;      # redirects the traffic to fallback location if file not found
            }
            
            location @fallback {
                return 200 "Fallback Content";
            }
        }
    }
    
    events {}
    </pre>
    <h4 class="header"> <mark>events</mark> context </h4>
    <pre>
    http {
        server {
            listen 3000;
            
            location / {
                return 200 "Hello World!";
            }
        }
    }
    
    events {
        worker_connections 1024;      # maximum number of simultaneous connections
    }
    </pre>
    <h4 class="header"> directive inheritance </h4>
    <pre>
    http {
        gzip on;
        
        server {
            gzip off;       # overrides this directive in this context
            
            listen 3000;
            
            location / {
                gzip off;     # overrides this directive in this context (again)
                
                root "/home/arpad/projects/My-Knowledge-Base/My Site";
            }
        }
    }
    
    events {}
    </pre>
    <h4 class="header"> the <mark>return</mark> statement breaks further context execution </h4>
    <pre>
    http {
        geo $client_allowed {
            default       0;
            127.0.0.1     1;
        }
        
        server {
            listen 3000;
            
            if ($client_allowed = 0) {            # client address check
                return 403 "You're not allowed!";
            }
            
            location / {
                return 200 "Hello World!";
            }
        }
    }
    
    events {}
    </pre>
  </details>
  <!-------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="header"> Importing configurations </h2>
    <pre class="syntax">
    import <strong>absoluteFilePath</strong>;              // imports the file and pareses the content as nginx config (can be used in any context)
    </pre>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <pre>
    http {
        server {
            include "/home/arpad/projects/My-Knowledge-Base/My Site/NGINX/server.conf";
        }
    }
    
    events { }
    
    
// server.conf ------------------------------------
    root "/var/www/test";
    index test.index;
    listen 3000;
    </pre>
  </details>
  <!-------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="header"> Mime type to file extension mapping </h2>
    <p> - when serving files NGINX must map file types to mime types, the <mark>types</mark> context does this (NGINX comes with default mime type mapping, located in <mark>/etc/nginx/mime.types</mark>) </p>
    <pre class="syntax">
    types {
        <strong>mimeType</strong> <strong>fileExtension</strong> <i>...</i>;       // maps <strong>mimeType</strong> to file extenstion(s) (default: <mark>text/plain</mark> -> for non specified file extensions)    
        <i>...</i>
    }
    </pre>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <pre>
    http {
        types {                         # file extension to mime types mapping 
            text/html               html;
            text/css                css;
            application/javascrpt   js;
        }
    
        server {
            listen 3000;
            root "/var/www";
            
            location / {
                index test;
            }
        }
    }
    
    events {}
    </pre>
    <pre>
    http {
        include /etc/nginx/mime.types;    # default nginx mime type mapping
    
        server {
            listen 3000;
            root "/var/www";
            
            location / {
                index test;
            }
        }
    }
    
    events {}
    </pre>
  </details>
  <!-------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="header"> Variables / <mark>if</mark> statement / <mark>map</mark> statement / <mark>geo</mark> statement </h2>
  <p> - built-in variables <a href="http://nginx.org/en/docs/varindex.html" target="_blank">[link]</a></p>
  <pre class="syntax">
<span style="color: darkgray;">// variables (allowed in context <mark class="mark">http</mark> / <mark class="mark">server</mark> / <mark class="mark">location</mark> / <mark class="mark">if</mark>) --------------------------------------</span>
    set $<strong>var</strong> <strong>val</strong>;                         // declares a new variable (variable scoping works as in programming languages) (<mark class="mark">location</mark> only)
    $<strong>var</strong>                                  // using variable <u><a href="http://nginx.org/en/docs/varindex.html" target="_blank">(there are a ton of built-in variables)</a></u>
    
    
<span style="color: darkgray;">// <mark>if</mark> statement (allowed in context <mark class="mark">http</mark> / <mark class="mark">server</mark> / <mark class="mark">location</mark>) ----------------------------------------</span>
    if (<strong>cond</strong>) {                           // executes the code block if <strong>cond</strong> evaluates true
        <i>some code ...</i>
    }
    
    
<span style="color: darkgray;">// <mark>map</mark> statement (allowed in context <mark class="mark">http</mark>) -----------------------------------------------------------</span>
    map <strong>str|varA</strong> <strong>varB</strong> {                   // basically a case statement 
        default <strong>val</strong>;                      // default case 
        <strong class="openable">case:str|regEx<div>
          <p> - <mark><strong>str</strong></mark> - exact match </p>
          <p> - <mark>~<strong>str</strong></mark> - regEx case-sensitive match </p> 
          <p> - <mark>~*<strong>str</strong></mark> - regEx case-insensitive match </p> 
        </div></strong> <strong>val</strong>;              // if <strong>str|varA</strong> == <strong>case</strong> assigns <strong>val</strong> to <strong>varB</strong> (otherwise tries the next case)   
        <i>...</i>
    }
    
    
<span style="color: darkgray;">// <mark>geo</mark> statement (allowed in context <mark class="mark">http</mark> / <mark class="mark">server</mark> / <mark class="mark">location</mark>) ---------------------------------------</span>
    geo <strong>var</strong> {                             // case statement which check the <mark>$remote_addr</mark> (remote address built-in variable) against casses (used to assign some value to a variable based on the remote address)   
        default <strong>val</strong>;                      // default case 
        <strong>case</strong> <strong>val</strong>;                         // if <mark>$remote_addr</mark> == <strong>case</strong> assigns <strong>val</strong> to <strong>var</strong> (otherwise tries the next case)   
        <i>...</i>
    }
  </pre>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <h4 class="header"> Variables </h4>
    <pre>
    http {
        server {
            set $hw "Hello World!";
            listen 3000;
            
            location = / {
                return 200 $hw;
            }
            
            location /somePath {
                set $hw "Hello World overriden!";   # local variable
                return 200 $hw;
            }
        }
    }
    
    events {}
    </pre>
    <h4 class="header"> <mark>if</mark> statement </h4>
    <pre>
    http {
        server {
            listen 3000;
        
            location / {
                if ($request_method != "GET") {       # block executed when the request method is not GET
                    return 405 "Only 'GET' request method allowed";
                }
                return 200 "OK";
            }
        }
    }
    
    events {}
    </pre>
    <h4 class="header"> <mark>map</mark> statement </h4>
    <pre>
    http {
        map $uri $return_value {      # basically a JavaScript case-like statement the <mark>$uri</mark> (built-in variable) is mapped to <mark>$return_value</mark> based on the case
            /test "Test";
            / "Root";
            default "Default";
        }
        
        server {
            listen 3000;
            
            location / {
                return 200 $return_value;
            }
        }
    }
    
    events {}
    </pre>
    <h4 class="header"> <mark>geo</mark> statement </h4>
    <pre>
    http {
        geo $locahost {       # checks if any case matches the <mark>$remote_addr</mark> built-in variable (remote address)   
            127.0.0.1   1;
            ::1         1;
            default     0;
        }
    
        server {
            listen 3000;
            location / {
                if ($locahost = 0) {
                    return 403 "Only localhost request allowed!";
                }
                return 200 "OK";
            }
        }
    }
    
    events {}
    </pre>
  </details>
  <!-------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="headerExtra"> Directives </h2>
  <h3 class="header"> The <mark>listen</mark> / <mark>server_name</mark> directives </h3>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <h4 class="header"> <mark>listen</mark> directive </h4>
    <pre>
    http {
        server {
            listen 172.17.0.2:3000; 
            
            location / {
                return 200 "Hello World!";
            }
        }
    }
    
    events { }
    </pre>
    <pre>
    http {
        server {
            listen unix:/var/run/nginx.sock;        # listening on domain socket  
            
            location = /test {
                return 200 "Hello World!";
            }
        }
    }
    
    events { }
    </pre>
    <h4 class="header"> <mark>server_name</mark> directive </h4>
    <pre>
    http {
        server {
            listen 3000;
            server_name test1 test2;        # server responds to requests having the <mark>Host: test1|test2</mark> header (or any rquests -> this is the default)
            
            location / {
                return 200 'respond to test1 or test2';
            }
        }
        
        server {
            listen 3000;
            server_name test3 test4;        # server responds to requests having the <mark>Host: test3|test4</mark> header
            
            location / {
                return 200 'respond to test3 or test4';
            }
        }
        
        server {
            listen 3000;
            server_name MiciMacko.com;       # server responds to requests having the <mark>Host: MiciMacko.com</mark> header
            
            location / {
                return 200 'Mici Macko responded brum brum!';
            }
        }
    }
    
    events {}
    </pre>
  </details>
  <h3 class="header"> The <mark>root</mark> / <mark>alias</mark> directives </h3>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <h4 class="header"> <mark>root</mark> directive </h4>
    <pre>
    http {
        root /var/www/test_site;    # the requested path will be resolved on the host as <mark>/var/www/test_site<strong>requestPath</strong></mark>   
        
        server {
            listen 3000;
        }
    }
    
    events { }
    </pre>
    <h4 class="header"> <mark>alias</mark> directive </h4>
    <pre>
    http {
        server {
            listen 3000;
            root /log;
            
            location /images {                                    # request <mark>localhost:3000/images/hi.jpg</mark> resolved on the host as <mark>/var/www/test_site/images/hi.jpg</mark>
                alias /var/www/test_site/images;                  # <mark>/images</mark> replaced by <mark>/var/www/test_site/images</mark> + remaining request path
            }
            
            location /tests {                                     # request <mark>localhost:3000/tests/render.test</mark> resolved on the host as <mark>/var/www/test_site/e2e/render.test</mark>
                alias /var/www/test_site/e2e;                     # <mark>/tests</mark> replaced by <mark>/var/www/test_site/e2e</mark> + remaining request path
            }
            
            location /data {                                      # request <mark>localhost:3000/data/me.txt</mark> resolved on the host as <mark>/var/www/test_site/ready_data/public/me.txt</mark>
                alias /var/www/test_site/ready_data/public;       # <mark>/data</mark> replaced by <mark>/var/test_site/ready_data/public</mark> + remainng request path
            }
        }
    }
    
    events { }
    </pre>
  </details>
  <h3 class="header"> The <mark>index</mark> / <mark>try_files</mark> / <mark>error_page</mark> / <mark>internal</mark> directives </h3>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <h4 class="header"> <mark>index</mark> directive </h4>
    <pre>
    http {
        index main.html index.html;       # default file lookups (on directory request)
        root /var/www/site;
        
        server {
            listen 3000;
        }
    }
    
    events { }
    </pre>
    <h4 class="header"> <mark>try_files</mark> directive </h4>
    <pre>
    http {
        include /etc/nginx/mime.types;
        
        server {
            listen 3000;
            root /var/www/site;
            
            location /main {
                try_files /main.html /index.html =404;        # files are looked up in <mark>/var/www/site</mark> directory    
            }
            
            location /data {
                alias /var/www/site/data;
                try_files /main.html /index.html =404;        # files are looked up in <mark>/var/www/site/data</mark> directory    
            }
            
            location /tests {
                alias /var/www/site/dir;                      # files are looked up in <mark>/var/www/site/dir</mark> directory    
                try_files /main.html /index.html @fallback;   # named location is the fallback value 
            }
            
            location @fallback {
                return 404 "Not Found!";
            }
            
        }
    }

    events {}
    </pre>
    <h4 class="header"> <mark>error_page</mark> / <mark>internal</mark> directives </h4>
    <pre>
    http {
        include /etc/nginx/mime.types;
        
        server {
            listen 3000;
            error_page 404 /errors/not_found.html;
            error_page 500 502 503 504 =500 /errors/server_error.html;    # response code will be <mark>500</mark>
            
            location ^~ /errors {
                internal;           # no external request allowed
                alias /var/www/site/errors;
            }
        }
    }
    
    events {}
    </pre>
    <pre>
    http {
        server {
            listen 3000;
            error_page 404 http://localhost:3005;       # NGINX will respond with a 302 (redirect)
            
            location = / {
                return 200 "OK";
            }
        }
    }
    
    events {}
    </pre>
  </details>
  <h3 class="header"> The <mark>add_header</mark> / <mark>gzip</mark> / <mark>gzip_types</mark> directives </h3>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <h4 class="header"> <mark>add_header</mark> directive </h4>
    <pre>
    http {
        server {
            listen 3000;
            add_header CustomHeader test;
            add_header CustomHeader2 test2 always;    # will be added to all responses (regardless of the response code)   
            
            location / {
                return 200 "Hello World!";
            }
        }
    }
    
    events {}
    </pre>
    <h4 class="header"> <mark>gzip</mark> / <mark>gzip_types</mark> directives </h4>
    <pre>
    http {
        gzip on;          # compresses (includes the header <mark>Content-Encoding gzip</mark>)
        gzip_types *;     # all files will be gzip compressed
        
        server { 
            listen 3000;
            root "/Users/DIARPALL/projects/My-Knowledge-Base/My Site";
            index index.html;
            
            location = /hiddenResource {
                return 200 "Hidden resource response!";
            }
        }
    }

    events {}
    </pre>
  </details>
  <h3 class="header"> The <mark>limit_except</mark> / <mark>allow</mark> / <mark>deny</mark> </h3>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <h4 class="header"> <mark>limit_except</mark> directive </h4>
    <pre>
    http {
        server {
            listen 3000;
            
            location / {
                limit_except GET { }      # only GET (and HEAD) requests are allowed, other requests will get 405 responses
                
                return 200 "OK";
            }
        }
    }
    
    events { }
    </pre>
    <pre>
    http {
        server {
            listen 3000;
            
            location / {
                limit_except GET PUT POST {   # only 127.0.0.1 can acces with GET, PUT, or POST request  
                    allow 127.0.0.1;
                    deny all;
                }
                
                return 200 "OK";
            }
        }
    }
    
    events { }
    </pre>
    <h4 class="header"> <mark>allow</mark> / <mark>deny</mark> directives </h4>
    <pre>
    http {
        server {
            listen 3000;
            # allow 127.0.0.1;
            deny all;
            
            location / {
                root "/Users/DIARPALL/projects/My-Knowledge-Base/My Site";    # blocked access
            }
            
            location /notBlocked {
                return 200 "Still accessed";          # -! <mark>allow</mark> & <mark>deny</mark> does not work for return statements!
            }
        }
    }
    
    events { }
    </pre>
  </details>
  <h3 class="header"> The <mark>worker_processes</mark> / <mark>worker_connections</mark> directives </h3>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <h4 class="header"> <mark>worker_processes</mark> / <mark>worker_connections</mark> directives </h4>
    <pre>
    worker_processes auto;          # NGINX automatically scales worker processes
    
    http {
        
        server {
            listen 3000;
            
            location / {
                return 200 "OK";
            }
        }
    }
    
    events {
        worker_connections 1024;    # number of simultaneous connections <b>per worker process</b>
    }
    </pre>
  </details>
  <h3 class="header"> The <mark>access_log</mark> / <mark>error_log</mark> directives </h3>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <h4 class="header"> <mark>worker_processes</mark> / <mark>worker_connections</mark> directive </h4>
    <pre>
    http {
        access_log /var/www/site/log/access.log;
        error_log /var/www/site/log/error.log info;
        
        server {
            listen 3000;
            location / {
                return 200 "Hello World!";
            }
        }
    }
    
    events { }
    </pre>
  </details>
<!----------------------------------------------------------------------------->
<hr>
  <h2 class="headerExtra"> Redirect & Rewrite </h3>
  <p> - redirecting is sending a <mark>3*</mark> response with the <mark>Location</mark> header containing the address where to redirect </p>
  <p> - rewriting is tunneling the request, the requested URL forwards the request to a 3rd URL without notifying the client </p>
  <pre class="syntax">
  http {
      server {
          location <strong>path</strong> {
              return 301 <strong>addressToRedirect</strong>;        // sends a redirect (<mark>3**</mark>) response 
          }
          
          rewrite <strong>thisURL</strong> <strong>forwardedURL</strong>;            // request is forwarded to <strong>forwardedURL</strong> (the client requests <strong>thisURL</strong> but served the <strong>forwardedURL</strong> content)    
      }
  }
  
  events { }
  </pre>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <h4 class="header"> Redirect </h4>
    <pre>
    http {
        server {
            listen 3002;
            
            location /login {
                return 200 "You've been redirected to /login";
            }
            
            location /profile {                   # redirect to an internal address 
                return 301 /base;
            }
            
            location /redirect1 {
                return 301 http://google.com;     # redirect to an external address
            }
        }
    }
    
    events {}
    </pre>
    <h4 class="header"> Redirect </h4>
    <pre>
    http {
        server {
            listen 3000;
            
            rewrite /newPath /test;           # /newPath requested but /test served    
            rewrite /g http://google.com;     # rewriting to an external resource
            
            location /test {
                return 200 "test";
            }
        }
    }
    
    events {}
    </pre>
  </details>
<!----------------------------------------------------------------------------->
<hr>
  <h2 class="headerExtra"> Load Balancing </h3>
  <pre class="syntax">
  http {
      upstream <strong>upstreamName</strong> {                      // distributes the traffic between the listed servers (Round-Robin fashion by default)    
          least_conn;                                // traffic routed to the server having the least active connection
          ip_hash;                                   // the same client is always routed to the same upstream server (calculates a hash based on the client's IP)   
          <a href="https://nginx.org/en/docs/http/ngx_http_upstream_module.html" target="_blank">all options...</a>
          
          server <strong>url</strong>|unix:<strong>unixSocket</strong> <i class="openable">options<div>
              <p> - <mark>weight=<strong>int</strong></mark> - weights the server (for weighted load balancing), the highest weighted server gets more request (Default server weight <mark>1</mark>) </p>
              <p> - <mark>backup</mark> - backup server, traffic redirected here when all upstream servers are down </p>
              <p> - <mark>max_fails</mark>=<strong>ing</strong> - after <strong>ing</strong> attempts the server is marked as unavailable </p>
              <p> - <mark>fail_timeout=<strong>time</strong> - for this long the server is marked as unavailable</mark> </p>
              <p> - <a href="https://nginx.org/en/docs/http/ngx_http_upstream_module.html#upstream" target="_blank">All options</a></p>
          </div></i>;
          <i>...</i>
      }
      
      proxy_set_header <strong>key</strong> <strong>val</strong>;                    // adds this header to the upstream servers (available in contexts <mark class="mark">http</mark> <mark class="mark">server</mark> <mark class="mark">location</mark>)   
      
      server {
          location <strong>path</strong> {
              proxy_pass <strong>url</strong>;                      // forwards (rewrites) the traffic to <strong>url</strong>    
              
              proxy_pass http://<strong>upstreamName</strong>;      // forwards the traffic to the upstream 
          }
      }
  }
  
  events { }
  </pre>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <h4 class="header"> proxy_pass </h4>
    <pre>
    http {
        server {
            listen 3000;
           
            location / {
                proxy_pass http://google.com;           # traffic passed (forwarded) to <mark>http://google.com</mark>
            }
        }
    }
    
    events { }
    </pre>
    <h4 class="header"> load balancing </h4>
    <pre>
    http {
        upstream backend {                    # traffict is distributed in Round Robin style
            server localhost:3001;
            server localhost:3002;
            server localhost:3003;
            server localhost:3004 backup;     # server kicks in when ALL upstream servers are down
        }
        
        server {
            listen 3000;
            
            location /ups {
                proxy_pass http://backend;
            }
        }
    }
    
    events {}
    </pre>
    <pre>
    http {
        upstream backend {                      # connection distributed based on server weight 
            server localhost:3001 weight=1;
            server localhost:3002 weight=5;
            server localhost:3003 weight=3;
            server localhost:3004;                  # default weight = 1
        }
        
        server {
            listen 3000;
            
            location / {
                proxy_pass http://backend;
            }
        }
    }
    
    events {}
    </pre>
    <pre>
    http {
        upstream backend {              # load distributed to the server having the least connection 
            least_conn;
            
            server localhost:3001;      // -! servers have to listen on path /test 
            server localhost:3002;
            server localhost:3003;
            server localhost:3004;
        }
        
        server {
            listen 3000;
            
            location /test {            # load balancer path
                proxy_pass http://backend;
            }
        }
    }
    
    events {}
    </pre>
    <h4 class="header"> health check </h4>
    <pre>
    http {
        upstream backend {
            hearth_check;                                         // -! active health check (NGINX Plus only)
            
            server localhost:3001;
            server localhost:3002 max_fails=3 fail_timeout=1m;    # after 3 failed attempts nginx marks this server as unavailable for 1 minute
        }
        
        server {
            listen 3000;
            
            location / { 
                proxy_pass http://backend;
            }
        }
    }
    
    events {}
    </pre>
    <h4 class="header"> <mark>proxy_set_header</mark> directive </h4>
    <pre>
    http {
        upstream up {
            server localhost:3001;
            server localhost:3002;
        }
    
        server {
            listen 3000;
    
            location / {
                proxy_set_header ToProxy ToProxyValue;    # header added to upstream servers    
                proxy_pass http://up;
            }
        }
    }
    
    events { }
    </pre>
  </details>
<!----------------------------------------------------------------------------->
<hr>
  <h2 class="headerExtra"> NGINX SSL </h2>
  <p> - NGINX can be used as SSL termination point </p>
  <pre class="syntax">
  http {
      server {
          listen <strong>port</strong> ssl;             # ssl connection
          
          ssl_certificate <strong>pathToCert</strong>;
          ssl_certificate_key <strong>pathToCertKey</strong>;
          ssl_protocols <strong class="openable">protocols<div>
              <p> Default: <mark>TLSv1 TLSv1.1 TLSv1.2 TLSv1.3</mark> </p>
          </div></strong>;
          ssl_ciphers <strong class="openable">ciphers<div>
              <p> Default: <mark>HIGH:!aNULL:!MD5</mark> </p>
          </div></strong>;
      }
  }
  
  events { }
  </pre>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <h4 class="header"> SSL connection </h4>
    <pre>
    http {
        server { 
            listen 443 ssl;
            
            ssl_certificate "/Users/DIARPALL/projects/My-Knowledge-Base/My Site/NGINX/test.cer";       # certificate   
            ssl_certificate_key "/Users/DIARPALL/projects/My-Knowledge-Base/My Site/NGINX/test.pem";   # the cectificate's key   
            
            location / {
                return 200 "Hello World!";
            }
        }
    }
    
    events {}
    </pre>
    <h4 class="header"> SSL termination point </h4>
    <pre>
    http {
        upstream backend {
            server localhost:3001;
            server localhost:3002;
        }
    
        server {                  # the ssl handshake is between the client - NGINX proxy (no ssl connection between NGINX proxy - upstream servers)  
            listen 3000 ssl;
            
            ssl_certificate "/Users/DIARPALL/projects/My-Knowledge-Base/My Site/NGINX/test.cer";
            ssl_certificate_key "/Users/DIARPALL/projects/My-Knowledge-Base/My Site/NGINX/test.pem";
            
            location / {
                proxy_pass http://backend;
            }
        }
    }
    
    events {}
    </pre>
  </details>
<!----------------------------------------------------------------------------->
<hr>
  <h2 class="headerExtra"> Authentication <a href="https://docs.nginx.com/nginx/admin-guide/security-controls/configuring-http-basic-authentication/" target="_blank">[link]</a> </h2>
  <p> - NGINX provides a simple web browser authentication (on non browser requests we get <mark>401</mark>) </p>
  <p> - we can use the <mark>htpasswd</mark> utility to create the user password file, then we link the file in NGINX config (that simple) </p>
  <pre class="syntax">
  http {
      server {
          auth_basic <strong>msg</strong>;              # message to prompt in the browser    (available in contexts <mark class="mark">http</mark> <mark class="mark">server</mark> <mark class="mark">location</mark> <mark class="mark">limit_except</mark>)   
          auth_basic_user_file <strong>path</strong>;   # user password file                  (available in contexts <mark class="mark">http</mark> <mark class="mark">server</mark> <mark class="mark">location</mark> <mark class="mark">limit_except</mark>)    
          
          location <strong>path</strong> {
              auth_basic off;          # disables authentication for this path
          }
      }
  }
  
  events { }
  </pre>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <h4 class="header"> SSL connection </h4>
    <pre>
    http {
        include /opt/homebrew/etc/nginx/mime.types;
        
        server {
            listen 3000 ssl;
            root "/Users/apall/Documents/Personal/my_knowledge_code_base/My Site";
            
            ssl_certificate "/Users/DIARPALL/projects/My-Knowledge-Base/My Site/NGINX/test.cer";                # Chrome forces you to use ssl (but from NGINX perspective SSL is not required)    
            ssl_certificate_key "/Users/DIARPALL/projects/My-Knowledge-Base/My Site/NGINX/test.pem";
            
            auth_basic "Buddy you have to authenticate to enter!";                                              # message will to prompt to the user (in prompt text box)   
            auth_basic_user_file "/Users/DIARPALL/projects/My-Knowledge-Base/My Site/NGINX/passwd/.htpasswd";   # auth file location
        }
    }
    
    events {}
    </pre>
  </details>
<!----------------------------------------------------------------------------->
<hr>
  <h2 class="headerExtra"> Caching <a href="https://docs.nginx.com/nginx/admin-guide/content-cache/content-caching/" target="_blank">[link]</a> </h2>
  <pre class="syntax">
  http {
      proxy_cache_path <strong>dirPath</strong> keys_zone=<strong>cacheZone</strong>:<strong>size</strong>  <i><a href="https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_path" target="_blank">options...</a></i>;    // specifies the cache directory and the cache zone  
      proxy_cache <strong>cacheZone</strong>;                                            // responses will be cahced in the current and all descendent scopes (available in contexts <mark class="mark">http</mark> <mark class="mark">server</mark> <mark class="mark">location</mark>)   
  }
  
  events { }
  </pre>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <pre>
    http {
        proxy_cache_path '/tmp' keys_zone=mycache:10m;
        proxy_cache_valid any 2m;     # for any request types (GET, POST, etc..) cache is valid for 2 minutes
        
        server {
            listen 3000;
            proxy_cache mycache;      # valid for this vhost (for all the server's locations)
            
            location /a {
                proxy_pass http://localhost:3001;
            }
          
            location /b {
                proxy_pass http://localhost:3002;
            }
        }
        
        server {                      # no caching for this context (vhost)
            listen 4000;
            
            location /a {
                proxy_pass http://localhost:4001;
            }
        
            location /b {
                proxy_pass http://localhost:4002;
            }
        }
    }
    
    events {}
    </pre>
    <pre>
    http {
        proxy_cache_path '/tmp' keys_zone=mycache:10m;
        proxy_cache_valid any 2m;     # for any request types (GET, POST, etc..) cache is valid for 2 minutes
        proxy_cache mycache;          # valid for both virtual servers (for the current and all child contexts)
        
        server {
            listen 3000;
            
            location /a {
                proxy_pass http://localhost:3001;
            }
          
            location /b {
                proxy_pass http://localhost:3002;
            }
        }
        
        server {                      # no caching for this context
            listen 4000;
            
            location /a {
                proxy_pass http://localhost:4001;
            }
        
            location /b {
                proxy_pass http://localhost:4002;
            }
        }
    }
    
    events {}
    </pre>
  </details>
  
  
  <br><br>
</body>

</html>