<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title> TypeScript </title>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../Assets/stylesPages.css">
    <script src="../Assets/scriptPages.js"></script>
  </head>

  <body>
    <h1> TypeScript </h1>
    <p> Updated ( 2022-12-04 )</p>
    <nav class="sitenav">
      <a href="../index.html">MySite > </a> TypeScript
    </nav>
    <p class="subSite"><a href="./Interface/index.html"> Interface > </a></p>
    <p class="subSite"><a href="./Class/index.html"> Class & Abstract Class > </a></p>
    <p class="subSite"><a href="./Namespace/index.html"> Namespace > </a></p>
    <table class="table">
      <caption>
        <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
      </caption>
      <tr>
        <th style="width:30%;"> command </th>
        <th> Description </th>
      </tr>
      <tr>
        <td>
          npm install <small>-g</small> typescript
        </td>
        <td>
          - installs TypeScript
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          tsc --help
        </td>
        <td>
          - tsc help
        </td>
      </tr>
      <tr>
        <td>
          tsc --init
        </td>
        <td>
          - creates the <mark>tsconfig.json</mark> file in the current directory
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          tsc <i>tscFile.ts</i>
        </td>
        <td>
          - transpiles the <i>tscFile.ts</i> (TypeScript) files into JavaScript file (in the current directory) <br>
          - in <mark>tsconfig.json</mark> we can set the transpilation source (<mark>rootDir</mark>) and target
          (<mark>outDir</mark>) directories
        </td>
      </tr>
      <tr>
        <td>
          tsc --out|--outFile <strong>outFile.js</strong> <strong>inFile.ts</strong> <i>...</i>
        </td>
        <td>
          - transpiles <strong>inFile.ts</strong> <i>...</i> (TypeScript) file(s) in one single
          <strong>outFile.js</strong> (JavaScirpt) file
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          tsc -w
        </td>
        <td>
          - watch mode, when there's a change in the <mark>rootDir</mark> -> runs the compiler
        </td>
      </tr>
    </table>
    <br>
    <details class="example" id="notes">
      <summary> Notes :</summary>
      <!-- <p> - paragraph removes the 'empty' message from the detail TAG -->
    </details>
    <h2 style="color:green;"><u> Useful Links : </u></h2>
    <p><a href="https://www.typescriptlang.org/" target="_blank">www.typescriptlang.org</a></p>
    <h2 style="color:green;"><u> Remember This : </u></h2>

    <h2 style="color:green;"><u> Description and Demonstration : </u></h2>
    <p> - TypeScript is basically a strongly typed JavaScript, it's an extension of JavaScript with typing approach (Static-like programming language) </p>
    <p> - TypeScript is a transpiler which transpiles TypeScript code into JavaScript code </p>
    <p> - TypeScript benefits: </p>
    <p style="text-indent: 30px;"> - statically typed (type errors are raised on transpile time) </p>
    <p style="text-indent: 30px;"> - we can use brand new features because the transpiler compiles compatilbe JavaScript code </p>
    <p style="text-indent: 30px;"> - code completition / intellisence (while developing we can see precise method/property suggestions becasue the type is known already) </p>
    <p> - the <mark>tsconfig.json</mark> file configures the Typescript compilier (can be created with <mark>tsc --init</mark>) </p>
    <hr>
    <!------------------------------------------------------------------------------------->
    <h2 class="header"> Type Annotation </h2>
    <pre class="syntax">
    let|const <strong>varName</strong>: <strong>tsType</strong> <small>[= <i>val</i>]</small>                   // variable type annotation     
    let|const <strong>varName</strong> <small>[= <i>val</i>]</small>                           // TypeScript will figure out the type if <strong>tsType</strong> is omitted    
    let <strong>varName</strong>                                         // variable has <mark>any</mark> type (no value assigned)    
    
    
// function annotation -----
    function <strong>fnName</strong>(<strong>arg<small>?: </small>tsType</strong>): <strong>tsType</strong> { }           // type annotation of function argument(s) and return value (<mark><small>?</small></mark> after function argument = optional argument)    
    function <strong>fnName</strong>(<strong>arg</strong>) { }                            // if types are omitted: argument types are set to <mark>any</mark>, the return type will be dynamically assigned 
    
    
// object annotation -----------
    { [key in <reqval>union</reqval>]: <reqval>tsType</reqval> }      // <reqval>union</reqval> describes required object keys
    { [key: string]: <reqval>tsType</reqval> }                        // string object keys
    
    type <reqval>keyTypes</reqval> = keyof <reqval>objType</reqval>     // extracts <reqval>objType</reqval> keys into <reqval>keyTypes</reqval> which is a <reqval>union</reqval> type
    </pre>
    <details class="example">
      <summary> DEMO </summary>
      <h4 class="header"> Variables </h4>
      <pre>
    let s : string = 'some string';
    let n : number = 21;
    let Parent : 'father' | 'mother';       // any of the listed values (types)
    
    
    let s2 = 'some string 2';               // typescript automatically annotates the type (string)
    let nope                                // <mark>any</mark> type 
    
    
// -------------------------------------------------------------------------
    const nestArr: string[][] = [           // nested string arrays 
        ['a', 'b', 'c'],
        ['d', 'e', 'f']
    ]
    
// -------------------------------------------------------------------------
    const animal: {                         // object annotation 
        name: string,
        readonly age: number,               // readonly property
        color?: string                      // optional property
    } = {name:'Morgo', age:12}
    
    console.log( animal );                  // -> { name: 'Morgo', age: 12 }
    console.log( animal.color );            // undefined
    
    animal.name = 'New Morgo';
    animal.age = 13;                        // this would trow an error (readonly property)
    </pre>
      <hr>
      <!------------------------------------------------------>
      <h4 class="header"> Functions Annotation </h4>
      <pre>
    function add(a : number, b : string): number {
        return a + parseInt(b);                         // returns a number type
    }
    
    function add2(a : number, b : string) {
        return a + parseInt(b);                         // returned type is figured out by TypeScrip (number)
    }
    
    function divide( a:number, b?:number ): number {    // optional parameter
        return a / (b ? b : 2);
    }
    
    console.log( add(1, '3') );                         // -> 4
    console.log( add2(1, '3') );                        // -> 4
    console.log( divide(10, 5) );                       // -> 2
    console.log( divide(10) );                          // -> 5 
    </pre>
      <hr>
      <!------------------------------------------------------>
      <h4 class="header"> Object annotation </h4>
      <pre>
    const person: { [key in 'name' | 'age' | 'email']: string | number } = {
      name: 'Doe',                                                    // annotated keys are required
      age: 40,
      email: 'doe@john.com',
    };
    
    
// <mark>keyof</mark> ---------------------------
    type Person = {
      name: string;
      age: number;
      email: string;
    };
    
    type PersonKeys = keyof Person;       // PersonKeys is a union type of "name" | "age" | "email"
    
    let personKey: PersonKeys;            // to loop through (kind of a duktape solution but Typescript is very annoying on this :/)
    for (personKey in person) {
      person[personKey]
    }
      </pre>
    </details>
    <hr>
    <!------------------------------------------------------------------------------------->
    <h2 class="header"> Data Types </h2>
    <p> - TypeScript supports all JavaScript types but extends these types with a few new ones </p>
    <pre class="syntax">
// Native JavaScript types -----------------------------
    <lit>string</lit>
    <lit>number</lit>
    <lit>bigint</lit>
    <lit>boolean</lit>
    <lit>undefined</lit>
    <lit>null</lit>
    <lit>symbol</lit>
    
    <lit>object</lit>
    <lit>Date</lit> | <lit>Function</lit> | <reqval>JavaScriptClass</reqval>    // any javaScript class can be used as type
    
    <strong>tsType</strong>[]                                                   // array of <strong>tsType</strong> (ex: <mark>number[]</mark> = array holding only numbers) 
    
    
// Typescript Types -------------------
    <strong>val</strong>                                                        // type can be any value (ex: <mark>'test'</mark> or <mark>32</mark>)    
    
    <lit>any</lit>                                                        // can be any type, callable, assignable 
    <lit>unknown</lit>                                                    // can be any type, not callable, not assignable  <span id="browserSupport" style="color:yellow;"><span>v.3</span></span>  
    
    <lit>void</lit>                                                       // function return type where function has no return     
    <lit>never</lit>                                                      // function return type where function throws an error or has inifinite loop (should never happen)    
    
    [<strong>tsType</strong><i>, ...</i>]                                              // tuple (fixed length array with annotated types) (values can be changes -> not a Python style tupe)    
    
    <lit>enum</lit> <strong>Enum</strong> { <strong>MEMBER</strong><small>=<i>val</i></small><i>, ...</i> }                              // enum (a set of <u>unchangable values</u> where only one member can be used) 
                                                               // values (<i>val</i>) are defined as <mark>0, 1, 2, ...</mark> by default
                                                               // values can be accessed as <mark><strong>Enum.MEMBER</strong></mark> or <mark><strong>Enum['MEMBER']</strong></mark> 
    </pre>
    <details class="example">
      <summary> DEMO </summary>
      <h4 class="header"> Array </h4>
      <pre>
    let myArray : number[] = [1, 2, 3];                     // array of types (array will have only number types)
    let myArray2 : (number|string)[] = [1, 2, '3'];         // number or string types can be contained 
    let myArray3 : any[] = [1, '2', false];                 // array can have any types
    </pre>
    <hr>
    <!---------------------------------------------------------------->
      <h4 class="header"> The <mark>any</mark> / <mark>unknown</mark> types </h4>
      <pre>
// any -------------------------------------------------------------------
    let a1: any = 10;
    let a2: any = (a:any) => a;
    
    console.log( a1 );          // -> 10        // can be any value
    const new1: string = a1;    // can be assigned to other values (this is the problem that <mark>unknown</mark> fixes)   
    console.log( new1 );        // -> 10        // -! the new variable has wrong value this way    
    
    console.log( a2(10));       // -> 'x'       // can be called 
    
    
// unknown ---------------------------------------------------------------
    let b1: unknown = 10;
    let b2: unknown = (a:any) => a;
    
    console.log( b1 );          // -> 10        // can be any value
    const new2:string = b1;     // -! not assignable (this throws an error)
    
    b2(10);                     // -! not callable (this throws an error)
    </pre>
    <hr>
    <!---------------------------------------------------------------->
      <h4 class="header"> The <mark>void</mark> / <mark>never</mark> types</h4>
      <pre>
// void ------------------------------------------------------------------
    function toPower2 (a: number): void {           // no return value 
        console.log( a**2 )
    }
    
    console.log( toPower2(4) )                      // 16 (side effect)
    
// never -----------------------------------------------------------------
    function throwSomeError(): never {              // throws an error (should be 'never' called)    
        throw Error('Some Error');
    }
    
    function hasIniniteLoop(): never {              // has infinite loop (should be 'never' called)    
        while (true)
            console.log( '?' );
    }
    </pre>
    <hr>
    <!---------------------------------------------------------------->
      <h4 class="header"> Tuple & Enum types </h4>
      <pre>
// tuple -----------------------------------------------------------
    const t : [string, number] = ['1', 1];
    
    t[0] = '2'                  // not a Python style tuple (values can be changed)
    console.log( t[0] )         // -> '2'
    
    
// enum ------------------------------------------------------------
    enum MyEnum { ZERO, ONE, TOW };
    
    console.log( MyEnum.ZERO )      // -> 0
    console.log( MyEnum.ONE )       // -> 1
    MyEnum.ZERO = 3;                // -! this throws an error
    
    
    enum Pepe { NAME="Péter", SURNAME="Bozóki" };
    
    function concateName(name : string, surname: string ): string {
        return surname + ' ' + name;
    }
    
    console.log( Pepe.SURNAME, Pepe.NAME );                 // -> 'Bozóki Péter'    
    console.log( concateName(Pepe.NAME, Pepe.SURNAME) )     // -> 'Bozóki Péter'    
    </pre>
    </details>
    <hr>
    <!------------------------------------------------------------------------------------->
    <h4 class="header"> Type Alias: </h4>
    <pre class="syntax">
    type <strong>TypeName</strong> = <strong>tsType</strong>                                     // the <mark>type</mark> keyword defines a type alias for <strong>tsType</strong>   
    
    type <strong>objType</strong> = {                                           // object type alias
        <small>readonly</small> <strong>propName</strong><small>?</small> : <strong>tsType</strong>                            // property (<mark><small>readonly</small></mark> = readonly property) (<mark><small>?</small></mark> = optional property)
        <strong>methodName</strong><small>?</small>(<i>arg<small>?</small> : tsType</i>): <strong>tsType</strong>                     // function 
    }
    </pre>
    <details class="example">
      <summary> DEMO </summary>
      <p> - <mark>type</mark> alias </p>
      <pre>
    type LoggedIn = 0 | 1                       // type alias for 2 possible values  
    
    function connect(id : number, logged: LoggedIn ) { ... }
    
// -------------------------------------------------------------------------
    type Person = {
        name : string,
        surname? : string,
        readonly sex: 'male' | 'female' | 'other',
        getAge(): number
    }
    
    const monika : Person = {
        name: 'Mónika',
        surname: 'Péter',
        sex: 'female',
        getAge: () => 34
    }
    
    console.log( monika )       // -> { name:'Mónika', surname:'Péter', sex:'female', getAge:fn }
    </pre>
    </details>
    <hr>
    <!------------------------------------------------------------------------------------->
    <h4 class="header"> Union (<mark>|</mark>) & Intersection (<mark>&</mark>) types </h4>
    <pre class="syntax">
    <strong>tsType</strong> | <strong>tsType</strong>                                            // implements one or any combination of the listed <strong>tsTypes</strong>    
    <strong>tsType</strong> & <strong>tsType</strong>                                            // implements all of the listed types    
    </pre>
    <details class="example">
      <summary> DEMO </summary>
      <p> - <mark>|</mark> (union) <mark>&</mark> (intersection) </p>
      <pre>
    type a = { propA: string }
    type b = { propB: string }
    type c = { propC: string }
    
// union -------------------------------------------------------------------
    const one : a | b = { propA:'valA' }                                    // any of the listed types
    const many : a | b | c = { propA:'valA', propC:'valC' }                 // any combination of the listed types
    
    console.log( one )                                                      // -> { propA:'valA' }    
    console.log( many )                                                     // -> { propA:'valA', propC:'valC' }    
    
    
// intersection ------------------------------------------------------------
    const all : a & b & c = { propA:'valA', propB:'valB', propC:'valC'}     // must implement all unified types 
    const allOf : a & c = { propA:'valA', propC:'valC'}
    
    console.log( all )                                                      // -> { propA:'valA', propB:'valB', propC:'valC' }
    console.log( allOf )                                                    // -> { propA:'valA', propC:'valC' }
    </pre>
    </details>
    <hr>
    <!------------------------------------------------------------------------------------->
    <h4 class="header"> Generics: </h4>
    <p> - captures the type(s) at code entry then reuses the <mark><strong>GenTypeAlias</strong></mark> in the code block
      (can <mark><small>extends</small></mark> the <mark><strong>tsType</strong></mark>) </p>
    <p> <u>- type narrowing doesn't work on generics </u>
      <pre class="syntax">
    function <strong>fnName</strong><em>&lt;</em><strong>GenTypeAlias</strong><i>, ...</i> <small>[extends <i>tsType, ...</i>]</small></strong><em>&gt;</em>(<strong>arg: GenTypeAlias</strong>): <strong>GenTypeAlias</strong> {}
    
    class <strong>ClassName</strong><em>&lt;</em><strong>GenTypeAlias</strong><i>, ...</i> <small>[extends <i>tsType, ...</i>]</small></strong><em>&gt;</em> {
        <strong>propName</strong> : <strong>GenTypeAlias</strong>  
        
        constructor( <strong>propName: GenTypeAlias</strong> <i>, ...</i>) {           // type captured here
            <span style="color:darkgrey;">// ...</span>
        }
    }
    </pre>
      <details class="example">
        <summary> DEMO </summary>
        <p> - Generics </p>
        <pre>
// on functions ---------------------------------------------------------------
    function getBack&lt;T1, T2&gt;(a: T1, b:T2): (T1|T2)[] {      // captures the entry type 
        return [a, b]
    }
    
    console.log( getBack(1, false) );           // -> [1, false]
    console.log( getBack('a', [2]) );           // -> ['a', [2]]
    
    
    function getBac2&lt;T&gt;(a:T, b:T): T {
        if (typeof a === 'number' && typeof b === 'number') {       // type narrowing does not work on Generics 
            return a + b;                                           // -! throws an error (type not narrowed)
        }
    }
    
    
// on classes -----------------------------------------------------------------
    class Cart&lt;Product&gt; {
        public cart: Product[] = [];
    
        addProductCart(p: Product): void {
            this.cart.push(p)
        }
    
        getAll(): Product[] {
            return this.cart
        }
    }
    
    const cart = new Cart();
    
    cart.addProductCart('apple');
    cart.addProductCart('mellon');
    cart.addProductCart(2);
    cart.addProductCart(true);
    console.log( cart.getAll() );   // -> ['apple', 'mellon', 2, true]
    </pre>
      </details>
      <hr>
      <!------------------------------------------------------------------------------------->
      <h2 class="headerExtra"> Type Narrowing (Type Guarding) & Type Assertion</h2>
      <p> - <b>Type Narrowing</b> is a technique which narrows down type possibilityes from a set of types (ex: we narrow down an
        <mark>any</mark> type to <mark>string</mark> so we can use string methods on the narrowed value)
      </p>
      <p style="text-indent: 30px;"> - to type narrow we use techniques like: <mark>typeof</mark> operator, checking type properties / protitype
        checking / using the TypeScript <mark>as</mark> operator </p>

      <p> - <b>Type Guard</b> is essentially a function that verifies the type(s) of an argument and returns a boolean accordingly <u>(this technique is especially powerful in Typescript because the <mark>typeof</mark> operator can only check built-in types (but not custom types))</u> </p>
      <p> - <b>Type Assertion</b> is a technique to identify a value as certain type </p>
      <pre class="syntax">
    <strong>val</strong> as <strong>tsType</strong>                                     // (type assertion) identifies the <strong>val</strong> type as <strong>tsType</strong>
    
    typeof <strong>val</strong>                                        // returns the <strong>tsType</strong> of <strong>val</strong> <u>(cannot return custom types)</u>
    
    <reqval>variable</reqval>!                                        // (non-null assertion operator) tells the compiler that the <reqval>variable</reqval> value is not <mark>null</mark> or <mark>undefined</mark>
    </pre>
      <details class="example">
        <summary> DEMO </summary>
        <h4 class="header"> Type Narrowing (Type Guarding) </h4>
        <pre>
// -------------------------------------------------------------------------
    type HelloType = 'Hello World'
    const hello: HelloType = 'Hello World';
    
    
    typeof hello === 'string'                       // -> true
    typeof hello === HelloType                      // -! this is not working (not Python word here)
    
  // we have to be creative with type guards like this
    function isHelloType(val: any): boolean {
        return val && typeof val === 'string' && val === 'Hello World';
    }
    
    isHelloType(hello)                              // -> true    
    
    
// -------------------------------------------------------------------------
    type myTypes = string | number | null;
    
    function getCorrectType(a: myTypes): myTypes {
        if (a)                                      // narrowing (excluding) null type
            if (typeof a === 'string') {
                return a.toUpperCase();             // once the type is fully narrowed we can use the appropriate opperation on the type (<mark>string</mark> type)    
            } else {
                return a++;                         // <mark>number</mark> type 
            }
        
        return null
    }
    
    console.log( getCorrectType(null) )     // -> null
    console.log( getCorrectType('x') )      // -> 'X'
    console.log( getCorrectType(1) )        // -> 2
    
    
// property check -----------------------------------------------------------
    type Fish = {
        swimSpeed: number
        getSwimSpeed(): number
    }
    
    type Bird = {
        flySpeed: number
        getFlySpeed(): number
    }
    
    function getSpeed( animal : Fish | Bird ): number {
        if ('swimSpeed' in animal) {            // type narrowed down to Fish type 
            return animal.getSwimSpeed()        // we can call Fish type methods here 
        } else {
            return animal.getFlySpeed()         // we can call Bird type methods here
        }
    }
    </pre>
        <h4 class="header"> Type Assertion </h4>
        <pre>
// <mark>as</mark> operator--------------------------------------------------
    type Fish = {
        swimSpeed : number
        getSwimSpeed(): number
    }
    type Bird = {
        flySpeed : number
        getFlySpeed(): number
    }
    
    function getSpeed(animal: Fish | Bird): number {
        return (animal as Fish).getSwimSpeed();     // argument identified as Fish type 
    }
    </pre>
      </details>
      <br><br>

    </body>

  </html>