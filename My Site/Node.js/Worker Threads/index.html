<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title> Worker Threads </title>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../Assets/stylesPages.css">
    <script src="../../Assets/scriptPages.js"></script>
  </head>

  <body>
    <h1> Worker Threads
      <span class="browserSupport" title="updated : 2025-03-23">
        <span><i class="fab fa-node-js"></i> 10.5.0 </span>
      </span>
    </h1>
    <p> Updated: ( 2020-07-01 / 2025-03-23 )</p>
    <nav class="sitenav">
      <a href="../../index.html">MySite > </a>
      <a href="../index.html">Node.js > </a> Worker Threads
    </nav>
    <p class="subSite"><a href="./Message Channel/index.html"> MessageChannel & MessagePort > </a></p>
    <p class="subSite"><a href="./Brodcast Channel/index.html"> BrodcastChannel > </a></p>
    <table class="table">
      <tr>
        <th style="width:30%;"> Method / Property </th>
        <th> Description </th>
      </tr>
      <tr>
        <td> <lit>worker_threads</lit>.isMainThread </td>
        <td>
          - returns <mark>true</mark> if executed in the main thread <br>
          - returns <mark>false</mark> if executed in a worker thread
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <lit>worker_threads</lit>.parentPort </td>
        <td>
          - (in worker) returns the <strong>msgPort</strong> connected to the parent thread
        </td>
      </tr>
      <tr>
        <td> <lit>worker_threads</lit>.receiveMessageOnPort(<strong>msgPort</strong>) </td>
        <td>
          - returns the message <mark>{message:<reqval>msg:str</reqval>}</mark> that is recevied through the <reqval>msgPort</reqval>
          <span class="browserSupport" title="updated : 2020-07-06">
            <span><i class="fab fa-node-js"></i> 12.3.0 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <lit>worker_threads</lit>.setEnvironmentData(<reqval>key:MapKey</reqval>, <reqval>val:any</reqval>) </td>
        <td>
          - (main thread) sets some <reqval>val</reqval> that can be retrieved in any worker thread (by <mark>getEnvironmentData()</mark>)
          <span class="browserSupport" title="updated : 2025-03-23">
            <span><i class="fab fa-node-js"></i> 16.15 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td> <lit>worker_threads</lit>.getEnvironmentData(<reqval>key:MapKey</reqval>) </td>
        <td>
          - (worker thread) returns the <reqval>val</reqval> <u>clone</u> set by <mark>setEnvironmentData()</mark> in the main thread (referenced by <reqval>key</reqval>)
          <span class="browserSupport" title="updated : 2025-03-23">
            <span><i class="fab fa-node-js"></i> 16.15 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <lit>worker_threads</lit>.threadId </td>
        <td>
          - returns a unique Identifier (number) of the current thread thread
        </td>
      </tr>
      <tr>
        <td> <lit>worker_threads</lit>.resourceLimits </td>
        <td>
          - (in worker) returns an <a href="https://nodejs.org/docs/latest/api/worker_threads.html#workerresourcelimits" target="_blank">object</a> that gives info about the worker thread resource constraints <br>
          - this object can be passed as option when creating the worker
          <span class="browserSupport" title="updated : 2020-07-06">
            <span><i class="fab fa-node-js"></i> 12.16.0 / 13.2.0 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <lit>worker_threads</lit>.workerData </td>
        <td>
          - (in worker) returns the <mark>workerData</mark> value (<mark>workerData</mark> option passed when creating the worker)
        </td>
      </tr>
      <tr>
        <td> <lit>worker_threads</lit>.SHARE_ENV </td>
        <td>
          - the returned value can be passed as <mark>env</mark> option when creating the worker, so the worker shares (read and write) the same environment variables with the parent thread
          <span class="browserSupport" title="updated : 2020-07-06">
            <span><i class="fab fa-node-js"></i> 11.14.0 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <lit>worker_threads</lit>.markAsUntransferable(<strong>obj</strong>)
        </td>
        <td>
          - marks the passed <strong>obj</strong> as untransferable, so <strong>obj</strong> cannot be removed from the current thread (but still can be sent)
          <span class="browserSupport" title="updated : 2020-07-06">
            <span><i class="fab fa-node-js"></i> 14.5.0 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>
          <lit>worker_threads</lit>.isMarkedUntransferable(<strong>obj</strong>)
        </td>
        <td>
          - returns <mark>true</mark> if the <reqval>obj</reqval> is marked untransferable (with <mark>markAsUntransferable()</mark>), otherwise returns <mark>false</mark>
          <span class="browserSupport" title="updated : 2025-03-23">
            <span><i class="fab fa-node-js"></i> 21 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>
          <lit>worker_threads</lit>.isMarkedUclonable(<strong>obj</strong>)
        </td>
        <td>
          - marks the passed <strong>obj</strong> as unclonable, this basically means it cannot be sent to any thread (because data is cloned when sent)
          <span class="browserSupport" title="updated : 2025-03-23">
            <span><i class="fab fa-node-js"></i> 23 </span>
          </span>
        </td>
      </tr>
      
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <lit>worker_threads</lit>.moveMessagePortToContext(<strong>msgPort</strong>, <strong>vmContext:obj</strong>)
        </td>
        <td>
          - moves a message port (<strong>msgPort</strong>) in V8 Virtual Machine context (<strong>vmContext</strong>) <br>
          - returns the moved <reqval>msgPort</reqval>
          <span class="browserSupport" title="updated : 2020-12-16">
            <span><i class="fab fa-node-js"></i> 11.13.0 </span>
          </span>
        </td>
      </tr>
    </table>
    <br>
    <table class="table">
      <caption> Worker </caption>
      <tr>
        <th style="width:30%;"> Method / Property </th>
        <th> Description </th>
      </tr>
      <tr>
        <td>
          new <lit>worker_thread</lit>.Worker(<strong>filePath:str|urlObj</strong>, <a href="https://nodejs.org/docs/latest/api/worker_threads.html#new-workerfilename-options" target="_blank">option:obj</a>)
        </td>
        <td> - creates a new worker (which represents an independent JavaScript execution thread), returns <strong>worker</strong> <br>
          - <span class="openable">in Worker threads most JS API are available<div>
              <p> - <mark>process.stdin</mark> / <mark>process.stdout</mark> / <mark>process.stderr</mark> are redirected to the parent thread by default </p>
              <p> - <mark>process.exit()</mark> stops only the thread not the whole program </p>
              <p> - <mark>process.abort()</mark> is not available </p>
              <p> - <mark>process.chdir()</mark> and process methods that set users or groups are not available </p>
              <p> - <mark>process.env</mark> is a copy of the parent thread by default </p>
              <p> - <mark>process.title</mark> cannot be modified </p>
              <p> - signals are not delivered through <mark>process.on('signal')</mark></p>
              <p> - IPC channels from parent process are not accessible </p>
              <p> - <mark>trace_events</mark> module is not supported </p>
            </div></span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>worker</strong>.postMessage(<strong>val:any</strong>, <i class="openable">[obj, ...]<div>
              <p> - this is called 'Transfer List' object passed here are <u>removed from this thread</u> </p>
              <p> - only <mark>ArrayBuffer</mark> <mark>MessagePort</mark> and <mark>FileHandle</mark> objects can be passed <u><mark>SharedArrayBuffer</mark> is not allowed because it is not transferable</u> </p>
              <p style="color:orangered;"> - if the <mark>ArrayBuffer</mark> was created by a <mark>Buffer</mark> method (<mark>Buffer.from()</mark> <mark>Buffer.alloc()</mark>) it <u>CANNOT be transfered</u> </p>
              <p style="font-weight:bold; font-size:1.1em; text-decoration:underline;"> Example : </p>
              <p> - <mark>worker_1.postMessage(arrBuf_1, [arrBuf_1])</mark> = the <mark>arrBuff_1</mark> ArrayBuffer is moved to the worker (not available in this thread anymore) </p>
              <p> - <mark>worker_1.postMessage(null, [arrBuf_1])</mark> = the <mark>arrBuff_1</mark> ArrayBuffer is removed from this thread (not available in the worker either) [TESTED: 2020-07-04] </p>
            </div></i>)
        </td>
        <td>
          - sends a message (<reqval>val</reqval>) to the main thread
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <strong>worker</strong>.terminate() </td>
        <td>
          - stops all JavaScript execution in the worker thread as soon as possible <br>
          - returns a <reqval>promise</reqval> which is fulfilled when the <mark>exit</mark> event is emitted (resolved with the exit code)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <strong>worker</strong>.stdin </td>
        <td>
          - <reqval>writableStream</reqval> if this <reqval>worker</reqval> is created with option <mark>stdin:true</mark>, otherwise <mark>null</mark> (stream channel between the main and worker thread) <br>
          - written data on it can be read inside the worker's <mark>process.stdin</mark> as <reqval>readableStream</reqval>
        </td>
      </tr>
      <tr>
        <td> <strong>worker</strong>.stdout </td>
        <td>
          - <reqval>readableStream</reqval> if this <reqval>worker</reqval> is created with option <mark>stdout:true</mark>, otherwise <mark>null</mark> (stream channel between the main and worker thread) <br>
          - data is readable what's written inside the worker's <mark>process.stdout</mark> as <reqval>writableStream</reqval>
        </td>
      </tr>
      <tr>
        <td> <strong>worker</strong>.stderr </td>
        <td>
          - <reqval>readableStream</reqval> if this <reqval>worker</reqval> is created with option <mark>stderr:true</mark>, otherwise <mark>null</mark> (stream channel between the main and worker thread) <br>
          - data is readable what's written inside the worker's <mark>process.stderr</mark> as <reqval>writableStream</reqval>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <strong>worker</strong>.unref() </td>
        <td>
          - removes this <strong>worker</strong> from the event loop, so this <mark>worker</mark> does not prevent the process from closing
        </td>
      </tr>
      <tr>
        <td> <strong>worker</strong>.ref() </td>
        <td>
          - (re)attaches this <strong>worker</strong> in the event loop, so this <strong>worker</strong> does prevent the process from closing (opposite of <mark>unref()</mark>)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <strong>worker</strong>.threadId </td>
        <td>
          - returns the worker's unique thread identifier (number)
        </td>
      </tr>
      <tr>
        <td> <strong>worker</strong>.resourceLimits </td>
        <td>
          - returns an <a href="https://nodejs.org/docs/latest/api/worker_threads.html#workerresourcelimits" target="_blank">object</a> that gives info about the worker thread resource constraints <br>
          - this object can be passed as option when creating the worker
          <span class="browserSupport" title="updated : 2020-07-06">
            <span><i class="fab fa-node-js"></i> 12.16.0 / 13.2.0 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td> <strong>worker</strong>.getHeapSnapshot(<a href="https://nodejs.org/docs/latest/api/worker_threads.html#workergetheapsnapshotoptions" target="_blank">option:obj</a>) </td>
        <td>
          - returns a promise which is when resolved resolves in a readable stream containing the Worker's current V8 heap snapshot <br>
          - if the worker is not running the the promise is rejected <u>(may occur before the <mark>exit</mark> event)</u>
          <span class="browserSupport" title="updated : 2020-07-06">
            <span><i class="fab fa-node-js"></i> 13.9.0 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td> <strong>worker</strong>.<a href="https://nodejs.org/docs/latest/api/worker_threads.html#workerperformance" target="_blank">performance</a> </td>
        <td>
          - provides performance information fo the worker thread
          <span class="browserSupport" title="updated : 2025-03-23">
            <span><i class="fab fa-node-js"></i> 15.1.0 / 14.17.0 / 12.22.0 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2"> events </td>
      </tr>
      <tr>
        <td> <strong>worker.listener</strong>('online', <strong>fn</strong>) </td>
        <td>
          - emitted when the worker thread starts executing JavaScript code
        </td>
      </tr>
      <tr>
        <td> <strong>worker.listener</strong>('message', <strong>fn(msg)</strong>) </td>
        <td>
          - emitted when a message is received from this worker
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <strong>worker.listener</strong>('exit', <strong>fn(exitCode)</strong>) </td>
        <td>
          - emitted when the worker has stopped (final event emitted by the worker)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <strong>worker.listener</strong>('error', <strong>fn(err)</strong>) </td>
        <td>
          - emitted when the worker thread throws an uncaught exception
        </td>
      </tr>
      <tr>
        <td> <strong>worker.listener</strong>('messageerror', <strong>fn(err)</strong>) </td>
        <td>
          - emitted when deserializing the message is failed
          <span class="browserSupport" title="updated : 2020-07-06">
            <span><i class="fab fa-node-js"></i> 14.5.0 </span>
          </span>
        </td>
      </tr>
    </table>
    <br>
    <h2 class="headerSection"> Notes : </h2>
    <details class="example" id="notes">
      <summary> Notes :</summary>
      <!-- <p> - paragraph removes the 'empty' message from the detail TAG -->
    </details>
    <h2 class="headerSection"> Useful Links : </h2>
    <p><a href="https://nodejs.org/docs/latest/api/worker_threads.html" target="_blank">Worker Threads (nodejs.org)</a></p>
    <h2 class="headerSection"> Remember This : </h2>
    <p> - data is cloned when sending to another thread </p>
    <p> - it is possible to create thread from another thread (ex: main thread -> child thread -> grand child thread) </p>
    <h2 class="headerSection"> Description and Demonstration : </h2>
    <p> - a node.js Worker thread runs in the same process but in a separate thread (in parallel with the main thread) </p>
    <p> - threads are used for CPU intensive tasks (not for I/O operations), they are lighter than child processes </p>
    <p> - threads share the same memory space (because of the same process name space) so they communicate with the main thread through shared memory (<mark>ArrayBuffer</mark> or <mark>SharedArrayBuffer</mark>) </p>
    <p class="indent-lv1"> - a <mark>MessageChannel</mark> is automatically created between the creating thread and the created thread (main -> child usually) </p>
    <hr>
    <!----------------------------------------------------------------------------------------------------------------->
    <h3 class="header"> The <mark>isMainThread</mark> / <mark>threadid</mark> / <mark>resourceLimits</mark> / <mark>parentPort</mark> / <mark>receiveMessageOnPort()</mark> / <mark>workerData</mark> / <mark>SHARE_ENV</mark> / <mark>moveMessagePortToContext()</mark> methods and properties </h3>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
// main.mjs (file) --------------------------
    import workerThreads from 'node:worker_threads'
    
    const worker1 = new workerThreads.Worker(
      './worker_1.js',
      {
        env: workerThreads.SHARE_ENV,           // worker will have the same environment variables as the parent thread
        workerData: 'some data'
      });
    
  // isMainThread / threadId / resourceLimits ------
    workerMd.isMainThread;                                    // -> true          // this is not a worker thread 
    workerMd.threadId;                                        // -> 0 
    workerMd.resourceLimits;                                  // -> {}            // empty object because this in not a worker thread 
    
    
// ----------------------------------------
// worker1.mjs (file) -----------------------------------------
    import workerThreads from 'node:worker_threads'
    
  // isMainThread / threadId / resourceLimits -------
    workerMd.isMainThread;                                  // -> false         // this is a Worker thread 
    workerMd.threadId;                                      // -> 1
    workerMd.resourceLimits;                                // -> {maxYoungGenerationSizeMb:48, maxOldGenerationSizeMb:4096, codeRangeSizeMb:0, stackSizeMb:4}
    
  // parentPort / workerData ------------------------
    workerMd.parentPort.postMessage("some message");       // 'parentPort' is the default MessagePort to the parent thread  
    
    workerMd.workerData;                                   // -> 'some data'    // the data what was passed as 'workderData' option when this Worker thread was created    
    </pre>
      <hr>
      <h4 style="color:darkblue;"><u> Demo <mark>moveMessagePortToContext()</mark> </u></h4>
      <p> - this technology is a little bit vague, this is the closes I could make it work [TESTED: 2020-12-16] </p>
      <pre>
    var workerMd = require('worker_threads');
    var vm = require('vm');
    
    var ctx_1 = {x:21};
    vm.createContext(ctx_1);                                                           // V8 Virtual Machine context   
    
    var msgChannel = new workerMd.MessageChannel();
    var ctxPort = workerMd.moveMessagePortToContext(msgChannel.port2, ctx_1);          // moves 'port2' of 'msgChannel' in 'ctx_1' context (the returned 'ctxPort' is an object (port2) in 'ctx_1' VM context)    
    
// post / receive message on this 'global' context ------------------------------------
    msgChannel.port1.postMessage('message from global context');
    
    msgChannel.port1.on('message', function(msg){
        msg;                                                                           // -> 'message from "ctx_1" vm context   
    });
    
// post / receive message on 'ctx_1' VM context ---------------------------------------
    ctxPort.postMessage('message from "ctx_1" vm context');    
    
    // ctxPort.on('message', function(msg){ console.log(msg) });                       // -! would throw a TypeError because there's no EventTarget API in 'ctx_1' VM context 
    workerMd.receiveMessageOnPort(ctxPort);                                            // -> {message:'message from global context'}   // received message on 'port2' which is in 'ctx_1' VM context    
    </pre>
      <hr>
      <h4 style="color:darkblue;"><u> Demo <mark>receiveMessageOnPort()</mark> </u></h4>
      <pre>
    var workerMd = require('worker_threads');
    
    var channel = new workerMd.MessageChannel();                                       // creating a message channel 
    
    channel.port1.postMessage('first message');                                        // sending serveral messages on port1
    channel.port1.postMessage('second message');
    channel.port1.postMessage('third message');
    
    workerMd.receiveMessageOnPort(channel.port2);                                      // -> {messsge:'first message'}         // returns the first message piece only 
    workerMd.receiveMessageOnPort(channel.port2);                                      // -> {messsge:'second message'}        // and so on...
    workerMd.receiveMessageOnPort(channel.port2);                                      // -> {messsge:'third message'}
    workerMd.receiveMessageOnPort(channel.port2);                                      // -> undefined                         // no message piece left in the message channel    
    
    channel.port2.on('message', (msg)=>{ msg });                                       // -! the 'message' event is not emmitted in this case 
    </pre>
    </details>
    <hr>
    <!----------------------------------------------------------------------------------------------------------------->
    <h3 class="header"> The <mark>markAsUntransferable()</mark> / <mark>isMarkedUntransferable()</mark> / <mark>markAsUnclonable()</mark> methods </h3>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
    import worker_thread from 'worker_threads';
    
    const woker1 = new worker_thread.Worker('./worker1.mjs')
    
    const myObj = { p1: 'Hello' };
    
    
// normal data sending -------------------------------------
    woker1.postMessage(myObj1);             // normal message sending (object is cloned, so the worker1 thread has its own copy of it)
    
    
// markAsUntransferable() / isMarkedAsUntransferable() ---------
    worker_thread.isMarkedAsUntransferable(myObj2);                // -> false
    worker_thread.markAsUntransferable(myObj2);                   // -> marking the object untransferable
    worker_thread.isMarkedAsUntransferable(myObj2);               // -> true
    
    woker1.postMessage(myObj2);                                   // still can be sent because the current thread still has this object
    woker1.postMessage(null, [myObj2]);                           // this fails because this approach tries to remove myObj2 from this thread
    
    
// markAsUnclonable() ------------------------------------
    worker_thread.markAsUncloneable(myObj3);                   // -> marking the object unclonable
    woker1.postMessage(myObj3);                               // fails because sending data to a worker thread basically tries to create a clone
      </pre>
      </pre>
    </details>
    <hr>
    <!----------------------------------------------------------------------------------------------------------------->
    <h3 class="header"> The <mark>setEnvironmentData()</mark> / <mark>getEnvironmentData()</mark> methods </h3>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
// -------------------------------------------------
// main.mjs (file) ---------------------------------
    import worker_thread from 'worker_threads';
    
    worker_thread.setEnvironmentData('key1', 'Hello Workers!');     // broadcasts the data <mark>'Hello Workers'</mark> to all threads
    
    new worker_thread.Worker('./worker1.mjs');
    new worker_thread.Worker('./worker2.mjs');
    
    
// -------------------------------------------------
// worker1.mjs (file) ------------------------------
    import worker_threads from 'node:worker_threads';
    
    worker_threads.getEnvironmentData('key1');      // -> 'Hello Workers!'
    
    
// -------------------------------------------------
// worker2.mjs (file) ------------------------------
    import worker_threads from 'node:worker_threads';
    
    worker_threads.getEnvironmentData('key1');      // -> 'Hello Workers!'
    </pre>
      <hr>
      <h4 style="color:darkblue;"><u> Demo <mark>moveMessagePortToContext()</mark> </u></h4>
      <p> - this technology is a little bit vague, this is the closes I could make it work [TESTED: 2020-12-16] </p>
      <pre>
    var workerMd = require('worker_threads');
    var vm = require('vm');
    
    var ctx_1 = {x:21};
    vm.createContext(ctx_1);                                                           // V8 Virtual Machine context   
    
    var msgChannel = new workerMd.MessageChannel();
    var ctxPort = workerMd.moveMessagePortToContext(msgChannel.port2, ctx_1);          // moves 'port2' of 'msgChannel' in 'ctx_1' context (the returned 'ctxPort' is an object (port2) in 'ctx_1' VM context)    
    
// post / receive message on this 'global' context ------------------------------------
    msgChannel.port1.postMessage('message from global context');
    
    msgChannel.port1.on('message', function(msg){
        msg;                                                                           // -> 'message from "ctx_1" vm context   
    });
    
// post / receive message on 'ctx_1' VM context ---------------------------------------
    ctxPort.postMessage('message from "ctx_1" vm context');    
    
    // ctxPort.on('message', function(msg){ console.log(msg) });                       // -! would throw a TypeError because there's no EventTarget API in 'ctx_1' VM context 
    workerMd.receiveMessageOnPort(ctxPort);                                            // -> {message:'message from global context'}   // received message on 'port2' which is in 'ctx_1' VM context    
    </pre>
      <hr>
      <h4 style="color:darkblue;"><u> Demo <mark>receiveMessageOnPort()</mark> </u></h4>
      <pre>
    var workerMd = require('worker_threads');
    
    var channel = new workerMd.MessageChannel();                                       // creating a message channel 
    
    channel.port1.postMessage('first message');                                        // sending serveral messages on port1
    channel.port1.postMessage('second message');
    channel.port1.postMessage('third message');
    
    workerMd.receiveMessageOnPort(channel.port2);                                      // -> {messsge:'first message'}         // returns the first message piece only 
    workerMd.receiveMessageOnPort(channel.port2);                                      // -> {messsge:'second message'}        // and so on...
    workerMd.receiveMessageOnPort(channel.port2);                                      // -> {messsge:'third message'}
    workerMd.receiveMessageOnPort(channel.port2);                                      // -> undefined                         // no message piece left in the message channel    
    
    channel.port2.on('message', (msg)=>{ msg });                                       // -! the 'message' event is not emmitted in this case 
    </pre>
    </details>
    <hr>
    <!----------------------------------------------------------------------------------------------------------------->
    <h3 class="header"> The <mark>Worker()</mark> / <mark>postMessage()</mark> / <mark>terminate()</mark> / <mark>stdin</mark> / <mark>stdout</mark> / <mark>stdout</mark> / <mark>unref()</mark> / <mark>ref()</mark> / <mark>threadId</mark> / <mark>resourceLimits</mark> / <mark>getHeapSnapshot()</mark> methods and properties <h3 class="header">
    <h3 style="color:darkblue;"><u> Events: <mark>online</mark> / <mark>message</mark> / <mark>exit</mark> / <mark>error</mark> / <mark>messageerror</mark> </u></h3>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
    var workerMd = require('worker_threads');
    
    var worker_1 = new workerMd.Worker('./worker_1.js');  
    
// postMessage() ----------------------------------------------------------------------
    worker_1.postMessage('some message');                                              // the worker receives a clone of the string 
    worker_1.postMessage(someArrayBuffer);                                             // the worker receives a clone of the ArrayBuffer
    worker_1.postMessage(someSharedArrayBuffer);                                       // the SharedArrayBuffer is shared between the main and the worker threads (both see the same underlying memory)    
    
    worker_1.postMessage(someArrayBuffer, [someArrayBuffer]);                          // the ArrayBuffer is moved to the Worker (not available in this thread anymore)   
    worker_1.postMessage(null, [someArrayBuffer]);                                     // this simply removes the ArrayBuffer   
    worker_1.postMessage(someSharedArrayBuffer, [someSharedArrayBuffer]);              // -! this throws an error because the SharedArrayBuffer cannot be removed from the current thread    
    
// terminate() ------------------------------------------------------------------------
    var terminate = worker_1.terminate()                                               // terminates the worker and returns a promise 
    
    terminate                                                                          // promise is fulfilled when the 'exit' event is emitted   
        .then((res)=>{ console.log(res)})                                              // -> 1         // exit code 
        .catch((rej)=>{ console.log(rej)});
    
// threadId / resourceLimits / getHeapSnapshot() --------------------------------------
    worker_1.threadId;                                                                 // -> 1          // unique Identifier of this worker 
    
    worker_1.resourceLimits;                                                           // -> {maxYoungGenerationSizeMb:48, maxOldGenerationSizeMb:4096, codeRangeSizeMb:0, stackSizeMb:4}   // resource limits if this worker 
    
    var heapSnap = worker_1.getHeapSnapshot();                                         // returns a promise 
    heapSnap
        .then((res)=>{ res })                                                          // resolved promise resolves into a ReadablStream which is when read contains the v8 heap snapshot of the Worker   
        .catch((rej)=>{ rej })                                                         // promise is rejected when the Worker is not running   
    
// unref()  / ref() -------------------------------------------------------------------
    worker_1.unref();                                                                  // this Worker won't prevent the process from closing (removed from the event loop)
    worker_1.ref();                                                                    // this Worker will prevent the process from closing (reattached to the event loop)   
    
// online / message (events) ----------------------------------------------------------
    worker_1.on('online', ()=>{});                                                     // emitted when the Worker starts executing JavaScript code 
    worker_1.on('message', function(msg){                                              // emitted when this (parent) thread receives some data from the Worker thread    
        msg;
    });
    
// exit (event) -----------------------------------------------------------------------
    worker_1.on('exit', function(exitCode){                                            // emitted when the worker exits 
        exitCode;                                                                      // -> 0  
    });
    
// error / messageerror (events) ------------------------------------------------------
    worker_1.on('error', function(err){                                                // emitted when the worker thread throws an error 
        err;                                                                           // -> error thrown  
    });
    worker_1.on('messageerror', function(err){                                         // emitted when deserializing the received message fails  
        err;                                                                           // -> error thrown  
    });
    </pre>
      <!-------------------------------------------------------------->
      <hr>
      <h4 class="header"> The <mark>stdin</mark> / <mark>stdout</mark> / <mark>stderr</mark> properties </h4>
      <pre>
// main.js (file) ---------------------------------------------------------------------
// ------------------------------------------------------------------------------------
    import workerMd from 'worker_threads';
    
    const worker1 = new workerMd.Worker('./worker1.mjs', {
      stdin: true,                                          // enable stream communicaiton between the main and worker thread
      stdout: true,
      stderr: true,
    });
    
    worker1.stdin.write('in data');
    
    worker1.stdout.on('data', (chunk) => chunk.toString());       // -> 'out data'
    worker1.stderr.on('data', (chunk) => chunk.toString());       // -> 'err data'
    
    
// worker_1.js (file) -----------------------------------------------------------------
// ------------------------------------------------------------------------------------
    process.stdin.on('data', (chunk) => chunk.toString());        // -> 'in data'
    
    process.stdout.write('out data');
    process.stderr.write('err data');
      </pre>
    </details>

    <br><br>
  </body>
</html>