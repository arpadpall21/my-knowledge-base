<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title> Crypto </title>
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <link rel="stylesheet" href="../../Assets/stylesPages.css">
  <script src="../../Assets/scriptPages.js"></script>
</head>

<body>
  <h1> Crypto </h1>
  <p> Updated ( 2021-03-03 )</p>
  <nav class="sitenav"> <a href="../../index.html">MySite > </a>
    <a href="../index.html">Node.js > </a> Crypto
  </nav>
  <table class="table">
    <tr>
      <th style="width:30%;"> Method / Property </th>
      <th> Description </th>
    </tr>
    <tr>
      <td>
        constants
      </td>
      <td>
        - returns an object with the <mark>crypto</mark> module's constants
        <span class="browserSupport" title="updated : 2021-03-10">
          <span><i class="fab fa-node-js"></i> 6.3.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        getCiphers()
      </td>
      <td>
        - returns an Array with the supported cipher algorithms
        <span class="browserSupport">
          <span><i class="fab fa-node-js"></i> 0.9.3 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        getCurves()
      </td>
      <td>
        - returns an Array with the supported elliptic curvers (for ECDH key exchange protocol)
        <span class="browserSupport">
          <span><i class="fab fa-node-js"></i> 2.3.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        getHashes()
      </td>
      <td>
        - returns an Array with the supported hash algorithms (digest algorithms)
        <span class="browserSupport">
          <span><i class="fab fa-node-js"></i> 0.9.3 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        getFips()
      </td>
      <td>
        - returns <mark>1</mark> if <strong class="openable">FIPS<div>
            <p> - FIPS (Federal Information Processing Standard) </p>
            <p> - it's a US government security standard for cryptographyc modules (security standard for Federal Systems) </p>
          </div></strong> compliant crypto provider is currently in use <mark>0</mark> otherwise
        <span class="browserSupport">
          <span><i class="fab fa-node-js"></i> 10.0.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        setFips(<strong>bol</strong>)
      </td>
      <td>
        - enables the <strong class="openable">FIPS<div>
            <p> - FIPS (Federal Information Processing Standard) </p>
            <p> - it's a US government security standard for cryptographyc modules (security standard for Federal Systems) </p>
          </div></strong> compliant crypto provider in a FIPS-enabled Node.js build <br>
        - throws an error if FIPS mode is not available
        <span class="browserSupport" title="updated : 2021-03-10">
          <span><i class="fab fa-node-js"></i> 10.0.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        randomBytes(<strong>length:nr</strong>, <i>fn(err, buf)</i>)
      </td>
      <td>
        - generates cryptographycally strong pseudo-random data of the specified <strong>length</strong> (the generated result is returned in a <strong>buf</strong> (Buffer)) <br>
        - no callback provided = synchronously operation | callback provided = asynchronous operation
        <span class="browserSupport">
          <span><i class="fab fa-node-js"></i> 0.5.8 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        randomFill(<strong class="openable">buf<div>
            <p> <strong>ArrayBuffer|TypedArray|DataView</strong>
          </div></strong>, <i class="openable">offset:nr, size:nr<div>
            <p> <i>offset</i> - index where to start writing the passed buffer (Default: <mark>0</mark>) </p>
            <p> <i>size</i> - how many bytes to write after the offset (Default: <mark>buffer.length - offset</mark>) <u>must not be larger than <mark>2**3-1</mark></u></p>
          </div></i>, <strong>fn(err, buf)</strong>)
      </td>
      <td>
        - asynchronously writes the passed <strong>buf</strong> (Buffer) with cryptographycally strong pseudo-random data
        <span class="browserSupport" title="updated : 2021-03-10">
          <span><i class="fab fa-node-js"></i> 7.10.0 / 6.13.0 </span>
          <span class="openable"> more... <div>
              <p> 9.0.0 - <strong>TypedArray</strong> and <strong>DataView</strong> support </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        randomFillSync(<strong class="openable">buf<div>
            <p> <strong>ArrayBuffer|TypedArray|DataView</strong>
          </div></strong>, <i class="openable">offset:nr, size:nr<div>
            <p> <i>offset</i> - index where to start writing the passed buffer (Default: <mark>0</mark>) </p>
            <p> <i>size</i> - how many bytes to write after the offset (Default: <mark>buffer.length - offset</mark>) <u>must not be larger than <mark>2**3-1</mark></u></p>
          </div></i>)
      </td>
      <td>
        - synchronously writes the passed <strong>buf</strong> (Buffer) with cryptographycally strong pseudo-random data and returns it
        <span class="browserSupport" title="updated : 2021-03-10">
          <span><i class="fab fa-node-js"></i> 7.10.0 / 6.13.0 </span>
          <span class="openable"> more... <div>
              <p> 9.0.0 - <strong>TypedArray</strong> and <strong>DataView</strong> support </p>
            </div></span>
        </span>
        <span class="browserSupport" title="updated : 2021-03-10">
          <span><i class="fab fa-node-js"></i> </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        randomInt(<i class="openable">min(inc):nr<div>
            <p> Default: <mark>0</mark> </p>
          </div></i>, <strong>max(exc):nr</strong>, <i>fn(err, n)</i>)
      </td>
      <td>
        - generates a random integer between the specified range (avoids <span class="openable">modulo bias<div>
            <p> - no modulo bias means equal chance to get any number in the range </p>
          </div></span>) <br>
        - no callback provided = synchronous operation | callback provided = asynchronous operation
        <span class="browserSupport" title="updated : 2021-03-10">
          <span><i class="fab fa-node-js"></i> 14.10.0 / 12.19.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        randomUUID(<strong class="openable">option:obj<div>
            <p> disableEntrophyCache: <strong>bol</strong> -
          </div></strong>)
      </td>
      <td>
        - generates and returns a <b>U</b>niversally <b>U</b>nique <b>ID</b>entifier (128 bits random data for unique identification) <br>
        - the returned data is 'hex' (hexadecimal) encoded (2 hex values desribe one byte)
        <span class="browserSupport" title="updated : 2021-03-10">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        secureHeapUsed()
      </td>
      <td>
        - returns an object which contains the underlying <span class="openable">OpenSSL secure heap<div>
            <p> - the OpenSSL's secure heap prevents sensitive data from leaking due to pointer overruns or underruns </p>
            <p> - this feature is NOT enabled by default (use the <mark>--secure-heap</mark> and <mark>--secure-heap-min</mark> flags to enable) </p>
          </div></span> details
        <span class="browserSupport" title="updated : 2021-03-10">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        setEngine(<strong class="openable">engine:str<div>
            <p> - id or a path to the engine's shared library </p>
          </div></strong>, <i class="openable">flags:nr<div>
            <p> - Default: <mark>crypto.constants.ENGINE_METHOD_ALL</mark> </p>
          </div></i>)
      </td>
      <td>
        - loads and set the engine for some or all OpenSSL functions
        <span class="browserSupport" title="updated : 2021-03-10">
          <span><i class="fab fa-node-js"></i> 0.11.11 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        webcrypto
      </td>
      <td>
        - returns a <strong>webCrypto</strong> object which is an implementation of the Web Crypto API standard <u>[Experimental: 2021-03-11]</u>
        <span class="browserSupport" title="updated : 2021-03-10">
          <span><i class="fab fa-node-js"></i> 15.0.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        timingSafeEqual(<strong class="openable">a:buf<div>
            <p> <strong>ArrayBuffer|TypedArray|DataView</strong> </p>
          </div></strong>, <strong class="openable">b:buf<div>
            <p> <strong>ArrayBuffer|TypedArray|DataView</strong> </p>
          </div></strong>)
      </td>
      <td>
        - compares 2 values and returns a boolean according to the match <br>
        - always makes the same time to compare the 2 values = prevents <span class="openable">timing attacks<div>
            <p> - attacker measures the timing differences the server makes to calculate the return response </p>
            <p> - from these timing differences the attacker can figure out the encrypted data </p>
            <p> - this function makes always the same time to compare 2 values so the attacker will have always the same return time making the server immune to timing attacks </p>
          </div></span>
        <span class="browserSupport" title="updated : 2021-03-10">
          <span><i class="fab fa-node-js"></i> 6.6.0 </span>
          <span class="openable"> more... <div>
              <p> v15.0.0 - <strong>ArrayBuffer</strong> supported </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td colspan="2"> Derivation Functions (deriving key|hash) </td>
    </tr>
    <tr>
      <td>
        hkdf(<strong>hashAlgorithm:str</strong>, <strong class="openable">key:str|...<div>
            <p> - the secret key (synchronous key) </p>
            <p> <strong>str|buf|keyObj|ArrayBuffer|TypedArray|DataView</strong> </p>
          </div></strong>, <strong class="openable">salt:str|...<div>
            <p> - salt value </p>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView</strong> </p>
          </div></strong>, <strong class="openable">info:str|...<div>
            <p> - additional info value, its length can be from <mark>0</mark> to <mark>1024</mark> bytes </p>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView</strong> </p>
          </div></strong>, <strong class="openable">keyLength:nr<div>
            <p> - key length (min 1 ) (max 255 times the selected digest algorith (ex: <mark>sha512</mark> generates a 64 byte hash so the maximum keylengt can be <mark>16320</mark> bytes) </p>
          </div></strong>, <strong>fn(err, key:ArrayBuffer)</strong>)
      </td>
      <td>
        - asynchronous simple key derivation function, generates a secret key of the specified length<br>
        - RFC 5869 specification (HKDF = key-Hashed Key Derivation Function)
        <span class="browserSupport" title="updated : 2021-03-14">
          <span><i class="fab fa-node-js"></i> 15.0.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        hkdfSync(<strong>hashAlgorithm:str</strong>, <strong class="openable">key:str|...<div>
            <p> - the secret key (synchronous key) </p>
            <p> <strong>str|buf|keyObj|ArrayBuffer|TypedArray|DataView</strong> </p>
          </div></strong>, <strong class="openable">salt:str|...<div>
            <p> - salt value </p>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView</strong> </p>
          </div></strong>, <strong class="openable">info:str|...<div>
            <p> - additional info value, its length can be from <mark>0</mark> to <mark>1024</mark> bytes </p>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView</strong> </p>
          </div></strong>, <strong class="openable">keyLength:nr<div>
            <p> - key length (min 1 ) (max 255 times the selected digest algorith (ex: <mark>sha512</mark> generates a 64 byte hash so the maximum keylengt can be <mark>16320</mark> bytes) </p>
          </div></strong>)
      </td>
      <td>
        - synchronous simple key derivation function, generates a secret key of the specified length (returns <strong>ArrayBuffer</strong>)<br>
        - RFC 5869 specification (HKDF = key-Hashed Key Derivation Function)
        <span class="browserSupport" title="updated : 2021-03-13">
          <span><i class="fab fa-node-js"></i> 15.0.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>

    <tr>
      <td>
        scrypt(<strong class="openable">passWord:str|...<div>
            <p> - password </p>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView</strong> </p>
          </div></strong>, <strong class="openable">salt:str|...<div>
            <p> - salt value (recommended to be at least 16 bytes long) </p>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView</strong> </p>
          </div></strong>, <strong>keyLength:nr</strong>, <strong class="openable">option:obj<div>
            <p> cost|N: <strong>nr</strong> - CPU/memory cost parameter, must be a power of 2 (Default: <mark>16384</mark>) </p>
            <p> blockSize|r: <strong>nr</strong> - block size (Default: <mark>8</mark>) </p>
            <p> paralleliztion|p: <strong>nr</strong> - parallelization parameter (Default: <mark>1</mark>) </p>
            <p> maxmem: <strong>nr</strong> - memory upper bound (Default: <mark>32 * 1024 * 1024</mark>) </p>
          </div></strong>, <strong>fn(err, buf)</strong>)
      </td>
      <td>
        - asynchronous password-based key derivation function, to generate a secret key|hashed password of the specified length (returns <reqval>buf</reqval>) <br>
        - RCF 7914 sepcification (designed to be computationally and memory-wise expensive in order to be resistent to brute-force attacks)
        <span class="browserSupport" title="updated : 2021-03-13">
          <span><i class="fab fa-node-js"></i> 10.5.0 </span>
          <span class="openable"> more... <div>
              <p> 12.8.0 / 10.17.0 </p>
              <p> - <mark>maxmem</mark> option can be a safe integer </p>
              <hr>
              <p> 15.0.0 </p>
              <p> - <strong>ArrayBuffer</strong> support </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        scryptSync(<strong class="openable">passWord:str|...<div>
            <p> - password </p>
            <p> <strong>str|buf|TypedArray|DataView</strong> </p>
          </div></strong>, <strong class="openable">salt:str|...<div>
            <p> - salt value (recommended to be at least 16 bytes long) </p>
            <p> <strong>str|buf|TypedArray|DataView</strong> </p>
          </div></strong>, <strong>keyLength:nr</strong>, <strong class="openable">option:obj<div>
            <p> cost|N: <strong>nr</strong> - CPU/memory cost parameter, must be a power of 2 (Default: <mark>16384</mark>) </p>
            <p> blockSize|r: <strong>nr</strong> - block size (Default: <mark>8</mark>) </p>
            <p> paralleliztion|p: <strong>nr</strong> - parallelization parameter (Default: <mark>1</mark>) </p>
            <p> maxmem: <strong>nr</strong> - memory upper bound (Default: <mark>32 * 1024 * 1024</mark>) </p>
          </div></strong>)
      </td>
      <td>
        - synchronous password-based key derivation function, to generate a secret key|hashed password of the specified length <br>
        - RCF 7914 sepcification (designed to be computationally and memory-wise expensive in order to be resistent to brute-force attacks)
        <span class="browserSupport" title="updated : 2021-03-13">
          <span><i class="fab fa-node-js"></i> 10.5.0 </span>
          <span class="openable"> more... <div>
              <p> 12.8.0 / 10.17.0 </p>
              <p> - <mark>maxmem</mark> option can be a safe integer </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        pbkdf2(<strong class="openable">passWord:str|...<div>
            <p> - password </p>
            <p> <strong>str|buf|TypedArray|DataView|ArrayBuffer</strong> </p>
          </div></strong>, <strong class="openable">salt:str|...<div>
            <p> - salt value (recommended to be at least 16 bytes long) </p>
            <p> <strong>str|buf|TypedArray|DataView|ArrayBuffer</strong> </p>
          </div></strong>, <strong>iteration:nr</strong>, <strong>keyLength:nr</strong>, <strong>hashAlgorithm:str</strong>, <strong>fn(err, key:buf)</strong>)
      </td>
      <td>
        - asynchronous password-based key derivation function, to generate a secret key|hashed password of the specified length <br>
        - RCF 2898 specification (Password Based Key Derivation Function 2)
        <span class="browserSupport" title="updated : 2021-03-16">
          <span><i class="fab fa-node-js"></i> 0.0.5 </span>
          <span class="openable"></i> more... <div>
              <p> 6.0.0 </p>
              <p> - <strong>password</strong> default encoding changed from binary to utf-8 </p>
              <hr>
              <p> 14.0.0 </p>
              <p> - <strong>iteration</strong> must be a positive integer </p>
              <hr>
              <p> 15.0.0 </p>
              <p> - <strong>ArrayBuffer</strong> support </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        pbkdf2Sync(<strong class="openable">passWord:str|...<div>
            <p> - password </p>
            <p> <strong>str|buf|TypedArray|DataView</strong> </p>
          </div></strong>, <strong class="openable">salt:str|...<div>
            <p> - salt value (recommended to be at least 16 bytes long) </p>
            <p> <strong>str|buf|TypedArray|DataView</strong> </p>
          </div></strong>, <strong>iteration:nr</strong>, <strong>keyLength:nr</strong>, <strong>hashAlgorithm:str</strong>)
      </td>
      <td>
        - synchronous password-based key derivation function, to generate a secret key|hashed password of the specified length (returns <reqval>buf</reqval>) <br>
        - RCF 2898 specification (Password Based Key Derivation Function 2)
        <span class="browserSupport" title="updated : 2021-03-16">
          <span><i class="fab fa-node-js"></i> 0.0.5 </span>
          <span class="openable"></i> more... <div>
              <p> 6.0.0 </p>
              <p> - <strong>password</strong> default encoding changed from binary to utf-8 </p>
              <hr>
              <p> 14.0.0 </p>
              <p> - <strong>iteration</strong> must be a positive integer </p>
            </div></span>
        </span>
      </td>
    </tr>
  </table>
  <br>
  <table class="table">
    <caption>
      Keys
    </caption>
    <tr>
      <th style="width:30%;"> Method / Property </th>
      <th> Description </th>
    </tr>
    <tr>
      <td>
        createSecretKey(<strong class="openable">key:str|...<div>
            <p> <strong>buf|ArrayBuffer|TypedArray|DataView</strong></p>
          </div></strong>, <i class="openable">encode:str<div>
            <p> Default: <mark>utf-8</mark> </p>
          </div></i>)
      </td>
      <td>
        - creates and returns a secret key <strong>keyObj</strong> (used for symmetric encryptions) from the passed data (<strong>key</strong>) <br>
        - basically wraps the passed data into a secret key
        <span class="browserSupport" title="updated : 2021-03-13">
          <span><i class="fab fa-node-js"></i> 11.6.0 </span>
          <span class="openable"> more... <div>
              <p> 15.0.0 </p>
              <p> - <strong>str</strong> and <strong>ArrayBuffer</strong> support </p>
              <p> - <i>encode</i> argument added </p>
              <p> - the key cannot be longer than <mark>2**32 -1</mark> </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        generateKey(<strong class="openable">type:str<div>
            <p> 'aes' or 'hmac' </p>
          </div></strong>, <strong class="openable">option:obj<div>
            <p> length: <strong>nr</strong> - the bit length of the generated key (for <mark>aes</mark> key must be <mark>128</mark>, <mark>192</mark> or <mark>256</mark>) (for <mark>hmac</mark> key must be between <mark>1</mark> to <mark>2**31 -1</mark>) </p>
          </div></strong>, <strong>fn(err, key)</strong>)
      </td>
      <td>
        - asynchronously generates a random secret key <strong>keyObj</strong> (used for symmetric encryptions)
        <span class="browserSupport" title="updated : 2021-03-13">
          <span><i class="fab fa-node-js"></i> </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        generateKeySync(<strong class="openable">type:str<div>
            <p> 'aes' or 'hmac' </p>
          </div></strong>, <strong class="openable">option:obj<div>
            <p> length: <strong>nr</strong> - the bit length of the generated key (for <mark>aes</mark> key must be <mark>128</mark>, <mark>192</mark> or <mark>256</mark>) (for <mark>hmac</mark> key must be between <mark>1</mark> to <mark>2**31 -1</mark>) </p>
          </div></strong>)
      </td>
      <td>
        - synchronously generates and returns a random secret key <strong>keyObj</strong> (used for symmetric encryptions)
        <span class="browserSupport" title="updated : 2021-03-13">
          <span><i class="fab fa-node-js"></i> </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        generateKeyPair(<strong class="openable">type:str<div>
            <p> <mark>rsa</mark>, <mark>dsa</mark>, <mark>ec</mark>, <mark>ed25519</mark>, <mark>ed448</mark>, <mark>x25519</mark>, <mark>x448</mark>, or <mark>dh</mark> </p>
          </div></strong>, <strong class="openable">option:obj<div>
            <p> modulusLength: <strong>nr</strong> - key size in bits (for <mark>RSA</mark> and <mark>DSA</mark>) </p>
            <p> publicExponent: <strong>nr</strong> - public exponent (for <mark>RSA</mark>) (Default: <mark>0x10001</mark>) </p>
            <p> divisorLength: <strong>nr</strong> - size <mark>q</mark> in bits (for <mark>DSA</mark>) </p>
            <p> namedCurve: <strong>str</strong> - curve name (for <mark>EC</mark>) </p>
            <p> prime: <strong>buf</strong> - the prime parameter (for <mark>DH</mark>) </p>
            <p> primeLength: <strong>nr</strong> - the prime length in bits (for <mark>DH</mark>) </p>
            <p> generator: <strong>nr</strong> - custom generator (for <mark>DH</mark>) (Default: <mark>2</mark>) </p>
            <p> groupName: <strong>str</strong> - Diffie-Hellman group name (for <mark>DH</mark>) </p>
            <p> publicKeyEncoding: <strong>obj</strong> - defines who to export the public key <u>(if nothing specified exported as <strong>keyObj</strong>)</u> </p>
            <p> privateKeyEncoding: <strong>obj</strong> - defines who to export the private key <u>(if nothing specified exported as <strong>keyObj</strong>)</u> </p>
            <hr>
            <hr>
            <p><u> <mark>publicKeyEncoding</mark> object properties </u></p>
            <p> type: 'pkcs1|spki' ('pkcs1' RSA only) </p>
            <p> format: 'pem|der|jwk' (jwk = JSON Web Key) </p>
            <hr>
            <p><u> <mark>privateKeyEncoding</mark> object properties </u></p>
            <p> type: 'pkcs1|pkcs8|sec1' ('pkcs1' RSA only) ('sec1' EC only) </p>
            <p> format: 'pem|der|jwk' (jwk = JSON Web Key) </p>
            <p> cipher: <strong>str</strong> - if specified the cipher to use to encrypt the private key (requires the <mark>passprase</mark> option too) (uses PKCS#5 v2.0 password based encryption) </p>
            <p> passprase: <strong>str|buf</strong> - encryption passprase when the <mark>cipher</mark> option is used </p>
          </div></strong>, <strong>fn(err, pubKey, privKey)</strong>)
      </td>
      <td>
        - asynchronously generates a new asymmetric key pair (private/public key pair)
        <span class="browserSupport" title="updated : 2021-03-13">
          <span><i class="fab fa-node-js"></i> 10.12.0 </span>
          <span class="openable"> more... <div>
              <p> 12.0.0</p>
              <p> - can generate <mark>Ed25519</mark> and <mark>Ed448</mark> key pairs </p>
              <p> - can generate <mark>X25519</mark> and <mark>X448</mark> key pairs </p>
              <hr>
              <p> 13.9.0 / 12.17.0</p>
              <p> - Diffie-Hellman support </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        generateKeyPairSync(<strong class="openable">type:str<div>
            <p> <mark>rsa</mark>, <mark>dsa</mark>, <mark>ec</mark>, <mark>ed25519</mark>, <mark>ed448</mark>, <mark>x25519</mark>, <mark>x448</mark>, or <mark>dh</mark> </p>
          </div></strong>, <strong class="openable">option:obj<div>
            <p> modulusLength: <strong>nr</strong> - key size in bits (for <mark>RSA</mark> and <mark>DSA</mark>) </p>
            <p> publicExponent: <strong>nr</strong> - public exponent (for <mark>RSA</mark>) (Default: <mark>0x10001</mark>) </p>
            <p> divisorLength: <strong>nr</strong> - size <mark>q</mark> in bits (for <mark>DSA</mark>) </p>
            <p> namedCurve: <strong>str</strong> - curve name (for <mark>EC</mark>) </p>
            <p> prime: <strong>buf</strong> - the prime parameter (for <mark>DH</mark>) </p>
            <p> primeLength: <strong>nr</strong> - the prime length in bits (for <mark>DH</mark>) </p>
            <p> generator: <strong>nr</strong> - custom generator (for <mark>DH</mark>) (Default: <mark>2</mark>) </p>
            <p> groupName: <strong>str</strong> - Diffie-Hellman group name (for <mark>DH</mark>) </p>
            <p> publicKeyEncoding: <strong>obj</strong> - defines who to export the public key <u>(if nothing specified exported as <strong>keyObj</strong>)</u> </p>
            <p> privateKeyEncoding: <strong>obj</strong> - defines who to export the private key <u>(if nothing specified exported as <strong>keyObj</strong>)</u> </p>
            <hr>
            <hr>
            <p><u> <mark>publicKeyEncoding</mark> object properties </u></p>
            <p> type: 'pkcs1|spki' ('pkcs1' RSA only) </p>
            <p> format: 'pem|der|jwk' (jwk = JSON Web Key) </p>
            <hr>
            <p><u> <mark>privateKeyEncoding</mark> object properties </u></p>
            <p> type: 'pkcs1|pkcs8|sec1' ('pkcs1' RSA only) ('sec1' EC only) </p>
            <p> format: 'pem|der|jwk' (jwk = JSON Web Key) </p>
            <p> cipher: <strong>str</strong> - if specified the cipher to use to encrypt the private key (requires the <mark>passprase</mark> option too) (uses PKCS#5 v2.0 password based encryption) </p>
            <p> passprase: <strong>str|buf</strong> - encryption passprase when the <mark>cipher</mark> option is used </p>
          </div></strong>)
      </td>
      <td>
        - synchronously generates a new asymmetric key pair (private/public key pair) and returns them in an object
        <span class="browserSupport" title="updated : 2021-03-13">
          <span><i class="fab fa-node-js"></i> 10.12.0 </span>
          <span class="openable"> more... <div>
              <p> 12.0.0</p>
              <p> - can generate <mark>Ed25519</mark> and <mark>Ed448</mark> key pairs </p>
              <p> - can generate <mark>X25519</mark> and <mark>X448</mark> key pairs </p>
              <hr>
              <p> 13.9.0 / 12.17.0</p>
              <p> - Diffie-Hellman support </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        createPrivateKey(<strong class="openable">key:obj|str|...<div>
            <p> - the passed key material must be a valid key in PEM or DER format </p>
            <hr>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView</strong> </p>
            <hr>
            <p> <strong>obj</strong> </p>
            <p> key: <strong>str|buf|ArrayBuffer|TypedArray|DataView</strong> - the key material in PEM of DER format </p>
            <p> format: 'pem|der' (Default: <mark>pem</mark>) </p>
            <p> type: <strong>str</strong> - can be <mark>pkcs1</mark>, <mark>pkcs8</mark> or <mark>sec1</mark> (for DER format only) </p>
            <p> passprase: <strong>str|buf</strong> - must be specified if the private key is encrypted </p>
            <p> encoding: <strong>str</strong> - encoding if the passed key is a string </p>
          </div></strong>)
      </td>
      <td>
        - creates a private key from the passed <u>valid private key material</u> (does not generate a new key) <br>
        - this is a wrapper method, it wraps a valid private key and returns it as a <strong>keyObj</strong> object
        <span class="browserSupport" title="updated : 2021-03-13">
          <span><i class="fab fa-node-js"></i> </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        createPublicKey(<strong class="openable">key:obj|str|...<div>
            <p> - the passed key material must be a valid key in PEM or DER format </p>
            <p> - X.509 certificate can be passed as well if the passed format is in PEM </p>
            <hr>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView</strong> </p>
            <hr>
            <p> <strong>obj</strong> </p>
            <p> key: <strong>str|buf|ArrayBuffer|TypedArray|DataView</strong> - the key material in PEM of DER format </p>
            <p> format: 'pem|der' (Default: <mark>pem</mark>) </p>
            <p> type: <strong>str</strong> - can be <mark>pkcs1</mark> or <mark>spki</mark> (for DER format only) </p>
            <p> encoding: <strong>str</strong> - encoding if the passed key is a string </p>
          </div></strong>)
      </td>
      <td>
        - creates a public key from the passed <u>valid public key material</u> (does not generate a new key) <br>
        - this is a wrapper method, it wraps a valid public key and returns it as a <strong>keyObj</strong> object
        <span class="browserSupport" title="updated : 2021-03-13">
          <span><i class="fab fa-node-js"></i> </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td colspan="2">
        Key Object
      </td>
    </tr>
    <tr>
      <td>
        <strong>keyObj</strong>
      </td>
      <td>
        - represents a cryptographyc key (symmetric or asymmetric)
        <span class="browserSupport" title="updated : 2021-03-16">
          <span><i class="fab fa-node-js"></i> 11.6.0 </span>
          <span class="openable"> more... <div>
              <p> 14.5.0 / 12.19.0 </p>
              <p> - a <strong>keyObj</strong> instance can be passed to worker threads using <mark>postMessage()</mark> </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        KeyObject.from(<strong>cryptoKey</strong>)
      </td>
      <td>
        - converts a <strong>cryptoKey</strong> into a <strong>keyObj</strong> [2021-03-16 <strong>cryptoKey</strong> is Experimental]
        <span class="browserSupport" title="updated : 2021-03-16">
          <span><i class="fab fa-node-js"></i> 15.0.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>keyObj</strong>.export(<strong class="openable">option:obj<div>
            <p><b><u> For symmetric (secret) key </u></b></p>
            <p> format: 'buffer|jwk' - exports to a Buffer or JSON Web Key format (Default: 'buffer') </p>
            <hr>
            <p><b><u> For public key </u></b></p>
            <p> format: 'pem|der|jwk' - exports to the specified format </p>
            <p> type: 'pkcs1|spki' - ('pkcs1' RSA only) </p>
            <hr>
            <p><b><u> For private key </u></b></p>
            <p> format: 'pem|der|jwk' - exports to the specified format </p>
            <p> type: 'pkcs1|pkcs8|sec1' - ('pkcs1' RSA only) ('sec1' EC only) </p>
            <p> cipher: <strong>str</strong> - cipher to encrypt the private key (if this option is ignored the private key won't be encoded) (uses PKCS#5 v2.0 password based encryption) </p>
            <p> passprase: <strong>str|buf</strong> - required if we want to encrypt the exported private key </p>
          </div></strong>)
      </td>
      <td>
        - exports the <strong>keyObj</strong> into the specified format (<strong>buf</strong>, <mark>pem</mark>, <mark>der</mark>, <mark>jwk</mark>)
        <span class="browserSupport" title="updated : 2021-03-17">
          <span><i class="fab fa-node-js"></i> 11.6.0 </span>
          <span>15.9.0 jwk support </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>keyObj</strong>.type
      </td>
      <td>
        - returns the <strong>keyObj</strong>'s type (<mark>'secret'</mark>, <mark>'public'</mark> or <mark>'private'</mark>)
        <span class="browserSupport" title="updated : 2021-03-17">
          <span><i class="fab fa-node-js"></i> 11.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>keyObj</strong>.symmetrycKeySize
      </td>
      <td>
        - for secret (symmetric) keys returns the key's size (in bytes) <br>
        - for public and private keys returns <mark>undefinded</mark>
        <span class="browserSupport" title="updated : 2021-03-17">
          <span><i class="fab fa-node-js"></i> 11.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>keyObj</strong>.asymmetrycKeyType
      </td>
      <td>
        - for public and private keys returns the key's type (ex: <mark>'rsa'</mark>) <br>
        - for secret (symmetric) keys returns <mark>undefinded</mark>
        <span class="browserSupport" title="updated : 2021-03-17">
          <span><i class="fab fa-node-js"></i> 11.6.0 </span>
          <span class="openable"> more... <div>
              <p> 12.0.0 </p>
              <p> - <mark>x25519</mark>, <mark>x448</mark>, <mark>ed25519</mark>, <mark>ed448</mark>, <mark>rsa-pss</mark> support </p>
              <hr>
              <p> 13.9.0 / 12.17.0 </p>
              <p> - <mark>dh</mark> support </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>keyObj</strong>.asymmetrycKeyDetails
      </td>
      <td>
        - for public and private keys returns an <span class="openable">object<div>
            <p> modulusLength: <strong>nr</strong> - key size in bits (RSA, DSA) </p>
            <p> publicExponent: <strong>bigInt</strong> - public exponent (RSA) </p>
            <p> divisorLength: <strong>nr</strong> - size of <mark>q</mark> in bits (DSA) </p>
            <p> namedCurve: <strong>nr</strong> - name of curve (EC) </p>
          </div></span> with the key details <br>
        - for secret (symmetric) keys returns <mark>undefinded</mark>
        <span class="browserSupport" title="updated : 2021-03-17">
          <span><i class="fab fa-node-js"></i> 15.7.0 </span>
        </span>
      </td>
    </tr>
  </table>
  <br>
  <table class="table">
    <caption>
      Cipher / Decipher
    </caption>
    <tr>
      <th style="width:30%;"> Method </th>
      <th> Description </th>
    </tr>
    <tr>
      <td>
        publicEncrypt(<strong class="openable">pubKey:obj|str|...<div>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView|keyObj|cryptoKey</strong> </p>
            <hr>
            <p> <strong>obj</strong> </p>
            <p> key: <strong>str|buf|ArrayBuffer|TypedArray|DataView|keyObj|cryptoKey</strong> - PEM encoded public key </p>
            <p> oaepHash: <strong>str</strong> - hash function to use for OAEP padding and MGF1 (Default: <mark>sha1</mark>) </p>
            <p> oaepLabel: <strong>str|bur|ArrayBuffer|TypedArray|DataView</strong> - label to use for OAEP padding (if not specified, no label is used) </p>
            <p> passprase: <strong>str|bur|ArrayBuffer|TypedArray|DataView</strong> - passprase if the passed key is a private key </p>
            <p> padding: <strong>str|bur|ArrayBuffer|TypedArray|DataView</strong> - padding value (can be <mark><strong>crypto</strong>.constants.RSA_NO_PADDING</mark>, <mark><strong>crypto</strong>.constants.RSA_PKCS1_PADDING</mark>, or <mark><strong>crypto</strong>.constants.RSA_PKCS1_OAEP_PADDING</mark>) </p>
            <p> encoding: <strong>str</strong> - encoding for the passed strings </p>
          </div></strong>, <strong class="openable">data:str|...<div>
            <p><strong>str|buf|ArrayBuffer|TypedArray|DataView</strong></p>
          </div></strong>)
      </td>
      <td>
        - encrypts the passed <strong>data</strong> with the public key and returns the result in a <strong>buf</strong> (Buffer) <br>
        - the encrypted data can be decrypted with the corresponding private key pair later on<br>
        - if the passed <strong>key</strong> argument is not a <strong>keyObj</strong> the <mark><strong>crypto</strong>.createPublicKey()</mark> will be called on it internally
        <span class="browserSupport" title="updated : 2021-03-17">
          <span><i class="fab fa-node-js"></i> 0.11.14 </span>
          <span class="openable"> more... <div>
              <p> 11.6.0 </p>
              <p> - <strong>keyObj</strong> support </p>
              <p> 12.9.0 </p>
              <p> - <mark>oaepHash</mark> option </p>
              <p> 12.11.0 </p>
              <p> - <mark>oaepLabel</mark> option </p>
              <p> 15.0.0 </p>
              <p> - <strong>ArrayBuffer</strong> and <strong>cryptoKey</strong> support </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        privateDecrypt(<strong class="openable">privKey:obj|str|...<div>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView|keyObj|cryptoKey</strong> </p>
            <hr>
            <p> <strong>obj</strong> </p>
            <p> key: <strong>str|buf|ArrayBuffer|TypedArray|DataView|keyObj|cryptoKey</strong> - private key </p>
            <p> oaepHash: <strong>str</strong> - hash function to use for OAEP padding and MGF1 (Default: <mark>sha1</mark>) </p>
            <p> oaepLabel: <strong>str|bur|ArrayBuffer|TypedArray|DataView</strong> - label to use for OAEP padding (if not specified, no label is used) </p>
            <p> padding: <strong>str|bur|ArrayBuffer|TypedArray|DataView</strong> - padding value (can be <mark><strong>crypto</strong>.constants.RSA_NO_PADDING</mark>, <mark><strong>crypto</strong>.constants.RSA_PKCS1_PADDING</mark>, or <mark><strong>crypto</strong>.constants.RSA_PKCS1_OAEP_PADDING</mark>) </p>
          </div></strong>, <strong class="openable">data:str|...<div>
            <p><strong>str|buf|ArrayBuffer|TypedArray|DataView</strong></p>
          </div></strong>)
      </td>
      <td>
        - decrypts the <strong>data</strong> with the private key and returns the result in a <strong>buf</strong> (Buffer) <br>
        - the <strong>data</strong> previously was encrypted with the corresponding private key pair <br>
        - if the passed <strong>key</strong> argument is not a <strong>keyObj</strong> the <mark><strong>crypto</strong>.createPrivateKey()</mark> will be called on it internally
        <span class="browserSupport" title="updated : 2021-03-17">
          <span><i class="fab fa-node-js"></i> 0.11.14 </span>
          <span class="openable"> more... <div>
              <p> 11.6.0 </p>
              <p> - <strong>keyObj</strong> support </p>
              <p> 12.9.0 </p>
              <p> - <mark>oaepHash</mark> option </p>
              <p> 12.11.0 </p>
              <p> - <mark>oaepLabel</mark> option </p>
              <p> 15.0.0 </p>
              <p> - <strong>ArrayBuffer</strong> and <strong>cryptoKey</strong> support </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        privateEncrypt(<strong class="openable">privKey:obj|str|...<div>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView|keyObj|cryptoKey</strong> </p>
            <hr>
            <p> <strong>obj</strong> </p>
            <p> key: <strong>str|buf|ArrayBuffer|TypedArray|DataView|keyObj|cryptoKey</strong> - PEM encoded public key </p>
            <p> passprase: <strong>str|bur|ArrayBuffer|TypedArray|DataView</strong> - passprase if the passed key is a private key </p>
            <p> padding: <strong>str|bur|ArrayBuffer|TypedArray|DataView</strong> - padding value (can be <mark><strong>crypto</strong>.constants.RSA_NO_PADDING</mark>, <mark><strong>crypto</strong>.constants.RSA_PKCS1_PADDING</mark>, or <mark><strong>crypto</strong>.constants.RSA_PKCS1_OAEP_PADDING</mark>) </p>
            <p> encoding: <strong>str</strong> - encoding for the passed strings </p>
          </div></strong>, <strong class="openable">data:str|...<div>
            <p><strong>str|buf|ArrayBuffer|TypedArray|DataView</strong></p>
          </div></strong>)
      </td>
      <td>
        - encrypts the passed <strong>data</strong> with the private key and returns the result in a <strong>buf</strong> (Buffer) <br>
        - the encrypted data can be decrypted with the corresponding public key pair later on<br>
        - if the passed <strong>key</strong> argument is not a <strong>keyObj</strong> the <mark><strong>crypto</strong>.createPrivateKey()</mark> will be called on it internally
        <span class="browserSupport" title="updated : 2021-03-17">
          <span><i class="fab fa-node-js"></i> 1.10.0 </span>
          <span class="openable"> more... <div>
              <p> 11.6.0 </p>
              <p> - <strong>keyObj</strong> support </p>
              <p> 15.0.0 </p>
              <p> - <strong>ArrayBuffer</strong> and <strong>cryptoKey</strong> support </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        publicDecrypt(<strong class="openable">pubKey:obj|str|...<div>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView|keyObj|cryptoKey</strong> </p>
            <hr>
            <p> <strong>obj</strong> </p>
            <p> key: <strong>str|buf|ArrayBuffer|TypedArray|DataView|keyObj|cryptoKey</strong> - PEM encoded public key </p>
            <p> passprase: <strong>str|bur|ArrayBuffer|TypedArray|DataView</strong> - passprase if the passed key is a private key </p>
            <p> padding: <strong>str|bur|ArrayBuffer|TypedArray|DataView</strong> - padding value (can be <mark><strong>crypto</strong>.constants.RSA_NO_PADDING</mark>, <mark><strong>crypto</strong>.constants.RSA_PKCS1_PADDING</mark>, or <mark><strong>crypto</strong>.constants.RSA_PKCS1_OAEP_PADDING</mark>) </p>
            <p> encoding: <strong>str</strong> - encoding for the passed strings </p>
          </div></strong>, <strong class="openable">data:str|...<div>
            <p><strong>str|buf|ArrayBuffer|TypedArray|DataView</strong></p>
          </div></strong>)
      </td>
      <td>
        - decrypts the passed <strong>data</strong> with the public key and returns the result in a <strong>buf</strong> (Buffer) <br>
        - the <strong>data</strong> previously was encrypted with the corresponding private key pair <br>
        - if the passed <strong>key</strong> argument is not a <strong>keyObj</strong> the <mark><strong>crypto</strong>.createPubliceKey()</mark> will be called on it internally
        <span class="browserSupport" title="updated : 2021-03-17">
          <span><i class="fab fa-node-js"></i> 1.10.0 </span>
          <span class="openable"> more... <div>
              <p> 11.6.0 </p>
              <p> - <strong>keyObj</strong> support </p>
              <p> 15.0.0 </p>
              <p> - <strong>ArrayBuffer</strong> and <strong>cryptoKey</strong> support </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td colspan="2">
        Cipher
      </td>
    </tr>
    <tr>
      <td>
        createCipheriv(<strong>algorithm:str</strong>, <strong class="openable">key:str|...<div>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView|keyObj|cryptoKey</strong> </p>
          </div></strong>, <strong class="openable">iv<div>
            <p> - initialization vector (Nonce) </p>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView|</strong> or <mark>null</mark> </p>
          </div></strong>, <i class="openable">option:obj<div>
            <p> - any <strong>transformStream</strong> options </p>
            <hr>
            <p> authTagLength: <strong>nr</strong> - the generated authentication tag length by the <strong>cipher</strong> <u>(required when CCM or OBC cipher mode is used (authenticated encryption moides))</u>
          </div></i>)
      </td>
      <td>
        - creates and returns a <strong>cipher</strong> object which is used to symmetrically encrypt data (2 ways to use it) <br>
        - 1) the returned <strong>cipher</strong> is a transform stream (data piped through will be encrypted) <u>(should not be used with authenticated encryption modes (<mark>GCM</mark>, <mark>CCM</mark> and <mark>OCB</mark>)</u> <br>
        - 2) calling the <mark>update()</mark> then <mark>final()</mark> on the <strong>cipher</strong> to encode the passed data
        <span class="browserSupport" title="updated : 2021-03-17">
          <span><i class="fab fa-node-js"></i> 0.1.94 </span>
          <span class="openable"> more...<div>
              <p> 9.9.0 </p>
              <p> - the <strong>iv</strong> parameter does not need to be <mark>null</mark> for ciphers not requiring the initialization vector </p>
              <hr>
              <p> 10.2.0 </p>
              <p> - the <mark>authTagLength</mark> option can now be used to produce shorter authentication tags in GCM mode and defaults to 16 bytes </p>
              <hr>
              <p> 10.10.0 </p>
              <p> - <mark>OCB</mark> cipher mode support </p>
              <hr>
              <p> 11.2.0 / 10.17.0 </p>
              <p> - <mark>chacha20-poly1305</mark> cipher support </p>
              <hr>
              <p> 11.6.0 </p>
              <p> - <strong>keyObj</strong> support </p>
              <hr>
              <p> 15.0.0 </p>
              <p> - <strong>ArrayBuffer</strong> support </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>cipher</strong>.update(<strong class="openable">data:str|...<div>
            <p> <strong>str|buf|TypedArray|DataView</strong> </p>
          </div></strong>, <i class="openable">inEncode:str<div>
            <p> - the input <strong>data</strong> encoding when string passed </p>
          </div></i>, <i class="openable">outEncode:str<div>
            <p> - output encoding </p>
          </div></i>)
      </td>
      <td>
        - feeds the <strong>cipher</strong> with data and returns the encoded result as <strong>str|buf</strong> (can be called multiple times)
        <span class="browserSupport" title="updated : 2021-03-17">
          <span><i class="fab fa-node-js"></i> 0.1.94 </span>
          <span class="openable"> more...<div>
              <p> 6.0.0 </p>
              <p> - default <i>inEncode</i> changed from <mark>binary</mark> to <mark>utf-8</mark> </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>cipher</strong>.final(<i class="openable">outEncode:str<div>
            <p> - output encoding </p>
          </div></i>)
      </td>
      <td>
        - returns any remaining enciphered content from the <strong>cipher</strong> object (once called the <strong>cipher</strong> is finalized (won't encrypt more data))
        <span class="browserSupport" title="updated : 2021-03-17">
          <span><i class="fab fa-node-js"></i> 0.1.94 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>cipher</strong>.setAAD(<strong class="openable">aad:str|...<div>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView</strong> </p>
            <p> - data used for additional authentication </p>
          </div></strong>, <i class="openable">option:obj<div>
            <p> plaintextLength: <strong>nr</strong> - the length <u>in bytes</u> of the original text what we want to encrypt <u>(required for <mark>CCM</mark> mode)</u> (optional for <mark>GCM</mark> and <mark>OCB</mark> modes) </p>
            <p> encoding: <strong>str</strong> - encoding for the <strong>data</strong> when string passed </p>
          </div></i>)
      </td>
      <td>
        - when authenticated encryption mode is used (<mark>GCM</mark>, <mark>CCM</mark> or <mark>OCB</mark>) sets the <b>a</b>dditional <b>a</b>uthenticated <b>d</b>ata for the <strong>cipher</strong> <br>
        - returns the <strong>cipher</strong> object for method chaining <br>
        - must be called before <mark><strong>cipher</strong>.update()</mark>
        <span class="browserSupport" title="updated : 2021-03-18">
          <span><i class="fab fa-node-js"></i> 1.0.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>cipher</strong>.getAuthTag()
      </td>
      <td>
        - when authenticated encryption mode is used (<mark>GCM</mark>, <mark>CCM</mark> or <mark>OCB</mark>) returns the computed authentication tag as a <strong>buf</strong> <br>
        - must be called after <mark><strong>cipher</strong>.final()</mark>
        <span class="browserSupport" title="updated : 2021-03-18">
          <span><i class="fab fa-node-js"></i> </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>cipher</strong>.setAutoPadding(<strong>bol</strong>)
      </td>
      <td>
        - enables/disables <span class="openable">auto padding<div>
            <p> - block ciphers automatically add a padding to the last cipher block on the chain, so all cipher blocks are full (ex: if <mark>AES128</mark> encryption's last block is a 64 bit block an additional 64 bit padding is added so the last block will be a full 128bit cipher block) </p>
            <p> - this method can disable this, but in this case we have to make sure that the last block of the encrypted data is a full block (like the data to encrypt is the exact length) </p>
          </div></span> for block encryptions (Default: <mark>true</mark>) <br>
        - must be called before <mark><strong>cipher</strong>.final()</mark>
        <span class="browserSupport" title="updated : 2021-03-18">
          <span><i class="fab fa-node-js"></i> 0.7.1 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td colspan="2">
        Decipher
      </td>
    </tr>
    <tr>
      <td>
        createDecipheriv(<strong>algorithm:str</strong>, <strong class="openable">key:str|...<div>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView|keyObj|cryptoKey</strong> </p>
          </div></strong>, <strong class="openable">iv<div>
            <p> - initialization vector (Nonce) </p>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView|</strong> or <mark>null</mark> </p>
          </div></strong>, <i class="openable">option:obj<div>
            <p> - any <strong>transformStream</strong> options </p>
            <hr>
            <p> authTagLength: <strong>nr</strong> - the passed authentication tag length <u>(required when CCM or OBC cipher mode is used (authenticated encryption moides))</u>
          </div></i>)
      </td>
      <td>
        - creates and returns a <strong>decipher</strong> object which is used to symmetrically decrypt data (2 ways to use it) <br>
        - 1) the returned <strong>decipher</strong> is a transform stream (data piped through will be decrypted) <u>(should not be used with authenticated encryption modes (<mark>GCM</mark>, <mark>CCM</mark> and <mark>OCB</mark>)</u> <br>
        - 2) calling the <mark>update()</mark> then <mark>final()</mark> on the <strong>decipher</strong> to decode the passed data
        <span class="browserSupport" title="updated : 2021-03-17">
          <span><i class="fab fa-node-js"></i> 0.1.94 </span>
          <span class="openable"> more...<div>
              <p> 9.9.0 </p>
              <p> - the <strong>iv</strong> parameter does not need to be <mark>null</mark> for ciphers not requiring the initialization vector </p>
              <hr>
              <p> 10.2.0 </p>
              <p> - the <mark>authTagLength</mark> option can now be used to produce shorter authentication tags in GCM mode and defaults to 16 bytes </p>
              <hr>
              <p> 10.10.0 </p>
              <p> - <mark>OCB</mark> cipher mode support </p>
              <hr>
              <p> 11.2.0 / 10.17.0 </p>
              <p> - <mark>chacha20-poly1305</mark> cipher support </p>
              <hr>
              <p> 11.6.0 </p>
              <p> - <strong>keyObj</strong> support </p>
              <hr>
              <p> 15.0.0 </p>
              <p> - <strong>ArrayBuffer</strong> support </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>decipher</strong>.update(<strong class="openable">data:str|...<div>
            <p> <strong>str|buf|TypedArray|DataView</strong> </p>
          </div></strong>, <i class="openable">inEncode:str<div>
            <p> - the input <strong>data</strong> encoding when string passed </p>
          </div></i>, <i class="openable">outEncode:str<div>
            <p> - output encoding </p>
          </div></i>)
      </td>
      <td>
        - feeds the <strong>decipher</strong> with data and returns the decoded result as <strong>str|buf</strong> (can be called multiple times)
        <span class="browserSupport" title="updated : 2021-03-17">
          <span><i class="fab fa-node-js"></i> 0.1.94 </span>
          <span class="openable"> more...<div>
              <p> 6.0.0 </p>
              <p> - default <i>inEncode</i> changed from <mark>binary</mark> to <mark>utf-8</mark> </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>decipher</strong>.final(<i class="openable">outEncode:str<div>
            <p> - output encoding </p>
          </div></i>)
      </td>
      <td>
        - returns any remaining deciphered content from the <strong>decipher</strong> object (once called the <strong>decipher</strong> is finalized (won't decrypt more data))
        <span class="browserSupport" title="updated : 2021-03-17">
          <span><i class="fab fa-node-js"></i> 0.1.94 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>decipher</strong>.setAuthTag(<strong class="openable">authTag:str|...<div>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView</strong> </p>
            <p> - authentication tag previously generated by the corresponding <mark><strong>cipher</strong>.getAuthTag()</mark> </p>
          </div></strong>, <i class="openable">encode:str<div>
            <p> - encoding for the <strong>authTag</strong> when string passed </p>
          </div></i>)
      </td>
      <td>
        - when authenticated encryption mode is used (<mark>GCM</mark>, <mark>CCM</mark> or <mark>OCB</mark>) sets the authentication tag to the <strong>decipher</strong> <br>
        - returns the <strong>decipher</strong> object for method chaining <br>
        - must be called before <mark><strong>decipher</strong>.update()</mark>
        <span class="browserSupport" title="updated : 2021-03-18">
          <span><i class="fab fa-node-js"></i> 1.0.0 </span>
          <span class="openable"> more... <div>
              <p> 7.2.0</p>
              <p> - returns the <strong>decipher</strong> object </p>
              <hr>
              <p> 11.0.0 </p>
              <p> - throws if the <mark>GCM</mark> tag length is invalid </p>
              <hr>
              <p> 15.0.0</p>
              <p> - <strong>ArrayBuffer</strong> support </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>decipher</strong>.setAAD(<strong class="openable">aad:str|...<div>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView</strong> </p>
            <p> - additional authenticated data used when the original data was encrypted </p>
          </div></strong>, <i class="openable">option:obj<div>
            <p> plaintextLength: <strong>nr</strong> - the length <u>in bytes</u> of the original text what was encrypted <u>(required for <mark>CCM</mark> mode)</u> (optional for <mark>GCM</mark> and <mark>OCB</mark> modes) </p>
            <p> encoding: <strong>str</strong> - encoding for the <strong>data</strong> when string passed </p>
          </div></i>)
      </td>
      <td>
        - when authenticated encryption mode is used (<mark>GCM</mark>, <mark>CCM</mark> or <mark>OCB</mark>) sets the <b>a</b>dditional <b>a</b>uthenticated <b>d</b>ata to the <strong>decipher</strong> <br>
        - returns the <strong>decipher</strong> object for method chaining <br>
        - must be called before <mark><strong>decipher</strong>.update()</mark>
        <span class="browserSupport" title="updated : 2021-03-18">
          <span><i class="fab fa-node-js"></i> 1.0.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>decipher</strong>.setAutoPadding(<strong>bol</strong>)
      </td>
      <td>
        - enables/disables <span class="openable">auto padding<div>
            <p> - block ciphers automatically add a padding to the last cipher block on the chain, so all cipher blocks are full (ex: if <mark>AES128</mark> encryption's last block is a 64 bit block an additional 64 bit padding is added so the last block will be a full 128bit cipher block) </p>
            <p> - this method can disable this, but in this case we have to make sure that the last block of the encrypted data is a full block (like the data to encrypt is the exact length) </p>
          </div></span> for block encryptions (Default: <mark>true</mark>) <br>
        - must be called before <mark><strong>cipher</strong>.final()</mark>
        <span class="browserSupport" title="updated : 2021-03-18">
          <span><i class="fab fa-node-js"></i> 0.7.1 </span>
        </span>
      </td>
    </tr>
  </table>
  <br>
  <table class="table">
    <caption>
      Sign / Verify
    </caption>
    <tr>
      <th style="width:30%;"> Method </th>
      <th> Description </th>
    </tr>
    <tr>
      <td>
        sign(<strong>hashAlgorithm:str</strong>, <strong class="openable">data:str|...<div>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView</strong> </p>
          </div></strong>, <strong class="openable">privKey:str|...<div>
            <p> <strong>obj|str|bur|ArrayBuffer|TypedArray|DataView|keyObj|cryptoKey</strong> </p>
            <p> - if not <strong>keyObj</strong> is passed the <mark><strong>crypto</strong>.createPrivateKey()</mark> is called internally</p>
            <hr>
            <p> <strong>obj</strong> </p>
            <p> key: <strong>str|bur|ArrayBuffer|TypedArray|DataView|keyObj|cryptoKey</strong> - key to sign with </p>
            <p> dsaEncoding: 'der'|'ieee-p1363' - for DSA and ECDSA specifies the format of the generated signature (Default: <mark>der</mark>) </p>
            <p> padding: <strong>nr</strong> - optional padding for RSA (<mark><strong>crypto</strong>.constants.RSA_PKCS1_PADDING</mark> (default) or <mark><strong>crypto</strong>.constants.RSA_PKCS1_PSS_PADDING</mark>) </p>
            <p> saltLength: <strong>nr</strong> - salt length when padding is <mark>RSA_PKCS1_PSS_PADDING</mark> </p>
          </div></strong>, <i>fn(err, signature)</i>)
      </td>
      <td>
        - signs the passed <strong>data</strong> with the <strong>hashAlgorithm</strong> and <strong>privKey</strong> <br>
        - no callback provided = synchronous operation | callback provided = asynchronous operation
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 12.0.0 </span>
          <span class="openable"> more...<div>
              <p> 13.2.0 / 12.16.0 </p>
              <p> IEEE-P1363 DSA and ECDSA support </p>
              <hr>
              <p> 15.0.0 </p>
              <p> <strong>ArrayBuffer</strong> support </p>
              <hr>
              <p> 15.12.0 </p>
              <p> asynchronous version support (callback added) </p>
            </div> </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        verify(<strong>hashAlgorithm:str</strong>, <strong class="openable">data:str|...<div>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView</strong> </p>
          </div></strong>, <strong class="openable">pubKey:str|...<div>
            <p> <strong>obj|str|bur|ArrayBuffer|TypedArray|DataView|keyObj|cryptoKey</strong> </p>
            <p> - if not <strong>keyObj</strong> is passed the <mark><strong>crypto</strong>.createPublicKey()</mark> is called internally</p>
            <hr>
            <p> <strong>obj</strong> </p>
            <p> key: <strong>str|bur|ArrayBuffer|TypedArray|DataView|keyObj|cryptoKey</strong> - key to sign with </p>
            <p> dsaEncoding: 'der'|'ieee-p1363' - for DSA and ECDSA specifies the format of the generated signature (Default: <mark>der</mark>) </p>
            <p> padding: <strong>nr</strong> - optional padding for RSA (<mark><strong>crypto</strong>.constants.RSA_PKCS1_PADDING</mark> (default) or <mark><strong>crypto</strong>.constants.RSA_PKCS1_PSS_PADDING</mark>) </p>
            <p> saltLength: <strong>nr</strong> - salt length when padding is <mark>RSA_PKCS1_PSS_PADDING</mark> </p>
          </div></strong>, <strong class="openable">signature:buf|...<div>
            <p> <strong>buf|ArrayBuffer|TypedArray|DataView</strong> </p>
          </div></strong>, <i>fn(err, res)</i>)
      </td>
      <td>
        - verifies if <strong>signature</strong> matches the passed <strong>data</strong> and returns a boolean accordingly <br>
        - no callback provided = synchronous operation | callback provided = asynchronous operation
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 12.0.0 </span>
          <span class="openable"> more...<div>
              <p> 13.2.0 / 12.16.0 </p>
              <p> IEEE-P1363 DSA and ECDSA support </p>
              <hr>
              <p> 15.0.0 </p>
              <p> <strong>ArrayBuffer</strong> support </p>
              <hr>
              <p> 15.12.0 </p>
              <p> asynchronous version support (callback added) </p>
            </div> </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td colspan="2">
        Sing
      </td>
    </tr>
    <tr>
      <td>
        createSing(<strong>hashAlgorithm:str</strong>, <i class="openable">option:obj<div>
            <p> - any <strong>writableStream</strong> options </p>
          </div></i>)
      </td>
      <td>
        - creates and returns a <strong>sing</strong> object which is used to create a digital signature (2 ways to use it) <br>
        - 1) the returned <strong>sign</strong> is a writable stream, we write the data what we want to sign then we use the <mark>sing()</mark> method to create the signature <br>
        - 2) calling the <mark>update()</mark> and <mark>end()</mark> methods to write the data what we want to sign then we use the <mark>sing()</mark> method to create the signature
        <span class="browserSupport" title="updated : 2021-03-23">
          <span><i class="fab fa-node-js"></i> 0.1.92 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>sign</strong>.update(<strong class="openable">data:str|...<div>
            <p> <strong>str|buf|TypedArray|DataView</strong> </p>
            <p> - the data what we want to sign </p>
          </div></strong>, <i class="openable">encode:str<div>
            <p> - encoding if <strong>data</strong> is a string (Default: <mark>utf-8</mark>) </p>
            <p> - if <strong>data</strong> is not a string this option is ignored </p>
          </div></i>)
      </td>
      <td>
        - feeds the <strong>sign</strong> object with the data what we want to sign (can be called multiple times)
        <span class="browserSupport" title="updated : 2021-03-23">
          <span><i class="fab fa-node-js"></i> 0.1.92 </span>
          <span class="openable"> more...<div>
              <p> 6.0.0 </p>
              <p> - default encoding changed from <mark>binary</mark> to <mark>utf-8</mark> </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>sign</strong>.end()
      </td>
      <td>
        - called after <mark>update()</mark> to signal that no more data will be written to the <strong>sign</strong> object
        <span class="browserSupport" title="updated : 2021-03-23">
          <span><i class="fab fa-node-js"></i> 0.1.92 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>sign</strong>.sign(<strong class="openable">privKey:str|...<div>
            <p> <strong>obj|str|bur|ArrayBuffer|TypedArray|DataView|keyObj|cryptoKey</strong> </p>
            <p> - if not <strong>keyObj</strong> is passed the <mark><strong>crypto</strong>.createPrivateKey()</mark> is called internally</p>
            <hr>
            <p> <strong>obj</strong> </p>
            <p> key: <strong>str|bur|ArrayBuffer|TypedArray|DataView|keyObj|cryptoKey</strong> - key to sign with </p>
            <p> dsaEncoding: 'der'|'ieee-p1363' - for DSA and ECDSA specifies the format of the generated signature (Default: <mark>der</mark>) </p>
            <p> padding: <strong>nr</strong> - optional padding for RSA (<mark><strong>crypto</strong>.constants.RSA_PKCS1_PADDING</mark> (default) or <mark><strong>crypto</strong>.constants.RSA_PKCS1_PSS_PADDING</mark>) </p>
            <p> saltLength: <strong>nr</strong> - salt length when padding is <mark>RSA_PKCS1_PSS_PADDING</mark> </p>
          </div></strong>, <i class="openable">encode<div>
            <p> - encoding for the returned signature </p>
            <p> - if this option is not provided <strong>buf</strong> is returned </p>
          </div></i>)
      </td>
      <td>
        - calculates and returns the signature for the data previously written to the <strong>sign</strong> object
        <span class="browserSupport" title="updated : 2021-03-23">
          <span><i class="fab fa-node-js"></i> 0.1.92 </span>
          <span class="openable"> more...<div>
              <p> 8.0.0 </p>
              <p> - RSASSA-PSS support </p>
              <hr>
              <p> 11.6.0 </p>
              <p> - <strong>keyObj</strong> support </p>
              <hr>
              <p> 12.0.0 </p>
              <p> RSA-PSS key support </p>
              <hr>
              <p> 13.2.0 / 12.16.0 </p>
              <p> IEEE-P1363 DSA and ECDSA support </p>
              <hr>
              <p> 15.0.0 </p>
              <p> <strong>ArrayBuffer</strong> and <strong>cryptoKey</strong> support </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td colspan="2">
        Verify
      </td>
    </tr>
    <tr>
      <td>
        createVerify(<strong>hashAlgorithm:str</strong>, <i class="openable">option:obj<div>
            <p> - any <strong>readableStream</strong> options </p>
          </div></i>)
      </td>
      <td>
        - creates and returns a <strong>verify</strong> object which is used to verify if the specified data was signed with the specified digital signature (2 ways to use it) <br>
        - 1) the returned <strong>verify</strong> is a writable stream, we write the data what we want to verify then we use the <mark>verify()</mark> method in order to verify the data and signature <br>
        - 2) calling the <mark>update()</mark> and <mark>end()</mark> methods to write the data what we want to verify then we use the <mark>verify()</mark> method to verify the data and signature
        <span class="browserSupport" title="updated : 2021-03-23">
          <span><i class="fab fa-node-js"></i> 0.1.92 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>verify</strong>.update(<strong class="openable">data:str|...<div>
            <p> <strong>str|buf|TypedArray|DataView</strong> </p>
            <p> - the data what we want to verify </p>
          </div></strong>, <i class="openable">encode:str<div>
            <p> - encoding if <strong>data</strong> is a string (Default: <mark>utf-8</mark>) </p>
            <p> - if <strong>data</strong> is not a string this option is ignored </p>
          </div></i>)
      </td>
      <td>
        - feeds the <strong>verify</strong> object with the data what we want to verify (can be called multiple times)
        <span class="browserSupport" title="updated : 2021-03-23">
          <span><i class="fab fa-node-js"></i> 0.1.92 </span>
          <span class="openable"> more...<div>
              <p> 6.0.0 </p>
              <p> - default encoding changed from <mark>binary</mark> to <mark>utf-8</mark> </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>verify</strong>.end()
      </td>
      <td>
        - called after <mark>update()</mark> to signal that no more data will be written to the <strong>verify</strong> object
        <span class="browserSupport" title="updated : 2021-03-23">
          <span><i class="fab fa-node-js"></i> 0.1.92 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>verify</strong>.verify(<strong class="openable">pubKey:str|...<div>
            <p> <strong>obj|str|bur|ArrayBuffer|TypedArray|DataView|keyObj|cryptoKey</strong> </p>
            <p> - if not <strong>keyObj</strong> is passed the <mark><strong>crypto</strong>.createPrivateKey()</mark> is called internally</p>
            <p><b> - because public keys can be derived from private keys we can pass <strong>privKey</strong> instead of <strong>pubKey</strong> </b></p>
            <hr>
            <p> <strong>obj</strong> </p>
            <p> key: <strong>str|bur|ArrayBuffer|TypedArray|DataView|keyObj|cryptoKey</strong> - key to sign with </p>
            <p> dsaEncoding: 'der'|'ieee-p1363' - for DSA and ECDSA specifies the format of the generated signature (Default: <mark>der</mark>) </p>
            <p> padding: <strong>nr</strong> - optional padding for RSA (<mark><strong>crypto</strong>.constants.RSA_PKCS1_PADDING</mark> (default) or <mark><strong>crypto</strong>.constants.RSA_PKCS1_PSS_PADDING</mark>) </p>
            <p> saltLength: <strong>nr</strong> - salt length when padding is <mark>RSA_PKCS1_PSS_PADDING</mark> </p>
          </div></strong>, <strong class="openable">signature:str|...<div>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView</strong> </p>
          </div></strong>, <i class="openable">encode<div>
            <p> - encoding for the passed signature </p>
            <p> - if this option is provided <strong>signature</strong> is expected to be a string </p>
          </div></i>)
      </td>
      <td>
        - verifies if the data previously written to the <strong>verify</strong> object was signed with the <strong>signature</strong> and returns a <strong>bol</strong> accordingly
        <span class="browserSupport" title="updated : 2021-03-23">
          <span><i class="fab fa-node-js"></i> 0.1.92 </span>
          <span class="openable"> more...<div>
              <p> 8.0.0 </p>
              <p> - RSASSA-PSS support </p>
              <hr>
              <p> 11.6.0 </p>
              <p> - <strong>keyObj</strong> support </p>
              <hr>
              <p> 12.0.0 </p>
              <p> RSA-PSS key support </p>
              <hr>
              <p> 13.2.0 / 12.16.0 </p>
              <p> IEEE-P1363 DSA and ECDSA support </p>
              <hr>
              <p> 15.0.0 </p>
              <p> <strong>ArrayBuffer</strong> and <strong>cryptoKey</strong> support </p>
            </div></span>
        </span>
      </td>
    </tr>
  </table>
  <br>
  <table class="table">
    <caption>
      Hashes
    </caption>
    <tr>
      <th style="width:30%;"> Method </th>
      <th> Description </th>
    </tr>
    <tr>
      <td colspan="2"> Hash </td>
    </tr>
    <tr>
      <td>
        createHash(<strong>hashAlgorithm:str</strong>, <i class="openable">option:obj<div>
            <p> - any <strong>transformStream</strong> options </p>
          </div></i>)
      </td>
      <td>
        - creates and returns a <strong>hash</strong> object which is used to create a hash digest (2 ways) <br>
        - 1) the returned <strong>hash</strong> object is a transform stream, we write the data to the stream and the hash digest is outputted on the readable side <br>
        - 2) calling the <mark>update()</mark> and <mark>digest()</mark> methods on the <strong>hash</strong> object to create the hash digest
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 0.1.92 </span>
          <span class="openable"> more...<div>
              <p> 12.8.0 </p>
              <p> - <mark>outputLength</mark> option for XOF hash functions </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>hash</strong>.update(<strong class="openable">data:str|...<div>
            <p> <strong>str|buf|TypedArray|DataView</strong> </p>
          </div></strong>, <i class="openable">encode:str<div>
            <p> - input encoding, ignored if <strong>data</strong> is not a string (Default: <strong>utf-8</strong>) </p>
          </div></i>)
      </td>
      <td>
        - feeds the <strong>hash</strong> object with data (can be called multiple times)
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 0.1.92 </span>
          <span class="openable"> more...<div>
              <p> 6.0.0 </p>
              <p> - default encoding changed from <mark>binary</mark> to <mark>utf-8</mark> </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>hash</strong>.digest(<i class="openable">encode:str<div>
            <p> - encoding of the return value (Default: <strong>buf</strong>) </p>
          </div></i>)
      </td>
      <td>
        - calculates and returns the digest (as <strong>buf</strong>) on the data passed to the <strong>hash</strong> object
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 0.1.92 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>hash</strong>.copy(<i class="openable">option:obj<div>
            <p> - any <strong>transformStream</strong> options </p>
          </div></i>)
      </td>
      <td>
        - creates and returns a new <strong>hash</strong> object copy <br>
        - the newly created <strong>hash</strong> contains a deep copy of the internal state of the original <strong>hash</strong>
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td colspan="2">
        HMAC (key-Hashed Message Authentication Code)
      </td>
    </tr>
    <tr>
      <td>
        createHmac(<strong>hashAlgorithm:str</strong>, <strong class="openable">key:str|...<div>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView|keyObj|cryptoKey</strong> </p>
          </div></strong>, <i class="openable">option:obj<div>
            <p> - any <strong>transformStream</strong> options </p>
          </div></i>)
      </td>
      <td>
        - creates and returns a <strong>hmac</strong> object which is used to create a HMAC hash (2 ways) <br>
        - 1) the returned <strong>hmac</strong> object is a transform stream, we write the data to the stream and the hmac hash is outputted on the readable side <br>
        - 2) calling the <mark>update()</mark> and <mark>digest()</mark> methods on the <strong>hmac</strong> object to create the hmac hash
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 0.1.92 </span>
          <span class="openable"> more...<div>
              <p> 11.6.0 </p>
              <p> - the <strong>key</strong> argument can be <strong>keyObj</strong> </p>
              <hr>
              <p> 15.0.0 </p>
              <p> - the <strong>key</strong> argument can be <strong>ArrayBuffer</strong> or <strong>cryptoKey</strong> </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>hmac</strong>.update(<strong class="openable">data:str|...<div>
            <p> <strong>str|buf|TypedArray|DataView</strong> </p>
          </div></strong>, <i class="openable">encode:str<div>
            <p> - input encoding, ignored if <strong>data</strong> is not a string (Default: <strong>utf-8</strong>) </p>
          </div></i>)
      </td>
      <td>
        - feeds the <strong>hmac</strong> object with data (can be called multiple times)
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 0.1.92 </span>
          <span class="openable"> more...<div>
              <p> 6.0.0 </p>
              <p> - default encoding changed from <mark>binary</mark> to <mark>utf-8</mark> </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>hmac</strong>.digest(<i class="openable">encode:str<div>
            <p> - encoding of the return value (Default: <strong>buf</strong>) </p>
          </div></i>)
      </td>
      <td>
        - calculates and returns the hmac hash (as <strong>buf</strong>) on the data and key passed to the <strong>hmac</strong> object
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 0.1.92 </span>
        </span>
      </td>
    </tr>
  </table>
  <br>
  <table class="table">
    <caption>
      Diffie-Hellman key exchange
      <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
    </caption>
    <tr>
      <th style="width:30%;"> Method </th>
      <th> Description </th>
    </tr>
    <tr>
      <td>
        generatePrime(<strong class="openable">size:nr<div>
            <p> - size in bits (ex: <mark>8</mark>bit = 1byte can be up to 255) </p>
          </div></strong>, <i class="openable">option:obj<div>
            <p> bigint: <strong>bol</strong> - if <mark>true</mark> the returned result is a <strong>bigint</strong> (Default: <mark>false</mark>) </p>
            <p> safe: <strong>bol</strong> - if <mark>true</mark> the returned result is a safe prime (<mark>(<strong>prime</strong> - 1) / 2</mark> also result in a prime) (Default <mark>false</mark>) </p>
            <p> add: <strong>bigint|buf|ArrayBuffer|SharedArrayBuffer|TypedArray|DataView</strong> (must be big-endian encoded) </p>
            <p> rem: <strong>bigint|buf|ArrayBuffer|SharedArrayBuffer|TypedArray|DataView</strong> (must be big-endian encoded) </p>
            <hr>
            <p><b> The <mark>add</mark> and <mark>rem</mark> options can be used to provide additional requirements for Diffiel-Hellman </b></p>
            <p> - if both <mark>add</mark> and <mark>rem</mark> set the generated prime will satisfy that <mark><strong>prime</strong> % <strong>add</strong> = <strong>rem</strong></mark> </p>
            <p> - if <mark>add</mark> is set and <mark>safe</mark> is false the generated prime will satisfy that <mark><strong>prime</strong> % <strong>add</strong> = 1</mark> </p>
            <p> - if <mark>add</mark> is set and <mark>safe</mark> is true the generated prime will satisfy that <mark><strong>prime</strong> % <strong>add</strong> = 3</mark> </p>

          </div></i>, <strong>fn(err, prime)</strong>)
      </td>
      <td>
        - asynchronously generates a pseudo-random prime number of the specified length <br>
        - the generated prime is stored in a big-endian sequence <strong>ArrayBuffer</strong> (by Default)
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 15.8.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        generatePrimeSync(<strong class="openable">size:nr<div>
            <p> - size in bits (ex: <mark>8</mark>bit = 1byte can be up to 255) </p>
          </div></strong>, <i class="openable">option:obj<div>
            <p> bigint: <strong>bol</strong> - if <mark>true</mark> the returned result is a <strong>bigint</strong> (Default: <mark>false</mark>) </p>
            <p> safe: <strong>bol</strong> - if <mark>true</mark> the returned result is a safe prime (<mark>(<strong>prime</strong> - 1) / 2</mark> also result in a prime) (Default <mark>false</mark>) </p>
            <p> add: <strong>bigint|buf|ArrayBuffer|SharedArrayBuffer|TypedArray|DataView</strong> (must be big-endian encoded) </p>
            <p> rem: <strong>bigint|buf|ArrayBuffer|SharedArrayBuffer|TypedArray|DataView</strong> (must be big-endian encoded) </p>
            <hr>
            <p><b> The <mark>add</mark> and <mark>rem</mark> options can be used to provide additional requirements for Diffiel-Hellman </b></p>
            <p> - if both <mark>add</mark> and <mark>rem</mark> set the generated prime will satisfy that <mark><strong>prime</strong> % <strong>add</strong> = <strong>rem</strong></mark> </p>
            <p> - if <mark>add</mark> is set and <mark>safe</mark> is false the generated prime will satisfy that <mark><strong>prime</strong> % <strong>add</strong> = 1</mark> </p>
            <p> - if <mark>add</mark> is set and <mark>safe</mark> is true the generated prime will satisfy that <mark><strong>prime</strong> % <strong>add</strong> = 3</mark> </p>

          </div></i>)
      </td>
      <td>
        - synchronously generates a pseudo-random prime number of the specified length and returns it <br>
        - the generated prime is stored in a big-endian sequence <strong>ArrayBuffer</strong> (by Default)
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 15.8.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        checkPrime(<strong class="openable">candidate:bigint|...<div>
            <p> <strong>bigint|buf|ArrayBuffer|SharedArrayBuffer|TypedArray|DataView</strong> (must be big-endian encoded) </p>
          </div></strong>, <i class="openable">option:obj<div>
            <p> checks: <strong>nr</strong> - the number of Miller-Rabin probabilistic primality iterations to perform. When the value is 0 (zero), a number of checks is used that yields a false positive rate of at most 2-64 for random input. Care must be used when selecting a number of checks. Refer to the OpenSSL documentation for the BN_is_prime_ex function nchecks options for more details (Default: <mark>0</mark>) </p>
          </div></i>, <strong>fn(err, res)</strong>)
      </td>
      <td>
        - asynchronously checks if the passed <strong>candidate</strong> is a prime number and returns a boolean accordingly
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 15.8.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        checkPrimeSync(<strong class="openable">candidate:bigint|...<div>
            <p> <strong>bigint|buf|ArrayBuffer|SharedArrayBuffer|TypedArray|DataView</strong> (must be big-endian encoded) </p>
          </div></strong>, <i class="openable">option:obj<div>
            <p> checks: <strong>nr</strong> - the number of Miller-Rabin probabilistic primality iterations to perform. When the value is 0 (zero), a number of checks is used that yields a false positive rate of at most 2-64 for random input. Care must be used when selecting a number of checks. Refer to the OpenSSL documentation for the BN_is_prime_ex function nchecks options for more details (Default: <mark>0</mark>) </p>
          </div></i>)
      </td>
      <td>
        - synchronously checks if the passed <strong>candidate</strong> is a prime number and returns a boolean accordingly
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 15.8.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td colspan="2">
        Diffie-Hellman (key exchange utility)
      </td>
    </tr>
    <tr>
      <td>
        createDiffieHellman(<strong class="openable">prime:str|...<div>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView</strong> </p>
            <p> - prime value (number) </p>
          </div></strong>, <i class="openable">primeEncode:str<div>
            <p> - <strong>prime</strong> encoding if string passed </p>
          </div></i>, <i class="openable">gen:nr|...<div>
            <p> <strong>nr|str|buf|ArrayBuffer|TypedArray|DataView</strong> </p>
            <p> - generator value (Default: <mark>2</mark>) </p>
          </div></i>, <i class="openable">genEncode:str<div>
            <p> - <i>gen</i> encoding if string passed </p>
          </div></i>) <br>
        <strong>crypto</strong>.createDiffieHellman(<strong class="openable">primeLength:nr<div>
            <p> - internally generates a prime of the specified <u>bit</u> length </p>
          </div></strong>, <i class="openable">gen:nr<div>
            <p> - generator value (Default: <mark>2</mark>) </p>
          </div></i>)
      </td>
      <td>
        - creates and returns a <strong>diffieHellman</strong> object with the provided prime and generator
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 0.11.12 </span>
          <span class="openable"> more...<div>
              <p> 6.0.0 </p>
              <p> - default encoding changed from <mark>binary</mark> to <mark>utf-8</mark> </p>
              <p> 8.0.0 </p>
              <p> - <strong>prime</strong> can be <strong>TypedArray|DataView</strong> </p>
              <hr>
              <p> 0.5.0 </p>
              <p> <mark><strong>crypto</strong>.createDiffieHellman(<strong>primeLength</strong>, <i>gen</i>)</mark> syntax support </p>
            </div></span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        createDiffieHellmanGroup(<strong class="openable">diffHellGroup:str<div>
            <p> - Diffie-Hellman group (pre defined fixed Diffie-Hellman primes) <u>bigger prime = better security</u> </p>
            <p> <mark>'modp1'</mark> = 768bit prime </p>
            <p> <mark>'modp2'</mark> = 1024bit prime </p>
            <p> <mark>'modp5'</mark> = 1536bit prime </p>
            <p> <mark>'modp14'</mark> = 2048bit prime (minimal recommended) </p>
            <p> <mark>'modp15'</mark> = 3072bit prime </p>
            <p> <mark>'modp16'</mark> = 4096bit prime </p>
            <p> <mark>'modp17'</mark> = 6144bit prime </p>
            <p> <mark>'modp18'</mark> = 8192bit prime </p>
          </div></strong>) <br>
        <strong>crypto</strong>.getDiffieHellman(<strong class="openable">diffHellGroup:str<div>
            <p> - Diffie-Hellman group (pre defined fixed Diffie-Hellman primes) <u>bigger prime = better security</u> </p>
            <p> <mark>'modp1'</mark> = 768bit prime </p>
            <p> <mark>'modp2'</mark> = 1024bit prime </p>
            <p> <mark>'modp5'</mark> = 1536bit prime </p>
            <p> <mark>'modp14'</mark> = 2048bit prime (minimal recommended) </p>
            <p> <mark>'modp15'</mark> = 3072bit prime </p>
            <p> <mark>'modp16'</mark> = 4096bit prime </p>
            <p> <mark>'modp17'</mark> = 6144bit prime </p>
            <p> <mark>'modp18'</mark> = 8192bit prime </p>
          </div></strong>)
      </td>
      <td>
        - creates and returns a <strong>diffieHellman</strong> object with the provided diffie-hellman group <br>
        - in this case we cannot set diffie-hellman keys to the returned <strong>diffieHellman</strong> object (calling the <mark>setPrivateKey()</mark> and <mark>setPublicKey()</mark> is not allowed)
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 0.9.3 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>diffieHellman</strong>.generateKeys(<i class="openable">encode:str<div>
            <p> - the returned public diffie-hellman key is encoded in this format </p>
            <p> - if this option is not provided <strong>buf</strong> will be returned </p>
          </div></i>)
      </td>
      <td>
        - generates the private and public <u>Diffie-Hellman keys</u> <br>
        - the public diffie-hellman key is kept internally and also returned (as <strong>buf</strong>), it should be transfered to the other party <br>
        - the private diffie-hellman key is kept internally (can be retrieved with <mark>getPrivateKey()</mark>)
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 0.5.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>diffieHellman</strong>.getPrivateKey(<i class="openable">encode:str<div>
            <p> - the returned private diffie-hellman key is encoded in this format </p>
            <p> - if this option is not provided <strong>buf</strong> will be returned </p>
          </div></i>)
      </td>
      <td>
        - returns the <u>diffie-hellman private key</u> as <strong>buf</strong> (previously generated by <mark>generateKeys()</mark> or set by <mark>setPrivateKey()</mark>)
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 0.5.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>diffieHellman</strong>.getPublicKey(<i class="openable">encode:str<div>
            <p> - the returned public diffie-hellman key is encoded in this format </p>
            <p> - if this option is not provided <strong>buf</strong> will be returned </p>
          </div></i>)
      </td>
      <td>
        - returns the <u>diffie-hellman public key</u> as <strong>buf</strong> (previously generated by <mark>generateKeys()</mark> or set by <mark>setPublicKey()</mark>)
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 0.5.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>diffieHellman</strong>.setPrivateKey(<strong class="openable">privKeyDiffHell:str|...<div>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView</strong> </p>
            <p> - Diffie-Hellman private key (previously generated by <mark><strong>diffieHellman</strong>.generateKeys()</mark>) </p>
          </div></strong>, <i class="openable">encode:str<div>
            <p> - <strong>privKeyDiffHell</strong> encoding if string passed </p>
          </div></i>)
      </td>
      <td>
        - sets a diffie-hellman private key to the <strong>diffieHellman</strong> object
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 0.5.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>diffieHellman</strong>.setPublicKey(<strong class="openable">pubKeyDiffHell:str|...<div>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView</strong> </p>
            <p> - Diffie-Hellman public key (previously generated by <mark><strong>diffieHellman</strong>.generateKeys()</mark>) </p>
          </div></strong>, <i class="openable">encode:str<div>
            <p> - <strong>pubKeyDiffHell</strong> encoding if string passed </p>
          </div></i>)
      </td>
      <td>
        - sets a diffie-hellman public key to the <strong>diffieHellman</strong> object
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 0.5.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>diffieHellman</strong>.getPrime(<i class="openable">encode:str<div>
            <p> - encoding for the returned string </p>
            <p> - if this option is not provided <strong>buf</strong> is returned </p>
          </div></i>)
      <td>
        - returns the diffie-hellman <strong>prime</strong> in a <strong>buf</strong> (by Default)
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 0.5.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>diffieHellman</strong>.getGenerator(<i class="openable">encode:str<div>
            <p> - encoding for the returned string </p>
            <p> - if this option is not provided <strong>buf</strong> is returned </p>
          </div></i>)
      </td>
      <td>
        - returns the diffie-hellman <strong>gen</strong> (generator) in a <strong>buf</strong> (by Default)
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 0.5.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>diffieHellman</strong>.verifyError
      </td>
      <td>
        - contains a <span class="openable">number<div>
            <p> <mark>1</mark> = <mark><strong>crypto</strong>.constants.DH_CHECK_P_NOT_PRIME</mark> </p>
            <p> <mark>2</mark> = <mark><strong>crypto</strong>.constants.DH_CHECK_P_NOT_SAFE_PRIME</mark> </p>
            <p> <mark>4</mark> = <mark><strong>crypto</strong>.constants.DH_UNABLE_TO_CHECK_GENERATOR</mark> </p>
            <p> <mark>8</mark> = <mark><strong>crypto</strong>.constants.DH_NOT_SUITABLE_GENERATOR</mark> </p>
          </div></span> which indicates any <strong>diffieHellman</strong> warnings/errors
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 0.11.12 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>diffieHellman</strong>.computeSecret(<strong class="openable">pubKeyDiffHell:str|...<div>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView</strong> </p>
            <p> - the diffie-hellman public key that is received from the other party </p>
          </div></strong>, <i class="openable">encodeKey:str<div>
            <p> - <strong>pubKeyDiffHell</strong> encoding if string passed </p>
          </div></i>, <i class="openable">encodeOut:str<div>
            <p> - encoding of the returned string </p>
            <p> - if this option is not provided <strong>buf</strong> is returned </p>
          </div></i>)
      </td>
      <td>
        - <span class="openable">computes<div>
            <p> - takes the internal diffie-hellman private key and the received other party's diffie-hellman public key then calculates the shared secret </p>
          </div></span> and returns the shared diffie-hellman secret as <strong>buf</strong> (by Default)
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 0.5.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td colspan="2">
        ECDH (Elliptic Curve Diffie-Hellman key exchange utility)
      </td>
    </tr>
    <tr>
      <td>
        ECDH.convertKey(<strong class="openable">pubKeyECDH:str|...<div>
            <p><strong>str|buf|ArrayBuffer|TypedArray|DataView</strong></p>
          </div></strong>, <strong>eCurve:str</strong>, <i>inEncode:str</i>, <i class="openable">outEncode:str<div>
            <p> - if this option is specified the returned value will be a string in this encoded format, otherwise the returned value is a <i>buf</strong> </p>
          </div></i>, <i class="openable">format:str<div>
            <p> <mark>'uncompressed'</mark> (Default) / <mark>'compressed'</mark> / <mark>'hybrid'</mark> </p>
          </div></i>)
      </td>
      <td>
        - converts the passed <strong>pubKeyECDH</strong> and <strong>eCurve</strong> into the specified format (compressed or uncompressed) and returns the converted <strong>pubKeyECDH</strong>
        <span class="browserSupport" title="updated : 2021-03-27">
          <span><i class="fab fa-node-js"></i> 10.0.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        createECDH(<strong>eCurve:str</strong>)
      </td>
      <td>
        - creates and returns an <strong>ecdh</strong> object with the provided elliptic curve
        <span class="browserSupport" title="updated : 2021-03-27">
          <span><i class="fab fa-node-js"></i> 0.11.14 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>ecdh</strong>.generateKeys(<i class="openable">encode:str<div>
            <p> - the returned public ECDH key is encoded in this format </p>
            <p> - if this option is not provided <strong>buf</strong> will be returned </p>
          </div></i>, <i class="openable">format:str<div>
            <p> - <mark>'uncompressed'</mark> (Default) / <mark>'compressed'</mark> </p>
          </div></i>)
      </td>
      <td>
        - generates the private and public <u>ECDH keys</u> <br>
        - the public ECDH key is kept internally and also returned (as <strong>buf</strong> in the specified <i>format</i> (uncompressed or compressed)), it should be transfered to the other party <br>
        - the private ECDH key is kept internally (can be retrieved with <mark>getPrivateKey()</mark>)
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 0.11.14 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>ecdh</strong>.getPrivateKey(<i class="openable">encode:str<div>
            <p> - the returned private ecdh key is encoded in this format </p>
            <p> - if this option is not provided <strong>buf</strong> will be returned </p>
          </div></i>)
      </td>
      <td>
        - returns the <u>ecdh private key</u> as <strong>buf</strong> (previously generated by <mark>generateKeys()</mark> or set by <mark>setPrivateKey()</mark>)
        <span class="browserSupport" title="updated : 2021-03-27">
          <span><i class="fab fa-node-js"></i> 0.11.14 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>ecdh</strong>.getPublicKey(<i class="openable">encode:str<div>
            <p> - the returned public ecdh key is encoded in this format </p>
            <p> - if this option is not provided <strong>buf</strong> will be returned </p>
          </div></i>, <i class="openable">format:str<div>
            <p> - <mark>'uncompressed'</mark> (Default) / <mark>'compressed'</mark> </p>
          </div></i>)
      </td>
      <td>
        - returns the <u>ecdh public key</u> as <strong>buf</strong> (previously generated by <mark>generateKeys()</mark> or set by <mark>setPublicKey()</mark>)
        <span class="browserSupport" title="updated : 2021-03-27">
          <span><i class="fab fa-node-js"></i> 0.11.14 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>ecdh</strong>.setPrivateKey(<strong class="openable">privKeyECDH:str|...<div>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView</strong> </p>
            <p> - ECDH private key (previously generated by <mark><strong>ecdh</strong>.generateKeys()</mark>) </p>
          </div></strong>, <i class="openable">encode:str<div>
            <p> - <strong>privKeyECDH</strong> encoding if string passed </p>
          </div></i>)
      </td>
      <td>
        - sets an ECDH private key to the <strong>ecdh</strong> object
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 0.11.14 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>ecdh</strong>.setPublicKey(<strong class="openable">pubKeyECDH:str|...<div>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView</strong> </p>
            <p> - ECDH public key (previously generated by <mark><strong>ecdn</strong>.generateKeys()</mark>) </p>
          </div></strong>, <i class="openable">encode:str<div>
            <p> - <strong>pubKeyECDH</strong> encoding if string passed </p>
          </div></i>)
      </td>
      <td>
        - <u class="openable">[DEPRECATED v5.2.0]<div>
            <p> - because the <strong>ecdh</strong> only needs the ECDH private key and the other party's public key to compute the shared secret </p>
          </div></u> sets an ECDH public key to the <strong>ecdh</strong> object
        <span class="browserSupport" title="updated : 2021-03-26">
          <span><i class="fab fa-node-js"></i> 0.11.14 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>ecdh</strong>.computeSecret(<strong class="openable">pubKeyECDH:str|...<div>
            <p> <strong>str|buf|ArrayBuffer|TypedArray|DataView</strong> </p>
            <p> - the ECDH public key that is received from the other party </p>
          </div></strong>, <i class="openable">encodeKey:str<div>
            <p> - <strong>pubKeyECDH</strong> encoding if string passed </p>
          </div></i>, <i class="openable">encodeOut:str<div>
            <p> - encoding of the returned string </p>
            <p> - if this option is not provided <strong>buf</strong> is returned </p>
          </div></i>)
      </td>
      <td>
        - <span class="openable">computes<div>
            <p> - takes the internal ECDH private key and the received other party's ECDH public key then calculates the shared secret </p>
          </div></span> and returns the shared ECDH secret as <strong>buf</strong> (by Default)
        <span class="browserSupport" title="updated : 2021-03-27">
          <span><i class="fab fa-node-js"></i> 0.11.14 </span>
          <span class="openable"> more...<div>
              <p> 6.0.0 </p>
              <p> - default encoding changed from <mark>binary</mark> to <mark>utf-8</mark> </p>
            </div></span>
        </span>
      </td>
    </tr>
  </table>
  <br>
  <table class="table">
    <caption>
      X509 Certificate
    </caption>
    <tr>
      <th style="width:30%;"> Method / Property </th>
      <th> Description </th>
    </tr>
    <tr>
      <td>
        new <strong>crypto</strong>.X509Certificate(<strong class="openable">cert:buf<div>
            <p> <strong>str|buf|TypedArray|DataView</strong></p>
            <p> - <mark>pem</mark> or <mark>der</mark> encoded X509 Certificate </p>
          </div></strong>)
      </td>
      <td>
        - wraps the passed <mark>pem</mark> or <mark>der</mark> encoded certifiate and returns it in a new <strong>x509</strong> object
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>x509</strong>.ca
      </td>
      <td>
        - returns <mark>true</mark> if the Certificate is a Certificate Authority certificate (certificate that is used to sign <span class="openable">CRS<div>
            <p> Certificate Signing Request </p>
          </div></span>), otherwise <mark>false</mark>
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>x509</strong>.subject
      </td>
      <td>
        - returns the complete certificate's <span class="openable">subject<div>
            <p> <mark>C</mark> = countryName </p>
            <p> <mark>O</mark> = organizationName </p>
            <p> <mark>OU</mark> = organizationalUnitName </p>
            <p> <mark>dnQualifier</mark> = distinguished name qualifier </p>
            <p> <mark>ST</mark> = state or province name </p>
            <p> <mark>CN</mark> = common name (FQDN like <mark>www.google.com</mark>) </p>
            <p> <mark>serialNumber</mark> = serial number </p>
            <p> <mark>OCSP</mark> - </p>
            <p> <mark>CA Issuers</mark> = Certificate Authority Isuer (the ICA that signed this certificate) </p>
          </div><span>
            <span class="browserSupport" title="updated : 2021-03-30">
              <span><i class="fab fa-node-js"></i> 15.6.0 </span>
            </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>x509</strong>.subjectAltName
      </td>
      <td>
        - returns the certificate's alternative names (domain name / IP)
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>x509</strong>.issuer
      </td>
      <td>
        - returns the certificate's issuers identification
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>x509</strong>.issuerCertificate
      </td>
      <td>
        - returns the issuers <strong>x509</strong> certificate (if available)
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 15.9.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>x509</strong>.infoAccess
      </td>
      <td>
        - returns the information access content of this certificate (returned the URL to the ICA's certificate)
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>x509</strong>.serialNumber
      </td>
      <td>
        - returns certificate serial number in a string
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>x509</strong>.checkEmail(<strong>eMail:str</strong>, <i class="openable">option:obj<div>
            <p> subject: 'always|never' - (Default: <mark>always</mark>) </p>
            <p> wildcards: <strong>bol</strong> - (Default: <mark>true</mark>) </p>
            <p> partialWildcards: <strong>bol</strong> - (Default: <mark>true</mark>) </p>
            <p> multiLabelWildcards: <strong>bol</strong> - (Default: <mark>false</mark>) </p>
            <p> singleLableSubdomains: <strong>bol</strong> - (Default: <mark>false</mark>) </p>
          </div></i>)
      </td>
      <td>
        - returns the <strong>eMail</strong> if the passed <strong>eMail</strong> matches the certificate, <mark>undefined</mark> otherwise
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>x509</strong>.checkHost(<strong class="openable">hostName:str<div>
            <p> hostname = FQDN (ex: <mark>www.google.com</mark>) </p>
          </div></strong>, <i class="openable">option:obj<div>
            <p> subject: 'always|never' - (Default: <mark>always</mark>) </p>
            <p> wildcards: <strong>bol</strong> - (Default: <mark>true</mark>) </p>
            <p> partialWildcards: <strong>bol</strong> - (Default: <mark>true</mark>) </p>
            <p> multiLabelWildcards: <strong>bol</strong> - (Default: <mark>false</mark>) </p>
            <p> singleLableSubdomains: <strong>bol</strong> - (Default: <mark>false</mark>) </p>
          </div></i>)
      </td>
      <td>
        - returns the <strong>hostName</strong> if the passed <strong>hostName</strong> matches the certificate, <mark>undefined</mark> otherwise
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>x509</strong>.checkIP(<strong>ip:str</strong>, <i class="openable">option:obj<div>
            <p> subject: 'always|never' - (Default: <mark>always</mark>) </p>
            <p> wildcards: <strong>bol</strong> - (Default: <mark>true</mark>) </p>
            <p> partialWildcards: <strong>bol</strong> - (Default: <mark>true</mark>) </p>
            <p> multiLabelWildcards: <strong>bol</strong> - (Default: <mark>false</mark>) </p>
            <p> singleLableSubdomains: <strong>bol</strong> - (Default: <mark>false</mark>) </p>
          </div></i>)
      </td>
      <td>
        - returns the <strong>ip</strong> if the passed <strong>ip</strong> matches the certificate, <mark>undefined</mark> otherwise (can be IPv4 or IPv6)
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>x509</strong>.validFrom
      </td>
      <td>
        - date/time the certificate is valid from
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>x509</strong>.validTo
      </td>
      <td>
        - date/time the certificate is valid to
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>x509</strong>.fingerprint
      </td>
      <td>
        - returns the SHA-1 fingerprint of the certificate in a string
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>x509</strong>.fingerprint256
      </td>
      <td>
        - returns the SHA-256 fingerprint of the certificate in a string
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>x509</strong>.publicKey
      </td>
      <td>
        - returns the certificate's public key in a <strong>keyObj</strong>
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>x509</strong>.keyUsage
      </td>
      <td>
        - return an Array which defines how the public key may be used (I don't know what is this)
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>x509</strong>.raw
      </td>
      <td>
        - returns the <mark>der</mark> encoded certificate in a <strong>buf</strong>
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>x509</strong>.toString()
      </td>
      <td>
        - returns the <mark>pem</mark> encoded certificate in a <strong>str</strong>
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>x509</strong>.toJSON()
      </td>
      <td>
        - returns the <mark>pem</mark> encoded certificate in a <strong>str</strong> (there's no JSON standard encoding for X509 Certificates)
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>x509</strong>.toLegacyObject()
      </td>
      <td>
        - returns the certificate in a <span class="openable">JavaScript (legacy) object<div>
            <p> subject: <strong>str</strong> </p>
            <p> issuer: <strong>str</strong> </p>
            <p> subjectaltname: <strong>str</strong> </p>
            <p> infoAccess: <strong>str</strong> </p>
            <p> bits: <strong>nr</strong> </p>
            <p> pubkey: <strong>buf</strong> </p>
            <p> asn1Curve: <strong>str</strong> </p>
            <p> nistCurve: <strong>str</strong> </p>
            <p> valid_from: <strong>date/time:str</strong> </p>
            <p> valid_to: <strong>date/time:str</strong> </p>
            <p> fingerprint: <strong>str</strong> </p>
            <p> fingerprint256: <strong>str</strong> </p>
            <p> ext_key_usage: <strong>arr</strong> </p>
            <p> serialNumber: <strong>nr</strong> </p>
            <p> raw: <strong>buf</strong> </p>
          </div></span>
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>x509</strong>.checkIssued(<strong>ca:x509</strong>)
      </td>
      <td>
        - returns <mark>true</mark> if the <strong>x509</strong> certificate was issued by the passed Certificate Authority's certificate <strong>ca</strong>, otherwise returns <mark>false</mark>
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>x509</strong>.verify(<strong>pubKey:keyObj</strong>)
      </td>
      <td>
        - returns <mark>true</mark> if the certificate was signed with the passed <strong>pubKey</strong>, otherwise <mark>false</mark>
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>
        <strong>x509</strong>.checkPrivateKey(<strong>privKey:keyObj</strong>)
      </td>
      <td>
        - returns <mark>true</mark> if the passed <strong>privKey</strong> is the pair of the certificate's public key, otherwiser <mark>false</mark>
        <span class="browserSupport" title="updated : 2021-03-30">
          <span><i class="fab fa-node-js"></i> 15.6.0 </span>
        </span>
      </td>
    </tr>
  </table>
  <br>
  <details class="example" id="notes">
    <summary> Notes :</summary>
    <p> - I did not tested the <mark>Certificate</mark> class, it was designed to work with SPKAC data (<mark>&lt;keygen&gt;</mark> element) which is deprecated in HTML 5.2</p>
    <p> - <mark>Certificate.exportChallenge()</mark> / <mark>Certificate.exportPublicKey()</mark> / <mark>Certificate.verifySpkac()</mark> </p>
    <p> - <mark>exportChallenge()</mark> / <mark>exportPublicKey()</mark> / <mark>verifySpkac()</mark> </p>
    <hr>
  </details>
  <h2 class="headerSection"> Useful Links : </h2>
  <p><a href="https://nodejs.org/dist/latest-v15.x/docs/api/crypto.html" target="_blank">Node.js Crypto (nodejs.org) </a></p>
  <h2 class="headerSection"> Remember This : </h2>
  <p> - any encryped data (data, keys, hash, etc...) should never be stored as <mark>utf-8</mark> encrypted, because the encrypted binary data cannot be correctly translated as utf-8 characters (<mark>hex</mark>, <mark>habse64</mark> encodings are recommended instead) </p>
  <p> - currently (2021-03-17) Node.js supports only <mark>GCM</mark>, <mark>CCM</mark> and <mark>OCB</mark> authenticated encryption modes, <u>when using authenticated encryption modes stream cipher should not be used (use the <mark>update()</mark> and <mark>final()</mark> approach instead)</u> </p>
  <p> - the initialization vector ('iv' or 'Nonce') must not be secret but must be an unpredictable random data </p>
  <h2 class="headerSection"> Description and Demonstration : </h2>
  <p> - the <mark>crypto</mark> module (library) is an OpenSSL wrapper (abstraction over OpenSSL in Node.js) </p>
  <p> - it provides cryptographyc functionalities (generating keys, cipher, decipher, sign, verify, hash, hmac, Diffiel-Hellman key exchange, x509 certificate) </p>
  <hr>
  <!---------------------------------------------------------------------------------------------------------------->
  <h2 style="color:darkblue;"><u> <mark>constants</mark> / <mark>getCiphers()</mark> / <mark>getCurvers()</mark> / <mark>getHashes()</mark> / <mark>getFips()</mark> / <mark>setFips()</mark> / <mark>randomBytes()</mark> / <mark>randomFill()</mark> / <mark>randomFillSync()</mark> / <mark>randomInt()</mark> / <mark>randomUUID()</mark> / <mark>secureHeapUsed()</mark> / <mark>setEngine()</mark> / <mark>timingSafe()</mark> / <mark>webcrypto</mark> </u></h2>
  <details class="example">
    <summary> DEMO </summary>
    <h4 style="color:darkblue;"><u> <mark>constants</mark> / <mark>getCiphers()</mark> / <mark>getCurves()</mark> / <mark>getHashes()</mark> / <mark>getFips()</mark> / <mark>setFips()</mark> </u></h4>
    <pre>
    const crypto = require('crypto');
    
// constants / getCiphers() / getCurves() / getHashes() -------------------------------
    crypto.constants;                                                                  // -> {OPENSSL_VERSION_NUMBER:269488303, ...}    // constants of the crypto module 
    
    crypto.getCiphers();                                                               // -> ['aes-128-cbc', ...]                       // returns the supported ciphers 
    crypto.getCurves();                                                                // -> ['Oakley-EC2N-3', ...]                     // returns the supported ellic curves (for Diffie-Hellman key exchange)    
    crypto.getHashes();                                                                // -> ['RSA-MD4', ...]                           // returns the supported 
    
// getFips() / setFips() --------------------------------------------------------------
    crypto.getFips()                                                                   // -> 0                                          // module is not FIPS complient 
    
    crypto.setFips(true);                                                              // error is thrown because this crypto module is not Fips compliant   
    </pre>
    <h4 style="color:darkblue;"><u> <mark>randomBytes()</mark> / <mark>randomFill()</mark> / <mark>randomFillSync()</mark> / <mark>randomInt()</mark> / <mark>randomUUID()</mark> </u></h4>
    <pre>
    const crypto = require('crypto');
    
// randomBytes() ----------------------------------------------------------------------
    crypto.randomBytes(16);                                                            // -> &lt;Buffer ...&gt;             // 16 bytes buffer randomly assigned    
    
    crypto.randomBytes(16, function(err, buf){                                         // asynchronous 
        buf;                                                                           // -> &lt;Buffer ...&gt;             // 16 bytes buffer randomly assigned    
    });
    
    
// randomFill() / randomFillSync() ----------------------------------------------------
    var buf = Buffer.alloc(8);                                                         // zero-filled buffers 
    var buf2 = Buffer.alloc(8);
    
    crypto.randomFill(buf, 1, 5, function(err, buf){                                   
        buf;                                                                           // -> &lt;Buffer 00 86 dd 79 04 1c 00 00&gt;
    })
    
    crypto.randomFillSync(buf2, 2, 2);                                                 // -> &lt;Buffer  00 00 c2 c5 00 00 00 00&gt;
    
    
// randomInt() ------------------------------------------------------------------------
    crypto.randomInt(25, 76)                                                           // -> 26                       // random integer between 25-76 (76 excluded)    
    
    crypto.randomInt(100, function(err, int){                                          // asynchronous                // random integer between 0-100 (100 excluded)    
        int;                                                                           // -> 91
    })
    
    
// randomUUID() -----------------------------------------------------------------------
    crypto.randomUUID()                                                                // -> 'b55ba342-62bc-4dfc-ac27-17698e7884e3'
    </pre>
    <h4 style="color:darkblue;"><u> <mark>secureHeapUsed()</mark> </u></h4>
    <pre>
// process tarted with 'node main'-----------------------------------------------------
// ------------------------------------------------------------------------------------
    crypto.secureHeapUsed()                                                            // -> {total:0, used:0, utilization:0, min:0}        // OpenSSL secure heap not enabled by default
    
    
// process tarted with 'node --secure-heap=512 --secure-heap-min=8 main'---------------
// ------------------------------------------------------------------------------------
    crypto.secureHeapUsed()                                                            // -> {total:512, used:0, utilization:0, min:8}      // OpenSSL secure heap enabled (512 bytes allocated for the secure heap and at least 8 bytes must be used)     
    </pre>
    <h4 style="color:darkblue;"><u> <mark>timingSafeEqual()</mark> </u></h4>
    <pre>
    const crypto = require('crypto');
    
    var buf1 = Buffer.from('1234', 'hex');
    var buf2 = Buffer.from('1234', 'hex');
    var buf3 = Buffer.from('1235', 'hex');
    
    crypto.timingSafeEqual(buf1, buf2)                                                 // -> true       // -! both comparisons make the same time (timing attack proof)    
    
    crypto.timingSafeEqual(buf1, buf3)                                                 // -> false 
    </pre>
  </details>
  <details class="example">
    <summary> Example : </summary>
    <h4 style="color:darkblue;"><u> <mark>getFips()</mark> / <mark>setFips()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    
    console.log( crypto.getFips() );                                                   // -> 0          // fips not enabled 
    
    crypto.setFips(true);                                                              // in my case this throws an error because this crypto module is not FIPS compliant (obviously)   
    </pre>
    <hr>
    <!---------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> <mark>randomBytes()</mark> / <mark>randomFill()</mark> / <mark>randomFillSync()</mark> / <mark>randomInt()</mark> / <mark>randomUUID()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    
// randomBytes() ----------------------------------------------------------------------
    console.log( crypto.randomBytes(16) );                                             // -> &lt;Buffer ...&gt;             // 16 bytes buffer randomly assigned    
    
    crypto.randomBytes(16, function(err, buf){                                         // -! asynchronous 
        console.log(buf);                                                              // -> &lt;Buffer ...&gt;             // 16 bytes buffer randomly assigned    
    });
    
    
// randomFill() / randomFillSync() ----------------------------------------------------
    var buf = Buffer.alloc(8);                                                         // zero-filled buffers 
    var buf2 = Buffer.alloc(8);
    
    crypto.randomFill(buf, 1, 5, function(err, buf){                                   
        console.log( buf );                                                            // -> &lt;Buffer 00 86 dd 79 04 1c 00 00&gt;
    })
    
    console.log( crypto.randomFillSync(buf2, 2, 2) );                                  // -> &lt;Buffer  00 00 c2 c5 00 00 00 00&gt;
    
    
// randomInt() ------------------------------------------------------------------------
    crypto.randomInt(100, function(err, int){                                          // -! asynchronous             // random integer between 0-100 (100 excluded)    
        console.log( int );                                                            // -> 91
    })
    
    console.log(
        crypto.randomInt(25, 76)                                                       // -> 26                       // random integer between 25-76 (76 excluded)    
    )
    
    
// randomUUID() -----------------------------------------------------------------------
    console.log(
        crypto.randomUUID()                                                            // -> 'b55ba342-62bc-4dfc-ac27-17698e7884e3'
    )
    </pre>
    <hr>
    <!---------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> <mark>secureHeapUsed()</mark> TEST </u></h4>
    <pre>
// process tarted with 'node main'-----------------------------------------------------
// ------------------------------------------------------------------------------------
    console.log(
        crypto.secureHeapUsed()                                                        // -> {total:0, used:0, utilization:0, min:0}        // OpenSSL secure heap not enabled by default
    )
    
// process tarted with 'node --secure-heap=512 --secure-heap-min=8 main'---------------
// ------------------------------------------------------------------------------------
    console.log(
        crypto.secureHeapUsed()                                                        // -> {total:512, used:0, utilization:0, min:8}      // OpenSSL secure heap enabled (512 bytes allocated for the secure heap)     
    )
    </pre>
    <hr>
    <!---------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> <mark>timingSafeEqual()</mark> TEST </u></h4>
    <p> - both operations makes the same time to complete = timing attack proof </p>
    <pre>
    const crypto = require('crypto');
    
    var buf1 = Buffer.from('1234', 'hex');
    var buf2 = Buffer.from('1234', 'hex');
    var buf3 = Buffer.from('1235', 'hex');
    
    console.log(
        crypto.timingSafeEqual(buf1, buf2)                                             // -> true
    );
    
    console.log(
        crypto.timingSafeEqual(buf1, buf3)                                             // -> false 
    );
    </pre>



  </details>
  <hr>
  <!---------------------------------------------------------------------------------------------------------------->
  <h2 style="color:darkblue;"><u> Keys <mark>createSecretKey()</mark> / <mark>generateKey()</mark> / <mark>generateKeySync()</mark> / <mark>generateKeyPair()</mark> / <mark>generateKeyPairSync()</mark> / <mark>createPrivateKey()</mark> / <mark>createPublicKey()</mark> / <mark>hkdf()</mark> / <mark>hkdfSync()</mark> / <mark>scrypt()</mark> / <mark>scryptSync()</mark> / <mark>pbkdf2()</mark> / <mark>pbkdf2Sync()</mark> / <mark>from()</mark> / <mark>export()</mark> / <mark>type</mark> / <mark>symmetricKeySize</mark> / <mark>asymmetricKeyType</mark> / <mark>asymmetricKeyDetails</mark> </u></h2>
  <details class="example">
    <summary> DEMO </summary>
    <h4 style="color:darkblue;"><u> <mark>createSecretKey()</mark> / <mark>generateKey()</mark> / <mark>generateKeySync()</mark></u></h4>
    <pre>
    const crypto = require('crypto');
    
// createSecretKey() ------------------------------------------------------------------
    crypto.createSecretKey('41548795455487621afd14351574646as', 'hex');                // -> keyObj     // this basically wraps the passed data into a secret key object   
        
// generateKey() / generateKeySync() --------------------------------------------------    
    crypto.generateKey('aes', {length:128}, function(err, key){                        // asynchronously generates an 'aes 128 bit long' random symmetric key    
        key;                                                                           // -> keyObj 
    })
    
    crypto.generateKeySync('aes', {length:128});                                       // -> keyObj     // synchronously generates an 'aes 128 bit long' random symmetric key    
    </pre>
    <h4 style="color:darkblue;"><u> <mark>generateKeyPair()</mark> / <mark>generateKeyPairSync()</mark> </u></h4>
    <pre>
    const crypto = require('crypto');
    
// generateKeyPair() / generateKeyPairSync() ------------------------------------------
    crypto.generateKeyPair('rsa', {modulusLength:2048}, function(err, pubKey, privKey){  // asynchronously generates an rsa private/public key pair    
        pubKey;                                                                        // -> keyObj     // public key
        privKey;                                                                       // -> keyObj     // private key
    });
    
    var keys = crypto.generateKeyPairSync('rsa', {modulusLength:1024});                // synchronously generates an rsa private/public key pair 
    keys.publicKey;                                                                    // -> keyObj     // public key
    keys.privateKey;                                                                   // -> keyObj     // private ke
    </pre>
    <h4 style="color:darkblue;"><u> <mark>createPrivateKey()</mark> / <mark>createPublicKey()</mark> </u></h4>
    <p> - this method is mostly used to import and use keys from files </p>
    <pre>
    const crypto = require('crypto');
    
    var keys = crypto.generateKeyPairSync('rsa', {
        modulusLength: 1024,
        publicKeyEncoding: {format:'pem', type:'pkcs1'},
        privateKeyEncoding: {format:'pem', type:'pkcs1'}
    });
    
    var pubKey = keys.publicKey;                                                       // public key in 'pem' format
    var privKey = keys.privateKey;                                                     // private key in 'pem' format
    
    crypto.createPublicKey(pubKey);                                                    // -> keyObj     // the passed 'pem' key is transformed into a keyObj     
    crypto.createPrivateKey(privKey);                                                  // -> keyObj     // the passed 'pem' key is transformed into a keyObj     
    </pre>
    <h4 style="color:darkblue;"><u> <mark>hkdf()</mark> / <mark>hkdfSync()</mark> / <mark>pbkdf2()</mark> / <mark>pbkdf2Sync()</mark> / <mark>scrypt()</mark> / <mark>scryptSync()</mark> </u></h4>
    <pre>
    const crypto = require('crypto');
    
// hkdf() / hkdfSync() ----------------------------------------------------------------
    crypto.hkdf('sha256', 'myKey', 'someSalt', 'info', 32, function(err, key){         // asynchronously generates a secret key matterial from the passed stuff   
            key;                                                                       // -> &lt;ArrayBuffer b6 87 45 ... &gt;
        });
    
    crypto.hkdfSync('sha256', 'myKey', 'someSalt', 'info', 32);                        // -> &lt;ArrayBuffer b6 87 45 ... &gt;  // synchronously generates a secret key matterial from the passed stuff    
    
// scrypt() / scryptSync() ------------------------------------------------------------
    crypto.scrypt('pass', 'someSalt', 32, function(err, key){                          // asynchronously generates a secret key matterial from the passed stuff   
        key;                                                                           // -> &lt;Buffer f4 aa ca ... &gt;
    })
    
    crypto.scryptSync('pass', 'someSalt', 32);                                         // -> &lt;Buffer f4 aa ca ... &gt;       // synchronously generates a secret key matterial from the passed stuff    
    
// pbkdf2() / pbkdf2Sync() ------------------------------------------------------------
    crypto.pbkdf2('pass', 'someSalt', 10, 32, 'sha256', function(err, key){            // asynchronously generates a secret key matterial from the passed stuff   
        key;                                                                           // -> &lt;Buffer b6 de 48 ... &gt; 
    })
    
    crypto.pbkdf2Sync('pass', 'someSalt', 10, 32, 'sha256');                           // -> &lt;Buffer b6 de 48 ... &gt;       // synchronously generates a secret key matterial from the passed stuff    
    </pre>
    <h4 style="color:darkblue;"><u> KeyObject <mark>export()</mark> / <mark>type</mark> / <mark>symmetricKeySize</mark> / <mark>asymmetricKeyType</mark> / <mark>asymmetricKeyDetails</mark> </u></h4>
    <pre>
    const crypto = require('crypto');
    
    var keyPair = crypto.generateKeyPairSync('rsa', {modulusLength:1024})
    
    var secretKey = crypto.generateKeySync('aes', {length:128});
    var publicKey = keyPair.publicKey;
    var privateKey = keyPair.privateKey;
    
// export() ---------------------------------------------------------------------------
  // secret key ------------------------------------------
    secretKey.export({format:'buffer'});                                               // -> &lt;Buffer ca 0a ba 6a ... &gt;                  // binary format 
    secretKey.export({format:'jwk'});                                                  // -> {kty:'oct', k:'ygq6alUG38nnuH3Fen-_Ww'}    // JSON web key format    
    
  // public key ------------------------------------------
    publicKey.export({format:'pem', type:'pkcs1'});                                    // -> '-----BEGIN RSA PUBLIC KEY----- ...'       // pem format    
    publicKey.export({format:'der', type:'pkcs1'});                                    // -> &lt;Buffer 30 81 89 02 ... &gt;                  // der format (binary encoded)    
    publicKey.export({format:'jwk', type:'pkcs1'});                                    // -> {kty:'RSA', n:'z_ag ...'}                  // JSON Web Key format    
    
  // private key -----------------------------------------
    privateKey.export({format:'pem', type:'pkcs1'});                                   // -> '-----BEGIN RSA PRIVATE KEY----- ...'      // pem format    
    privateKey.export({format:'der', type:'pkcs1'});                                   // -> '&lt;Buffer 30 82 02 5c ... &gt;                 // der format (binary encoded)    
    privateKey.export({format:'jwk', type:'pkcs1'});                                   // -> {kty:'RSA', n:'XclpdH ...'}                // JSON Web Key format    
    
// type / symmetricKeySize / asymmetricKeyType / asymmetricKeyDetails -----------------
    secretKey.type;                                                                    // -> 'secret'
    publicKey.type;                                                                    // -> 'public'
    privateKey.type;                                                                   // -> 'private'
    
    secretKey.symmetricKeySize;                                                        // -> 16
    publicKey.symmetricKeySize;                                                        // -> undefined
    privateKey.symmetricKeySize;                                                       // -> undefined
    
    secretKey.asymmetricKeyType;                                                       // -> 'rsa'
    publicKey.asymmetricKeyType;                                                       // -> 'rsa'
    privateKey.asymmetricKeyType;                                                      // -> undefined  
    
    secretKey.asymmetricKeyDetails;                                                    // -> undefined  
    publicKey.asymmetricKeyDetails;                                                    // -> {modulusLength:1024, publicExponent:65537n}    
    privateKey.asymmetricKeyDetails;                                                   // -> {modulusLength:1024, publicExponent:65537n}    
    </pre>
  </details>
  <details class="example">
    <summary> Example : </summary>
    <h4 style="color:darkblue;"><u> <mark>createSecretKey()</mark> / <mark>generateKey()</mark> / <mark>generateKeySync()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    
// createSecretKey() ------------------------------------------------------------------
    let key1 = crypto.createSecretKey('41548795455487621afd14351574646as', 'hex');     // this basically wraps the passed data into a secret key object   
    
    const cipher = crypto.createCipheriv('aes-128-ecb', key1, null);
    
    var secret = cipher.update('encode this data', 'utf-8', 'hex');
    secret += cipher.final('hex');
    
    console.log( secret );                                                             // -> '23c5fdcf45971bcce47d2c6c74a727d188e82874ba2736d865ff0aa3ae2275dc'  
    
    const decipher = crypto.createDecipheriv('aes-128-ecb', key1, null);
    var decode = decipher.update(secret, 'hex', 'utf-8');
    decode += decipher.final('utf-8');
    
    console.log( decode );                                                             // -> 'encode this data'
    
    
// generateKey() ----------------------------------------------------------------------
    let key2 = crypto.generateKeySync('aes', {length:128})                             // synchronously generates an 'aes 128 bit long' random symmetric key    
    
    const cipher2 = crypto.createCipheriv('aes-128-ecb', key2, null);
    
    var secret2 = cipher2.update('encode this data', 'utf-8', 'hex');
    secret2 += cipher2.final('hex');
    
    console.log( secret2 );                                                            // -> '742cfd2d0ef3ff0733c9fc720b2e5e6ad4a71b88e59b2e913f057bc8c9cf6b67'    
    
    const decipher2 = crypto.createDecipheriv('aes-128-ecb', key2, null);
    var decode2 = decipher2.update(secret2, 'hex', 'utf-8');
    decode2 += decipher2.final('utf-8');
    
    console.log( decode2 );                                                            // -> 'encode this data'    
    
    
// generateKeySync() ------------------------------------------------------------------
    crypto.generateKey('aes', {length:128}, function(err, key){                        // asynchronously generates an 'aes 128 bit long' random symmetric key    
        const cipher = crypto.createCipheriv('aes-128-ecb', key1, null);
    
        var secret = cipher.update('encode this data', 'utf-8', 'hex');
        secret += cipher.final('hex');
    
        console.log( secret );                                                         // -> '23c5fdcf45971bcce47d2c6c74a727d188e82874ba2736d865ff0aa3ae2275dc'
    
        const decipher = crypto.createDecipheriv('aes-128-ecb', key1, null);
        var decode = decipher.update(secret, 'hex', 'utf-8');
        decode += decipher.final('utf-8');
    
        console.log( decode );                                                         // -> 'encode this data'
    })
    </pre>
    <hr>
    <!---------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> <mark>generateKeyPair()</mark> / <mark>generateKeyPairSync()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    
// generateKeyPairSync() --------------------------------------------------------------
    var keys = crypto.generateKeyPairSync('rsa', {modulusLength:1024});                // synchronously generates an rsa private/public key pair 
    
    var pubKey = keys.publicKey;
    var privKey = keys.privateKey;
    
    var encryptedData = crypto.privateEncrypt(privKey, 'data to encrypt...');
    console.log( encryptedData );                                                      // -> &lt;Buffer ...&gt;         // encrypted 
    
    var decryptedData = crypto.publicDecrypt(pubKey, encryptedData);
    console.log( decryptedData.toString() );                                           // -> 'data to encrypt...'       // decrypted  
    
// generateKeyPair() -----------------------------------------------------------------
    crypto.generateKeyPair('rsa', {modulusLength:2048}, function(err, pubKey, privKey){     // asynchronously generates an rsa private/public key pair    
        var encryptedData = crypto.privateEncrypt(privKey, 'data to encrypt...');
        console.log( encryptedData );                                                  // -> &lt;Buffer ...&gt;         // encrypted 
        
        var decryptedData = crypto.publicDecrypt(pubKey, encryptedData);
        console.log( decryptedData.toString() );                                       // -> 'data to encrypt...'       // decrypted  
    })
    </pre>
    <hr>
    <!---------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> <mark>createPrivateKey()</mark> / <mark>createPublicKey()</mark> TEST </u></h4>
    <p> - in this test I generated the asymmetric key pair but these methods mostly used for import already existing asymmetric key paris (from files) </p>
    <pre>
    const crypto = require('crypto');
    
    var keys = crypto.generateKeyPairSync('rsa', {
        modulusLength: 1024,
        publicKeyEncoding: {format:'pem', type:'pkcs1'},
        privateKeyEncoding: {format:'pem', type:'pkcs1'}
    });
    
    var pubKey = keys.publicKey;                                                       // public key in 'pem' format
    var privKey = keys.privateKey;                                                     // private key in 'pem' format
    
    var wrapPubKey = crypto.createPublicKey(pubKey);                                   // returns a keyObj from the passed valid public key material    
    var wrapPrivKey = crypto.createPrivateKey(privKey);                                // returns a keyObj from the passed value private key material    
    
    
    var encrypted = crypto.privateEncrypt(wrapPrivKey, 'original data...');           
    console.log( encrypted );   
    
    var decrypt = crypto.publicDecrypt(wrapPubKey, encrypted);
    console.log( decrypt.toString() );                                                 // -> 'original data...'  // decrypted 
    </pre>
    <hr>
    <!---------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> <mark>hkdf()</mark> / <mark>hkdfSync()</mark> / <mark>pbkdf2()</mark> / <mark>pbkdf2Sync()</mark> / <mark>scrypt()</mark> / <mark>scryptSync()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    
// hkdf() / hkdfSync() ----------------------------------------------------------------
    crypto.hkdf('sha256', 'myKey', 'someSalt', 'info', 32, function(err, key){
            console.log( key );                                                        // -> &lt;ArrayBuffer b6 87 45 ... &gt;
        });
    
    console.log(
        crypto.hkdfSync('sha256', 'myKey', 'someSalt', 'info', 32)                     // -> &lt;ArrayBuffer b6 87 45 ... &gt;
    )
    
    
// scrypt() / scryptSync() ------------------------------------------------------------
    crypto.scrypt('pass', 'someSalt', 32, function(err, key){
        console.log( key );                                                            // -> &lt;Buffer f4 aa ca ... &gt;
    })
    
    console.log(
        crypto.scryptSync('pass', 'someSalt', 32)                                      // -> &lt;Buffer f4 aa ca ... &gt;
    );
    
    
// pbkdf2() / pbkdf2Sync() ------------------------------------------------------------
    crypto.pbkdf2('pass', 'someSalt', 10, 32, 'sha256', function(err, key){
        console.log( key );                                                            // -> &lt;Buffer b6 de 48 ... &gt;
    })
    
    console.log(
        crypto.pbkdf2Sync('pass', 'someSalt', 10, 32, 'sha256')                        // -> &lt;Buffer b6 de 48 ... &gt;
    )    
    </pre>
    <hr>
    <!---------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> <mark>KeyObject.from()</mark> TEST </u></h4>
    <pre>
    const { webcrypto:{subtle}, KeyObject } = require('crypto');
    
    (async function(){
        const key = await subtle.generateKey({                                         // cryptoKey 
            name: 'HMAC',
            hash: 'SHA-256',
            length: 256
        }, true, ['sign', 'verify']);
        
        var keyObject = KeyObject.from(key);
        console.log( keyObject );                                                      // transformed to a KeyObject instance   
    })();    
    </pre>
    <hr>
    <!---------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> <mark>.export()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    
    var keyPair = crypto.generateKeyPairSync('rsa', {modulusLength:1024})
    
    var secretKey = crypto.generateKeySync('aes', {length:128});
    var publicKey = keyPair.publicKey;
    var privateKey = keyPair.privateKey;
    
// export secret key ------------------------------------------------------------------
    console.log(
        secretKey.export({format:'buffer'})                                            // -> &lt;Buffer ca 0a ba 6a ... &gt;                  // binary format 
    );
    
    console.log(
        secretKey.export({format:'jwk'})                                               // -> {kty:'oct', k:'ygq6alUG38nnuH3Fen-_Ww'}    // JSON web key format    
    );
    
    
// export public key ------------------------------------------------------------------
    console.log(
        publicKey.export({format:'pem', type:'pkcs1'})                                 // -> '-----BEGIN RSA PUBLIC KEY----- ...'       // pem format    
    )
    
    console.log(
        publicKey.export({format:'der', type:'pkcs1'})                                 // -> &lt;Buffer 30 81 89 02 ... &gt;                  // der format (binary encoded)    
    )
    
    console.log(
        publicKey.export({format:'jwk', type:'pkcs1'})                                 // -> {kty:'RSA', n:'z_ag ...'}                  // JSON Web Key format    
    )
    
    
// export private key -----------------------------------------------------------------
    console.log(
        privateKey.export({format:'pem', type:'pkcs1'})                                // -> '-----BEGIN RSA PRIVATE KEY----- ...'      // pem format    
    )
    
    console.log(
        privateKey.export({format:'der', type:'pkcs1'})                                // -> '&lt;Buffer 30 82 02 5c ... &gt;                 // der format (binary encoded)    
    )
    
    console.log(
        privateKey.export({format:'jwk', type:'pkcs1'})                                // -> {kty:'RSA', n:'XclpdH ...'}                // JSON Web Key format    
    )
    </pre>
    <hr>
    <!---------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> <mark>type</mark> / <mark>symmetricKeySize</mark> / <mark>asymmetricKeyType</mark> / <mark>asymmetricKeyDetails</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    
    var keyPair = crypto.generateKeyPairSync('rsa', {modulusLength:1024})
    
    var secretKey = crypto.generateKeySync('aes', {length:128});
    var publicKey = keyPair.publicKey;
    var privateKey = keyPair.privateKey;
    
    
    console.log( secretKey.type );                                                     // -> 'secret'
    console.log( publicKey.type );                                                     // -> 'public'
    console.log( privateKey.type );                                                    // -> 'private'
    
    
    console.log( secretKey.symmetricKeySize );                                         // -> 16
    console.log( publicKey.symmetricKeySize );                                         // -> undefined
    console.log( privateKey.symmetricKeySize );                                        // -> undefined
    
    
    console.log( secretKey.asymmetricKeyType );                                        // -> 'rsa'
    console.log( publicKey.asymmetricKeyType );                                        // -> 'rsa'
    console.log( privateKey.asymmetricKeyType );                                       // -> undefined  
    
    
    console.log( secretKey.asymmetricKeyDetails );                                     // -> undefined  
    console.log( publicKey.asymmetricKeyDetails );                                     // -> {modulusLength:1024, publicExponent:65537n}    
    console.log( privateKey.asymmetricKeyDetails );                                    // -> {modulusLength:1024, publicExponent:65537n}    
    </pre>
  </details>
  <hr>
  <!---------------------------------------------------------------------------------------------------------------->
  <h2 style="color:darkblue;"><u> Cipher / Decipher <mark>publicEncrypt()</mark> / <mark>privateDecrypt()</mark> / <mark>privateEncrypt()</mark> / <mark>publicDecrypt()</mark> / <mark>Cipher</mark> / <mark>Decipher</mark> / <mark>createCipheriv()</mark> / <mark>createDecipheriv()</mark> / <mark>update()</mark> / <mark>final()</mark> / <mark>setAAD()</mark> / <mark>getAuthTag()</mark> / <mark>setAuthTag()</mark> / <mark>setAutoPadding()</mark> </u></h2>
  <details class="example">
    <summary> DEMO </summary>
    <h4 style="color:darkblue;"><u> Asymmetric Encryption </u></h4>
    <h4 style="color:darkblue;"><u> <mark>privateEncrypt()</mark> / <mark>publicDecrypt()</mark> / <mark>publicEncrypt()</mark> / <mark>privateDecrypt()</mark> </u></h4>
    <pre>
    const crypto = require('crypto');
    
    var keys = crypto.generateKeyPairSync('rsa', {modulusLength:1024});         
    var pubKey = keys.publicKey;
    var privKey = keys.privateKey;
    
// publicEncrypt() / privateDecrypt() -------------------------------------------------
    var encryptedData = crypto.publicEncrypt(pubKey, 'original data...' );             // -> &lt;Buffer ...&gt;           // encrypts the data with the public key and returns it    
    
    crypto.privateDecrypt(privKey, encryptedData);                                     // -> 'original data...'     // decrypts the data with the private key 
    
    
// privateEncrypt() / purblicDecrypt() ------------------------------------------------ 
    var encryptedData_ = crypto.privateEncrypt(privKey, 'original data....' );         // -> &lt;Buffer ...&gt;           // encrypts the data with the private key and returns it    
    
    crypto.publicDecrypt(pubKey, encryptedData_);                                      // -> 'original data...'     // decrypts the data with the public key 
    </pre>
    <h4 style="color:darkblue;"><u> Symmetric Encryption </u></h4>
    <h4 style="color:darkblue;"><u> <mark>Cipher</mark> / <mark>Decipher</mark> / <mark>createCipheriv()</mark> / <mark>createDecipheriv()</mark> / <mark>update()</mark> / <mark>final()</mark> </u></h4>
    <p> - <mark>Cipher</mark> / <mark>Decipher</mark> instances can be used in 2 ways (as transform stream) (using <mark>update()</mark> / <mark>final()</mark> methods) </p>
    <pre>
    const crypto = require('crypto');
    
    const key = crypto.generateKeySync('aes', {length:128});
    const iv = crypto.randomBytes(16);                                                 // AES ciphers use 16 byte initialization vectors   
    
// as transform stream ----------------------------------------------------------------
    const cipher = crypto.createCipheriv('aes-128-cbc', key, iv);                      // algorithm, key and initialization vector used for encryption    
    
    let encrypted = ''
    cipher.setEncoding('hex')                                                          // result will be hex encoded    
    
    cipher.on('data', (chunk) => encrypted += chunk);
    cipher.on('end', () => encrypted );                                                // -> '746851307aee882370590a7c607f87b4b8f1c5932f807e996d4abd652faed06c'   // encrypted data    
    
    cipher.write( 'original data...' );                                                // data written to the cipher transform streaming will be encoded   
    cipher.end();
    
    
    const decipher = crypto.createDecipheriv('aes-128-cbc', key, iv);                  // algorithm, key and initialization vector used for decryption    
    
    let decrypted = ''
    
    decipher.on('data', (chunk) => decrypted += chunk);
    decipher.on('end', () => decrypted );                                              // -> 'original data...'     // decrypted data 
    
    decipher.write(encrypted, 'hex');                                                  // data written to the decipher transform streaming will be decoded     
    decipher.end();
    
    
// update() / final() -----------------------------------------------------------------
    const cipher_ = crypto.createCipheriv('aes-128-cbc', key, iv);
    
    let encrypted_ = cipher_.update('original data...', 'utf-8', 'hex');               // data is feeded to the cipher which will encrypt it 
    encrypted_ += cipher_.final('hex');                                                // the remaining enciphered data is flushed from the cipher object 
    encrypted_;                                                                        // -> '746851307aee882370590a7c607f87b4b8f1c5932f807e996d4abd652faed06c'   // encrypted data    
    
    
    const decipher_ = crypto.createDecipheriv('aes-128-cbc', key, iv);
    
    let decrypted_ = decipher_.update(encrypted_, 'hex', 'utf-8');                     // data is feeded to the decipher which will decrypt it    
    decrypted_ += decipher_.final('utf-8');                                            // the remaining deciphered data is flushed from the decipher object 
    decrypted_;                                                                        // -> 'original data...'
    </pre>
    <h4 style="color:darkblue;"><u> <mark>setAAD()</mark> / <mark>getAuthTag()</mark> / <mark>setAuthTag()</mark> </u></h4>
    <p> - these methods are required only by authenticated encryption modes (<mark>GCM</mark>, <mark>CCM</mark> and <mark>OCB</mark>) </p>
    <pre>
    const crypto = require('crypto');
    
    const key = crypto.generateKeySync('aes', {length:192});
    const iv = crypto.randomBytes(12);
    const aad = 'additional authenticated data';
    const orgData = 'original data....ʨ';                                              // -! the last character takes 2 bytes 
    const orgDataLength = Buffer.from(orgData).byteLength;                             // we need the exact byte length of the encrypted data 
    
// encrypt ---------------------------------------------------------------------------- 
    const cipher = crypto.createCipheriv('aes-192-ccm', key, iv, {
        authTagLength:16                                                               // 16 byte length authentication tag will be generated 
    });   
    
    cipher.setAAD(aad, {                                                               // setting the AAD to the encryption   
        plaintextLength:orgDataLength                                                  // -! original data byte length is required (for CCM encryption mode)    
    });                                
    
    var encrypted = cipher.update(orgData, 'utf-8', 'hex');                            // encrypting the data 
    encrypted += cipher.final('hex');
    console.log( encrypted );
    
    let authTag = cipher.getAuthTag();                                                 // -> &lt;Buffer ...&gt;      // returns the generated (16 byte length) authentication tag (once the data fully encrypted)    
    
    
// we transfer the encypted text, iv, authentication tag, and add (the attacker can see all this)   
// only the secret key must be secretly transfered (all this jazz ensures authenticity)  
    
// decrypt ---------------------------------------------------------------------------- 
    const decipher = crypto.createDecipheriv('aes-192-ccm', key, iv, {authTagLength:16});
    
    decipher.setAuthTag(authTag);                                                      // setting the authenticated tag to the decryption 
    decipher.setAAD(aad, {                                                             // setting the AAD to the dercyption 
        plaintextLength:orgDataLength                                                  // -! original data byte length is required    
    });                             
    
    var decrypted = decipher.update(encrypted, 'hex', 'utf-8');                        // decrypting the data 
    decrypted += decipher.final('utf-8');
    decrypted;                                                                         // -> 'original data....ʨ'  
    </pre>
  </details>
  <details class="example">
    <summary> Example : </summary>
    <h4 style="color:darkblue;"><u> <mark>privateEncrypt()</mark> / <mark>publicDecrypt()</mark> / <mark>publicEncrypt()</mark> / <mark>privateDecrypt()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    
    var keys = crypto.generateKeyPairSync('rsa', {modulusLength:1024});         
    var pubKey = keys.publicKey;
    var privKey = keys.privateKey;
    
// publicEncrypt() / privateDecrypt() -------------------------------------------------
    var encryptedData = crypto.publicEncrypt(pubKey, 'original data...' );             // encrypts the data with the public key 
    console.log( encryptedData.toString() );                                           // -> gibberish data 
    
    var decryptedData = crypto.privateDecrypt(privKey, encryptedData);                 // decrypts the data with the private key 
    console.log( decryptedData.toString() );                                           // -> 'original data...'
    
// privateEncrypt() / purblicDecrypt() ------------------------------------------------ 
    var encryptedData_ = crypto.privateEncrypt(privKey, 'original data....' );         // encrypts the data with the private key 
    console.log( encryptedData_.toString() );                                          // -> gibberish data 
    
    var decryptedData_ = crypto.publicDecrypt(pubKey, encryptedData_);                 // decrypts the data with the public key 
    console.log( decryptedData_.toString() );                                          // -> 'original data....'    
    </pre>
    <hr>
    <!---------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> <mark>createCipheriv()</mark> / <mark>createDecipheriv()</mark> / <mark>update()</mark> / <mark>final()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    
    const key = crypto.generateKeySync('aes', {length:128});
    const iv = crypto.randomBytes(16);
    
// as transform stream ----------------------------------------------------------------
    const cipher = crypto.createCipheriv('aes-128-cbc', key, iv);                      // algorithm, key and initialization vector used for encryption    
    
    let encrypted = ''
    cipher.setEncoding('hex')                                                          // result will be encoded hex encoded   
    
    cipher.on('data', (chunk) => encrypted += chunk);
    cipher.on('end', () => console.log(encrypted));                                    // -> '746851307aee882370590a7c607f87b4b8f1c5932f807e996d4abd652faed06c'   // encrypted data    
    
    cipher.write( 'original data...' );                                                // data streaming through will be encoded   
    cipher.end();
    
    
    const decipher = crypto.createDecipheriv('aes-128-cbc', key, iv);                  // algorithm, key and initialization vector used for decryption    
    
    let decrypted = ''
    
    decipher.on('data', (chunk) => decrypted += chunk);
    decipher.on('end', () => console.log(decrypted));                                  // -> 'original data...'     // decrypted data 
    
    decipher.write(encrypted, 'hex');                                                  // the passed data to decrypt is hex encoded 
    decipher.end();
    
    
// update() / final() -----------------------------------------------------------------
    const cipher_ = crypto.createCipheriv('aes-128-cbc', key, iv);
    
    let encrypted_ = cipher_.update('original data...', 'utf-8', 'hex');               // data is feeded to the cipher which will encrypt it 
    encrypted_ += cipher_.final('hex');                                                // the remaining enciphered data is flushed from the cipher object 
    console.log( encrypted_ );                                                         // -> '746851307aee882370590a7c607f87b4b8f1c5932f807e996d4abd652faed06c'   // encrypted data    
    
    
    const decipher_ = crypto.createDecipheriv('aes-128-cbc', key, iv);
    
    let decrypted_ = decipher_.update(encrypted_, 'hex', 'utf-8');                     // data is feeded to the decipher which will decrypt it    
    decrypted_ += decipher_.final('utf-8');                                            // the remaining deciphered data is flushed from the decipher object 
    console.log( decrypted_ );                                                         // -> 'original data...'
    </pre>
    <hr>
    <!---------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> <mark>setAAD()</mark> / <mark>getAuthTag()</mark> / <mark>setAuthTag()</mark> TEST in CCM mode </u></h4>
    <p> - TESTED: works the same way in <mark>OCB</mark> and <mark>GCM</mark> modes </p>
    <pre>
    const crypto = require('crypto');
    
    const key = crypto.generateKeySync('aes', {length:192});
    const iv = crypto.randomBytes(12);
    const aad = 'additional authenticated data';
    const orgData = 'original data....ʨ';                                              // -! the last character takes 2 bytes 
    const orgDataLength = Buffer.from(orgData).byteLength;                             // we need the exact byte length of the encrypted data 
    
// encrypt ---------------------------------------------------------------------------- 
    const cipher = crypto.createCipheriv('aes-192-ccm', key, iv, {
        authTagLength:16                                                               // 16 byte length authentication tag will be generated 
    });   
    
    cipher.setAAD(aad, {                                                               // setting the AAD to the encryption   
        plaintextLength:orgDataLength                                                  // -! original data byte length is required    
    });                                
    
    var encrypted = cipher.update(orgData, 'utf-8', 'hex');                            // encrypting the data 
    encrypted += cipher.final('hex');
    console.log( encrypted );
    
    let authTag = cipher.getAuthTag();                                                 // returns the generated (16 byte length) authentication tag (once the data fully encrypted)    
    
    
// we transfer the encypted text, iv, authentication tag, aad (the attacker can see all this) 
// only the secret key must be secretly transfered (all this jazz ensures authenticity)  
    
// decrypt ---------------------------------------------------------------------------- 
    const decipher = crypto.createDecipheriv('aes-192-ccm', key, iv, {authTagLength:16});
    
    decipher.setAuthTag(authTag);                                                      // setting the authenticated tag to the decryption 
    decipher.setAAD(aad, {                                                             // setting the AAD to the dercyption 
        plaintextLength:orgDataLength                                                  // -! original data byte length is required    
    });                             
    
    var decrypted = decipher.update(encrypted, 'hex', 'utf-8');                        // decrypting the data 
    decrypted += decipher.final('utf-8');
    console.log( decrypted );                                                          // -> 'original data....ʨ'  
    </pre>
    <hr>
    <!---------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> <mark>setAutoPadding()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    
    const key = crypto.generateKeySync('aes', {length:128});
    const iv = crypto.randomBytes(16);
    
// encrypt ----------------------------------------------------------------------------
    const cipher = crypto.createCipheriv('aes128', key, iv);
    cipher.setAutoPadding(false);                                                      // auto padding disabled 
    
    var encrypted = cipher.update('original data...', 'utf-8', 'hex');                 // -! in this situation the encryption/decrpytion works because the 'original data...' produces full cipher blocks   
                                                                                       // !! however if the passed data is 'orignal data....' the encryption/decryption fails because the last cipher block won't be a full block    
    encrypted += cipher.final('hex');
    console.log( encrypted );                                                          // -> 'cfd40c2f6fcfb7e7e068bdbbe3ace6af'
    
    
// decrypt ----------------------------------------------------------------------------
    const decipher = crypto.createDecipheriv('aes128', key, iv);
    decipher.setAutoPadding(false);
    
    var decrypted = decipher.update(encrypted, 'hex', 'utf-8');
    decrypted += decipher.final('utf-8');
    console.log( decrypted );                                                          // -> 'original data...'
    </pre>
  </details>
  <hr>
  <!---------------------------------------------------------------------------------------------------------------->
  <h2 style="color:darkblue;"><u> Sign / Verify <mark>sign()</mark> / <mark>verify()</mark> / <mark>Sign</mark> / <mark>Verify</mark> / <mark>update()</mark> / <mark>end()</mark> / <mark>sign()</mark> / <mark>verify()</mark> </u></h2>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    const crypto = require('crypto');
    
    let keyPair = crypto.generateKeyPairSync('rsa', {modulusLength:2048});
    let privKey = keyPair.privateKey;
    let pubKey = keyPair.publicKey;
    
    const signature = crypto.sign('sha256', 'some data...', privKey);                  // signs the data with 'sha256' hash algorithm and the passed private key   
    signature;                                                                         // -> &lt;Buffer ...&gt;           // generated signature   
    
    crypto.verify('sha256', 'some data...', pubKey, signature);                        // -> true                   // signature verifed (with the hash algoritm public key and the signature)    
    </pre>
    <pre>
    const crypto = require('crypto');
    
    const keyPair = crypto.generateKeyPairSync('rsa', {modulusLength:1024});
    
// as stream --------------------------------------------------------------------------
  // sign ----------------------------------
    const sign = crypto.createSign('sha256');                                          // the sign object will create signatures with the 'sha256' hash algorithm    
    
    sign.write('data to sign...');                                                     // writing data to the 'sign' object writable stream    
    sign.write('444');
    sign.end();
    
    let signature = sign.sign(keyPair.privateKey, 'hex');                              // calculates and returns the signature (with the private key) 
    signature;                                                                         // -> '8878c849ae2f6a4cad0a...'      // hex encoded signature...
    
  // verify --------------------------------
    const verify = crypto.createVerify('sha256');                                      // the verify object will verify with the 'sha256' hash algorithm    
    
    verify.write('data to sign...');                                                   // writing data to the 'verify' object writable stream (the data whan we want to verify)    
    verify.write('444');
    verify.end(); 
    
    verify.verify(keyPair.publicKey, signature, 'hex');                                // -> true                           // verifies the written data with the public key and the signature    
    
    
// update() / end() / sing() / verify() -----------------------------------------------
  // sign ----------------------------------
    const sign_ = crypto.createSign('sha256');                                         // the sign object will create signatures with the 'sha256' hash algorithm    
    
    sign_.update('data to sign...');                                                   // writing data to the 'sign'object   
    sign_.end();
    
    const signature_ = sign_.sign(keyPair.privateKey, 'hex');                          // calculates and returns the signature (with the private key)    
    signature_;                                                                        // -> '5e3df0df346a32d7c94a63...'    // hex encoded signature...
    
  // verify --------------------------------
    const verify_ = crypto.createVerify('sha256');                                     // the verify object will verify with the 'sha256' hash algorithm    
    
    verify_.update('data to sign...' );                                                // writing data to the 'verify' object (data what we want to verify)    
    verify_.end();
    
    verify_.verify(keyPair.publicKey, signature_, 'hex');                              // -> true                           // verifies the written data with the public key and the signature    
    </pre>
  </details>
  <details class="example">
    <summary> Example : </summary>
    <h4 style="color:darkblue;"><u> <mark>sign()</mark> / <mark>verify()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    
    let keyPair = crypto.generateKeyPairSync('rsa', {modulusLength:2048});
    let privKey = keyPair.privateKey;
    let pubKey = keyPair.publicKey;
    
    const signature = crypto.sign('sha256', 'some data...', privKey);                  // signs the data with 'sha256' hash algorithm and the passed private key   
    console.log( signature );                                                          // -> &lt;Buffer ...&gt;           // generated signature   
    
    console.log( crypto.verify('sha256', 'some data...', pubKey, signature) );         // -> true                   // signature verifed (with the hash algoritm public key and the signature)    
    </pre>
    <h4 style="color:darkblue;"><u> <mark>Sign</mark> / <mark>Verify</mark> / <mark>update()</mark> / <mark>sign()</mark> / <mark>verify()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    
    const keyPair = crypto.generateKeyPairSync('rsa', {modulusLength:1024});
    
// as stream --------------------------------------------------------------------------
  // sign ----------------------------------
    const sign = crypto.createSign('sha256');                                          // the sign object will create signatures with the 'sha256' hash algorithm    
    
    sign.write('data to sign...');                                                     // writing data to the 'sign' object writable stream    
    sign.write('444');
    sign.end();
    
    let signature = sign.sign(keyPair.privateKey, 'hex');                              // calculates and returns the signature (with the private key) 
    console.log( signature );                                                          // -> '8878c849ae2f6a4cad0a...'      // hex encoded signature...
    
  // verify --------------------------------
    const verify = crypto.createVerify('sha256');                                      // the verify object will verify with the 'sha256' hash algorithm    
    
    verify.write('data to sign...');                                                   // writing data to the 'verify' object writable stream (the data whan we want to verify)    
    verify.write('444');
    verify.end(); 
    
    console.log(
        verify.verify(keyPair.publicKey, signature, 'hex')                             // -> true                           // verifies the written data with the public key and the signature    
    )
    
// update() / end() / sing() / verify() -----------------------------------------------
  // sign ----------------------------------
    const sign_ = crypto.createSign('sha256');                                         // the sign object will create signatures with the 'sha256' hash algorithm    
    
    sign_.update('data to sign...');                                                   // writing data to the 'sign'object   
    sign_.end();
    
    const signature_ = sign_.sign(keyPair.privateKey, 'hex');                          // calculates and returns the signature (with the private key)    
    console.log( signature_ );                                                         // -> '5e3df0df346a32d7c94a63...'    // hex encoded signature...
    
  // verify --------------------------------
    const verify_ = crypto.createVerify('sha256');                                     // the verify object will verify with the 'sha256' hash algorithm    
    
    verify_.update('data to sign...' );                                                // writing data to the 'verify' object (data whan we want to verify)    
    verify_.end();
    
    console.log(
        verify_.verify(keyPair.publicKey, signature_, 'hex')                           // -> true                           // verifies the written data with the public key and the signature    
    )    
    </pre>
  </details>
  <hr>
  <!---------------------------------------------------------------------------------------------------------------->
  <h2 style="color:darkblue;"><u> Hashes <mark>Hash</mark> / <mark>Hmac</mark> / <mark>update()</mark> / <mark>digest()</mark> / <mark>copy()</mark> </u></h2>
  <details class="example">
    <summary> DEMO </summary>
    <h4 style="color:darkblue;"><u> Hash <mark>Hash</mark> / <mark>update()</mark> / <mark>digest()</mark> / <mark>copy()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    
// as stream --------------------------------------------------------------------------
    const hash = crypto.createHash('sha256');                                          // digests will be generated with 'sha256' hash algoritm 
    
    let digest = '';
    hash.setEncoding('hex');                                                           // the output will be hex encoded    
    
    hash.on('data', (chunk) => digest += chunk);
    hash.on('end', () => digest );                                                     // -> '3b3d3e1b79dbda5ecad5cebf9fd000a45a28c765e9406952907585cdd71f342d'    
    
    hash.write('original data...'); 
    hash.end();
    
    
// update() / digest() ----------------------------------------------------------------
    const hash_ = crypto.createHash('sha256');    
    
    hash_.update('original data...');  
    hash_.digest('hex');                                                               // -> '3b3d3e1b79dbda5ecad5cebf9fd000a45a28c765e9406952907585cdd71f342d'    
    
    
// copy() -----------------------------------------------------------------------------
    const hash$ = crypto.createHash('sha256');
    
    hash$.update('one '); 
    let hash$_1 = hash$.copy();                                                        // creates a copy of the current hash object   
    hash$.digest('hex');                                                               // -> '68b2589574c8fb725a4836aaef9461f39a10c01064aa500948939188e4cba6de'    
    
    hash$_1.update('two');
    hash$_1.digest('hex');                                                             // -> '8ab63e29a4ba14e4e1688f9c15e5af90895421358c945b0431f85d66977bd3d2'   // sha256 hash of 'one two'    
    
    
    const hash$$ = crypto.createHash('sha256');
    
    hash$$.update('one two');
    hash$$.digest('hex');                                                              // -> '8ab63e29a4ba14e4e1688f9c15e5af90895421358c945b0431f85d66977bd3d2'   // sha256 hash of 'one two'    
    </pre>
    <hr>
    <!---------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> Hmac <mark>Hmac</mark> / <mark>update()</mark> / <mark>digest()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    
    const key = crypto.generateKeySync('aes', {length:128});
    
// as stream --------------------------------------------------------------------------
    const hmac = crypto.createHmac('sha256', key);                                     // HMAC will be generated with 'sha256' hash algoritm and the passed secret key    
    
    let hmac_ = '';
    hmac.setEncoding('hex');                                                           // the output will be hex encoded    
    
    hmac.on('data', (chunk) => hmac_ += chunk);
    hmac.on('end', () => hmac_ );                                                      // -> '41ad06f7e726d6d7d6e230364cba880dcbb14d02a417f8dfa8c9336e100ba0c0'    // the generated hmac    
    
    hmac.write('original data...'); 
    hmac.end();
    
    
// update() / digest() ----------------------------------------------------------------
    const hmac$ = crypto.createHmac('sha256', key);    
    
    hmac$.update('original data...');  
    hmac$.digest('hex');                                                               // -> '41ad06f7e726d6d7d6e230364cba880dcbb14d02a417f8dfa8c9336e100ba0c0'    // the generated hmac    
    </pre>
  </details>
  <details class="example">
    <summary> Example : </summary>
    <h4 style="color:darkblue;"><u> <mark>Hash</mark> / <mark>update()</mark> / <mark>digest()</mark> / <mark>copy()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    
// as stream --------------------------------------------------------------------------
    const hash = crypto.createHash('sha256');                                          // digests will be generated with 'sha256' hash algoritm 
    
    let digest = '';
    hash.setEncoding('hex');                                                           // the output will be hex encoded    
    
    hash.on('data', (chunk) => digest += chunk);
    hash.on('end', () => console.log(digest));                                         // -> '3b3d3e1b79dbda5ecad5cebf9fd000a45a28c765e9406952907585cdd71f342d'    
    
    hash.write('original data...'); 
    hash.end();
    
    
// update() / digest() ----------------------------------------------------------------
    const hash_ = crypto.createHash('sha256');    
    
    hash_.update('original data...');  
    console.log( hash_.digest('hex') );                                                // -> '3b3d3e1b79dbda5ecad5cebf9fd000a45a28c765e9406952907585cdd71f342d'    
    
    
// copy() -----------------------------------------------------------------------------
    const hash$ = crypto.createHash('sha256');
    
    hash$.update('one '); 
    let hash$_1 = hash$.copy();                                                        // creates a copy of the current hash object   
    console.log( hash$.digest('hex') );                                                // -> '68b2589574c8fb725a4836aaef9461f39a10c01064aa500948939188e4cba6de'    
    
    hash$_1.update('two');
    console.log( hash$_1.digest('hex') );                                              // -> '8ab63e29a4ba14e4e1688f9c15e5af90895421358c945b0431f85d66977bd3d2'   // sha256 hash of 'one two'    
    
    
    const hash$$ = crypto.createHash('sha256');
    
    hash$$.update('one two');
    console.log( hash$$.digest('hex') );                                               // -> '8ab63e29a4ba14e4e1688f9c15e5af90895421358c945b0431f85d66977bd3d2'   // sha256 hash of 'one two'    
    </pre>
    <hr>
    <!---------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> <mark>Hmac</mark> / <mark>update()</mark> / <mark>digest()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    
    const key = crypto.generateKeySync('aes', {length:128});
    
// as stream --------------------------------------------------------------------------
    const hmac = crypto.createHmac('sha256', key);                                     // HMAC will be generated with 'sha256' hash algoritm and the passed secret key    
    
    let hmac_ = '';
    hmac.setEncoding('hex');                                                           // the output will be hex encoded    
    
    hmac.on('data', (chunk) => hmac_ += chunk);
    hmac.on('end', () => console.log(hmac_));                                          // -> '41ad06f7e726d6d7d6e230364cba880dcbb14d02a417f8dfa8c9336e100ba0c0'    // the generated hmac    
    
    hmac.write('original data...'); 
    hmac.end();
    
    
// update() / digest() ----------------------------------------------------------------
    const hmac$ = crypto.createHmac('sha256', key);    
    
    hmac$.update('original data...');  
    console.log( hmac$.digest('hex') );                                                // -> '41ad06f7e726d6d7d6e230364cba880dcbb14d02a417f8dfa8c9336e100ba0c0'    // the generated hmac    
    </pre>
  </details>
  <hr>
  <!---------------------------------------------------------------------------------------------------------------->
  <h2 style="color:darkblue;"><u> Diffie-Hellman key exchange protocol <mark>generatePrime()</mark> / <mark>generatePrimeSync()</mark> / <mark>checkPrime()</mark> / <mark>checkPrimeSync()</mark> / <mark>createDiffieHellman()</mark> / <mark>createDiffieHellmanGroup()</mark> / <mark>getDiffieHellman()</mark> / <mark>createECDH()</mark> / <mark>generateKeys()</mark> / <mark>getPrivateKey()</mark> / <mark>getPublicKey()</mark> / <mark>setPrivateKey()</mark> / <mark>setPublicKey()</mark> / <mark>getPrime()</mark> / <mark>getGenerator()</mark> / <mark>verifyError</mark> / <mark>computeSecret()</mark> / <mark>ECDH.convertKey()</mark> </u></h2>
  <details class="example">
    <summary> DEMO </summary>
    <h4 style="color:darkblue;"><u> Prime <mark>generatePrime()</mark> / <mark>generatePrimeSync()</mark> / <mark>checkPrime()</mark> / <mark>checkPrimeSync()</mark> </u></h4>
    <pre>
    const crypto = require('crypto');
    
// generatePrime() / generatePrimeSync() ----------------------------------------------
    crypto.generatePrime(8, {bigint:true}, function(err, prime){                       // asynchronously generates a random prime up to 8bit (1byte)  
        prime;                                                                         // -> 211n               // prime number 
    });
    
    crypto.generatePrimeSync(8, {bigint:true});                                        // -> 239n               // synchronous version  
    
// checkPrime() / checkPrimeSync() ----------------------------------------------------
    crypto.checkPrime(239n, function(err, res){                                        // asynchronously check if the passed 1st argument is a valid prime number   
        res;                                                                           // -> true
    })
    crypto.checkPrime(240n, function(err, res){
        res;                                                                           // -> false 
    })
    
    crypto.checkPrimeSync(239n);                                                       // -> true               // synchronous version   
    crypto.checkPrimeSync(240n);                                                       // -> false 
    </pre>
    <h4 style="color:darkblue;"><u> Diffie-Hellman key exchange <mark>createDiffieHellman()</mark> / <mark>generateKeys()</mark> / <mark>computeSecret()</mark> / <mark>verify</mark> </u></h4>
    <pre>
    const crypto = require('crypto');
    const util = require('util');
    
    const prime = crypto.generatePrimeSync(2048);                                      // a 2048bit prime length is the minimal recommended prime for diffie-hellman key exchanges    
    
// Alice ------------------------------------------------------------------------------
    const alice = crypto.createDiffieHellman(prime, 2);                                // alice creates its Diffie-Hellman   
    const alicePubKey = alice.generateKeys();                                          // alice generates its diffie-hellman private and public key pair (the public key is returned)   
    
    
// Bob --------------------------------------------------------------------------------
    const bob = crypto.createDiffieHellman(prime, 2);                                  // bob creates it's diffie-hellman
    const bobPubKey = bob.generateKeys();                                              // bob generates its diffie-hellman private and public key pair (the public key is returned)   
    
    
// exchanging diffie-hellman public keys ----------------------------------------------
// ------------------------------------------------------------------------------------
    // Alice ------------------------------------------------------
    const aliceSecret = alice.computeSecret(bobPubKey);                                // Alice takes Bob's public key and generates the shared secret (symmetric key)   
    
    // Bob --------------------------------------------------------
    const bobSecret = bob.computeSecret(alicePubKey);                                  // Bob takes Alice's public key and generates the shared secret (symmetric key)   
    
// ------------------------------------------------------------------------------------
    util.isDeepStrictEqual(aliceSecret, bobSecret);                                    // -> true                // Alice and Bob has a shared secret that can be used as secret key 
    
    alice.verifyError;                                                                 // -> 2                   // crypto.constants.DH_CHECK_P_NOT_SAFE_PRIME (the used prime is not a 'safe-prime')     
    bob.verifyError;                                                                   // -> 2                   // crypto.constants.DH_CHECK_P_NOT_SAFE_PRIME (the used prime is not a 'safe-prime')     
    </pre>
    <h4 style="color:darkblue;"><u> Diffie-Hellman <mark>getPrivateKey()</mark> / <mark>getPublicKey()</mark> / <mark>setPrivateKey()</mark> / <mark>setPublicKey()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    const util = require('util');
    
// prestored diffie hellman keys ------------------------------------------------------    
    const prime = crypto.generatePrimeSync(2048);                         
    const alice = crypto.createDiffieHellman(prime, 3);
    
    alice.generateKeys();
    const alicePubKey = alice.getPublicKey();                                          // returns the generated diffie-hellman public key    
    const alicePrivKey = alice.getPrivateKey();                                        // returns the generated diffie-hellman private key    
    
    const bob = crypto.createDiffieHellman(prime, 3);
    bob.generateKeys();
    const bobPubKey = bob.getPublicKey();                                              // returns the generated diffie-hellman public key    
    const bobPrivKey = bob.getPrivateKey();                                            // returns the generated diffie-hellman private key    
    
    
// Charlie ----------------------------------------------------------------------------
    const charlie = crypto.createDiffieHellman(prime, 4);                              // same prime and generator used 
    charlie.setPublicKey(alicePubKey);                                                 // charlie uses alice's keys (sets the prestored diffie-hellman keys)    
    charlie.setPrivateKey(alicePrivKey);
    
    
// Dany -------------------------------------------------------------------------------
    const dany = crypto.createDiffieHellman(prime, 4);                                 // same prime and generator used 
    dany.setPublicKey(bobPubKey);                                                      // dany uses bob's keys (sets the prestored diffie-hellman keys)    
    dany.setPrivateKey(bobPrivKey);
    
    
// exchanging diffie-hellman public keys ----------------------------------------------
// ------------------------------------------------------------------------------------
// Charlie ----------------------------------------------------------------------------
    const charlieSecret = charlie.computeSecret(bobPubKey);                            // Charlie takes Dany's public key and generates the shared secret 
    
// Dany -------------------------------------------------------------------------------
    const danySecret = dany.computeSecret(alicePubKey);                                // Dany takes Chariles's public key and generates the shared secret 
    
// ------------------------------------------------------------------------------------
    util.isDeepStrictEqual(charlieSecret, danySecret);                                 // -> true       // Charlie and Dany has a shared secret that can be used as secret key   
    </pre>
    <h4 style="color:darkblue;"><u> Diffie-Hellman Group <mark>createDiffieHellmanGroup()</mark> / <mark>getDiffieHellman()</mark> </u></h4>
    <pre>
    const crypto = require('crypto');
    const util = require('util');
    
// Alice ------------------------------------------------------------------------------
    const alice = crypto.createDiffieHellmanGroup('modp14');                           // the modp14 is a predefined 2048bit diffie-hellman prime basically (diffie-hellman group)    
      // const alice = crypto.getDiffieHellman('modp14');                                // would do the same as above 

    const alicePubKey = alice.generateKeys();  
    
// Bob --------------------------------------------------------------------------------
    const bob = crypto.createDiffieHellmanGroup('modp14');                             // the modp14 is a predefined 2048bit diffie-hellman prime basically (diffie-hellman group)    
      // const bob = crypto.getDiffieHellman('modp14');                                  // would do the same as above 
    const bobPubKey = bob.generateKeys();  
    
    
// exchanging diffie-hellman public keys ----------------------------------------------
// ------------------------------------------------------------------------------------
    // Alice ------------------------------------------------------
    const aliceSecret = alice.computeSecret(bobPubKey);                                // Alice takes Bob's public key and generates the shared secret (symmetric key)   
    
    // Bob --------------------------------------------------------
    const bobSecret = bob.computeSecret(alicePubKey);                                  // Bob takes Alice's public key and generates the shared secret (symmetric key)   
    
// ------------------------------------------------------------------------------------
    util.isDeepStrictEqual(aliceSecret, bobSecret);                                    // -> true                // Alice and Bob has a shared secret that can be used as secret key 
    </pre>
    <h4 style="color:darkblue;"><u> Elliptic Curve Diffie-Hellman <mark>createECDH()</mark> / <mark>generateKeys()</mark> / <mark>computeSecret()</mark> </u></h4>
    <pre>
    const crypto = require('crypto');
    const util = require('util');
    
// Alice ------------------------------------------------------------------------------
    const alice = crypto.createECDH('secp521r1');                                      // uses the 'secp521r1' curve for for this ECDH key exchange utility    
    const alicePubKey = alice.generateKeys();                                          // the generated public ECDH key is returned 
    
// Bob --------------------------------------------------------------------------------
    const bob = crypto.createECDH('secp521r1');                                        // uses the 'secp521r1' curve for for this ECDH key exchange utility    
    const bobPubKey = bob.generateKeys();                                              // the generated public ECDH key is returned 
    
    
// exchanging ECDH public keys --------------------------------------------------------
// ------------------------------------------------------------------------------------
    // Alice ------------------------------------------------------
    const aliceSecret = alice.computeSecret(bobPubKey);                                // Alice takes Bob's ECHD public key and generates the shared secret (symmetricy key)   
    
    // Bob --------------------------------------------------------
    const bobSecret = bob.computeSecret(alicePubKey);                                  // Bob takes Alice's ECDH public key and generates the shared secret (symmetricy key)   
    
// ------------------------------------------------------------------------------------
    util.isDeepStrictEqual(aliceSecret, bobSecret);                                    // -> true                // Alice and Bob has a shared secret now   
    </pre>
    <h4 style="color:darkblue;"><u> Elliptic Curve Diffie-Hellman <mark>getPrivateKey()</mark> / <mark>getPublicKey()</mark> / <mark>setPrivateKey()</mark> / <mark>setPublicKey()</mark> </u></h4>
    <pre>
    const crypto = require('crypto');
    const util = require('util');
    
// prestored ECDH keys ----------------------------------------------------------------
    const alice = crypto.createECDH('secp224k1');
    alice.generateKeys();
    const alicePrivKey = alice.getPrivateKey();                                        // getting alice's ECDH private key
    const alicePubKey = alice.getPublicKey();                                          // getting alice's ECDH public key 
    
    const bob = crypto.createECDH('secp224k1');
    bob.generateKeys();
    const bobPrivKey = bob.getPrivateKey();                                            // getting bob's ECDH private key
    const bobPubKey = bob.getPublicKey();                                              // getting bob's ECDH public key 
    
    
// Charlie ----------------------------------------------------------------------------
    const charlie =crypto.createECDH('secp224k1');                                     // same curve used    
    charlie.setPrivateKey(alicePrivKey);                                               // charlie uses alice's key
    // charlie.setPublicKey(alicePubKey);                                              // -! ECDH utility only need the private key to be set (this method is deprecated node v5.2.0) 
    
    
// Dany -------------------------------------------------------------------------------
    const dany = crypto.createECDH('secp224k1');                                       // same curve used     
    dany.setPrivateKey(bobPrivKey);                                                    // dany uses bob's key 
    // dany.setPublicKey(bobPubKey);                                                   // -! ECDH utility only need the private key to be set (this method is deprecated node v5.2.0)  
    
    
// exchanging diffie-hellman public keys ----------------------------------------------
// ------------------------------------------------------------------------------------
// Charlie ----------------------------------------------------------------------------
    const charlieSecret = charlie.computeSecret(bobPubKey);                            // Charlie takes Dany's public key and generates the shared secret (symmetric key)   
    
// Dany -------------------------------------------------------------------------------
    const danySecret = dany.computeSecret(alicePubKey);                                // Dany takes Chariles's public key and generates the shared secret (symmetric key)   
    
// ------------------------------------------------------------------------------------
    util.isDeepStrictEqual(charlieSecret, danySecret);                                 // -> true       // Charlie and Dany have a shared secret now 
    </pre>
    <hr>
    <!---------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> Elliptic Curve Diffie-Hellman <mark>ECHD.convertKey()</mark> </u></h4>
    <pre>
    const crypto = require('crypto');
    const util = require('util');
    
    const ecdh = crypto.createECDH('c2pnb176v1');
    const ecdhPubKey = ecdh.generateKeys();
    
    const uncompressedKey = crypto.ECDH.convertKey(ecdhPubKey, 'c2pnb176v1', null, 'hex', 'uncompressed');
    const compressedKey = crypto.ECDH.convertKey(ecdhPubKey, 'c2pnb176v1', null, 'hex', 'compressed');
    const hybridKey = crypto.ECDH.convertKey(ecdhPubKey, 'c2pnb176v1', null, 'hex', 'hybrid');
    
    uncompressedKey;                                                                   // -> '041ad485a2666bc9edd90e53a33fd966ca6be61fa02259d4a8afb0f9b8efe2bbb541f3ebea3614a28dcac7e767'    
    uncompressedKey.length;                                                            // -> 90  
    
    compressedKey;                                                                     // -> '021ad485a2666bc9edd90e53a33fd966ca6be61fa02259'
    compressedKey.length;                                                              // -> 46
    
    hybridKey;                                                                         // -> '041ad485a2666bc9edd90e53a33fd966ca6be61fa02259d4a8afb0f9b8efe2bbb541f3ebea3614a28dcac7e767'    
    hybridKey.length;                                                                  // -> 90  
    </pre>
  </details>
  <details class="example">
    <summary> Example : </summary>
    <h4 style="color:darkblue;"><u> <mark>generatePrime()</mark> / <mark>generatePrimeSync()</mark> / <mark>checkPrime()</mark> / <mark>checkPrimeSync()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    
// generatePrime() / generatePrimeSync() ----------------------------------------------
    crypto.generatePrime(8, {bigint:true}, function(err, prime){
        if(err) console.log( err );
        console.log( prime );                                                          // -> 211n               // prime number 
    });

    console.log(
        crypto.generatePrimeSync(8, {bigint:true})                                     // -> 239n               // prime number  
    )
    
// checkPrime() / checkPrimeSync() ----------------------------------------------------
    crypto.checkPrime(239n, function(err, res){
        if(err) console.log( err );
        console.log( res );                                                            // -> true
    })

    crypto.checkPrime(240n, function(err, res){
        if(err) console.log( err );
        console.log( res );                                                            // -> false 
    })

    console.log(
        crypto.checkPrimeSync(239n)                                                    // -> true 
    );

    console.log(
        crypto.checkPrimeSync(240n)                                                    // -> false 
    );    
    </pre>
    <hr>
    <!---------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> Diffie-Hellman <mark>createDiffieHellman()</mark> / <mark>generateKeys()</mark> / <mark>getPrime()</mark> / <mark>getGenerator()</mark> / <mark>getPrivateKey()</mark> / <mark>getPublicKey()</mark> / <mark>verify</mark> / <mark>computeSecret()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    const util = require('util');
    
    const prime = crypto.generatePrimeSync(2048);                                      // a 2048bit prime length is the minimal recommended prime for diffie-hellman key exchanges    
    
// Alice ------------------------------------------------------------------------------
    const alice = crypto.createDiffieHellman(prime, 2);                                // alice creates its Diffie-Hellman   
    const alicePubKey = alice.generateKeys();                                          // alice generates its diffie-hellman private and public key pair (the public key is returned)   
    
    console.log( alice.getPrime() );                                                   // -> &lt;Buffer ...&gt;        // prime used by 'alice' diffie-hellman 
    console.log( alice.getGenerator() );                                               // -> &lt;Buffer ...&gt;        // generator used by 'alice' diffiel-hellman
    
    console.log( alice.getPrivateKey() );                                              // -> &lt;Buffer ...&gt;        // the generated private key 
    console.log( alice.getPublicKey() );                                               // -> &lt;Buffer ...&gt;        // the generated public key 
    
    console.log( util.isDeepStrictEqual(alicePubKey, alice.getPublicKey()))            // -> true 
    
    
// Bob --------------------------------------------------------------------------------
    const bob = crypto.createDiffieHellman(prime, 2);                                  // bob creates it's diffie-hellman
    const bobPubKey = bob.generateKeys();                                              // bob generates its diffie-hellman private and public key pair (the public key is returned)   
    
    
// exchanging diffie-hellman public keys ----------------------------------------------
// ------------------------------------------------------------------------------------
    // Alice ------------------------------------------------------
    const aliceSecret = alice.computeSecret(bobPubKey);                                // Alice takes Bob's public key and generates the shared secret (symmetric key)   
    
    // Bob --------------------------------------------------------
    const bobSecret = bob.computeSecret(alicePubKey);                                  // Bob takes Alice's public key and generates the shared secret (symmetric key)   
    
// ------------------------------------------------------------------------------------
    console.log( util.isDeepStrictEqual(aliceSecret, bobSecret) );                     // -> true                // Alice and Bob has a shared secret that can be used as secret key 
    
    console.log( alice.verifyError );                                                  // -> 2                   // crypto.constants.DH_CHECK_P_NOT_SAFE_PRIME (the used prime is not a 'safe-prime')     
    console.log( bob.verifyError );                                                    // -> 2                   // crypto.constants.DH_CHECK_P_NOT_SAFE_PRIME (the used prime is not a 'safe-prime')     
    </pre>
    <hr>
    <!---------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> Diffie-Hellman <mark>setPrivateKey()</mark> / <mark>setPublicKey()</mark> TEST </u></h4>
    <p> - non Diffie-Hellman private/public keys cannot be set! [TESTED] </p>
    <p> - the reason is that the diffie hellman protocol generates the private/public key with the provided prime and generator, so the returned 'diffie-hellman' keys contains the provided prime and generator </p>
    <pre>
    const crypto = require('crypto');
    const util = require('util');
    
// prestored diffie hellman keys --------------------------------------------------------    
    const prime = crypto.generatePrimeSync(2048);                         
    const alice = crypto.createDiffieHellman(prime, 3);
    
    alice.generateKeys();
    const alicePubKey = alice.getPublicKey();
    const alicePrivKey = alice.getPrivateKey();
    
    const bob = crypto.createDiffieHellman(prime, 3);
    bob.generateKeys();
    const bobPubKey = bob.getPublicKey();
    const bobPrivKey = bob.getPrivateKey();
    
    
// Charlie ----------------------------------------------------------------------------
    const charlie = crypto.createDiffieHellman(prime, 4);                              // same prime and generator used 
    charlie.setPublicKey(alicePubKey);                                                 // charlie uses alice's keys 
    charlie.setPrivateKey(alicePrivKey);
    
    
// Dany -------------------------------------------------------------------------------
    const dany = crypto.createDiffieHellman(prime, 4);                                 // same prime and generator used 
    dany.setPublicKey(bobPubKey);                                                      // dany uses bob's keys 
    dany.setPrivateKey(bobPrivKey);
    
    
// exchanging diffie-hellman public keys ----------------------------------------------
// ------------------------------------------------------------------------------------
// Charlie ----------------------------------------------------------------------------
    const charlieSecret = charlie.computeSecret(bobPubKey);                            // Charlie takes Dany's public key and generates the shared secret (symmetric key)   
    
// Dany -------------------------------------------------------------------------------
    const danySecret = dany.computeSecret(alicePubKey);                                // Dany takes Chariles's public key and generates the shared secret (symmetric key)   
    
// ------------------------------------------------------------------------------------
    console.log( util.isDeepStrictEqual(charlieSecret, danySecret) );                  // -> true       // Charlie and Dany has a shared secret that can be used as secret key   
    </pre>
    <hr>
    <!---------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> Diffie-Hellman Group <mark>createDiffieHellmanGroup()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    const util = require('util');
    
    
// Alice ------------------------------------------------------------------------------
    const alice = crypto.createDiffieHellmanGroup('modp14');                           // the modp14 is a predefined 2048bit diffie-hellman prime basically (diffie-hellman group)    
    const alicePubKey = alice.generateKeys();  
    
// Bob --------------------------------------------------------------------------------
    const bob = crypto.createDiffieHellmanGroup('modp14');                             // the modp14 is a predefined 2048bit diffie-hellman prime basically (diffie-hellman group)    
    const bobPubKey = bob.generateKeys();  
    
    
// exchanging diffie-hellman public keys ----------------------------------------------
// ------------------------------------------------------------------------------------
    // Alice ------------------------------------------------------
    const aliceSecret = alice.computeSecret(bobPubKey);                                // Alice takes Bob's public key and generates the shared secret (symmetric key)   
    
    // Bob --------------------------------------------------------
    const bobSecret = bob.computeSecret(alicePubKey);                                  // Bob takes Alice's public key and generates the shared secret (symmetric key)   
    
// ------------------------------------------------------------------------------------
    console.log( util.isDeepStrictEqual(aliceSecret, bobSecret) );                     // -> true                // Alice and Bob has a shared secret that can be used as secret key 
    </pre>
    <hr>
    <!---------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> Diffie-Hellman Group <mark>getDiffieHellman()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    const util = require('util');
    
    
// Alice ------------------------------------------------------------------------------
    const alice = crypto.getDiffieHellman('modp14');                                   // the modp14 is a predefined 2048bit diffie-hellman prime basically (diffie-hellman group)    
    const alicePubKey = alice.generateKeys();  
    
// Bob --------------------------------------------------------------------------------
    const bob = crypto.getDiffieHellman('modp14');                                     // the modp14 is a predefined 2048bit diffie-hellman prime basically (diffie-hellman group)    
    const bobPubKey = bob.generateKeys();  
    
    
// exchanging diffie-hellman public keys ----------------------------------------------
// ------------------------------------------------------------------------------------
    // Alice ------------------------------------------------------
    const aliceSecret = alice.computeSecret(bobPubKey);                                // Alice takes Bob's public key and generates the shared secret (symmetricy key)   
    
    // Bob --------------------------------------------------------
    const bobSecret = bob.computeSecret(alicePubKey);                                  // Bob takes Alice's public key and generates the shared secret (symmetricy key)   
    
// ------------------------------------------------------------------------------------
    console.log( util.isDeepStrictEqual(aliceSecret, bobSecret) );                     // -> true                // Alice and Bob has a shared secret that can be used as secret key 
    </pre>
    <hr>
    <!---------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> Elliptic Curve Diffie-Hellman <mark>createECDH()</mark> / <mark>generateKeys()</mark> / <mark>computeSecret()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    const util = require('util');
    
// Alice ------------------------------------------------------------------------------
    const alice = crypto.createECDH('secp521r1');                                      // uses the 'secp521r1' curve for for this ECDH key exchange utility    
    const alicePubKey = alice.generateKeys();                                          // the generated public ECDH key is returned 
    
// Bob --------------------------------------------------------------------------------
    const bob = crypto.createECDH('secp521r1');                                        // uses the 'secp521r1' curve for for this ECDH key exchange utility    
    const bobPubKey = bob.generateKeys();                                              // the generated public ECDH key is returned 
    
    
// exchanging ECDH public keys --------------------------------------------------------
// ------------------------------------------------------------------------------------
    // Alice ------------------------------------------------------
    const aliceSecret = alice.computeSecret(bobPubKey);                                // Alice takes Bob's ECHD public key and generates the shared secret (symmetricy key)   
    
    // Bob --------------------------------------------------------
    const bobSecret = bob.computeSecret(alicePubKey);                                  // Bob takes Alice's ECDH public key and generates the shared secret (symmetricy key)   
    
// ------------------------------------------------------------------------------------
    console.log( util.isDeepStrictEqual(aliceSecret, bobSecret) );                     // -> true                // Alice and Bob has a shared secret now   
    </pre>
    <hr>
    <!---------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> Elliptic Curve Diffie-Hellman <mark>getPrivateKey()</mark> / <mark>getPublicKey()</mark> / <mark>setPrivateKey()</mark> / <mark>setPublicKey()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    const util = require('util');
    
// prestored ECDH keys ----------------------------------------------------------------
    const alice = crypto.createECDH('secp224k1');
    alice.generateKeys();
    const alicePrivKey = alice.getPrivateKey();                                        // getting alice's ECDH private key
    const alicePubKey = alice.getPublicKey();                                          // getting alice's ECDH public key 
    
    const bob = crypto.createECDH('secp224k1');
    bob.generateKeys();
    const bobPrivKey = bob.getPrivateKey();                                            // getting bob's ECDH private key
    const bobPubKey = bob.getPublicKey();                                              // getting bob's ECDH public key 
    
    
// Charlie ----------------------------------------------------------------------------
    const charlie =crypto.createECDH('secp224k1');                                     // same curve used    
    charlie.setPrivateKey(alicePrivKey);                                               // charlie uses alice's key
    // charlie.setPublicKey(alicePubKey);                                              // -! ECDH utility only need the private key to be set (this method is deprecated node v5.2.0) 
    
    
// Dany -------------------------------------------------------------------------------
    const dany = crypto.createECDH('secp224k1');                                       // same curve used     
    dany.setPrivateKey(bobPrivKey);                                                    // dany uses bob's key 
    // dany.setPublicKey(bobPubKey);                                                   // -! ECDH utility only need the private key to be set (this method is deprecated node v5.2.0)  
    dany.setPrivateKey(bobPrivKey);
    
    
// exchanging diffie-hellman public keys ----------------------------------------------
// ------------------------------------------------------------------------------------
// Charlie ----------------------------------------------------------------------------
    const charlieSecret = charlie.computeSecret(bobPubKey);                            // Charlie takes Dany's public key and generates the shared secret (symmetric key)   
    
// Dany -------------------------------------------------------------------------------
    const danySecret = dany.computeSecret(alicePubKey);                                // Dany takes Chariles's public key and generates the shared secret (symmetric key)   
    
// ------------------------------------------------------------------------------------
    console.log( util.isDeepStrictEqual(charlieSecret, danySecret) );                  // -> true       // Charlie and Dany have a shared secret now 
    </pre>
    <hr>
    <!---------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> Elliptic Curve Diffie-Hellman <mark>ECHD.convertKey()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    const util = require('util');
    
    const ecdh = crypto.createECDH('c2pnb176v1');
    const ecdhPubKey = ecdh.generateKeys();
    
    const uncompressedKey = crypto.ECDH.convertKey(ecdhPubKey, 'c2pnb176v1', null, 'hex', 'uncompressed');
    const compressedKey = crypto.ECDH.convertKey(ecdhPubKey, 'c2pnb176v1', null, 'hex', 'compressed');
    const hybridKey = crypto.ECDH.convertKey(ecdhPubKey, 'c2pnb176v1', null, 'hex', 'hybrid');
    
    
    console.log( uncompressedKey );                                                    // -> '041ad485a2666bc9edd90e53a33fd966ca6be61fa02259d4a8afb0f9b8efe2bbb541f3ebea3614a28dcac7e767'    
    console.log( uncompressedKey.length );                                             // -> 90  
    
    console.log( compressedKey );                                                      // -> '021ad485a2666bc9edd90e53a33fd966ca6be61fa02259'
    console.log( compressedKey.length );                                               // -> 46
    
    console.log( hybridKey );                                                          // -> '041ad485a2666bc9edd90e53a33fd966ca6be61fa02259d4a8afb0f9b8efe2bbb541f3ebea3614a28dcac7e767'    
    console.log( hybridKey.length );                                                   // -> 90  
    </pre>
    <hr>
    <!---------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> compressed ECDH public keys TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    const util = require('util');
    
// Alice ------------------------------------------------------------------------------
    const alice = crypto.createECDH('secp521r1'); 
    const alicePubKey = alice.generateKeys(null, 'compressed');                        // the generated public ECDH key is compressed and returned 
    
// Bob --------------------------------------------------------------------------------
    const bob = crypto.createECDH('secp521r1'); 
    const bobPubKey = bob.generateKeys(null, 'compressed');                            // the generated public ECDH key is compressed and returned 
    
    
// exchanging ECDH public keys --------------------------------------------------------
// ------------------------------------------------------------------------------------
    // Alice ------------------------------------------------------
    const aliceSecret = alice.computeSecret(bobPubKey); 
    
    // Bob --------------------------------------------------------
    const bobSecret = bob.computeSecret(alicePubKey);  
    
// ------------------------------------------------------------------------------------
    console.log( util.isDeepStrictEqual(aliceSecret, bobSecret) );                     // -> true   
    </pre>
  </details>
  <hr>
  <!---------------------------------------------------------------------------------------------------------------->
  <h2 style="color:darkblue;"><u> X509 Certificate / <mark>new X509Certificate()</mark> / <mark>ca</mark> / <mark>subject</mark> / <mark>subjectAltName</mark> / <mark>issuer</mark> / <mark>issuerCertificate</mark> / <mark>infoAccess</mark> / <mark>serialNumber</mark> / <mark>checkEmail()</mark> / <mark>checkHost()</mark> / <mark>checkIP()</mark> / <mark>validFrom</mark> / <mark>validTo</mark> / <mark>fingerprint</mark> / <mark>fingerprint256</mark> / <mark>publicKey</mark> / <mark>keyUsage</mark> / <mark>raw</mark> / <mark>toString()</mark> / <mark>toJSON()</mark> / <mark>toLegacyObject()</mark> / <mark>checkIssued()</mark> / <mark>verify()</mark> / <mark>checkPrivateKey()</mark> </u></h2>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    const crypto = require('crypto');
    const https = require('https');
    const fs = require('fs');
    const tls = require('tls');
    
    let ca = new crypto.X509Certificate(fs.readFileSync('./GTS1O1.crt'));              // the ICA's certificate (the certificate that actually signed the received certificate from the server)  
    let somePrivKey = crypto.generateKeyPairSync('rsa', {modulusLength:2048}).privateKey;
    
    let clientReq = https.get('https://www.google.com', function(incMsg){
        let crt =  new crypto.X509Certificate(incMsg.socket.getPeerCertificate().raw); // server's certificate wrapped in an x509 certificate object   
    
// ca ---------------------------------------------------------------------------------
        crt.ca;                                                                        // -> false                         // not a Certificate Authority Certificate (it's a server certificate)    
        ca.ca;                                                                         // -> true                          // ICA's certificate is a CA certificate (certificate that is used to sign CSRs)    
    
// subject / subjectAltName / issuer / issuerCertificate / infoAccess / serialNumber --
        crt.subject;                                                                   // -> 'C=US ...'                    // the complete certificate's subject 
        crt.subjectAltName;                                                            // -> 'DNS...'                      // domain name and     
        
        crt.issuer;                                                                    // -> 'C=US ...                     // issuer's identifications 
        crt.issuerCertificate;                                                         // -> undefined                     // issuer's certificate 
        
        crt.infoAccess;                                                                // -> OCSP - ...'                   // access information of the certifiate 
        
        crt.serialNumber;                                                              // -> '1670310C..'                  // serial number of the certificate 
    
// checkEmail() / checkHost() / checkIP() ---------------------------------------------
        crt.checkEmail('somemail@gmail.com');                                          // -> undefined                     // certificate does not match the passed email  
        crt.checkHost('www.google.com');                                               // -> 'www.google.com'              // certificate matches the passed hostname   
        crt.checkHost('127.0.0.1');                                                    // -> undefined                     // certificate does not match the passed ip address    
    
// validFrom / validTo ----------------------------------------------------------------
        crt.validFrom;                                                                 // -> 'Mar 11 15:00:19 2021 GMT'  
        crt.validTo;                                                                   // -> 'Jun  3 15:00:18 2021 GMT'   
    
// fingerpirnt / fingerprint256 -------------------------------------------------------
        crt.fingerprint;                                                               // -> '06:CB:C1:ED:3F:...'           // certificate SHA-1 fingerprint    
        crt.fingerprint256;                                                            // -> '21:AE:85:DA:B9:...'           // certificate SHA-256 fingerprint    
    
// publicKey / keyUsage ---------------------------------------------------------------
        crt.publicKey;                                                                 // -> keyObj                        // the public key of the certificate     
        crt.keyUsage;                                                                  // -> ['1.3.6.1.5....']             // how the public key ma be used 
    
// raw / toString() / toJSON() / toLegacyObject() -------------------------------------
        crt.raw;                                                                       // -> &lt;Buffer ...&gt;                  // returns a buffer containing the der encoded certificate   
        crt.toString();                                                                // -> '-----BEGIN CER...'           // returns the pem encoded certificate in a string  
        crt.toJSON();                                                                  // -> '-----BEGIN CER...'           // returns the pem encoded certificate in a string  
        crt.toLegacyObject();                                                          // -> {subject:..., ...}            // returns the certificate in a JS (legacy) object    
    
// checkIssued() / verify() / checkPrivateKey() ---------------------------------------
        crt.checkIssued(ca);                                                           // -> true                          // certificate issued by the passed ca (Certificate Authority certificate)    
        crt.verify(ca.publicKey);                                                      // -> true                          // certificate was signed with the passed public key 
        crt.checkPrivateKey(somePrivKey);                                              // -> false                         // private key is not the certificate's private key pair   
    }); 
    </pre>
  </details>
  <details class="example">
    <summary> Example : </summary>
    <h4 style="color:darkblue;"><u> x509 Certificate <mark>ca</mark> / <mark>subject</mark> / <mark>subjectAltName</mark> / <mark>infoAccess</mark> / <mark>issuer</mark> / <mark>issuerCertificate</mark> / <mark>checkEmail()</mark> / <mark>checkHost()</mark> / <mark>checkIP()</mark> / <mark>fingerprint</mark> / <mark>fingerprint256</mark> / <mark>keyUsage</mark> / <mark>publicKey</mark> / <mark>raw</mark> / <mark>serialNumber</mark> / <mark>toJSON()</mark> / <mark>toString()</mark> / <mark>validFrom</mark> / <mark>validTo</mark> / <mark>verify()</mark> TEST </u></h4>
    <pre>
    const crypto = require('crypto');
    const https = require('https');
    const fs = require('fs');
    const tls = require('tls');
    
    let ca = new crypto.X509Certificate(fs.readFileSync('./GTS1O1.crt'));              // the ICA's certificate (the certificate that actually signed the received certificate from the server)  
    let somePrivKey = crypto.generateKeyPairSync('rsa', {modulusLength:2048}).privateKey;
    
    let clientReq = https.get('https://www.google.com', function(incMsg){
        let crt =  new crypto.X509Certificate(incMsg.socket.getPeerCertificate().raw);
    
// ca ---------------------------------------------------------------------------------
        console.log( crt.ca );                                                         // -> false                         // not a Certificate Authority Certificate (it's a server certificate)    
        console.log( ca.ca );                                                          // -> true                          // ICA's certificate is a CA certificate (certificate that is used to sign CSRs)    
    
    
// subject / subjectAltName / issuer / issuerCertificate / infoAccess / serialNumber --
        console.log( crt.subject );                                                    // -> 'C=US ...'                    // the complete certificate's subject 
        console.log( crt.subjectAltName );                                             // -> 'DNS...'                      // domain name and     
        console.log( crt.issuer );                                                     // -> 'C=US ...                     // issuer's identifications 
        console.log( crt.issuerCertificate );                                          // -> undefined                     // issuer's certificate 
        console.log( crt.infoAccess );                                                 // -> OCSP - ...'                   // access information of the certifiate 
        console.log( crt.serialNumber );                                               // -> '1670310C..'                  // serial number of the certificate 
    
    
// checkEmail() / checkHost() / checkIP() ---------------------------------------------
        console.log( crt.checkEmail('somemail@gmail.com') );                           // -> undefined                     // certificate does not match the passed email  
        console.log( crt.checkHost('www.google.com') );                                // -> 'www.google.com'              // certificate matches the passed hostname   
        console.log( crt.checkHost('127.0.0.1') );                                     // -> undefined                     // certificate does not match the passed ip address    
    
    
// validFrom / validTo ----------------------------------------------------------------
        console.log( crt.validFrom );                                                  // -> 'Mar 11 15:00:19 2021 GMT'  
        console.log( crt.validTo );                                                    // -> 'Jun  3 15:00:18 2021 GMT'   
    
    
// fingerpirnt / fingerprint256 -------------------------------------------------------
        console.log( crt.fingerprint );                                                // -> '06:CB:C1:ED:3F:...'           // certificate SHA-1 fingerprint    
        console.log( crt.fingerprint256 );                                             // -> '21:AE:85:DA:B9:...'           // certificate SHA-256 fingerprint    
    
    
// publicKey / keyUsage ---------------------------------------------------------------
        console.log( crt.publicKey );                                                  // -> keyObj                        // the public key of the certificate     
        console.log( crt.keyUsage );                                                   // -> ['1.3.6.1.5....']             // how the public key ma be used 
    
    
// raw / toString() / toJSON() / toLegacyObject() -------------------------------------
        console.log( crt.raw );                                                        // -> &lt;Buffer ...&gt;            // returns a buffer containing the der encoded certificate   
        console.log( crt.toString() );                                                 // -> '-----BEGIN CER...'           // returns the pem encoded certificate in a string  
        console.log( crt.toJSON() );                                                   // -> '-----BEGIN CER...'           // returns the pem encoded certificate in a string  
        console.log( crt.toLegacyObject() );                                           // -> {subject:..., ...}            // returns the certificate in a JS (legacy) object    
    
    
// checkIssued() / verify() / checkPrivateKey() ---------------------------------------
        console.log( crt.checkIssued(ca) );                                            // -> true                          // certificate issued by the passed ca (Certificate Authority certificate)    
        console.log( crt.verify(ca.publicKey) );                                       // -> true                          // certificate was signed with the passed public key 
        console.log( crt.checkPrivateKey(somePrivKey) );                               // -> false                         // private key is not the certificate's private key pair   
    }); 
    </pre>
    <pre class="cmd">
    pall@Ryzen:~/Documents/CodePlus/My Site/Node.js/Crypto$ node main
        false
        true
        C=US
        ST=California
        L=Mountain View
        O=Google LLC
        CN=www.google.com
        DNS:www.google.com
        C=US
        O=Google Trust Services
        CN=GTS CA 1O1
        undefined
        OCSP - URI:http://ocsp.pki.goog/gts1o1core
        CA Issuers - URI:http://pki.goog/gsr2/GTS1O1.crt
        C15EA0383C79E3440300000000CBCFBA
        undefined
        www.google.com
        undefined
        Mar 16 19:35:00 2021 GMT
        Jun  8 19:34:59 2021 GMT
        82:ED:34:E0:23:5F:0A:96:32:D1:58:9D:1E:66:62:90:34:42:AD:AF
        E1:1F:58:0D:A5:75:BB:7F:3E:17:BB:0D:31:EE:2D:E0:C7:20:B6:6A:FF:EE:F6:9C:D2:33:88:7C:D8:AD:54:10
        PublicKeyObject { [Symbol(kKeyType)]: 'public' }
        [ '1.3.6.1.5.5.7.3.1' ]
        &lt;Buffer 30 82 04 c8 30 82 03 b0 a0 03 02 01 02 02 11 00 c1 5e a0 38 3c 79 e3 44 03 00 00 00 00 cb cf ba 30 0d 06 09 2a 86 48 86 f7 0d 01 01 0b 05 00 30 42 31 ... 1178 more bytes&gt;
        -----BEGIN CERTIFICATE-----
        MIIEyDCCA7CgAwIBAgIRAMFeoDg8eeNEAwAAAADLz7owDQYJKoZIhvcNAQELBQAw
        QjELMAkGA1UEBhMCVVMxHjAcBgNVBAoTFUdvb2dsZSBUcnVzdCBTZXJ2aWNlczET
        MBEGA1UEAxMKR1RTIENBIDFPMTAeFw0yMTAzMTYxOTM1MDBaFw0yMTA2MDgxOTM0
        NTlaMGgxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQH
        Ew1Nb3VudGFpbiBWaWV3MRMwEQYDVQQKEwpHb29nbGUgTExDMRcwFQYDVQQDEw53
        d3cuZ29vZ2xlLmNvbTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABFmtG1hqQopw
        vwO0CIf5xfHU5ci/665r+JmBPDybtzPK7JmT840m7q1/yPcES/a0BqqLTPTNJyZI
        796ZAFcqbbijggJcMIICWDAOBgNVHQ8BAf8EBAMCB4AwEwYDVR0lBAwwCgYIKwYB
        BQUHAwEwDAYDVR0TAQH/BAIwADAdBgNVHQ4EFgQUS/14JW+kX3ax4OPTiPrRbuIn
        STwwHwYDVR0jBBgwFoAUmNH4bhDrz5vsYJ8YkBug630J/SswaAYIKwYBBQUHAQEE
        XDBaMCsGCCsGAQUFBzABhh9odHRwOi8vb2NzcC5wa2kuZ29vZy9ndHMxbzFjb3Jl
        MCsGCCsGAQUFBzAChh9odHRwOi8vcGtpLmdvb2cvZ3NyMi9HVFMxTzEuY3J0MBkG
        A1UdEQQSMBCCDnd3dy5nb29nbGUuY29tMCEGA1UdIAQaMBgwCAYGZ4EMAQICMAwG
        CisGAQQB1nkCBQMwMwYDVR0fBCwwKjAooCagJIYiaHR0cDovL2NybC5wa2kuZ29v
        Zy9HVFMxTzFjb3JlLmNybDCCAQQGCisGAQQB1nkCBAIEgfUEgfIA8AB2AESUZS6w
        7s6vxEAH2Kj+KMDa5oK+2MsxtT/TM5a1toGoAAABeDy/udIAAAQDAEcwRQIgVY40
        WyUysNidcbnrylA4SESze0CQvUWMQKMI4gHzi34CIQDidQzVoDiSGdDqrDp5yKDR
        6z0zKd1mm0MQjpYoUD+TPgB2AH0+8viP/4hVaCTCwMqeUol5K8UOeAl/LmqXaJl+
        IvDXAAABeDy/ucoAAAQDAEcwRQIhAOohO9kpFZYdIyC57GAtfHQTXK78ovv3VIVn
        SP1bhW1qAiANrObfVpLoprzfwqyPpzczU3u1xqIsNIZ+BDPJm+XvbjANBgkqhkiG
        9w0BAQsFAAOCAQEALRKpgqxd0etTPsoYcQrDReuVq+4x5NdgA31vliZuX7liwPT9
        3E/5kRtElaeW3G3SqPKBURKAr1AG20WWIeYqv9SXz6kI4hoU5ZEPMbW3L2fetXiq
        WZM3TAEyiOCYuO1nenmaHCzu3dEzwAts8xqOq6tq0fktZom+V8WRyD3IMnsydMWu
        GtOUxbIE8T/1JWBMMMJv8NxT3Ia2uv1OK0Zr2WKNpoiziq2YFs4hMhCg3nvSYb7/
        FXZ0bKq0nU88Ve409XsKe4LkPCRVO725R/NtsfsPtPE8vWYgyUXOSN1tBwLNjIva
        bTMkzuKeiopJoGQI75BoQejw+Y53N9YRaKCbiA==
        -----END CERTIFICATE-----
    
        -----BEGIN CERTIFICATE-----
        MIIEyDCCA7CgAwIBAgIRAMFeoDg8eeNEAwAAAADLz7owDQYJKoZIhvcNAQELBQAw
        QjELMAkGA1UEBhMCVVMxHjAcBgNVBAoTFUdvb2dsZSBUcnVzdCBTZXJ2aWNlczET
        MBEGA1UEAxMKR1RTIENBIDFPMTAeFw0yMTAzMTYxOTM1MDBaFw0yMTA2MDgxOTM0
        NTlaMGgxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQH
        Ew1Nb3VudGFpbiBWaWV3MRMwEQYDVQQKEwpHb29nbGUgTExDMRcwFQYDVQQDEw53
        d3cuZ29vZ2xlLmNvbTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABFmtG1hqQopw
        vwO0CIf5xfHU5ci/665r+JmBPDybtzPK7JmT840m7q1/yPcES/a0BqqLTPTNJyZI
        796ZAFcqbbijggJcMIICWDAOBgNVHQ8BAf8EBAMCB4AwEwYDVR0lBAwwCgYIKwYB
        BQUHAwEwDAYDVR0TAQH/BAIwADAdBgNVHQ4EFgQUS/14JW+kX3ax4OPTiPrRbuIn
        STwwHwYDVR0jBBgwFoAUmNH4bhDrz5vsYJ8YkBug630J/SswaAYIKwYBBQUHAQEE
        XDBaMCsGCCsGAQUFBzABhh9odHRwOi8vb2NzcC5wa2kuZ29vZy9ndHMxbzFjb3Jl
        MCsGCCsGAQUFBzAChh9odHRwOi8vcGtpLmdvb2cvZ3NyMi9HVFMxTzEuY3J0MBkG
        A1UdEQQSMBCCDnd3dy5nb29nbGUuY29tMCEGA1UdIAQaMBgwCAYGZ4EMAQICMAwG
        CisGAQQB1nkCBQMwMwYDVR0fBCwwKjAooCagJIYiaHR0cDovL2NybC5wa2kuZ29v
        Zy9HVFMxTzFjb3JlLmNybDCCAQQGCisGAQQB1nkCBAIEgfUEgfIA8AB2AESUZS6w
        7s6vxEAH2Kj+KMDa5oK+2MsxtT/TM5a1toGoAAABeDy/udIAAAQDAEcwRQIgVY40
        WyUysNidcbnrylA4SESze0CQvUWMQKMI4gHzi34CIQDidQzVoDiSGdDqrDp5yKDR
        6z0zKd1mm0MQjpYoUD+TPgB2AH0+8viP/4hVaCTCwMqeUol5K8UOeAl/LmqXaJl+
        IvDXAAABeDy/ucoAAAQDAEcwRQIhAOohO9kpFZYdIyC57GAtfHQTXK78ovv3VIVn
        SP1bhW1qAiANrObfVpLoprzfwqyPpzczU3u1xqIsNIZ+BDPJm+XvbjANBgkqhkiG
        9w0BAQsFAAOCAQEALRKpgqxd0etTPsoYcQrDReuVq+4x5NdgA31vliZuX7liwPT9
        3E/5kRtElaeW3G3SqPKBURKAr1AG20WWIeYqv9SXz6kI4hoU5ZEPMbW3L2fetXiq
        WZM3TAEyiOCYuO1nenmaHCzu3dEzwAts8xqOq6tq0fktZom+V8WRyD3IMnsydMWu
        GtOUxbIE8T/1JWBMMMJv8NxT3Ia2uv1OK0Zr2WKNpoiziq2YFs4hMhCg3nvSYb7/
        FXZ0bKq0nU88Ve409XsKe4LkPCRVO725R/NtsfsPtPE8vWYgyUXOSN1tBwLNjIva
        bTMkzuKeiopJoGQI75BoQejw+Y53N9YRaKCbiA==
        -----END CERTIFICATE-----
        
        {
        subject: 'C=US\nST=California\nL=Mountain View\nO=Google LLC\nCN=www.google.com',
        issuer: 'C=US\nO=Google Trust Services\nCN=GTS CA 1O1',
        subjectaltname: 'DNS:www.google.com',
        infoAccess: 'OCSP - URI:http://ocsp.pki.goog/gts1o1core\n' +
            'CA Issuers - URI:http://pki.goog/gsr2/GTS1O1.crt\n',
        bits: 256,
        pubkey: &lt;Buffer 04 59 ad 1b 58 6a 42 8a 70 bf 03 b4 08 87 f9 c5 f1 d4 e5 c8 bf eb ae 6b f8 99 81 3c 3c 9b b7 33 ca ec 99 93 f3 8d 26 ee ad 7f c8 f7 04 4b f6 b4 06 aa ... 15 more bytes&gt;,
        asn1Curve: 'prime256v1',
        nistCurve: 'P-256',
        valid_from: 'Mar 16 19:35:00 2021 GMT',
        valid_to: 'Jun  8 19:34:59 2021 GMT',
        fingerprint: '82:ED:34:E0:23:5F:0A:96:32:D1:58:9D:1E:66:62:90:34:42:AD:AF',
        fingerprint256: 'E1:1F:58:0D:A5:75:BB:7F:3E:17:BB:0D:31:EE:2D:E0:C7:20:B6:6A:FF:EE:F6:9C:D2:33:88:7C:D8:AD:54:10',
        ext_key_usage: [ '1.3.6.1.5.5.7.3.1' ],
        serialNumber: 'C15EA0383C79E3440300000000CBCFBA',
        raw: &lt;Buffer 30 82 04 c8 30 82 03 b0 a0 03 02 01 02 02 11 00 c1 5e a0 38 3c 79 e3 44 03 00 00 00 00 cb cf ba 30 0d 06 09 2a 86 48 86 f7 0d 01 01 0b 05 00 30 42 31 ... 1178 more bytes&gt;
        }
        true
        true
        false
    pall@Ryzen:~/Documents/CodePlus/My Site/Node.js/Crypto$ 
    </pre>
  </details>

  <br><br>
</body>

</html>