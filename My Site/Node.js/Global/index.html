<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title> Global </title>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

    <link rel="stylesheet" href="../../Assets/stylesPages.css">
    <script src="../../Assets/scriptPages.js"></script>
  </head>

  <body>
    <h1> Global </h1>
    <p> Updated ( 2022-02-12 / 2024-03-13 )</p>
    <nav class="sitenav"> <a href="../../index.html">MySite > </a>
      <a href="../index.html">Node.js > </a> Global
    </nav>
    <table class="table">
      <tr>
        <th style="width:30%;"> Method / Property </th>
        <th> Description </th>
      </tr>
      <tr>
        <td>
          atob(<strong>str</strong>)
        </td>
        <td>
          - encodes the passed <strong>str</strong> into base64 and returns it (Not recommended to use, use some <mark>Buffer</mark> tools instead)
          <span class="browserSupport" title="updated : 2022-02-12">
            <span><i class="fab fa-node-js"></i> 16.0.0 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>
          btoa(<strong class="openable">strBase64<div>
              <p> - base64 encoded string </p>
            </div></strong>)
        </td>
        <td>
          - encodes the passed <strong>strBase64</strong> into a JavaScript string (Not recommended to use, use some <mark>Buffer</mark> tools instead)
          <span class="browserSupport" title="updated : 2022-02-12">
            <span><i class="fab fa-node-js"></i> 16.0.0 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr id="queueMicroTask">
        <td>
          queueMicroTask(<reqval>fn</reqval>)
        </td>
        <td>
          - puts the <reqval>fn</reqval> at the end of the micro queue (so the <reqval>fn</reqval> runs before any macro queue callbacks) <br>
          - recommended over <mark>process.nextTick()</mark> after <span class="browserSupport" title="updated: 2025-03-18"><span><i class="fab fa-node-js"></i> 20.18 </span></span> <br>
          <span class="browserSupport" title="updated: 2025-03-18">
            <span><i class="fab fa-node-js"></i> 11 </span>
          </span>
        </td>
      </tr>
    </table>
    <br>
    <table class="table">
      <caption>
        <mark>AbortController</mark> and <mark>AbortSignal</mark> API
        <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
      </caption>
      <tr>
        <th style="width:30%;"> Method / Property / statement ect... </th>
        <th> Description </th>
      </tr>
      <tr>
        <td colspan="2"> <mark>AbortController</mark> </td>
      </tr>
      <tr>
        <td>
          new AbortController()
        </td>
        <td>
          - creates and returns a new <strong>abortController</strong> object
          <span class="browserSupport" title="updated : 2022-02-13">
            <span><i class="fab fa-node-js"></i> 15.4.0 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>abortController</strong>.signal
        </td>
        <td>
          - returns the <strong>abortSignal</strong> instance of the abortController
          <span class="browserSupport" title="updated : 2022-02-13">
            <span><i class="fab fa-node-js"></i> 15.4.0 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>
          <strong>abortController</strong>.abort(<i class="openable">reason:any<div>
              <p> - retrieveable on the <mark><strong>abortSginal</strong>.reason</mark> property </p>
            </div></i>)
        </td>
        <td>
          - triggers the abort signal, causes the <mark><strong>abortController</strong>.signal</mark> to emit the <mark>abort</mark> event
          <span class="browserSupport" title="updated : 2022-02-13">
            <span><i class="fab fa-node-js"></i> 15.4.0 </span>
            <span><i class="fab fa-node-js"></i> 17.2.0 <i>reason</i> option </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2"> <mark>AbortSignal</mark> </td>
      </tr>
      <tr>
        <td>
          AbortSignal.abort(<i>reason:any</i>)
        </td>
        <td>
          - returns an already aborted <strong>abortSignal</strong> object
          <span class="browserSupport" title="updated : 2022-02-13">
            <span><i class="fab fa-node-js"></i> 15.4.0 </span>
            <span><i class="fab fa-node-js"></i> 17.2.0 <i>reason</i> option </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>
          AbortSignal.timeout(<strong>delay:ms</strong>)
        </td>
        <td>
          - returns an <strong>abortSignal</strong> object which will be aborted after <strong>delay</strong>
          <span class="browserSupport" title="updated : 2022-02-13">
            <span><i class="fab fa-node-js"></i> 15.4.0 </span>
            <span><i class="fab fa-node-js"></i> 17.2.0 <i>reason</i> option </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>
          AbortSignal.any(<reqval>abrotSignal[]</reqval>)
        </td>
        <td>
          - returns a aborted new <reqval>abrotSignal</reqval> if any of the passed <reqval>abrotSignal</reqval> is aborted
          <span class="browserSupport">
            <span><i class="fab fa-node-js"></i> 20.3.0 / 18.17.0 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>abortSignal</strong>.aborted
        </td>
        <td>
          - returns <mark>true</mark> if the signal is aborted, othewise returns <mark>false</mark>
          <span class="browserSupport" title="updated : 2022-02-13">
            <span><i class="fab fa-node-js"></i> 15.4.0 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>
          <strong>abortSignal</strong>.reason
        </td>
        <td>
          - returns abort reason (the argument passed in <mark>abort()</mark>
          <span class="browserSupport" title="updated : 2022-02-13">
            <span><i class="fab fa-node-js"></i> 17.2.0 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>abortSignal</strong>.throwIfAborted()
        </td>
        <td>
          - if <mark>abortSignal.<reqval>aborted</reqval></mark> is <mark>true</mark> throws <mark>abortSignal.<reqval>reason</reqval></mark> when called
          <span class="browserSupport" title="updated : 2022-02-13">
            <span><i class="fab fa-node-js"></i> 17.3.0 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>abortSginal</strong>.onabort = <strong>fn(ev)</strong>
        </td>
        <td>
          - <reqval>fn</reqval> called when the <mark><reqval>abortControler</reqval>.abort()</mark> called
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2"> events </td>
      </tr>
      <tr>
        <td>
          <strong>abortSginal</strong>.addEventListener('abort', <strong>fn(ev)</strong>, {once:true})
        </td>
        <td>
          - event emitted when the <strong>abortSginal</strong> is aborted (on <mark><strong>abortController</strong>.abort()</mark> / <mark><strong>abortSignal</strong>.abort()</mark> / <mark><strong>abortSignal</strong>.timeout()</mark>) <br>
          - the <mark>AbortController</mark> API is a frontend implementation in Node.js, this is the reason why we can use <mark>addEventListener()</mark> or <mark>onabort</mark> <br>
          - the this even should be listened only once that's why we pass the <mark>{once:true}</mark> option
          <span class="browserSupport" title="updated : 2022-02-13">
            <span><i class="fab fa-node-js"></i> 15.4.0 </span>
          </span>
        </td>
      </tr>
    </table>
    <br>
    
    <h2 class="headerSection"> Useful Links : </h2>
    <p><a href="https://nodejs.org/api/globals.html" target="_blanc">Globals (nodejs.org)</a></p>
    <h2 class="headerSection"> Remember This : </h2>

    <h2 class="headerSection"> Description and Demonstration : </h2>
    <p> - this page contains tools that are available on the <mark>global</mark> object but not really relevant elsewhere </p>
    <!----------------------------------------------------------------------------------------------->
    <hr>
    <h3 class="header"> The <mark>atob()</mark> / <mark>btoa()</mark> methods </h3>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
    const toBase64 = atob('test');                                                     // encodes the passed string in base64   
    toBase64;                                                                          // -> 'µë-'        // 'test' encoded in base64   
    
    btoa(toBase64);                                                                    // -> 'test'       // converts the base64 encoded data to string   
    </pre>
    </details>
    <!----------------------------------------------------------------------------------------------->
    <hr>
    <h3 class="header"> The <mark>queueMicroTask()</mark> method </h3>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
    queueMicrotask(() => {
      console.log('microtask 1')
    })
      </pre>
    </details>
    <!----------------------------------------------------------------------------------------------->
    <hr>
    <h2 class="header"> The <mark>AbortController</mark> / <mark>Signal</mark> API </h2>
    <p> - This API is used to send an abort signal to promise based APIs (Compatible with the browser <mark>AbortController</mark> API) </p>
    <p> - we can send an abort signal to promisees that are pending </p>
    <details class="example">
      <summary> DEMO : </summary>
      <p> - at the time of writing this (2022-02-13) I couldn't find any build in promise that supports the AbortController API, so I ductaped one here in the bellow example </p>
      <pre style="margin-bottom:1px">
    const abortController = new AbortController();                                     // the abort controller that will send the abort signal    
    
    const somePromise = new Promise((res, rej) => {                                    // promise stays pending for 1 minute (unless receives the abort signal)  
        let counter = 0
        let interval = setInterval(() => {
            if (counter > 1) {
                res('resolved!');
                clearInterval(interval)
            }
            counter++
        }, 1000);
        
        abortController.signal.addEventListener('abort', () => {                      // abort signal reject's the promise 
            rej('aborted');
        })
    }); 
    
    somePromise
        .then(res => console.log(res))
        .catch(err=> console.log(err));
    
    setTimeout(() => {
        abortController.abort();                                                       // sending the abort signal after 3 seconds    
    }, 3000);
    </pre>
      <pre class="cmd" style="margin-top:1px">
    root@5fe3a71c2b64:/test# node ts.mjs
        aborted                                                                        // after 3 seconds 
    </pre>
      <pre>
    const abortController = new AbortController()
    const abortSignal = abortController.signal
    
    abortSignal.addEventListener('abort', (ev) => {                                    // the abortController is a frontend API so we can use 'addEventListener()' or 'onabort' 
        abortSignal.reason;                                                            // -> 'some abort reason'
        abortSignal.aborted;                                                           // -> false    // signal not aborted yet
    }, {once:true});                                                                   // we have to make sure that the event is triggered only     once   
    
// does the same as the above 'addEventListener()' method -----------------------------
    abortSignal.onabort = (ev) => {
        abortSignal.reason;                                                            // -> 'some abort reason'
        abortSignal.aborted;                                                           // -> false    // signal not aborted yet
    }
    
    abortSignal.aborted;                                                               // -> true     // signal aborted 
    
    setTimeout(() => {
        abortController.abort('some abort reason');                                    // aborting after 3 seconds 
    }, 3000);
    </pre>
      <pre>
// AbortSignal.abort() ----------------------------------------------------------------
    const abortSignal1 = AbortSignal.abort();                                          // creates an already aborted abortSignal 
    console.log( abortSignal1.aborted );                                               // -> true  
    
    abortSignal1.addEventListener('abort', ev => {}, {once:true});                     // this never triggers because the signal is already aborted    
    
// AbortSignal.timeout() --------------------------------------------------------------
    const abortSignal2 = AbortSignal.timeout(1000);                                    // abortSignal will abort after 1 second 
    abortSignal2.aborted;                                                              // -> false    // will be true after 1 second    
    
    abortSignal2.addEventListener('abort', ev => {}, {once:true});                     // emitted after 1 second
    
// throwIfAborted() -------------------------------------------------------------------
    const abortController = new AbortController();
    
    abortController.signal.aborted;                                                    // -> false
    abortController.signal.throwIfAborted();                                           // this won't throw because the 'abortController.signal.aborted' is 'false' (signal not aborted yet)    
    
    abortController.abort('some abort error');                                         // aborting the abort signal    
    
    abortController.signal.aborted;                                                    // -> true 
    try {
        abortController.signal.throwIfAborted();                                       // throws 'some abort error'  
    } catch (err) {
        err;                                                                           // -> 'some abort error'    
    }
    </pre>
    </details>
    <details class="example">
      <summary> Example : </summary>
      <h3 class="header"> <mark>AbortController</mark> / <mark>signal</mark> / <mark>abort()</mark> / <mark>addEventListener()</mark> / <mark>onabort</mark> / <mark>reason</mark> / <mark>aborted</mark> TEST </h3>
      <pre style="margin-bottom:1px">
    const abortController = new AbortController()
    const abortSignal = abortController.signal
    
    abortSignal.addEventListener('abort', (ev) => {                                    // the abortController is a frontend API so we can use 'addEventListener()' or 'onabort' 
        console.log( 'abort signal emitted!' ); 
        console.log( abortSignal.reason );                                             // -> 'some abort reason'
        console.log( abortSignal.aborted );                                            // -> true
    }, {once:true});                                                                   // we have to make sure that the event is triggered only     once   
    
// does the same as the above 'addEventListener()' method -----------------------------
    abortSignal.onabort = (ev) => {
        console.log( 'abort signal emitted!' );
        console.log( abortSignal.reason );                                             // -> 'some abort reason'
        console.log( abortSignal.aborted );                                            // -> true
    }
    
    console.log( abortSignal.aborted );                                                // -> false 
    
    setTimeout(() => {
        abortController.abort('some abort reason');                                    // aborting after 3 seconds 
    }, 3000);
    </pre>
      <pre class="cmd" style="margin-top:1px">
    root@5fe3a71c2b64:/test# node ts.mjs
        false
        abort signal emitted!                                                          // after 3 seconds 
        some abort reason
        true
    </pre>
      <!--------------------------------------------------------------------------------------------->
      <hr>
      <h3 class="header"> <mark>AbortSignal.abort()</mark> / <mark>AbortSignal.timeout()</mark> TEST </h3>
      <pre style="margin-bottom:1px">
// AbortSignal.abort() ----------------------------------------------------------------
    const abortSignal1 = AbortSignal.abort();                                          // creates an already aborted abortSignal 
    console.log( abortSignal1.aborted );                                               // -> true  
    
    abortSignal1.addEventListener('abort', ev => {                                     // this never triggers because the signal is already aborted    
        console.log( 'abortSignal1 aborted!' );
    }, {once:true})
    
// AbortSignal.timeout() --------------------------------------------------------------
    const abortSignal2 = AbortSignal.timeout(1000);                                    // abortSignal will abort after 1 second 
    console.log( abortSignal2.aborted );                                               // -> false 
    
    abortSignal2.addEventListener('abort', ev => {                                     // emitted after 1 second
        console.log( 'abortSignal2 aborted!' );
    }, {once:true});
    
    
    setTimeout(() => {
        console.log( abortSignal2.aborted );                                           // -> true 
    }, 2000);
    </pre>
      <pre class="cmd" style="margin-top:1px">
    root@5fe3a71c2b64:/test# node ts.mjs
        true
        false
        abortSignal2 aborted!                                                          // after 1 second 
        true
    </pre>
      <!--------------------------------------------------------------------------------------------->
      <hr>
      <h3 class="header"> <mark>throwIfAborted()</mark> TEST </h3>
      <pre style="margin-bottom:1px">
    const abortController = new AbortController();
    console.log( abortController.signal.aborted );                                     // -> false
    abortController.signal.throwIfAborted();                                           // this won't throw because the 'abortController.signal.aborted' is 'false'    
    
    abortController.abort('some abort error');                                         // aborting the abort signal   
    console.log( abortController.signal.aborted );                                     // -> true 
    
    try {
        abortController.signal.throwIfAborted();                                       // throws 'some abort error'  
    } catch (err) {
        console.log(err);                                                              // -> 'some abort error'   
    }
    </pre>
      <pre class="cmd" style="margin-top:1px">
    root@5fe3a71c2b64:/test# node ts.mjs
        false
        true
        some abort error
    </pre>
    </details>

    <br><br>
  </body>

</html>