<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title> Mokking, Spying & Stabbing </title> 
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous"> 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../../../Assets/stylesPages.css"> 
    <script src="../../../../Assets/scriptPages.js"></script>
</head>
<body>
<h1> Mokking, Spying & Stabbing (ver 4.0.0) </h1>
    <p> Updated ( 2021-08-20 )</p>
  <nav class="sitenav">
    <a href="../../../../index.html">MySite></a>
    <a href="../../../index.html">Node.js></a>
    <a href="../index.html">Jest></a> Mokking, Spying & Stabbing
  </nav>
<table class="table">
<caption>
    Mock Functions 
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Method  </th>
        <th> Description </th>
    </tr>
<tr class="05.01">
  <td> 
        jest.fn(<i class="openable">mockImplementation:fn<div>
          <p> - function runs when the returned <strong>mockFn</strong> is called </p>
        </div></i>)
  </td>
  <td> 
      - creates and returns a <strong>mockFn</strong>, implements a mock function which returns <mark>undefined</mark> if not specified 
  </td>
</tr>
<tr class="05.02">
  <td> 
        jest.isMockFunction(<strong>fn</strong>)
  </td>
  <td> 
        - returns <mark>true</mark> if the passed <strong>fn</strong> is a mock function, <mark>false</mark> otherwise
  </td>
</tr>
<tr class="35.02">
  <td> 
        jest.clearAllMocks()
  </td>
  <td> 
      - resets (empties) all data in <mark>mock.calls</mark> and <mark>mock.results</mark> of <u>all</u> mock functions in this scope 
  </td>
</tr>
<tr class="35.04">
  <td> 
        jest.resetAllMocks()
  </td>
  <td> 
      - resets (empties) all data in <mark>mock.calls</mark> and <mark>mock.results</mark> of <u>all</u> mock functions in this scope <br>
      - also removes any mock function implementations 
  </td>
</tr>
<tr class="25.02">
  <td> 
        <strong>mockFn</strong>.getMockName()
  </td>
  <td> 
      - returns the <strong>mockFn</strong>'s name (which is displayed in failed tests)
  </td>
</tr>
<tr class="30.01">
  <td> 
        <strong>mockFn</strong>.mock.calls
  </td>
  <td> 
      - returns an Array in which each item is an Array containing the call arguments for each call (ex: <mark>[[1, 2], [5, 5]]</mark>)
  </td>
</tr>
<tr class="30.02">
  <td> 
        <strong>mockFn</strong>.mock.results
  </td>
  <td> 
      - returns an Array in which each item is an <strong class="openable">obj<div>
        <p> <mark>type: 'return|throw|incomplete'</mark> - contains the result type </p>
        <p> <mark>value: <strong>val</strong></mark> - contains the value of the call result </p>
      </div></strong> containing the results for each call (ex: <mark>[{type:return, value:3}, {type:'throw', value:'err'}]</mark>)
  </td>
</tr>
<tr class="35.01">
  <td> 
        <strong>mockFn</strong>.mockClear()
  </td>
  <td> 
      - resets (empties) all data in <mark>mock.calls</mark> and <mark>mock.results</mark> of <u>this</u> mock function
  </td>
</tr>
<tr class="10.01">
  <td> 
        <strong>mockFn</strong>.mockImplementation(<strong>fn</strong>)
  </td>
  <td> 
      - overrides the mock implementation of <strong>mockFn</strong> 
  </td>
</tr>
<tr class="10.02">
  <td> 
        <strong>mockFn</strong>.mockImplementationOnce(<strong>fn</strong>)
  </td>
  <td> 
      - overrides the mock implementation of <strong>mockFn</strong> only once (expires when called once)
  </td>
</tr>
<tr class="25.01">
  <td> 
        <strong>mockFn</strong>.mockName(<strong>name:str</strong>)
  </td>
  <td> 
      - sets the <strong>mockFn</strong>'s name (which is displayed in failed tests) 
  </td>
</tr>
<tr class="20.03">
  <td> 
        <strong>mockFn</strong>.mockRejectedValue(<strong>val</strong>)
  </td>
  <td> 
      - sets the rejected value for a <strong>mockFn</strong> that returns a resolved promise 
  </td>
</tr>
<tr class="20.04">
  <td> 
        <strong>mockFn</strong>.mockRejectedValueOnce(<strong>val</strong>)
  </td>
  <td> 
      - sets the rejected value for a <strong>mockFn</strong> that returns a resolved promise only once (expires after the promise is resolved once)
  </td>
</tr>
<tr class="35.03">
  <td> 
        <strong>mockFn</strong>.mockReset()
  </td>
  <td> 
      - resets (empties) all data in <mark>mock.calls</mark> and <mark>mock.results</mark> of <u>this</u> mock function <br>
      - also removes any mock function implementations 
  </td>
</tr>
<tr class="20.01">
  <td> 
        <strong>mockFn</strong>.mockResolvedValue(<strong>val</strong>)
  </td>
  <td> 
      - sets the resolved value for a <strong>mockFn</strong> that returns a resolved promise 
  </td>
</tr>
<tr class="20.02">
  <td> 
        <strong>mockFn</strong>.mockResolvedValueOnce(<strong>val</strong>)
  </td>
  <td> 
      - sets the resolved value for a <strong>mockFn</strong> that returns a resolved promise only once (expires after the promise is resolved once)
  </td>
</tr>
<tr class="15.03">
  <td> 
        <strong>mockFn</strong>.mockReturnThis()
  </td>
  <td> 
      - returns the <mark>this</mark> value of the <strong>mockFn</strong> 
  </td>
</tr>
<tr class="15.01">
  <td> 
        <strong>mockFn</strong>.mockReturnValue(<strong>val</strong>)
  </td>
  <td> 
      - sets the mock function's return value 
  </td>
</tr>
<tr class="15.02">
  <td> 
        <strong>mockFn</strong>.mockReturnValueOnce(<strong>val</strong>)
  </td>
  <td> 
      - sets the mock function's return value only once (expires when called once)
  </td>
</tr>
</table>
  <br>
<table class="table">
<caption>
    Spying 
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Method  </th>
        <th> Description </th>
    </tr>
<tr class="05.01">
  <td> 
        jest.spyOn(<strong>obj</strong>, <strong>method:str</strong>, <small class="openable">get|set<div>
          <p> Supported from Jest v22.1.0 </p>
          <p> - spies only when the property is get or set </p>
        </div></small>)
  </td>
  <td> 
      - spies on the specified object's method by returning a <strong>spyFn</strong> <br>
      - we can use spying methods on the returned <strong>spyFn</strong> which holds the spied data (ex: <mark>expect(<strong>sypFn</strong>).<strong>sypMatcherMethod</strong></mark>) <br>
      - we can also mock the object method by registering a mock implementation (ex: <mark><strong>spyFn</strong>.mockImplementation(<strong>fn</strong>)</mark>)
  </td>
</tr>
<tr class="10.01">
  <td> 
        <strong>spyFn</strong>.mockRestore()
  </td>
  <td> 
      - for this <strong>spyFn</strong> returned by <mark>jest.spyOn()</mark> <br>
      - resets (empties) all data in <mark>mock.calls</mark> and <mark>mock.results</mark>, removes any mock implementation and <u>stops spying</u> 
  </td>
</tr>
<tr class="10.02">
  <td> 
        jest.restoreAllMocks()
  </td>
  <td> 
      - for all <strong>spyFn</strong> returned by <mark>jest.spyOn()</mark> <u>in this scope</u> <br>
      - removes any mock implementation and <u>stops spying</u> (does not removes data from <mark>mock.calls</mark> and <mark>mock.results</mark>)
  </td>
</tr>
<tr class="15.01">
  <td colspan="2"> Spying Matcher Methods </td>
</tr>
<tr class="15.02">
  <td> 
        toHaveBeenCalled()
  </td>
  <td> 
      - the expected <strong>spyFn</strong> should have been called at least once 
  </td>
</tr>
<tr class="15.03">
  <td> 
        toHaveBeenCalledTimes(<strong>nr</strong>)
  </td>
  <td> 
      - the expected <strong>spyFn</strong> should have been called <strong>nr</strong> times 
  </td>
</tr>
<tr class="20.01">
  <td> 
        toHaveBeenCalledWith(<strong>arg</strong>, <i>...</i>)
  </td>
  <td> 
      - the expected <strong>spyFn</strong> should have been called with these arguments at least once 
  </td>
</tr>
<tr class="20.02">
  <td> 
        toHaveBeenLastCalledWith(<strong>arg</strong>, <i>...</i>)
  </td>
  <td> 
      - the expected <strong>spyFn</strong> should have been called with these arguments for the last time   
  </td>
</tr>
<tr class="20.03">
  <td> 
        toHaveBeenNthCalledWith(<strong>nthCall:nr</strong>, <strong>arg</strong>, <i>...</i>)
  </td>
  <td> 
      - the expected <strong>spyFn</strong> should have been called with these arguments for the <strong>nth</strong> time   
  </td>
</tr>
<tr class="25.01">
  <td> 
        toHaveReturned()
  </td>
  <td> 
      - the expected <strong>spyFn</strong> has returned at least once (not thrown)
  </td>
</tr>
<tr class="25.02">
  <td> 
        toHaveReturnedTimes(<strong>nr</strong>)
  </td>
  <td> 
      - the expected <strong>spyFn</strong> has returned <strong>nr</strong> times (throws are excluded from this counter)  
  </td>
</tr>
<tr class="30.01">
  <td> 
        toHaveReturnedWith(<strong>data:any</strong>)
  </td>
  <td> 
      - the expected <strong>spyFn</strong> has returned <strong>data</strong> at least once 
  </td>
</tr>
<tr class="30.02">
  <td> 
        toHaveLastReturnedWith(<strong>data:any</strong>)
  </td>
  <td> 
      - the expected <strong>spyFn</strong> has returned <strong>data</strong> for the last call  
  </td>
</tr>
<tr class="30.02">
  <td> 
        toHaveNthReturnedWith(<strong>nthCall:nr</strong>, <strong>data:any</strong>) 
  </td>
  <td> 
      - the expected <strong>spyFn</strong> has returned <strong>data</strong> for the <strong>nth</strong> call  
  </td>
</tr>
</tr>
</table>
  <br>
<table class="table">
<caption>
    Mocking Modules 
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Method  </th>
        <th> Description </th>
    </tr>
<tr class="05.01">
  <td> 
      jest.createMockFromModule(<strong>modulePath:str</strong>) <br>
      jest.requireMock(<strong>modulePath:str</strong>) 
  </td>
  <td> 
      - creates and returns a mocked version from the targeted module 
  </td>
</tr>
<tr class="10.01">
  <td> 
        jest.mock(<strong>modulePath:str</strong>, <i class="openable">factoryFn<div>
          <p> - the returned data will be used as mock module instead of the original module </p>
          <p> ex: <mark>jest.mock('./someModule', () => {p1:'factory module'})</mark> </p>
        </div></i>, <i class="openable">option:obj<div>
          <p> virtual: <strong>bol</strong> - allows to create a virtual mock module (module that don't exist in the system) (Default: <mark>false</mark>) </p>
        </div></i>)
  </td>
  <td> 
        - automatically mocks the specified module (<strong>modulePath</strong>) when imported in this file <u>(this call is hoisted)</u>, returns the <mark>jest</mark> object for chaining 
  </td>
</tr>
<tr class="10.02">
  <td> 
        jest.unmock(<strong>modulePath:str</strong>)
  </td>
  <td> 
        - prevents from <u class="openable">any mocking<div>
          <p> - this call prevents any (even explicit mocking) of the specified module! </p>
        </div></u> the specified module (<strong>modulePath</strong>) in this file <u>(this call is hoisted)</u>
  </td>
</tr>
<tr class="15.01">
  <td> 
        jest.requireActual(<strong>modulePath:str</strong>) 
  </td>
  <td> 
        - returns the actual (original) module instead of the mocked one (useful when the module is automocked with <mark>jest.mock()</mark>)
  </td>
</tr>
<tr class="20.01">
  <td> 
        jest.resetModules()
  </td>
  <td> 
        - resets the node module registry (module cache), so imported modules after this call will be a new module instances  
  </td>
</tr>
<tr class="20.02">
  <td> 
        jest.isolateModules(<strong>fn</strong>)
  </td>
  <td> 
        - isolate modules (imported in the callback) from the ouside scope <br>
        - imports new module instances (bypasses the module registry)
  </td>
</tr>
</table>
    <br>
<h2 class="headerSection"> Useful Links : </h2>

<h2 class="headerSection"> Remember This : </h2>
    
<h2 class="headerSection"> Description and Demonstration : </h2>
  <p> - mocking is faking a specific behaviour (like replacing a 'mocked' function with the original) </p>
  <p> - spying is 'spying' on some specific behaviour (like a function has ben called or not) </p>
  <p> - stabbing is replacing an original data with a fake one </p>
<hr>
<!----------------------------------------------------------------------------------->
<h2 style='color:darkblue;'><u> Mock Functions <mark>jest.fn()</mark> / <mark>jest.isMockFunction()</mark> / <mark>mockImplementaion()</mark> / <mark>mockImplementaionOnce()</mark> / <mark>mockReturnValue()</mark> / <mark>mockReturnValueOnce()</mark> / <mark>mockReturnThis()</mark> / <mark>mockResolvedValue()</mark> / <mark>mockResolvedValueOnce()</mark> / <mark>mockRejectValue()</mark> / <mark>mockRejectValueOnce()</mark> / <mark>mockName()</mark> / <mark>getMockName()</mark> / <mark>mock.calls</mark> / <mark>mock.results</mark> / <mark>jest.clearAllMocks()</mark> / <mark>.mockClear()</mark> / <mark>jest.resetAllMocks()</mark> / <mark>.mockReset()</mark> </u></h2>
<details class="example"> 
<summary> DEMO </summary>
  <pre>
  test('some-test', function(){
// jest.fn() / jest.isMockFunction() --------------------------------------------------
    const mockFn = jest.fn()                                                           // creates a mock function (without implementation -> returns undefined) 
    const mockFn2 = jest.fn(function(val, idx, arr){                                   // creates a mock function with a mock implementation (function which runs when the mock is called)   
      return [idx, val]
    })
    
    mockFn();                                                                          // -> undefined 
    
    const someArray = ['un', 'deux', 'trois'];
    const newArray = someArray.map(mockFn2);                                           // the mock function is replaced and executed with te original (original callback is never called)
    
    newArray;                                                                          // -> [[0, 'un'], [1, 'deux'], [2, 'trois']] 
    
    
    jest.isMockFunction(mockFn)                                                        // -> true
    jest.isMockFunction(function(){})                                                  // -> false
    
// mockImplementation() / mockImplementaionOnce() -------------------------------------
    const mockFn = jest.fn(() => 21)
    mockFn.mockImplementation(() => 22)                                                // overrides the previous mock implementation 
    
    mockFn();                                                                          // -> 22
    
    mockFn.mockImplementationOnce(() => 'one');                                        // overrides the previous mock implementation for one call only 
    mockFn.mockImplementationOnce(() => 'two');
        
    mockFn();                                                                          // -> 'one'
    mockFn();                                                                          // -> 'two'
    mockFn();                                                                          // -> 22 
    mockFn();                                                                          // -> 22 
    
// mockReturnValue() / mockReturnValueOnce() / mockReturnthis() -----------------------
    const mockFn = jest.fn(() => 21);
    mockFn.mockReturnValue(22);                                                        // sets the return value of the mock function (regardless of the mock implementation)    
    
    mockFn();                                                                          // -> 22 
    
    mockFn.mockReturnValueOnce('one');                                                 // sets the return value for one call only  
    mockFn.mockReturnValueOnce('two');
    
    mockFn();                                                                          // -> 'one'
    mockFn();                                                                          // -> 'two'
    mockFn();                                                                          // -> 22
    mockFn();                                                                          // -> 22
    
    const mockFn2 = jest.fn().mockReturnThis()
    const myObj = {mockFn2}
    
    myObj.mockFn2();                                                                   // -> returns the myObj (the this value of the mock function)   
    
// getMockName() / mockName() ---------------------------------------------------------
    const mockFn = jest.fn();                                                          // jest function mock names are printed on the console 
    
    mockFn.getMockName();                                                              // -> 'jest.fn()'
    
    mockFn.mockName('awesome mock!');                                                  // sets the mock function's name 
    mockFn.getMockName();                                                              // -> 'awesome mock!'
  })
  </pre>
  <p> - <mark>mockResolvedValue()</mark> / <mark>mockResolvedValueOnce()</mark> / <mark>mockRejectedValue()</mark> / <mark>mockRejectedValueOnce()</mark> </p>
  <pre>
  test('some test', function(){
// mockResolvedValue() / mockResolvedValueOnce() --------------------------------------
    const mockFnRes = jest.fn(() => Promise.resolve());
    
    mockFnRes.mockResolvedValue(21);                                                   // sets the resolved value for a mock function that returns a resolved promise 
    mockFnRes.mockResolvedValueOnce('one');                                            // sets the resolved value for one promise consumption  
    mockFnRes.mockResolvedValueOnce('two');
    
    mockFnRes()
      .then((res) => console.log(res))                                                 // -> 'one'
      .catch((rej) => console.log(rej))
    mockFnRes()
      .then((res) => console.log(res))                                                 // -> 'two'
      .catch((rej) => console.log(rej))
    mockFnRes()
      .then((res) => console.log(res))                                                 // -> 21
      .catch((rej) => console.log(rej))
    mockFnRes()
      .then((res) => console.log(res))                                                 // -> 21
      .catch((rej) => console.log(rej))
  
// mockRejectedValue() / mockRejectedValueOnce() -------------------------------------
    const mockFnRej = jest.fn(() => Promise.reject());
    
    mockFnRej.mockRejectedValue(22);                                                   // sets the rejected value for a mock function that returns a rejected promise
    mockFnRej.mockRejectedValueOnce('un');                                             // sets the rejected value for one promise consumption  
    mockFnRej.mockRejectedValueOnce('deux');
  
    mockFnRej()
      .then((res) => console.log(res))
      .catch((rej) => console.log(rej))                                                // -> 'un'
    mockFnRej()
      .then((res) => console.log(res))
      .catch((rej) => console.log(rej))                                                // -> 'deux'
    mockFnRej()
      .then((res) => console.log(res))
      .catch((rej) => console.log(rej))                                                // -> 22
    mockFnRej()
      .then((res) => console.log(res))
      .catch((rej) => console.log(rej))                                                // -> 22
  })  
  </pre>
  <p> - <mark>mock.calls</mark> / <mark>mock.results</mark> / <mark>.mockClear()</mark> / <mark>jest.clearAllMocks()</mark> / <mark>.mockReset()</mark> / <mark>jest.resetAllMocks()</mark> </p>
  <pre>
  test('some-test', function(){
// mock.calls / mock.results ----------------------------------------------------------
    const mockFn = jest.fn( (a, b) => a + b );
    
    mockFn(1, 2);
    mockFn(5, 5);
    
    mockFn.mock.calls;                                                                 // -> [[1, 2], [5, 5]]                                        // returns the mock call arguments for each call 
    mockFn.mock.results;                                                               // -> [{type:'return', value:3}, {type:'return', value:10}]   // returns the results for each call 
  
// .mockClear() / jest.crearAllMocks() ------------------------------------------------
    const mockFn1 = jest.fn((a, b) => a + b);
    const mockFn2 = jest.fn((a, b) => a + b);
    const mockFn3 = jest.fn((a, b) => a + b);
    
    mockFn1(1, 2)
    mockFn2(5, 5)
    mockFn3(7, 4)
    
    mockFn1.mock.calls;                                                                // -> [[1, 2]]                    
    mockFn2.mock.results;                                                              // -> [{type:'return', value:10}] 
    mockFn3.mock.results;                                                              // -> [{type:'return', value:11}] 
    
    mockFn1.mockClear();                                                               // clears the 'mock.calls' and mock.results' for this mock function only 
    
    mockFn1.mock.calls;                                                                // -> [] 
    mockFn2.mock.results;                                                              // -> [{type:'return', value:10}] 
    mockFn3.mock.results;                                                              // -> [{type:'return', value:11}] 
    
    jest.clearAllMocks();                                                              // clears the 'mock.calls' and mock.results' for all mock functions of this scope  
    
    mockFn1.mock.calls;                                                                // -> [] 
    mockFn2.mock.results;                                                              // -> [] 
    mockFn3.mock.results;                                                              // -> []   
    
    mockFn1(1, 2);                                                                     // -> 3              // does not remove any mock implementation 
    
// .mockReset() / jest.resetAllMocks() ------------------------------------------------
    const mockFn4 = jest.fn((a, b) => a + b);
    const mockFn5 = jest.fn((a, b) => a + b);
    
    mockFn4(1, 2)
    mockFn5(5, 5)
    
    mockFn4.mock.calls;                                                                // -> [[1, 2]]                    
    mockFn5.mock.results;                                                              // -> [{type:'return', value:10}] 
    
    mockFn4.mockReset;                                                                              // clears the 'mock.calls' and mock.results' and also resets all mock implementations for this mock function only   
    
    mockFn4.mock.calls;                                                                // -> []
    mockFn5.mock.results;                                                              // -> [{type:'return', value:10}]
    mockFn4(1, 2);                                                                     // -> undefined        // because mock implementations are cleared as well 
    mockFn5(5, 5);                                                                     // -> 10 
    
    jest.resetAllMocks;                                                                             // clears the 'mock.calls' and mock.results' and also resets all mock implementations for all mock functions of this scope   
    
    mockFn4.mock.calls;                                                                // -> []
    mockFn5.mock.results;                                                              // -> []
    mockFn4(1, 2);                                                                     // -> undefined        // because mock implementations are cleared as well 
    mockFn5(5, 5);                                                                     // -> undefined  
  })
  </pre>
</details>
<details class="example"> 
<summary> Example : </summary>
<h4 style="color:darkblue"><u> <mark>jest.fn()</mark> / <mark>jest.isMockFunction()</mark> TEST </u></h4>
  <pre>
  test('some-test', function(){
    const mockFn = jest.fn()                                                           // creates a mock function that returns undefined 
    const mockFn2 = jest.fn(function(val, idx, arr){                                   // creates a mock function with a specific behaviour 
      return [idx, val]
    })
    
    console.log( jest.isMockFunction(mockFn) );                                        // -> true      // mock function
    console.log( jest.isMockFunction(() => {}) );                                      // -> false     // not a mock function 
    
// basic usage of mock functions ------------------------------------------------------
    const someArray = ['un', 'deux', 'trois'];
    
    const newArray = someArray.map(mockFn2);                                           // the mock function is replaced and executed with te original (original callback is never called)
    
    console.log( newArray );                                                           // -> [[0, 'un'], [1, 'deux'], [2, 'trois']] 
  })
  </pre>
<hr>
<!----------------------------------------------------------------------------------->
<h4 style="color:darkblue"><u> <mark>.mockImplementation()</mark> / <mark>.mockImplementationOnce()</mark> TEST </u></h4>
  <pre>
// 'module_1.js' (file) ---------------------------------------------------------------
  module.exports = class Animal {
    constructor(race, wild){
      this.race = race;
      this.wild = wild;
    }
    
    getAnimal(){
      return {
        race: this.race,
        wild: this.wild
      }
    }
  }

// 'jestTest.test.js' (file) ----------------------------------------------------------
  const AnimalClass = jest.createMockFromModule('./module_1')                          // imported mocked class 
  
  test('some-test', function(){
    const mockFn = jest.fn(() => 21);
    mockFn.mockImplementation(() => 22)                                                // overrides the mock function implementation 
    
    console.log( mockFn() );                                                           // -> 22
    
    console.log( jest.isMockFunction(AnimalClass) );                                   // -> true    // a mocked classes are turned into mockFunctions 
    AnimalClass.mockImplementation(function(){                                         // we can use it on a mocked class 
      return {
        getAnimal: function(){
          return 'some animal'
        }
      }
    })
    
    const animal = new AnimalClass();
    console.log( animal.getAnimal() );                                                 // -> 'some animal'
    
  // mockImplementationOnce() ---------------------------------------------------------
    const mockFn2 = jest.fn(() => 'default');
    mockFn2
      .mockImplementationOnce(() => 'one')                                             // implements the specified mock function only once 
      .mockImplementationOnce(() => 'two')                                             // returns the mock function so we can chain it 
    
    console.log( mockFn2() );                                                          // -> 'one'
    console.log( mockFn2() );                                                          // -> 'two'
    console.log( mockFn2() );                                                          // -> 'default'
    console.log( mockFn2() );                                                          // -> 'default'
  })
  </pre>
<hr>
<!----------------------------------------------------------------------------------->
<h4 style="color:darkblue"><u> <mark>.mockReturnValue()</mark> / <mark>.mockReturnValueOnce()</mark> / <mark>mockReturnThis()</mark> TEST </u></h4>
  <pre>
  test('some-test', function(){
    const mockFn = jest.fn();
    mockFn.mockReturnValue('default');                                                 // sets the return value of the mock function 
    
    console.log( mockFn() );                                                           // -> 'default'
    console.log( mockFn() );                                                           // -> 'default'
    
    mockFn.mockReturnValueOnce('one');                                                 // sets the return value of the mock function for one call only 
    mockFn.mockReturnValueOnce('two'); 
    
    console.log( mockFn() );                                                           // -> 'one'
    console.log( mockFn() );                                                           // -> 'two'
    console.log( mockFn() );                                                           // -> 'default'
    console.log( mockFn() );                                                           // -> 'default'
    
// .mockReturnThis() ------------------------------------------------------------------
    console.log( mockFn.mockReturnThis() )                                             // -> MockConstructor     // returns the this value of the mock function (which is the Mock constructor in this case)
    
    const myObj = {p1:21, someFn: jest.fn()};
    console.log( myObj.someFn.mockReturnThis() )                                       // -> MockConstructor     // apparently the this value of a mock function is always the Mock constructor
  })
  </pre>
<hr>
<!----------------------------------------------------------------------------------->
<h4 style="color:darkblue"><u> <mark>.mockResolvedValue()</mark> / <mark>.mockResolvedValueOnce()</mark> / <mark>.mockRejectedValue()</mark> / <mark>.mockRejectedValueOnce()</mark> TEST </u></h4>
  <pre>
  test('some-test', async function(){
// mockResolvedValue() / mockResolvedValueOnce() --------------------------------------
    const mockFnRes = jest.fn(() => Promise.resolve());                                // mock function that return a rejected promise 
    mockFnRes.mockResolvedValue('resolve default');                                    // sets the resolved value of the mock function that returns a resolved promise 
    
    console.log( await mockFnRes() );                                                  // -> 'resolve default'
    
    mockFnRes.mockResolvedValueOnce('resolved one');                                   // sets the resolved value for one call only 
    mockFnRes.mockResolvedValueOnce('resolved two');
    
    console.log( await mockFnRes() );                                                  // -> 'resolve one'
    console.log( await mockFnRes() );                                                  // -> 'resolve two'
    console.log( await mockFnRes() );                                                  // -> 'resolve default'
    console.log( await mockFnRes() );                                                  // -> 'resolve default'
  
// mockRejectedValue() / mockRejectedValueOnce() --------------------------------------
    const mockFnRej = jest.fn(() => Promise.reject());                                 // mock function that return a rejected promise 
    mockFnRej.mockRejectedValue('rejected default');                                   // sets the rejected value of the mock function that returns a rejected promise 
    
    await expect(mockFnRej()).rejects.toBe('rejected default');                        // passes (rejected value is matching)
    
    mockFnRej.mockRejectedValueOnce('rejected one');                                   // sets the rejected value for one call only 
    mockFnRej.mockRejectedValueOnce('rejected two');
    
    await expect(mockFnRej()).rejects.toBe('rejected one');                            // passes (rejected value is matching)
    await expect(mockFnRej()).rejects.toBe('rejected two');                            // passes (rejected value is matching)
    await expect(mockFnRej()).rejects.toBe('rejected default');                        // passes (rejected value is matching)
    await expect(mockFnRej()).rejects.toBe('rejected default');                        // passes (rejected value is matching)
  })
  </pre>
<hr>
<!----------------------------------------------------------------------------------->
<h4 style="color:darkblue"><u> <mark>.mockName()</mark> / <mark>.getMockName()</mark> TEST </u></h4>
  <pre>
  test('some-test', async function(){
    const mockFn = jest.fn();
    
    console.log( mockFn.getMockName() );                                               // -> 'jest.fn()'    // default jest function name 
    
    mockFn.mockName('my mock function');                                               // sets the mock function's name 
    console.log( mockFn.getMockName() );                                               // -> 'my mock function'
  })
  </pre>
<hr>
<!----------------------------------------------------------------------------------->
<h4 style="color:darkblue"><u> <mark>mock.calls</mark> / <mark>mock.results</mark> TEST </u></h4>
  <pre>
  test('some-test', async function(){
    const mockFn = jest.fn(function(a, b){
      return a + b;
    });
    
    mockFn(1, 2)
    mockFn(5, 5)
    
    console.log( mockFn.mock.calls );                                                  // -> [[1, 2], [5, 5]]                                        // returns the mock call arguments for each call 
    console.log( mockFn.mock.results );                                                // -> [{type:'return', value:3}, {type:'return', value:10}]   // returns the results for each call 
  })
  </pre>
<hr>
<!----------------------------------------------------------------------------------->
<h4 style="color:darkblue"><u> <mark>.mockClear()</mark> / <mark>jest.clearAllMocks()</mark> / <mark>.mockReset()</mark> / <mark>jest.resetAllMocks()</mark> TEST </u></h4>
  <pre>
  test('some-test', async function(){
// .mockClear() / jest.crearAllMocks() ------------------------------------------------
    const mockFn1 = jest.fn((a, b) => a + b);
    const mockFn2 = jest.fn((a, b) => a + b);
    const mockFn3 = jest.fn((a, b) => a + b);
    
    mockFn1(1, 2)
    mockFn2(5, 5)
    mockFn3(7, 4)
    
    console.log( mockFn1.mock.calls );                                                 // -> [[1, 2]]                    
    console.log( mockFn2.mock.results );                                               // -> [{type:'return', value:10}] 
    console.log( mockFn3.mock.results );                                               // -> [{type:'return', value:11}] 
    
    mockFn1.mockClear();                                                               // clears the 'mock.calls' and mock.results' for this mock function only 
    
    console.log( mockFn1.mock.calls );                                                 // -> [] 
    console.log( mockFn2.mock.results );                                               // -> [{type:'return', value:10}] 
    console.log( mockFn3.mock.results );                                               // -> [{type:'return', value:11}] 
    
    jest.clearAllMocks();                                                              // clears the 'mock.calls' and mock.results' for all mock functions 
    
    console.log( mockFn1.mock.calls );                                                 // -> [] 
    console.log( mockFn2.mock.results );                                               // -> [] 
    console.log( mockFn3.mock.results );                                               // -> []   
    
    console.log( mockFn1(1, 2) )                                                       // -> 3              // does not remove any mock implementation 
    
// .mockReset() / jest.resetAllMocks() ------------------------------------------------
    const mockFn4 = jest.fn((a, b) => a + b);
    const mockFn5 = jest.fn((a, b) => a + b);
    
    mockFn4(1, 2)
    mockFn5(5, 5)
    
    console.log( mockFn4.mock.calls );                                                 // -> [[1, 2]]                    
    console.log( mockFn5.mock.results );                                               // -> [{type:'return', value:10}] 
    
    mockFn4.mockReset();                                                               // clears the 'mock.calls' and mock.results' and also resets all mock implementations for this mock  function only   
    
    console.log( mockFn4.mock.calls );                                                 // -> []
    console.log( mockFn5.mock.results );                                               // -> [{type:'return', value:10}]
    console.log( mockFn4(1, 2) );                                                      // -> undefined        // because mock implementations are cleared as well 
    console.log( mockFn5(5, 5) );                                                      // -> 10 
    
    jest.resetAllMocks();                                                              // clears the 'mock.calls' and mock.results' and also resets all mock implementations for all mock   functions    
    
    console.log( mockFn4.mock.calls );                                                 // -> []
    console.log( mockFn5.mock.results );                                               // -> []
    console.log( mockFn4(1, 2) );                                                      // -> undefined        // because mock implementations are cleared as well 
    console.log( mockFn5(5, 5) );                                                      // -> undefined  
  })
  </pre>
</details>
<hr>
<!----------------------------------------------------------------------------------->
<h2 style="color:darkblue;"><u> Spying <mark>jest.spyOn()</mark> / <mark>mockRestore()</mark> / <mark>jest.restoreAllMocks()</mark> / <mark>toHaveBeenCalled()</mark> / <mark>toHaveBeenCalledTimes()</mark> / <mark>toHaveBeenCalledWith()</mark> / <mark>toHaveBeenLastCalledWith()</mark> / <mark>toHaveBeenNthCalledWith()</mark> / <mark>toHaveReturned()</mark> / <mark>toHaveReturnedTimes()</mark> / <mark>toHaveReturnedWith()</mark> / <mark>toHaveLastReturnedWith()</mark> / <mark>toHaveNthReturnedWith()</mark> </u></h2>
  <p> - Jest allows us to spy on object methods or on mock functions </p>
<details class="example"> 
<summary> DEMO </summary>
  <p> - <mark>jest.spyOn()</mark> </p>
  <pre>
  test('some test', function(){
    const myObj = { add(a, b){ return a + b} }
    
    const spy = jest.spyOn(myObj, 'add');                                              // spying on the specified object method   
    
    myObj.add(1, 2);                                                                   // -> 3
    
    expect(spy).toHaveBeenCalled();                                                    // the spy is used to spy on the spied method 
    
  // apply mock implementation ------------------------------------
    spy.mockImplementation(() => 'new mock implementation!');                          // mock implementation applied on the object's method 
    myObj.add(1, 2);                                                                   // -> 'new mock implementation!' 
    
    myObj.add = jest.fn(() => 'another mock implementation!')
    myObj.add(1, 2);                                                                   // -> 'another mock implementation!' 
    
  // using 'get' 'set' options ------------------------------------
    const myObj2 = {
      animal_: 'default animal',
      get animal() { return this.animal_ },
      set animal(val) { this.animal_ = val }
    }
    
    const spy_get = jest.spyOn(myObj2, 'animal', 'get');                               // spies only when get the property 
    const spy_set = jest.spyOn(myObj2, 'animal', 'set');                               // spies only when set the property 
    
    myObj2.animal = 'cat';
    
    spy_set.mock.calls                                                                 // -> [['cat]]    // only the set spy is triggered 
    spy_get.mock.calls                                                                 // -> []          // empty because the spy_get does not spy when the property gets 
    
    jest.clearAllMocks();                                                              // clears all mocks in this scope 
    
    myObj2.animal; 
    
    spy_set.mock.calls                                                                 // -> []
    spy_get.mock.calls                                                                 // -> [[]]        // only the get spy is triggered 
  })
  </pre>
   <p> - <mark>mockRestore()</mark> / <mark>jest.restoreAllMocks()</mark> </p>
  <pre>
  test('some test', function(){
    const myObj = { 
      add(a, b){ return a + b},
      multiply(a, b){ return a * b}
    }
    
    const spy1 = jest.spyOn(myObj, 'add'); 
    const spy2 = jest.spyOn(myObj, 'multiply'); 
    
    spy1.mockImplementation((a, b) => `additions result is ${a + b}`);                 // mock implementation applied  
    spy2.mockImplementation((a, b) => `multiplication result is ${a * b}`);
    
    myObj.add(3, 2);                                                                   // -> 'additions result is 5'
    myObj.multiply(3, 2);                                                              // -> 'multiplication result is 6'
    
    spy1.mock.calls );                                                                 // -> [[3, 2]]
    spy2.mock.calls );                                                                 // -> [[3, 2]]
    
// mockRestore() ----------------------------------------------------------------------
    spy1.mockRestore();                                                                // stops spying, clears all data from 'mock.calls' and 'mock.results' and removes the mock implementation    
    
    myObj.add(3, 2);                                                                   // -> 5             // mock implementaiont also removed 
    spy1.mock.calls;                                                                   // -> []            // data removed from the spy  
    myObj.multiply(3, 2);                                                              // -> 'multiplication result is 6'
    spy2.mock.calls;                                                                   // -> [[3, 2], [3, 2]]
    
// jest.restoreAllMocks() -------------------------------------------------------------
    jest.restoreAllMocks();                                                            // stops all spies in this scope   // -! does not clears 'mock'calls', and 'mock.results' and does not remove mock implementation (as it was specified in the docs)    
    
    spy1.mock.calls;                                                                   // -> []  
    myObj.add(3, 2);                                                                   // -> 5  
    spy2.mock.calls;                                                                   // -> [[3, 2], [3, 2]]      // -! does not remove mock data for some reason 
    myObj.multiply(3, 2);                                                              // -> 6             // removes mock implementations
    
  })
  </pre>
  <p> - Spying Matcher Methods <mark>toHaveBeenCalled()</mark> / <mark>toHaveBeenCalledTimes()</mark> / <mark>toHaveBeenCalledWith()</mark> / <mark>toHaveBeenLastCalledWith()</mark> / <mark>toHaveBeenNthCalledWith()</mark> </p>
  <pre>
  test('some test', function(){
// toHaveBeenCalled() / toHaveBeenCalledTimes() ---------------------------------------
    const mockFn = jest.fn();
    
    mockFn();
    mockFn();
    mockFn();
    
    expect(mockFn).toHaveBeenCalled();                                                 // test passes because the mock function has been called 
    expect(mockFn).toHaveBeenCalledTimes(3);                                           // test passes because the mock function has been called 2 times 
  
// to toHaveBeenCalledWith() / toHaveBeenLastCalledWith() / toHaveBeenNthCalledWith() -
    const mockFn2 = jest.fn(function(a, b){
      return a + b;
    });
    
    mockFn2(2, 2);
    mockFn2(1, 6);
    mockFn2(7, 3);
    
    expect(mockFn2).toHaveBeenCalledWith(2, 2);                                        // mock function has been called with these arguments 
    expect(mockFn2).toHaveBeenCalledWith(7, 3);
    
    expect(mockFn2).toHaveBeenLastCalledWith(7, 3);                                    // has been called with these arguments for the last time 
    
    expect(mockFn2).toHaveBeenNthCalledWith(1, 2, 2);                                  // has been called with these arguments with the 1st time 
    expect(mockFn2).toHaveBeenNthCalledWith(2, 1, 6);                                  // has been called with these arguments with the 2nd time 
    expect(mockFn2).toHaveBeenNthCalledWith(3, 7, 3);                                  // has been called with these arguments with the 3rd time 
    

// toHaveReturned() / toHaveReturnedTimes() -------------------------------------------
    const mockFn3 = jest.fn( function(shouldThrow){
      if (shouldThrow) {
        throw new Error('some error');
      } else {
        return 'something';
      }
    })
    
    mockFn3();
    try { mockFn3(true); } catch(e) { }
    mockFn3();
    
    expect(mockFn3).toHaveReturned();                                                  // mock function returned (not throw) at least once 
    expect(mockFn3).toHaveReturnedTimes(2);                                            // mock function returned 2 times (of of 3 calls throws once)
    
// toHaveReturnedWith() / toHaveLastReturnedWith() / toHaveNthReturnedWith() ----------
    let counter = 0;
    const jestFn4 = jest.fn( function(){
      counter++;
      return counter;
    })
    
    jestFn4();
    jestFn4();
    jestFn4();
    
    expect(jestFn4).toHaveReturnedWith(2);                                             // mock function have returned 2 at lest once 
    
    expect(jestFn4).toHaveLastReturnedWith(3);                                         // mock function have returned 3 for the last time  
    
    expect(jestFn4).toHaveNthReturnedWith(1, 1);                                       // mock function have returned 1 for the fist time 
    expect(jestFn4).toHaveNthReturnedWith(2, 2);                                       // mock function have returned 2 for the 2nd time 
    expect(jestFn4).toHaveNthReturnedWith(3, 3);                                       // mock function have returned 3 for the 3rd time 
  })
  </pre>
</details>
<details class="example"> 
<summary> Example </summary>
<h4 style="color:darkblue"><u> <mark>jest.spyOn()</mark> TEST </u></h4>
  <pre>
  test('some test', function(){
    const myObj = { add(a, b){ return a + b} }
    
    const spy = jest.spyOn(myObj, 'add');                                              // spying on the specified object method   
    
    myObj.add(1, 2);                                                                   // -> 3
    
    expect(spy).toHaveBeenCalled();                                                    // the spy is used to spy on the spied method 
    
// apply mock implementation ----------------------------------------------------------
    spy.mockImplementation(() => 'new mock implementation!');                          // mock implementation applied on the object's method 
    console.log( myObj.add(1, 2) );                                                    // -> 'new mock implementation!' 
    
    myObj.add = jest.fn(() => 'another mock implementation!')
    console.log( myObj.add(1, 2) );                                                    // -> 'another mock implementation!' 
    
// using 'get' 'set' options ----------------------------------------------------------
    const myObj2 = {
      animal_: 'default animal',
      get animal() { return this.animal_ },
      set animal(val) { this.animal_ = val }
    }
    
    const spy_get = jest.spyOn(myObj2, 'animal', 'get');                               // spies only when get the property 
    const spy_set = jest.spyOn(myObj2, 'animal', 'set');                               // spies only when set the property 
    
    myObj2.animal = 'cat';
    
    console.log( spy_set.mock.calls )                                                  // -> [['cat]]    // only the set spy is triggered 
    console.log( spy_get.mock.calls )                                                  // -> []          // empty because the spy_get does not spy when the property gets 
    
    jest.clearAllMocks();                                                              // clears all mocks in this scope 
    
    myObj2.animal; 
    
    console.log( spy_set.mock.calls )                                                  // -> []
    console.log( spy_get.mock.calls )                                                  // -> [[]]        // only the get spy is triggered 
  })

  
  </pre>
<hr>
<!----------------------------------------------------------------------------------->
<h4 style="color:darkblue"><u> <mark>mockRestore()</mark> / <mark>jest.restoreAllMocks()</mark> TEST </u></h4>
  <pre>
  test('some test', function(){
    const myObj = { 
      add(a, b){ return a + b},
      multiply(a, b){ return a * b}
    }
    
    const spy1 = jest.spyOn(myObj, 'add'); 
    const spy2 = jest.spyOn(myObj, 'multiply'); 
    
    myObj.add(3, 2);
    myObj.multiply(3, 2);
    
    console.log( spy1.mock.calls );                                                    // -> [[3, 2]]
    console.log( spy2.mock.calls );                                                    // -> [[3, 2]]
    
    spy1.mockRestore();                                                                // clears all data from 'mock.calls' and 'mock.results' removes the mock implementation and stops the spying  
    
    console.log( spy1.mock.calls );                                                    // -> []
    console.log( spy2.mock.calls );                                                    // -> [[3, 2]]
    
    jest.restoreAllMocks();                                                            // stops all spies in this scope 
    
    myObj.add(3, 2);
    myObj.multiply(3, 2);
    
    console.log( spy1.mock.calls );                                                    // -> []            // no further spying 
    console.log( spy2.mock.calls );                                                    // -> [[3, 2]]
  })
  </pre>
<hr>
<!----------------------------------------------------------------------------------->
<h4 style="color:darkblue"><u> <mark>toHaveBeenCalled()</mark> / <mark>toHaveBeenCalledTimes()</mark> TEST </u></h4>
  <pre>
  test('some test', function(){
    const mockFn = jest.fn();
    
    mockFn();
    mockFn();
    mockFn();
    
    expect(mockFn).toHaveBeenCalled();                                                 // test passes because the mock function has been called 
    expect(mockFn).toHaveBeenCalledTimes(3);                                           // test passes because the mock function has been called 2 times 
  })
  </pre>
<hr>
<!----------------------------------------------------------------------------------->
<h4 style="color:darkblue"><u> <mark>toHaveBeenCalledWith()</mark> / <mark>toHaveBeenLastCalledWith()</mark> / <mark>toHaveBeenNthCalledWith()</mark> TEST </u></h4>
  <pre>
  test('some test', function(){
    const mockFn = jest.fn(function(a, b){
      return a + b;
    });
    
    mockFn(2, 2);
    mockFn(1, 6);
    mockFn(7, 3);
    
    expect(mockFn).toHaveBeenCalledWith(2, 2);                                         // mock function has been called with these arguments 
    expect(mockFn).toHaveBeenCalledWith(7, 3);
    
    expect(mockFn).toHaveBeenLastCalledWith(7, 3);                                     // has been called with these arguments for the last time 
    
    expect(mockFn).toHaveBeenNthCalledWith(1, 2, 2);                                   // has been called with these arguments with the 1st time 
    expect(mockFn).toHaveBeenNthCalledWith(2, 1, 6);                                   // has been called with these arguments with the 2nd time 
    expect(mockFn).toHaveBeenNthCalledWith(3, 7, 3);                                   // has been called with these arguments with the 3rd time 
  })
  </pre>
<hr>
<!----------------------------------------------------------------------------------->
<h4 style="color:darkblue"><u> <mark>toHaveReturned()</mark> / <mark>toHaveReturnedTime()</mark> / <mark>toHaveReturnedWith()</mark> / <mark>toHaveLastReturnedWith()</mark> / <mark>toHaveNthReturnedWith()</mark> TEST </u></h4>
  <pre>
  test('some test', function(){
    const mockFn = jest.fn(function(shouldThrow){
      if (shouldThrow) {
        throw new Error('some error');
      } else {
        return 'something';
      }
    })
    
    mockFn();
    try { mockFn(true); } catch(e) { }
    mockFn();
    
// toHaveReturned() / toHaveReturnedTimes() -------------------------------------------
    expect(mockFn).toHaveReturned();                                                   // mock function returned (not throw) at least once 
    expect(mockFn).toHaveReturnedTimes(2);                                             // mock function returned 2 times (of of 3 calls throws once)
    
// toHaveReturnedWith() / toHaveLastReturnedWith() / toHaveNthReturnedWith() ----------
    let counter = 0;
    const jestFn2 = jest.fn(function(){
      counter++;
      return counter;
    })
    
    jestFn2();
    jestFn2();
    jestFn2();
    
    expect(jestFn2).toHaveReturnedWith(2);                                             // mock function have returned 2 at lest once 
    
    expect(jestFn2).toHaveLastReturnedWith(3);                                         // mock function have returned 3 for the last time  
    
    expect(jestFn2).toHaveNthReturnedWith(1, 1);                                       // mock function have returned 1 for the fist time 
    expect(jestFn2).toHaveNthReturnedWith(2, 2);                                       // mock function have returned 2 for the 2nd time 
    expect(jestFn2).toHaveNthReturnedWith(3, 3);                                       // mock function have returned 3 for the 3rd time 
  })
  </pre>
</details>
<hr>
<!----------------------------------------------------------------------------------->
<h2 style="color:darkblue;"><u> Mocking Modules <mark>createMockFromModule()</mark> / <mark>requireMock()</mark> / <mark>mock()</mark> / <mark>unmock()</mark> / <mark>requireActual()</mark> / <mark>resetModules()</mark> / <mark>isolateModules()</mark> </u></h2>
  <p> - Jest can mock imported modules, <u>the mocked data is cloned</u> </p>
  <pre class="syntax">
  <span style="color:yellow; font-weight:bold; font-size:1.2em;"> Imported data                                 Jest mocked data </span>
  
  'str' | 21 | false                                 ->   'str' | 21 | false                     <span style="color:darkgray">// any primitives are cloned </span>
  function(){}                                       ->   <strong>mockFn</strong>                                 <span style="color:darkgray">// function are replaced with mock functions without mock implementation </span>
  [1, 'str', true]                                   ->   []                                     <span style="color:darkgray">// Arrays are replaced with an empty Array  </span>
  { p1:'str', p2(){}, p3:[1, 2] }                    ->   { p1:'str', p2:<strong>mockFn</strong>, p3:[] }         <span style="color:darkgray">// Objects keep their keys and transform their values according to the mock protocol</span>   
  class SomeClass{}                                  ->   <strong>mockFn</strong>                                 <span style="color:darkgray">// Classes are replaced with a mock function <u>(their constructor and all functions are mocked)</u> 
  </pre>
<details class="example"> 
<summary> DEMO </summary>
  <p> - Mocking imported modules </p>
  <pre>
// module_1.js (file) ----------------------------------------------------------------
  module.exports = {
    somePrimitive: 'some string',
    someFunction(a) { return a },
    someArray: [1, 'un', true],
    someObject:{ p1:'str', p2:21, p3(){ return 'something' }, p4:[1, 2, 3] },
    someClass: class SomeClass{
      constructor(a){
        this.a = a;
      }
      
      getAll(){
        return this.a + this.b;
      }
    }
  }
  
  
// myTest.test.js (file) -------------------------------------------------------------
  jest.mock('./module_1');
  const module_1 = require('./module_1');                                              // auto mocking 
  
  test('some test', function(){
  // primitives --------------------------------------
    console.log( module_1.somePrimitive );                                             // -> 'some string'                           // primitives are cloned 
    
  // functions ---------------------------------------
    console.log( module_1.someFunction() );                                            // -> undefined                               // functions are automatically mocked 
    console.log( jest.isMockFunction(module_1.someFunction) );                         // -> true  
    
  // Arrays ------------------------------------------
    console.log( module_1.someArray );                                                 // -> []                                      // we get an empty Array 
    
  // Objects -----------------------------------------
    console.log( module_1.someObject );                                                // -> { p1:'str, p2:21, p3:mockedFn, p4:[] }  // objects keep their original keys and transform key values according to the module mock    
    
  // Classes -----------------------------------------
    const MockClass = module_1.someClass;                                              // mocked classes have their constructor and all their functions are mocked 
    console.log( jest.isMockFunction(MockClass) );                                     // -> true 
    
    const newObj = new MockClass('str', 21);
    console.log( jest.isMockFunction(MockClass.prototype.constructor) );               // -> true                                    // the constructor is automatically mocked 
    console.log( newObj.a );                                                           // -> undefined  
    
    console.log( MockClass.prototype.getAll() );                                       // -> undefined                               // class functions are mocked 
    console.log( newObj.getAll() );                                                    // -> undefined 
  })
  </pre>
  <p> - <mark>jest.createMockFromModule()</mark> / <mark>jest.requireMock()</mark> </p>
  <pre>
// module_1.js (file) ----------------------------------------------------------------
  module.exports = {
    someFunction(a) { return 'default' },
  }  
  
  
// main.js (file) ---------------------------------------------------------------------
  test('some test', () => {
    const mockedModule1 = jest.createMockFromModule('./module_1');                     // returns a mocked version of the required module 
    const mockedModule2 = jest.requireMock('./module_1');                              // does the same 
    
    const originalModule = require('./module_1');
        
    mockedModule1.someFunction();                                                      // -> undefined         // because the module is mocked  
    mockedModule2.someFunction();                                                      // -> undefined
    originalModule.someFunction();                                                     // -> 'default'
    
    mockedModule1.someFunction = jest.fn(() => 'mocked - 1');                          // applying mock implementation 
    mockedModule2.someFunction = jest.fn(() => 'mocked - 2');
    
    mockedModule1.someFunction();                                                      // -> 'mocked - 1'
    mockedModule2.someFunction();                                                      // -> 'mocked - 2'
    originalModule.someFunction();                                                     // -> 'default'
  })
  </pre>
  <p> - <mark>jest.mock()</mark> / <mark>jest.unmock()</mark> / <mark>jest.requireActual()</mark> </p>
  <pre>
// module_1.js (file) -----------------------------------------------------------------
  module.exports = () => 'default - module_1';
  
// module_2.js (file) -----------------------------------------------------------------
  module.exports = () => 'default - module_2';
  
// module_3.js (file) -----------------------------------------------------------------
  module.exports = () => 'default - module_3';
  
  
// main.js (file) ---------------------------------------------------------------------
  test('some test', () => {
  // jest.mock() ---------------------------------------
    const mockedModule1 = require('./module_1');                                       // imported module is automatically mocked   
    mockedModule1();                                                                   // -> undefined   
    
    const mockedModule2 = require('./module_2'); 
    mockedModule2();                                                                   // -> 'factory mocked!'
    
    const noModule = require('./noModule');
    noModule();                                                                        // -> 'virtual mock!'
    
    // -! jest.mock() calls are hoisted!
    jest.mock('./module_1');                                                           // any further 'module_1' will be automatically mocked  
    jest.mock('./module_2', () => {                                                    // we can explicity set a mocked module 
      return jest.fn(() => 'factory mocked!');
    }); 
    jest.mock('./noModule', () => {                                                    // we can also create a virtual module (module that does not exist)
      return jest.fn(() => 'virtual mock!');
    }, {virtual: true}); 
    
  // jest.unmock() -------------------------------------
    jest.mock('./module_3');
    
    const mockedModule3 = require('./module_3');
    mockedModule3();                                                                   // -> 'default - module_3'
    
    // -! jest.unmock() calls are hoisted! 
    jest.unmock('./module_3');                                                         // prevents 'module_3' from mocking 
    
    const myMockModule = jest.createMockFromModule('./module_3');                      // even explicit mockings are prevented 
    mockedModule3();                                                                   // -> 'default - module_3'   // -! the 'jest.unmock()' prevents any mocking 
  
  // jest.requireActual() ------------------------------
    const module_1 = jest.requireActual(./module_1);                                   // requires the original (actual) module (useful when the module is automocked with 'jest.mock()')    
    module_1();                                                                        // -> 'default - module_1'
  })
  </pre>
  <p> - <mark>jest.resetModules()</mark> / <mark>jest.isolateModules()</mark> </p>
  <pre>
  test('some test', () => {
// jest.resetModules() ----------------------------------------------------------------
    const m1 = require('./module_1');
    const m2 = require('./module_1');
    
    m1 === m2;                                                                         // -> true    // because node re-requires the module from the module cashe 
    
    const m3 = require('./module_1');
    jest.resetModules();                                                               // empties the module registry (cache)
    const m4 = require('./module_1');
    
    m3 === m4;                                                                         // -> false   // m3 and m4 are different instances 
    
// jest.isolateModules() --------------------------------------------------------------
    let m5;
    let m6;
    
    jest.isolateModules(function(){                                                    // requires and isolates modules (bypases the module registry)
      m5 = require('./module_1');                                                      // module instance is isolated from the outside scope 
    })
    jest.isolateModules(function(){ 
      m6 = require('./module_1'); 
    })
    
    m4 === m5;                                                                         // -> false   // different instances 
    m5 === m6;                                                                         // -> false 
  })
  </pre>
</details>
<details class="example"> 
<summary> Example:  </summary>
<h4 style="color:darkblue"><u> module auto mocking TEST </u></h4>
  <p> - <mark>module_1.js</mark> (file) </p>
  <pre>
  const somePrimitive = 'some string';
  const someFunction = (a, b) => a + b;
  const someArray = [1, 'un', true];
  const someObject = { p1:'str', p2:21, p3(){ return 'something' }, p4:[1, 2, 3] };
  const someClass = class SomeClass{
    constructor(a, b){
      this.a = a;
      this.b = b;
    }
    
    getAll(){
      return this.a + this.b;
    }
  }
  
  module.exports = {
    somePrimitive,
    someFunction,
    someArray,
    someObject,
    someClass
  }
  </pre>
  <p> - <mark>myTest.test.js</mark> (file) </p>
  <pre>
  jest.mock('./module_1');
  const module_1 = require('./module_1');                                              // auto mocking 
  
  test('some test', function(){
// primitives -------------------------------------------------------------------------
    console.log( module_1.somePrimitive );                                             // -> 'some string'                           // primitives are cloned 
    
// functions --------------------------------------------------------------------------
    console.log( module_1.someFunction() );                                            // -> undefined                               // functions are automatically mocked 
    console.log( jest.isMockFunction(module_1.someFunction) );                         // -> true  
    
// Arrays -----------------------------------------------------------------------------
    console.log( module_1.someArray );                                                 // -> []                                      // we get an empty Array 
    
// Objects ----------------------------------------------------------------------------
    console.log( module_1.someObject );                                                // -> { p1:'str, p2:21, p3:mockedFn, p4:[] }  // objects keep their original keys and transform key values according to the module mock    
    
// Classes ----------------------------------------------------------------------------
    const MockClass = module_1.someClass;                                              // mocked classes loose their constructor and all their functions are mocked 
    console.log( jest.isMockFunction(MockClass) );                                     // -> true 
    
    const newObj = new MockClass('str', 21);
    console.log( jest.isMockFunction(MockClass.prototype.constructor) );               // -> true                                    // the constructor is automatically mocked 
    console.log( newObj.a );                                                           // -> undefined  
    
    console.log( MockClass.prototype.getAll() );                                       // -> undefined                               // class functions are mocked 
    console.log( newObj.getAll() );                                                    // -> undefined 
  })
  </pre>
<hr>
<!----------------------------------------------------------------------------------->
<h4 style="color:darkblue"><u> <mark>jest.createMockFromModule()</mark> / <mark>jest.requireMock()</mark> TEST </u></h4>
  <p> - <mark>module_1.js</mark> (file) </p>
  <pre>
  module.exports = {
    someFunction(a) { return 'default' },
  }  
  </pre>
  <p> - <mark>myTest.test.js</mark> (file) </p>
  <pre>
  test('some test', () => {
    const mockedModule1 = jest.createMockFromModule('./module_1');                     // returns a mocked version of this module 
    const mockedModule2 = jest.requireMock('./module_1');                              // does the same 
    
    const originalModule = require('./module_1');
        
    console.log( mockedModule1.someFunction() );                                       // -> undefined         // because the modules are mocked 
    console.log( mockedModule2.someFunction() );                                       // -> undefined
    console.log( originalModule.someFunction() );                                      // -> 'default'
    
    mockedModule1.someFunction = jest.fn(() => 'mocked - 1');
    mockedModule2.someFunction = jest.fn(() => 'mocked - 2');
    
    console.log( mockedModule1.someFunction() );                                       // -> 'mocked - 1'
    console.log( mockedModule2.someFunction() );                                       // -> 'mocked - 2'
  })
  </pre>
<hr>
<!----------------------------------------------------------------------------------->
<h4 style="color:darkblue"><u> <mark>jest.mock()</mark> / <mark>jest.unmock()</mark> TEST </u></h4>
  <p> - <mark>module_1.js</mark> / <mark>module_2.js</mark> / <mark>module_3.js</mark> (file) </p>
  <pre>
// module_1.js (file) -----------------------------------------------------------------
  module.exports = () => 'default - module_1';
  
// module_2.js (file) -----------------------------------------------------------------
  module.exports = () => 'default - module_2';
  
// module_3.js (file) -----------------------------------------------------------------
  module.exports = () => 'default - module_3';
  </pre>
  <p> - <mark>myTest.test.js</mark> (file) </p>
  <pre>
  test('some test', () => {
// jest.mock() ------------------------------------------------------------------------
    const mockedModule1 = require('./module_1');                                       // imported module is automatically mocked   
    console.log( mockedModule1() );                                                    // -> undefined   
    
    const mockedModule2 = require('./module_2'); 
    console.log( mockedModule2() );                                                    // -> 'factory mocked!'
    
    const noModule = require('./noModule');
    console.log( noModule() );                                                         // -> 'virtual mock!'
    
  // -! jest.mock() calls are hoisted!
    jest.mock('./module_1');                                                           // any further 'module_1' will be automatically mocked  
    jest.mock('./module_2', () => {                                                    // we can explicity set a mocked module 
      return jest.fn(() => 'factory mocked!');
    }); 
    jest.mock('./noModule', () => {                                                    // we can also create a virtual module (module that does not exist)
      return jest.fn(() => 'virtual mock!');
    }, {virtual: true}); 
    
// jest.unmock() ----------------------------------------------------------------------
    jest.mock('./module_3');
    
    const mockedModule3 = require('./module_3');
    console.log( mockedModule3() );                                                    // -> 'default - module_3'
    
  // -! jest.unmock() calls are hoisted! 
    jest.unmock('./module_3');                                                         // prevents 'module_3' from mocking 
    
    const myMockModule = jest.createMockFromModule('./module_3');                      // even explicit mockings are prevented 
    console.log( mockedModule3() );                                                    // -> 'default - module_3'   // -! the 'jest.unmock()' prevents any mocking 
  })
  </pre>
<hr>
<!----------------------------------------------------------------------------------->
<h4 style="color:darkblue"><u> <mark>jest.requireActual()</mark> TEST </u></h4>
  <pre>
  jest.mock('./module_1');                                                             // 'module_1' will be automocked in this file 
  
  test('some test', () => {
    const mockedModule = require('./module_1');                                        // module is atomocked 
    console.log( mockedModule() );                                                     // -> undefined  
    
    const originalModule = jest.requireActual('./module_1');                           // requires the original module  
    console.log( originalModule() );                                                   // -> 'default - module_1'
  })
  </pre>
<hr>
<!----------------------------------------------------------------------------------->
<h4 style="color:darkblue"><u> <mark>jest.resetModules()</mark> / <mark>jest.isolateModules()</mark> TEST </u></h4>
  <pre>
  test('some test', () => {
// jest.resetModules() ----------------------------------------------------------------
    const m1 = require('./module_1');
    const m2 = require('./module_1');
    
    console.log( m1 === m2 );                                                          // -> true    // because node re-requires the module from the module cashe 
    
    const m3 = require('./module_1');
    jest.resetModules();                                                               // empties the module registry (cache)
    const m4 = require('./module_1');
    
    console.log( m3 === m4 );                                                          // -> false   // m3 and m4 are different instances 
    
// jest.isolateModules() --------------------------------------------------------------
    let m5;
    let m6;
    
    jest.isolateModules(function(){                                                    // requires and isolates modules (bypases the module registry)
      m5 = require('./module_1');                                                      // module instance is isolated from the outside scope 
    })
    jest.isolateModules(function(){ 
      m6 = require('./module_1'); 
    })
    
    console.log( m4 === m5 );                                                          // -> false   // different instances 
    console.log( m5 === m6 );                                                          // -> false 
  })
  </pre>
</details>
<h3 style="color:darkblue;"><u> Auto Mocking and Manual Mocks </u></h3>
  <p> - when auto mocking enabled (from config) any required modules are mocked automatically (without calling <mark>jest.mock()</mark> etc...) </p>
  <p> - we can use manual mocks in this case, a manual mock is basically a module which is used instead of the original module <u>when auto mock is enabled</u> </p>
  <p> - mocked modules are placed in a <mark>__mocks__</mark> directory, so when automocking is enabled Jest tries to find the mocked module first in the nearest <mark>__mocks__</mark> directory </p>
  <pre>
    // in this case Jest will load the './__mocks__/module_1.js' module when './module_1.js' is required and automock is enabled   
    // if there's no './__mocks__/module_1.js' file Jest will create a mock module based on the './module_1.js'  
    
// file system ------------------------------------------------------------------------
    ├── module_1.js                                                                    // original module 
    └── __mocks__                                                                      // nearest mock directory 
      └── module_1.js                                                                  // mock module 
      
// nearest 'package.json' file --------------------------------------------------------
  {
    // package descriptions ...
    "jest": {
      "automock": true                                                                 // automocking enabled 
    }
  }
  </pre>
<details class="example"> 
<summary> DEMO </summary>
  <p> - directory structure </p>
  <pre>
    ├── package.json 
    ├── main.js 
    ├── module_1.js                                                                    // original module 
    ├── module_2.js                                                                    // module has no mock 
    └── __mocks__                                                                      // nearest mock directory 
      └── module_1.js                                                                  // mock module 
  </pre>
  <pre>
// ./package.json ---------------------------------------------------------------------
  {
    <span style="color:darkgray;">//...</span>
    "jest": {
      "automock": true                                                                 // automocking enabled 
    }
  }
    
// ./module_1.js ----------------------------------------------------------------------
  module.exports = {
    p1: () => 'default - module_1',
    p2: [1, 2, 3]
  }
  
// ./__mocks__/module_1.js ------------------------------------------------------------
  module.exports = {
    p1: () => function from the mocked - module_1',
    p2: ['array', 'from', 'the', 'mocked', 'module']
  }
  
// ./module_2.js ----------------------------------------------------------------------
  module.exports = {
    p1: () => 'default - module_2',
    p2: [1, 2, 3]
  }
  
// ./main.js --------------------------------------------------------------------------
  test('some test', () => {
    const m1 = require('./module_1')
    m1.p1();                                                                           // -> 'function from the mocked - module_1'
    m1.p2;                                                                             // -> ['array', 'from', 'the', 'mocked', 'module']
    
    const m2 = require('./module_2');                                                  // because there's no mock module in the '__mocks__' directory Jest creates a mock based on the './modules_2.js' file    
    m2.p1();                                                                           // -> undefined 
    m2.p2;                                                                             // -> []
  })
  </pre>
</details>
    
    <br><br>
</body>
</html>
