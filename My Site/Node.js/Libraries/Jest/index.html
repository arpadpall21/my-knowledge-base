<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title> Jest </title>
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <link rel="stylesheet" href="../../../Assets/stylesPages.css">
  <script src="../../../Assets/scriptPages.js"></script>
</head>

<body>
  <h1> Jest v27.0.0 (ver 4.0.0) </h1>
  <p> Updated ( 2021-07-18 / 2021-08-16 )</p>
  <nav class="sitenav">
    <a href="../../../index.html">MySite></a>
    <a href="../../index.html">Node.js></a> Jest
  </nav>
  <p class="subSite"><a href="Mocking, Stabbing & Spying/index.html"> Mocking, Spying & Stabbing > </a></p>
  <table class="table">
    <caption>
      <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
    </caption>
    <tr>
      <th style="width:30%;"> Command </th>
      <th> Description </th>
    </tr>
    <tr class="05.01">
      <td>
        <em>npm install</em> jest</em>
      </td>
      <td>
        - installs jest
      </td>
    </tr>
    <tr class="05.02">
      <td>
        <strong>fileName</strong>.test.js
      </td>
      <td>
        - jest file, jest will run these files in the current directory for testing
      </td>
    </tr>
    <tr class="05.03">
      <td>
        jest <small>[--coverage]</small> <small>[--config=<i>path</i>]</small> <i>pathToJestFile</i>
      </td>
      <td>
        - runs all jest files in the current direcoty or the specified file (the <mark>.test.js</mark> extension can be omitted ex: (<mark>jest someTest.test.js</mark> can be called as <mark>jest someTest</mark>)) <br>
        - (<small>--coverage</small>) also runs the coverage test (prints the result at the end of the test) <br>
        - (<small>--config=<i>path</i></small>) specifies the location of the <mark>jest.config.js</mark> file (Default: current directory)
      </td>
    </tr>
  </table>
  <br>
  <table class="table">
    <caption>
      Scopes and Teardown
      <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
    </caption>
    <tr>
      <th style="width:30%;"> Method / Property </th>
      <th> Description </th>
    </tr>
    <tr class="05.0">
      <td colspan="2"> Scope Methods </td>
    </tr>
    <tr class="05.01">
      <td>
        describe<small class="openable">[.only|skip<div>
            <p> <small>only</small> - only this describe scope will be executed in this test file </p>
            <p> <small>skip</small> - skips this describe scope </p>
          </div>]</small>(<strong>name:str</strong>, <strong>fn</strong>)
      </td>
      <td>
        - creates a scope for test suites
      </td>
    </tr>
    <tr class="10.01">
      <td>
        describe<small class="openable">[.only|skip<div>
            <p> <small>only</small> - only this describe scope will be executed in this test file </p>
            <p> <small>skip</small> - skips this describe scope </p>
          </div>]</small>.each([<strong>item:any</strong>, <i>...</i>])(<strong class="openable">name:str<div>
            <p> <mark>%s</mark> - String </p>
            <p> <mark>%d</mark> - Number </p>
            <p> <mark>%i</mark> - Integer </p>
            <p> <mark>%f</mark> - Floating point value </p>
            <p> <mark>%j</mark> - JSON </p>
            <p> <mark>%o</mark> - Object </p>
            <p> <mark>%#</mark> - Index of the test case </p>
            <p> <mark>%%</mark> - single percent sign ('%'). This does not consume an argument </p>
          </div></strong>, <strong>fn</strong>)
      </td>
      <td>
        - runs a describe scope for each <strong>item</strong>
      </td>
    </tr>
    <tr class="20.01">
      <td colspan="2"> Teardown Methods </td>
    </tr>
    <tr class="20.02">
      <td>
        afterAll(<strong>fn|asyncFn</strong>, <i class="openable">timeout:nr<div>
            <p> - default <mark>5000</mark> </p>
          </div></i>)
      </td>
      <td>
        - runs the <strong>fn</strong> after all test suite cases in this scope
      </td>
    </tr>
    <tr class="20.03">
      <td>
        afterEach(<strong>fn|asyncFn</strong>, <i class="openable">timeout:nr<div>
            <p> - default <mark>5000</mark> </p>
          </div></i>)
      </td>
      <td>
        - runs the <strong>fn</strong> after each test suite cases in this scope
      </td>
    </tr>
    <tr class="25.01">
      <td>
        beforeAll(<strong>fn|asyncFn</strong>, <i class="openable">timeout:nr<div>
            <p> - default <mark>5000</mark> </p>
          </div></i>)
      </td>
      <td>
        - runs the <strong>fn</strong> before all test suite cases in this scope
      </td>
    </tr>
    <tr class="25.02">
      <td>
        beforeEach(<strong>fn|asycnFn</strong>, <i class="openable">timeout:nr<div>
            <p> - default <mark>5000</mark> </p>
          </div></i>)
      </td>
      <td>
        - runs the <strong>fn</strong> before each test suite cases in this scope
      </td>
    </tr>
  </table>
  <br>
  <table class="table">
    <caption>
      Test Cases
      <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
    </caption>
    <tr>
      <th style="width:30%;"> Method </th>
      <th> Description </th>
    </tr>
    <tr class="05.01">
      <td>
        test|it<small class="openable">[.only|skip<div>
            <p> <small>only</small> - runs only this test case in the file </p>
            <p> <small>skip</small> - skips this test case </p>
          </div>]</small>(<strong>name:str</strong>, <strong>fn|asyncFn</strong>, <i class="openable">timeout:nr<div>
            <p> - default <mark>5000</mark> </p>
          </div></i>)
      </td>
      <td>
        - runs a test case (executes its <strong>fn</strong>) and prints the test <strong>name</strong> in the output
      </td>
    </tr>
    <tr class="10.01">
      <td>
        test|it<small class="openable">[.only|skip<div>
            <p> <small>only</small> - runs only this test case in the file </p>
            <p> <small>skip</small> - skips this test case </p>
          </div>]</small>.each([<strong>item:any</strong>, <i>...</i>])(<strong class="openable">name:str<div>
            <p> <mark>%s</mark> - String </p>
            <p> <mark>%d</mark> - Number </p>
            <p> <mark>%i</mark> - Integer </p>
            <p> <mark>%f</mark> - Floating point value </p>
            <p> <mark>%j</mark> - JSON </p>
            <p> <mark>%o</mark> - Object </p>
            <p> <mark>%#</mark> - Index of the test case </p>
            <p> <mark>%%</mark> - single percent sign ('%'). This does not consume an argument </p>
          </div></strong>, <strong>fn|asyncFn</strong>, <i class="openable">timeout:nr<div>
            <p> - default <mark>5000</mark> </p>
          </div></i>)
      </td>
      <td>
        - runs a test case for each <strong>item</strong> (executes its <strong>fn</strong>) and prints the test <strong>name</strong> in the output
      </td>
    </tr>
    <tr class="15.01">
      <td>
        test|it.todo(<strong>name:str</strong>)
      </td>
      <td>
        - writes a todo <strong>name</strong> at the end of the of the output (used to write notes in the test)
      </td>
    </tr>
  </table>
  <br>
  <table class="table">
    <caption>
      Expect and Matchers
      <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
    </caption>
    <tr>
      <th style="width:30%;"> Method </th>
      <th> Description </th>
    </tr>
    <tr class="05.01">
      <td colspan="2"> Expect </td>
    </tr>
    <tr class="05.02">
      <td>
        expect(<strong>exp</strong>).<strong>matcherMethod</strong>
      </td>
      <td>
        - the <strong>exp</strong> return a result which is verified by the <strong>matcherMethod</strong> to check if the test passes of fails <br>
        - used inside a <mark>test</mark> function
      </td>
    </tr>
    <tr class="15.01">
      <td>
        expect.assertions(<strong>nr</strong>)
      </td>
      <td>
        - this test case must have <strong>nr</strong> of assertions in order for the test to pass <u>(supports asynchronous code)</u>
      </td>
    </tr>
    <tr class="10.05">
      <td>
        expect.extend({<strong class="openable">fn(received)<div>
            <p> - the <strong>received</strong> is the value passed by the expect method preceding this matcher </p>
            <p> - the function returns an object <mark>{pass:<strong>bol</strong>, message:<strong>fn</strong>}</mark> based on a passed or failed test (<strong>fn</strong> generates and returns the message) </p>
          </div></strong><i>, ...</i>})
      </td>
      <td>
        - creates custom <strong>matcherMethod</strong>s that can be used anywhere in the jest scope (just like any other matcher methods)
      </td>
    </tr>
    <tr class="15.02">
      <td>
        expect.hasAssertions()
      </td>
      <td>
        - this test case must have at least one assertion for the test to pass <u>(supports asynchronous code)</u>
      </td>
    </tr>
    <tr class="20.01">
      <td colspan="2"> Matchers Methods </td>
    </tr>
    <tr class="20.02">
      <td>
        not<strong>.matcherMethod</strong>
      </td>
      <td>
        - negates the <strong>matcherMethod</strong>
      </td>
    </tr>
    <tr class="25.01">
      <td>
        toBe(<strong>val</strong>)
      </td>
      <td>
        - the expected value should be equal <strong>val</strong> (uses the <mark>===</mark> operator)
      </td>
    </tr>
    <tr class="35.05">
      <td>
        toBeCloseTo(<strong>nr</strong>)
      </td>
      <td>
        - the expected value should close to the <strong>nr</strong> (ex: <mark>0.1 + 0.2</mark> will be close to <mark>0.3</mark>)
      </td>
    </tr>
    <tr class="30.04">
      <td>
        toBeDefined()
      </td>
      <td>
        - the expected value should be <u>other than</u> <mark>undefined</mark>
      </td>
    </tr>
    <tr class="30.06">
      <td>
        toBeFalsy()
      </td>
      <td>
        - the expected value should be evaluated <mark>false</mark>
      </td>
    </tr>
    <tr class="35.01">
      <td>
        toBeGreaterThan(<strong>nr</strong>)
      </td>
      <td>
        - the expected value should be greater than the <strong>nr</strong>
      </td>
    </tr>
    <tr class="35.02">
      <td>
        toBeGreaterThanOrEqual(<strong>nr</strong>)
      </td>
      <td>
        - the expected value should be greater or equal than the <strong>nr</strong>
      </td>
    </tr>
    <tr class="50.02">
      <td>
        toBeInstanceOf(<strong>class</strong>)
      </td>
      <td>
        - the expected data should be an instance of <strong>class</strong>
      </td>
    </tr>
    <tr class="35.03">
      <td>
        toBeLessThan(<strong>nr</strong>)
      </td>
      <td>
        - the expected value should be less than the <strong>nr</strong>
      </td>
    </tr>
    <tr class="35.04">
      <td>
        toBeLessThanOrEqual(<strong>nr</strong>)
      </td>
      <td>
        - the expected value should be less or equal than the <strong>nr</strong>
      </td>
    </tr>
    <tr class="30.02">
      <td>
        toBeNaN()
      </td>
      <td>
        - the expected value should be <mark>NaN</mark>
      </td>
    </tr>
    <tr class="30.01">
      <td>
        toBeNull()
      </td>
      <td>
        - the expected value should be <mark>null</mark>
      </td>
    </tr>
    <tr class="30.05">
      <td>
        toBeTruthy()
      </td>
      <td>
        - the expected value should be evaluated <mark>true</mark>
      </td>
    </tr>
    <tr class="30.03">
      <td>
        toBeUndefined()
      </td>
      <td>
        - the expected value should be <mark>undefined</mark>
      </td>
    </tr>
    <tr class="40.02">
      <td>
        toContain(<strong>val</strong>)
      </td>
      <td>
        - the expected data should be iterable that contains <strong>val</strong>
      </td>
    </tr>
    <tr class="40.03">
      <td>
        toContainEqual(<strong>data:any</strong>)
      </td>
      <td>
        - the expected data should be an Array, one of the Array item should have the same data structure as <strong>data</strong>
      </td>
    </tr>
    <tr class="25.02">
      <td>
        toEqual(<strong>data</strong>)
      </td>
      <td>
        - the expected data should be equal <strong>data</strong> <u>(recursively checks the expected data (used to compare objects))</u>
      </td>
    </tr>
    <tr class="45.01">
      <td>
        toHaveLength(<strong>nr</strong>)
      </td>
      <td>
        - the expected data should be iterable and should contain <strong>nr</strong> items
      </td>
    </tr>
    <tr class="50.01">
      <td>
        toHaveProperty(<strong class="openable">propPath:str<div>
            <p> - ex: an object nested property <mark>{p1:{n2:21}}</mark> can be reached as <mark>p1.n2</mark> </p>
          </div></strong>)
      </td>
      <td>
        - the expected data should be an object having <strong>propPath</strong> (nested properties can be reached)
      </td>
    </tr>
    <tr class="40.01">
      <td>
        toMatch(<strong>str|regExp</strong>)
      </td>
      <td>
        - the expected data should match <strong>str|regExp</strong>
      </td>
    </tr>
    <tr class="40.02">
      <td>
        toMatchObject(<strong>obj</strong>)
      </td>
      <td>
        - the expected data should be an object, the <strong>obj</strong> should contain at least one key/value pair that is present in the expected object <br>
        - recusively checks for nested objects too (ex: <mark>expect( {p1:{n1:22, n2:23}} ).toMatchObject( {p1:{n2:23}} )</mark> will pass) <br>
        - does not work with Arrays (ex: <mark>expect( {p1:[1, 2]} ).toMatchObject( {p1:[1]} )</mark> will fail)
      </td>
    </tr>
    <tr class="25.03">
      <td>
        toStrictEqual(<strong>data</strong>)
      </td>
      <td>
        - the expected data should be equal <strong>data</strong> <u>(recursively checks the expected data (used to compare objects))</u> <br>
        - stricter version of <mark>toEqual</mark> (<mark>{}</mark> not equal <mark>{p1:undefined}</mark>, strict object check = class instances are not equal literal objects)
      </td>
    </tr>
    <tr class="55.01">
      <td>
        toThrow(<i class="openable">err<div>
            <p> - thrown error object </p>
            <p> - the thrown error object's class (ex: <mark>Error</mark>) </p>
            <p> - the thrown error's message as a string </p>
            <p> - the thrown error's message as <strong>regExp</strong> </p>
          </div></i>)
      </td>
      <td>
        - the expected data should be a function that optionally throws an error <br>
        - <u class="openable">(wrap the expected function in the <mark>expect</mark>)<div>
            <p> - <mark>expect(function(){ return <strong>fnThatThrows</strong>() }).toThrow()</mark></p>
            <p> - function inside <mark>expect()</mark> must not be called, jest calls it for you </p>
          </div></u>
      </td>
    </tr>
    <tr class="60.01">
      <td colspan="2"> Expect can be used in <mark>toEqual()</mark> / <mark>toBeCalledWith()</mark> matchers </td>
    </tr>
    <tr class="70.02">
      <td>
        expect.any(<strong>constructor</strong>)
      </td>
      <td>
        - the expected value should be created by the <strong>constructor</strong>
      </td>
    </tr>
    <tr class="70.01">
      <td>
        expect.anything()
      </td>
      <td>
        - the expected value should NOT be <mark>undefined</mark> or <mark>null</mark>
      </td>
    </tr>
    <tr class="65.02">
      <td>
        expect<small>[.not]</small>.arrayContaining(<strong>arr</strong>)
      </td>
      <td>
        - the expect array should contain items in <strong>arr</strong> (shallow comparison)
      </td>
    </tr>
    <tr class="65.01">
      <td>
        expect<small>[.not]</small>.objectContaining(<strong>obj</strong>)
      </td>
      <td>
        - the expected object should contain key/value pairs in <strong>obj</strong> (shallow comparison)
      </td>
    </tr>
    <tr class="60.02">
      <td>
        expect<small>[.not]</small>.stringContaining(<strong>str</strong>)
      </td>
      <td>
        - expect value should contain <strong>str</strong> part
      </td>
    </tr>
    <tr class="60.03">
      <td>
        expect<small>[.not]</small>.stringMatching(<strong>str|regExp</strong>)
      </td>
      <td>
        - the expect value should contain <strong>str|regExp</strong> part
      </td>
    </tr>
  </table>
  <br>
  <table class="table">
    <caption>
      Fake Timers (managing virtual time)
      <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
    </caption>
    <tr>
      <th style="width:30%;"> Method </th>
      <th> Description </th>
    </tr>
    <tr class="10.02">
      <td>
        jest.advanceTimersByTime(<strong>ms:nr</strong>)
      </td>
      <td>
        - advances the virtual time by the specified milliseconds then stops it
      </td>
    </tr>
    <tr class="10.03">
      <td>
        jest.advanceTimersToNextTimer(<i class="openable">step:nr<div>
            <p> - if there's a <mark>setInterval</mark> advances the virtual time by how many cycles the interval takes </p>
            <p> - if there's no <mark>setInterval</mark> this option has no effect </p>
          </div></i>)
      </td>
      <td>
        - advances the virtual time till the shortest pending timer is exhausted then stops is <br>
        - for <mark>setInterval</mark> takes only the first cycle length
      </td>
    </tr>
    <tr class="20.02">
      <td>
        jest.clearAllTimers()
      </td>
      <td>
        - removes all pending timers from the system (pending <mark>setTimeout</mark> / <mark>setInterval</mark> / <mark>setImmediate</mark>, <mark>process.nextTick()</mark> and pending promises)
      </td>
    </tr>
    <tr class="25.02">
      <td>
        jest.getRealSystemTime()
      </td>
      <td>
        - returns the real UTC system time in milliseconds
      </td>
    </tr>
    <tr class="20.01">
      <td>
        jest.getTimerCount()
      </td>
      <td>
        - returns the number of pending timers (pending <mark>setTimeout</mark> / <mark>setInterval</mark> / <mark>setImmediate</mark>, <mark>process.nextTick()</mark> and pending promises)
      </td>
    </tr>
    <tr class="15.01">
      <td>
        jest.runAllTicks()
      </td>
      <td>
        - exhausts functions set by <mark>process.nextTick()</mark>
      </td>
    </tr>
    <tr class="10.01">
      <td>
        jest.runAllTimers()
      </td>
      <td>
        - starts the virtual time and elapses it untill all timers are exhausted (<mark>setTimeout</mark> / <mark>setImmediate</mark> / <mark>process.nextTick()</mark> and all promises) <br>
        - also exhaust timers scheduled by other timers , <u><mark>setInterval</mark> will be called infinitely </u>
      </td>
    </tr>
    <tr class="10.04">
      <td>
        jest.runOnlyPendingTimers()
      </td>
      <td>
        - advances the virtual time till the longest pending timer is exhausted then stops it <br>
        - for <mark>setInterval</mark> takes only the first cycle length
      </td>
    </tr>
    <tr class="25.01">
      <td>
        jest.setSystemTime(<strong>nr:ms|date:obj</strong>)
      </td>
      <td>
        - sets the virtual (fake) time to the specified time <u>(does not trigger pending timers)</u>
      </td>
    </tr>
    <tr class="05.01">
      <td>
        jest.useFakeTimers()
      </td>
      <td>
        - globally enables fake (virtual) time in Jest (allows the use of <mark>setTimeout</mark> / <mark>setInterval</mark> / <mark>setImmediate</mark> / <mark>process.nextTick()</mark> and virtual time management) <u>(this call is hoisted)</u> <br>
        - also affects <mark>Date</mark> instances what shows the current virtual time when created
      </td>
    </tr>
    <tr class="05.02">
      <td>
        jest.useRealTimers()
      </td>
      <td>
        - globally disables Jest fake timers, also resets the virtual time <u>(this call is hoisted)</u>
      </td>
    </tr>
  </table>
  <h2 class="headerSection"> Remember This : </h2>
    <p> - concurrent (parallel) testing <mark>test.concurrent()</mark> works but it's still buggy [Experimental TESTED: 2021-07-31] </p>
  <h2 class="headerSection"> Useful Links : </h2>
  <p> <a href="https://jestjs.io/" target="_blank">JestJs.io </a></p>
  <p> <a href="https://jestjs.io/docs/configuration" target="_blank">Jest config (jestjs.io) </a></p>
  <h2 class="headerSection"> Remember This : </h2>
  <p> - Jest runs all <mark>describe</mark> scopes (before all test cases) then runs all tests, the execution order is from top-to-bottom <u>not in scoping order</u> </p>
  <p> - unfortunately <mark>Date</mark> instances don't track the virtually elapsed time! They only show the virtual time at the moment when they are created </p>
  <h2 class="headerSection"> Description and Demonstration : </h2>
  <p> - Jest is a JavaScript testing framework </p>
  <p> - currently [2021-09-05] Jest support only CommonJS modules (ESM module support is still experimental) </p>
  <pre class="syntax">
<span style="color:darkgray;">// <strong>fileName</strong>.test.js (file) ------------------------------------------------------------</span>
  test|it(<strong>testLabel:str</strong>, function(){                                                   // labeled test case (the <strong>testLabel</strong> is printed on CLI)   
    expect(<strong>exp</strong>).<strong>matcherMethod</strong>                                                          // the <strong>exp</strong> is the case what we want to test, the <strong>matcherMethod</strong> checks to outcome   
  })
  </pre>
  <details class="example">
    <summary> DEMO </summary>
    <p> - <mark>jest.test.js</mark> (file) </p>
    <pre>
  test('addition check-1', function(){
    expect(1 + 1).toBe(2)                                                              // test passes 
  })
  
  test('addition check-2', function(){
    expect(1 + 1).toBe(3)                                                              // test fails 
  })
  </pre>
  </details>
  <details class="example">
    <summary> Example : </summary>
    <h4 style="color:darkblue;"><u> coverage test </u></h4>
    <p> - <mark>myTest.test.js</mark> file </p>
    <pre>
  const {myFn1, myFn2} = require('./testFn')
  
  test('should run imported functions', function(){
    expect(myFn1()).toBe(5)
    expect(myFn2()).toBe(7)
    
  })
  </pre>
    <p> - <mark>testFn.js</mark> file </p>
    <pre>
  function myFn1(){
    let x = 2;
    let y = 3;
    const result = x + y
    
    return result
  }
  
  function myFn2(){
    let x = 7
    let y = 8
    const result = x + y
    
    return result
  }
  
  module.exports = {
    myFn1,
    myFn2
  }
  </pre>
    <pre class="cmd">
  pall@Aspire:~/Documents/CodePlus/My Site/Jest/TEST$ jest --coverage
    PASS  ./myTest.test.js
      ✓ should run imported functions (4 ms)
      
    -----------|---------|----------|---------|---------|-------------------
    File       | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
    -----------|---------|----------|---------|---------|-------------------
    All files  |     100 |      100 |     100 |     100 |                   
    testFn.js  |     100 |      100 |     100 |     100 |                   
    -----------|---------|----------|---------|---------|-------------------
    Test Suites: 1 passed, 1 total
    Tests:       1 passed, 1 total
    Snapshots:   0 total
    Time:        0.472 s, estimated 1 s
    Ran all test suites.
  pall@Aspire:~/Documents/CodePlus/My Site/Jest/TEST$ 
  </pre>
  </details>
  <hr>
  <!------------------------------------------------------------------------------------------------------>
  <h2 style="color:darkblue;"><u> Testing Asynchronous code </u></h2>
  <pre class="syntax">
<span style="color:darkgray;">// asynchronous callback --------------------------------------------------------------</span>
  test(<strong>testLabel:str</strong>, function(done){                                                  // the <mark>done</mark> callback will signal the end of an async task   
    function <strong>callback</strong>(){
      expect(<strong>something</strong>).<strong>matcherMethod</strong>                                                  // we verify the async returned result 
      done(<i>err</i>)                                                                        // signals the end of the async task (pass <i>err</i> if async task fails)
    }
    
    someAsyncApi(<strong>callback</strong>)                                                             // calling the async api 
  })
  
  
<span style="color:darkgray;">// promises ---------------------------------------------------------------------------</span>
  test(<strong>testLabel:str</strong>, function(){
    return <strong>promise</strong>                                                                     // promises must be returned 
      then((res) => { expect(<strong>expVal</strong>).<strong>matcherMethod</strong> })                                    // the expected value is checkted here 
      catch((rej) => { expect(<strong>expVal</strong>).<strong>matcherMethod</strong> })                                   // the caught value is checkted here 
  })
  
  
  test(<strong>testLabel:str</strong>, function(){
    return expect(<strong>promise</strong>).resolves.<strong>matcherMethod</strong>                                      // the <mark>.resolves</mark> expects a resolved promise    
    return expect(<strong>promise</strong>).rejects.<strong>matcherMethod</strong>                                       // the <mark>.rejects</mark> expects a rejected promise    
  })
  
  
<span style="color:darkgray;">// async functions --------------------------------------------------------------------</span>
  test(<strong>testLabel:str</strong>, async function(){
    await <strong>promise</strong>                                                                      // waits the promise to be resolved or rejected 
    
    await expect(<strong>promise</strong>).resolves.<strong>matcherMethod</strong>                                       // we can directly write a test after the await 
    await expect(<strong>promise</strong>).rejects.<strong>matcherMethod</strong> 
  })
  </pre>
  <details class="example">
    <summary> DEMO </summary>
    <p> - asynchronous callback </p>
    <pre>
  const fs = require('fs')
  
  test('should read file', function(done){
    function cb(err, data){
      expect(data.toString()).toBe('test file content')
      done()                                                                           // the doen callback signals the end of an async task 
    }
    
    fs.readFile('testFile.txt', cb)
  })
  </pre>
    <p> - promises </p>
    <pre>
  const fs = require('fs').promises
  const resPromise = Promise.resolve('res')
  const rejPromise = Promise.reject('rej')
  
  test('should read file', function(){
    return fs.readFile('./testFile.txt')                                               // promises should be returned 
      .then((res) => {
        expect(res.toString()).toBe('test file content')
      })
  })
  
// ------------------------------------------------------------------------------------
  test('should resolve promise', function(){
    return expect(resPromise).resolves.toBe('res')                                     // the '.resolves' property expects a resolved promise result  
  })
  
  test('should reject promise', function(){
    return expect(rejPromise).rejects.toBe('rej')                                      // the '.rejects' property expects a rejected promise result  
  })
  </pre>
    <p> - async function </p>
    <pre>
  const resPromise = Promise.resolve('res')
  const rejPromise = Promise.reject('rej')
  
  test('async test', async function(){
    await expect(resPromise).resolves.toBe('res')                                      // waits for the promise then tests the result directly   
    await expect(rejPromise).rejects.toBe('rej')
  })
  </pre>
  </details>
  <details class="example">
    <summary> Example : </summary>
    <h4 style="color:darkblue;"><u> testing async code </u></h4>
    <p> - both cases work fine, however the jest specification says that the <mark>done</mark> callback should be used for accurate testing </p>
    <pre>
  const fs = require('fs')
  
// -------------------------------------------------------------------------
  test('should read file', function(){
    function cb(err, data){
      expect(data.toString()).toBe('test file content')
    }
    
    fs.readFile('testFile.txt', cb)
  })
  
// -------------------------------------------------------------------------
  test('should read file', function(done){
    function cb(err, data){
      expect(data.toString()).toBe('test file content')
      done()
    }
    
    fs.readFile('testFile.txt', cb)
  })
  </pre>
    <hr>
    <!------------------------------------------------------------------------------------------------------>
    <h4 style="color:darkblue;"><u> testing promisses </u></h4>
    <pre>
  const fs = require('fs').promises
  
  test('should read file', function(){
    return fs.readFile('./testFile.txt')
      .then((res) => {
        expect(res.toString()).toBe('test file content')
      })
  })
  </pre>
    <pre>
  const resPromise = Promise.resolve('res')
  const rejPromise = Promise.reject('rej')
  
  test('should resolve promise', function(){
    return expect(resPromise).resolves.toBe('res')
  })
  
  test('should reject promise', function(){
    return expect(rejPromise).rejects.toBe('rej')
  })
  </pre>
    <p> - async functions </p>
    <pre>
  const resPromise = Promise.resolve('res')
  const rejPromise = Promise.reject('rej')

  test('async test', async function(){
    await expect(resPromise).resolves.toBe('res')
    await expect(rejPromise).rejects.toBe('rej')
  })
  </pre>
  </details>
  <hr>
  <!------------------------------------------------------------------------------------------------------>
  <h2 style="color:darkblue;"><u> Configuration </u></h2>
  <p> - there are 2 ways to configure Jest, in the nearest <mark>package.json</mark> file in the top <mark>"jest":{}</mark> object or in a <mark>jest.config.js|ts</mark> file through the <mark>--config</mark> option </p>
  <p> - <a href="https://jestjs.io/docs/configuration" target="_blank">Jest config options [link]</a></p>
  <hr>
  <!------------------------------------------------------------------------------------------------------>
  <h3 style="color:darkblue;"><u> Jest config in <mark>package.json</mark></u></h3>
  <pre>
// nearest package.json file ----------------------------------------------------------
  {
    // other package.json configs... 
    "jest": {                                                                          // jest configs come here 
      "verbose": true
    }
  }
  </pre>
  <pre class="cmd">
  apall@apall-notebook:~$ jest                                                         // jest runs with verbose setting enabled 
  </pre>
  <hr>
  <!------------------------------------------------------------------------------------------------------>
  <h3 style="color:darkblue;"><u> Jest config with <mark>jest.config.js</mark></u></h3>
  <pre>
// jest.config.js file ----------------------------------------------------------------
  module.exports = {
    verbose: true
  }
  </pre>
  <pre class="cmd">
  apall@apall-notebook:~$ jest                                                         // jest runs with verbose setting enabled (the jest.config.js is looked up in the current direcoty)
  
// jest.config.js file in other directory ---------------------------------------------
  apall@apall-notebook:~$ jest --config=../jest.config.js                              // jest config file path specified on startup    
  </pre>
  <hr>
  <!------------------------------------------------------------------------------------------------------>
  <h2 style="color:darkblue;"><u> Scopes and Teardown </u></h2>
  <h3 style="color:darkblue;"><u> Scope Methods <mark>describe()</mark> / <mark>describe.skip()</mark> / <mark>describe.only()</mark> / <mark>describe.each()()</mark> / <mark>describe.skip.each()()</mark> / <mark>describe.only.each()()</mark> </u></h3>
  <h3 style="color:darkblue;"><u> Teardown Methods <mark>beforeEach()</mark> / <mark>afterEach()</mark> / <mark>beforeAll()</mark> / <mark>afterAll()</mark> </u></h3>
  <p> - we can scope our test so test suites are isolated from each other, in Jest scopes are executed from top-to-bottom (not nesting execution order) </p>
  <p> - teardown methods execute their functions at the desired time </p>
  <p> - Jest runs all <mark>describe</mark> scopes (before all test cases) then runs all tests, the execution order is from top-to-bottom <u>not in scoping order</u> </p>
  <details class="example">
    <summary> DEMO </summary>
    <!--
  - no test is executed before all describe runs (collection phase)  
  
  
  
  - which is the order of describes (top to bottom ???)

-->
    <p> - all scopes are executed before any test cases </p>
    <pre>
  describe('desc-1', () => {                                                           // Jest first executes all describe cases then all test cases   // -! from top-to-bottom 
    test('test-1 in desc-1', () =>  });                                                // the execution order in this case is...  
                                                                                         // -> desc-1
    describe('desc-1.1', () => {                                                         // -> desc-1.1
      test('test-1 in desc-1.1', () => {})                                               // -> desc-1.1.1
                                                                                         // -> desc-1.2
      describe('desc-1.1.1', () => {                                                     // -> desc-2
        test('test-1 in desc-1.1.1', () => {})                                           // -> test-1 in desc-1.1       // all describe scopes are executed first then all test cases   
      })                                                                                 // -> test-1 in desc-1.1.1
    })                                                                                   // -> test-2 in desc-1
                                                                                         // -> test-1 in desc-1.2
    test('test-2 in desc-1', () => {})                                                   // -> test-2 in desc-1.2
                                                                                         // -> test-1 in desc-2 
    describe('desc-1.2', () => {
      test('test-1 in desc-1.2', () => {})
      test('test-2 in desc-1.2', () => {})
    })
  })
  
  describe('desc-2', () => { 
    test('test-1 in desc-2', () => {})
  })
  </pre>
    <p> - <mark>describe()</mark> / <mark>describe.skip()</mark> / <mark>describe.only()</mark> / <mark>describe.each()</mark> / <mark>describe.skip.each()</mark> / <mark>describe.only.each()</mark> </p>
    <pre>
// describe() -------------------------------------------------------------------------
  describe('some desc 1', () => {                                                      // describe scopes are isolated from each other 
    // some here ...  
  })
  describe('some desc 2', () => { 
        // some here ...  
  })
  
// describe.only() --------------------------------------------------------------------
  describe.only('desc-2', () => {                                                      // only this describe scope is executed in this jest file    
    // some test ...
  })
  
// describe.skip() --------------------------------------------------------------------
  describe.skip('desc-2', () => {                                                      // this describe scope is skipped (not executed by Jest)
    // some test ...
  })
  
  
// describe.each()() ------------------------------------------------------------------
  describe.each(['desc-1', 'desc-2', 'desc-3'])('name: %s', function(){                // runs 3 describe scopes (%s = is the name of the current scope)
    // some test ...                                                                   // 3 decribe scope names will be 'name :desc-1' | 'name :desc-2' | 'name :desc-3'
  })
  
// describe.only.each()() -------------------------------------------------------------
  describe.only.each(['des-1', 'desc-2', 'desc-3'])('name: %s', function(){            // only this describe each is executed in this jest file  
    // some test ...
  })
  
// describe.skip.each()() -------------------------------------------------------------
  describe.skip.each(['des-1', 'desc-2', 'desc-3'])('name: %s', function(){            // this describe each is skipped (not executed by Jest)   
    // some test ...
  })
  </pre>
    <p> - teardown methods <mark>beforeEach()</mark> / <mark>afterEach()</mark> / <mark>beforeAll()</mark> / <mark>afterAll()</mark> </p>
    <pre>
  describe('some description-1', () => {
    beforeEach(() => {                                                                 // runs its function before each test in this scope   
      // some code ...
    })
    
    afterEach(() => {                                                                  // runs its function after each test in this scope   
      // some code ...
    })
    
    beforeAll(() => {                                                                  // runs its function (once) before all tests in this scope   
      // some code ...
    })
    
    afterAll(() => {                                                                   // runs its function (once) before all tests in this scope   
      // some code ...
    })
    
    test('test-1', () => {
      // some test...
    })
    test('test-2', () => {
      // some test...
    })
  })
  
  describe('some description-2', () => { 
    test('test-1', () => {                                                             // the above teardown methods have no effect in this scope   
      // some test...
    })
  })
  </pre>
  </details>
  <details class="example">
    <summary> Example : </summary>
    <h4 style="color:darkblue;"><u> scope calling order TEST </u></h4>
    <p> - <mark>describe</mark> scopes are called form top-to-bottom </p>
    <pre>
  describe('main', function(){
    it('someTest', function(){})
    
    describe('nest-1', function(){
      it('someTest', function(){})

      describe('nest-nest-1', function(){
        it('someTest', function(){})
      })
    })
    
    describe('nest-2', function(){
      it('someTest', function(){})
      
      describe('nest-nest-2', function(){
        it('someTest', function(){})
      })
    })
  })
  </pre>
    <pre class="cmd">
  pall@apall-notebook:~/Documents/Pall's Stuff/CodePlus/My Site/Jest/TEST$ ./node_modules/.bin/jest 
    PASS  ./myTest.test.js
      main
        ✓ someTest (1 ms)
        nest-1
          ✓ someTest
          nest-nest-1
            ✓ someTest
        nest-2
          ✓ someTest
          nest-nest-2
            ✓ someTest

    Test Suites: 1 passed, 1 total
    Tests:       5 passed, 5 total
    Snapshots:   0 total
    Time:        0.179 s, estimated 1 s
    Ran all test suites.
  apall@apall-notebook:~/Documents/Pall's Stuff/CodePlus/My Site/Jest/TEST$ 
  </pre>
    <hr>
    <!------------------------------------------------------------------------------------------------------>
    <h4 style="color:darkblue;"><u> <mark>describe.only()</mark> / <mark>describe.skip()</mark> / <mark>describe.each()</mark> / <mark>describe.skip.each()</mark> / <mark>describe.only.each()</mark> / <mark>describe.skip.each()</mark> TEST </u></h4>
    <hr>
    <pre>
// describe.each()() ------------------------------------------------------------------
  describe.each(['des-1', 'desc-2', 'desc-3'])('name: %s', function(){                 // runs 3 describe scopes (%s = is the name of the current scope)
    test('test', function(){})
  })
  
// describe.only() --------------------------------------------------------------------
  describe('desc-1', function(){
    test('test', function(){})
  })
  
  describe.only('desc-2', function(){                                                  // only this describe scope is executed 
    test('test', function(){})
  })
  
  describe('desc-3', function(){
    test('test', function(){})
  })
  
// describe.sip() --------------------------------------------------------------------
  describe('desc-1', function(){
    test('test', function(){})
  })
  
  describe.skip('desc-2', function(){                                                  // skips this describe scope 
    test('test', function(){})
  })
  
  describe('desc-3', function(){
    test('test', function(){})
  })
  
// describe.only.each()() -------------------------------------------------------------
  describe('desc-1', function(){
    test('test', function(){})
  })
  
  describe.only.each(['des-1', 'desc-2', 'desc-3'])('name: %s', function(){            // only this describe each is executed 
    test('test', function(){})
  })
  
  describe('desc-3', function(){
    test('test', function(){})
  })
  
// describe.skip.each()() -------------------------------------------------------------
  describe('desc-1', function(){
    test('test', function(){})
  })

  describe.skip.each(['des-1', 'desc-2', 'desc-3'])('name: %s', function(){            // skips these describe each scopes 
    test('test', function(){})
  })

  describe('desc-3', function(){
    test('test', function(){})
  })
  </pre>
    <!------------------------------------------------------------------------------------------------------>
    <h4 style="color:darkblue;"><u> <mark>beforeEach()</mark> / <mark>afterEach()</mark> / <mark>beforeAll()</mark> / <mark>afterAll()</mark> TEST </u></h4>
    <pre>
  beforeEach(function(){
    console.log( 'before-each')
  })
  afterEach(function(){
    console.log( 'after-each')
  })

  beforeAll(function(){
    console.log( 'before-all')
  })
  afterAll(function(){
    console.log( 'after-all')
  })

  test('test-1', function(){
    console.log( 'test-1' )
  })
  test('test-2', function(){
    console.log( 'test-2' )
  })
  </pre>
    <pre class="cmd">
  pall@apall-notebook:~/Documents/Pall's Stuff/CodePlus/My Site/Jest/TEST$ ./node_modules/.bin/jest 
    PASS  ./myTest.test.js
      ✓ test-1 (2 ms)
      ✓ test-2 (1 ms)
      console.log
        before-all
          at myTest.test.js:9:11
      console.log
        before-each
          at Object.<anonymous> (myTest.test.js:2:11)
      console.log
        test-1
          at Object.<anonymous> (myTest.test.js:16:11)
      console.log
        after-each
          at Object.<anonymous> (myTest.test.js:5:11)
      console.log
        before-each
          at Object.<anonymous> (myTest.test.js:2:11)
      console.log
        test-2
          at Object.<anonymous> (myTest.test.js:19:11)
      console.log
        after-each
          at Object.<anonymous> (myTest.test.js:5:11)
      console.log
        after-all

          at myTest.test.js:12:11

    Test Suites: 1 passed, 1 total
    Tests:       2 passed, 2 total
    Snapshots:   0 total
    Time:        0.189 s, estimated 1 s
    Ran all test suites.
  apall@apall-notebook:~/Documents/Pall's Stuff/CodePlus/My Site/Jest/TEST$ 
  </pre>
  </details>
  <hr>
  <!------------------------------------------------------------------------------------------------------>
  <h2 style="color:darkblue;"><u> Test cases <mark>test()</mark> / <mark>test.only()</mark> / <mark>test.skip()</mark> / <mark>test.each()()</mark> / <mark>test.only.each()()</mark> / <mark>test.skip.each()()</mark> / <mark>test.todo()</mark> </u></h2>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
  test('some test', function(){
    // expect test case here...
  })
  
// test.only() ------------------------------------------------------------------------
  test.only('some test', function(){                                                   // only this test case is executed in this jest file   
    // expect test case here...
  })
  
// test.skip() ------------------------------------------------------------------------
  test.skip('some test', function(){                                                   // this test case is skipped 
    // expect test case here...
  })
  
// test.each() ------------------------------------------------------------------------
  test.each([1, 2, 3])('test-%d', function(){                                          // executes the test case function 3 times for each item  ('test-1' | 'test-2' 'test-3') 
    // expect test case here...
  })
  
// test.only.each() -------------------------------------------------------------------
  test.only.each([1, 2, 3])('test-%d', function(){                                     // only these test cases will be executed in this jest file 
    // expect test case here...
  })
  
// test.skip.each() -------------------------------------------------------------------
  test.skip.each([1, 2, 3])('test-%d', function(){                                     // these test cases will be skipped 
    // expect test case here...
  })
  
// test.todo() ------------------------------------------------------------------------
  test('test-1', () => {})
  test('test-2', () => {})
  test('test-3', () => {})
  
  test.todo('we should do 5 tests')                                                    // this is basically a note which is printed at the end of the test cases in the output  
  
  test('test-4', () => {})
  test('test-5', () => {})
  </pre>
  </details>
  <details class="example">
    <summary> Example : </summary>
    <h4 style='color:darkblue'><u> <mark>test()</mark> / <mark>test.only()</mark> / <mark>test.skip()</mark> TEST </u></h4>
    <pre>
  test('test-1', function(){
    console.log( 'test1')
  })
  
// ------------------------------------------------------------------------------------
  test.only('test2', function(){                                                       // only this test case is executed in this jest file   
    console.log( 'test2')
  })
  
// ------------------------------------------------------------------------------------
  test.skip('test3', function(){                                                       // this test case is skipped 
    console.log( 'test2')
  })
  </pre>
    <hr>
    <!------------------------------------------------------------------------------------------------------>
    <h4 style='color:darkblue'><u> <mark>test.eac()</mark> / <mark>test.only.each()</mark> / <mark>test.skip.each()</mark> TEST </u></h4>
    <pre>
  test.each([1, 2, 3])('test-%d', function(){
    console.log( 'test')                                                               // 3 test cases are executed here 
  })
  
// ------------------------------------------------------------------------------------
  test.only.each([1, 2, 3])('test-%d', function(){                                     // only these test cases will be executed in this jest file 
    console.log( 'test')
  })
  
// ------------------------------------------------------------------------------------
  test.skip.each([1, 2, 3])('test-%d', function(){                                     // these test cases will be skipped 
    console.log( 'test')
  })
  </pre>
    <hr>
    <!------------------------------------------------------------------------------------------------------>
    <h4 style='color:darkblue'><u> <mark>test.todo()</mark> TEST </u></h4>
    <pre>
  test('test-1', () => {})
  test('test-2', () => {})
  test('test-3', () => {})
  
  test.todo('we should have 4 tests')
  
  test('test-4', () => {})
  
  test.todo('ok we have 4 tests now')  
  </pre>
    <pre class="cmd">
  apall@apall-notebook:~/Documents/Pall's Stuff/CodePlus/My Site/Jest/TEST$ ./node_modules/.bin/jest
    PASS  ./myTest.test.js
      ✓ test-1
      ✓ test-2
      ✓ test-3
      ✓ test-4 (1 ms)
      ✎ todo we should have 4 tests
      ✎ todo ok we have 4 tests now
    
    Test Suites: 1 passed, 1 total
    Tests:       2 todo, 4 passed, 6 total
    Snapshots:   0 total
    Time:        0.181 s, estimated 1 s
    Ran all test suites.
  apall@apall-notebook:~/Documents/Pall's Stuff/CodePlus/My Site/Jest/TEST$  
  </pre>
  </details>
  <hr>
  <!------------------------------------------------------------------------------------------------------>
  <h2 style="color:darkblue;"><u> Expect and Matchers </u></h2>
  <h3 style="color:darkblue"><u> Expect <mark>expect()</mark> / <mark>expect.extend()</mark> / <mark>expect.assertions()</mark> / <mark>expect.hasAssertions()</mark> / <mark>expect.stringContaining()</mark> / <mark>expect.stringMatching()</mark> / <mark>objectContaining()</mark> / <mark>arrayContaining()</mark> / <mark>expect.anything()</mark> / <mark>expect.any()</mark> </u></h3>
  <h3 style="color:darkblue;"><u> Matchers <mark>not</mark> / <mark>toBe()</mark> / <mark>toEqual()</mark> / <mark>toStrictEqual()</mark> / <mark>toBeNull()</mark> / <mark>toBeNaN</mark> / <mark>toBeUndefined()</mark> / <mark>toBeDefined()</mark> / <mark>toBeTruthy()</mark> / <mark>toBeFalsy()</mark> / <mark>toBeGreaterThan()</mark> / <mark>toBeGreaterThanOrEqual()</mark> / <mark>toBeLessThan()</mark> / <mark>toBeLessThanOrEqual()</mark> / <mark>toBeCloseTo()</mark> / <mark>toMatch()</mark> / <mark>toMatchObject</mark> / <mark>toContain()</mark> / <mark>toContainEqual()</mark> / <mark>toHaveLength()</mark> / <mark>toHaveProperty()</mark> / <mark>toBeInstanceOf()</mark> / <mark>toThrow()</mark> </u></h3>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
// expect.extend() --------------------------------------------------------------------
  expect.extend({
    toBeNotString(received){                                                           // creating a custom matcher method 
      if(typeof received !== 'string'){
        return {pass:true, message:() => 'not a string data type'}
      } else {
        return {pass:false, message:() => `${received} is a string data type`}
      }
    }
  })
  
  test('should not be a string', function(){
    expect(21).toBeNotString()                                                         // test passes     // custom matcher method used   
    expect('21').toBeNotString()                                                       // test fails 
  })
  
  
// expect.objectContaining() ----------------------------------------------------------
  test('obj containing-1', function(){
    expect({p1:21, p2:22}).toEqual(expect.objectContaining({p2:22}))                   // test passes 
  })
  
  test('obj containing-2', function(){
    expect({p1:21, p2:22}).toEqual(expect.objectContaining({p1:21, p2:22, p3:23}))     // test fails (expected object does not contain 'p3:23')
  })
  
  test('obj containing-3', function(){
    expect({p1:21, p2:{nest:22}}).toEqual(expect.objectContaining({nest:22}))          // test fails 
  })
  
  test('obj containing-4', function(){
    expect({p1:21, p2:{nest:22}}).toEqual(expect.objectContaining({p2:{nest:22}}))     // test passes  
  })
  
  
// expect.arrayContaining() -----------------------------------------------------------
  test('array containing-1', function(){
    expect([1, 2, 3, 4, 5]).toEqual(expect.arrayContaining([2, 5]))                    // test passes  
  }) 
  
  test('array containing-2', function(){
    expect([1, 2, 3, 4, 5]).toEqual(expect.arrayContaining([2, 5]))                    // test passes  
  })
  
  
// expect.anything() ------------------------------------------------------------------
  test('anything-1', function(){
    expect(0).toEqual(expect.anything())                                               // test passes
    expect('str').toEqual(expect.anything())                                           // test passes 
    expect(undefined).toEqual(expect.anything())                                       // test fails
  })
  
  
// expect.any() -----------------------------------------------------------------------
  test('any-1', function(){
    expect(12).toEqual(expect.any(Number))                                             // test passes 
    
    function Animal(race){
      this.race = race
    }
    
    var cat = new Animal('cat')
    
    expect(cat).toEqual(expect.any(Animal))                                            // test passes 
  })
  
  
// expect.assertions() / expect.hasAssertions() ---------------------------------------  
  const myTimeout = new Promise(function(res, rej){
    setTimeout(function(){
      res('timeout promise OK!')
    }, 2000)
  })
  
  test('assert test-1', async function(){
    expect.assertions(2)                                                               // 2 assertions in this test => test passes 
    
    expect(2**2).toBe(4)
    await expect(myTimeout).resolves.toBe('timeout promise OK!')                       // also works with async code 
  })
  
  test('assert test-1', async function(){
    expect.hasAssertions()                                                             // test should have at least 1 assertion
    
    expect(2**2).toBe(4)
    expect(2**4).toBe(16)
    await expect(myTimeout).resolves.toBe('timeout promise OK!')                       // also works with async code 
  })
  </pre>
    <pre>
// not --------------------------------------------------------------------------------
  test('test', function(){
    expect(2).not.toBe(3)                                                              // test passes 
    expect(2).not.toBe(2)                                                              // test fails 
  })
  
// toBe() / toEqual() -----------------------------------------------------------------
  test('test', function(){
    expect(2).toBe(2)                                                                  // test passes 
    expect(2).toBe('2')                                                                // test fails because the toBe() uses the same value comparison operator (===)
    expect({p1:21, p2:22}).toBe({p1:21, p2:22})                                        // test fails because the toBe() cannot compare objects 
  })
  
  test('test', function(){
    expect({p1:21, p2:22}).toEqual({p1:21, p2:22})                                     // test passes (recursively compares object properties)
    expect([1, 2, 3]).toEqual([1, 2, 3])                                               // test passes 
  })
  
// toEqual() VS toStrictEqual() -------------------------------------------------------
  class TestClass {
    constructor(a, b){
      this.a = a
      this.b = b;
    }
  }
  
  var myObj = new TestClass(21, 22)
  
  test('test', function(){
    expect({}).toEqual({p1:undefined})                                                 // test passes 
    expect([,1]).toEqual([undefined,1])                                                // test passes 
    expect({a:21, b:22}).toEqual(myObj)                                                // test passes
  })
  
  test('test-2', function(){
    expect({}).toStrictEqual({p1:undefined})                                           // the 'toStrictEqual()' is a stricter version of 'toEqual' all these tests will fail    
    expect([,1]).toStrictEqual([undefined,1]) 
    expect({a:21, b:22}).toStrictEqual(myObj) 
  })
  
// toBeNull() / toBeNaN() / toBeUndefined() / toBeDefined() / toBeTruthy() / toBeFalsy() --
  test('test', function(){
    expect(null).toBeNull()                                                            // test passes 
    
    expect(NaN).toBeNaN()                                                              // test passes 
    
    expect(undefined).toBeUndefined()                                                  // test passes 
    expect('').toBeDefined()                                                           // test passes (any value which is not undefined) 
    
    expect(1).toBeTruthy()                                                             // test passes 
    expect(0).toBeFalsy()                                                              // test passes 
  })
  
// toBeGreaterThan() / toBeGreaterThanOrEqual() / toBeLessThan() / toBeLessThanOrEqual() / toBeCloseTo() --
  test('test', function(){
    expect(5).toBeGreaterThan(3)                                                       // test passes 
    expect(5).toBeGreaterThanOrEqual(3)                                                // test passes 
    expect(5).toBeGreaterThanOrEqual(5)                                                // test passes 
    
    expect(5).toBeLessThan(7)                                                          // test passes   
    expect(5).toBeLessThanOrEqual(7)                                                   // test passes   
    expect(5).toBeLessThanOrEqual(5)                                                   // test passes   
    
    expect(0.1 + 0.2).toBeCloseTo(0.3)                                                 // test passes (used for double floating comparison)   
  })
  
// toMatch() / toMatchObject() --------------------------------------------------------
  test('test', function(){
    expect('some test').toMatch('some test')                                           // test passes 
    expect('some test').toMatch(/SOME TEST/i)                                          // test passes (also accepts regular expressions)
  })
  
  test('test', function(){
    expect({p1:21, p2:{a:1, b:2}, p3:{nest1:111, nest2:222}}).toMatchObject({p1:21})           // test passes 
    expect({p1:21, p2:{a:1, b:2}, p3:{nest1:111, nest2:222}}).toMatchObject({p2:{b:2}})        // test passes (also check for nested objects)
    expect({p1:21, p2:{a:1, b:2}, p3:{nest1:111, nest2:222}}).toMatchObject({p3:{nest2:222}})  // test passes 
    
    expect({p1:[1, 2, 3]}).toMatchObject({p1:[1, 2]})                                          // test fails (does not work with Arrays)
    
    expect({p1:[1, 2, 3]}).toMatchObject({p1:[1, 2, 3]})                                       // test passes (the nested Array has the same structure as in the expected object)    
  })
  
// toHaveLength() / toContain() / toContainEqual() ------------------------------------
  test('test', function(){
    expect([1, 2, 3]).toHaveLength(3)                                                  // test passes 
    expect('some string').toHaveLength(11)                                             // test passes 
  })
  
  test('test', function(){
    expect([1, 2, 3]).toContain(2)                                                     // test passes (Array contains the item)
    expect(['egy', 'ketto', 'harom']).toContain('ketto')                               // test passes 
    expect('some string').toContain(' ')                                               // test passes 
  })
  
  test('test', function(){
    expect([{p1:21, p2:22}, {nest:[1, 2]}, {p3:33}]).toContainEqual({p3:33})           // test passes (the expected array contains the item)
    expect([{p1:21, p2:22}, {nest:[1, 2]}, {p3:33}]).toContainEqual({nest:[1, 2]})     // test passes 
    expect([{p1:21, p2:22}, {nest:[1, 2]}, {p3:33}]).toContainEqual({p1:21, p2:22})    // test passes 
    
    expect([{p1:21, p2:22}, {nest:[1, 2]}, {p3:33}]).toContainEqual({p1:21})           // test fails 
    expect({p1:21, p2:22, p3:[1, 2]}).toContainEqual({p2:22})                          // test fails (object is not expected)
  })
  
// toHaveProperty() / toBeInstanceOf() ------------------------------------------------
  test('test', function(){
    expect({p1:21, p2:{n1:33}}).toHaveProperty('p1')                                   // test passes 
    expect({p1:21, p2:{n1:33}}).toHaveProperty('p2.n1')                                // test passes (we can check for nested properties)
    expect({p1:21, p2:{n1:33, n2:{d1:true}}}).toHaveProperty('p2.n2.d1')               // test passes 
  })
  
  test('test', function(){
    expect({p1:21}).toBeInstanceOf(Object)                                             // test passes 
    expect([1, 2]).toBeInstanceOf(Array)                                               // test passes 
    expect(/./).toBeInstanceOf(RegExp)                                                 // test passes 
    
    class SomeClass {}
    let myInstance = new SomeClass()
    
    expect(myInstance).toBeInstanceOf(SomeClass)                                       // test passes 
  })
  
// toThrow() --------------------------------------------------------------------------
  function testFn(){
    throw new Error('someError')
  }
    
  test('test', function(){
    expect(testFn).toThrow()                                                           // test passes 
    expect(testFn).toThrow('someError')                                                // test passes 
    expect(testFn).toThrow(/someError/)                                                // test passes 
    expect(testFn).toThrow(Error)                                                      // test passes (the thrown error is an instance of this class)
  })
  </pre>
  </details>
  <details class="example">
    <summary> Example : </summary>
    <h4 style="color:darkblue;"><u> <mark>expect.extend()</mark> TEST </u></h4>
    <pre>
  expect.extend({
    toBeBiggerThan0(received){
      if(received > 0){
        return {
          pass: true,
          message: () => 'bigger than 0'
        }
      } else {
        return {
          pass: false,
          message: () => 'smaller or equal 0'
        }
      }
    },
    toBeInRangeOf(received, min, max){
      if(received >= min && received &lt;= max){
        return {
          pass: true,
          message: () => `${received} is in range of min ${min} max ${max}`
        }
      } else {
        return {
          pass: false,
          message: () => `${received} is not in range of min ${min} max ${max}`
        }
      }
    }
  })
  
  test('should be bigger than 0', function(){
    expect(42).toBeBiggerThan0()                                                       // test passes 
  })
  
  test('should be bigger than 0', function(){
    expect(-8).toBeBiggerThan0()                                                       // test fails
  })
  
  test('should be in range', function(){
    expect(10).toBeInRangeOf(5, 15)                                                    // test passes 
  })
  
  test('should be in range', function(){                                               // test fails  
    expect(10).toBeInRangeOf(11, 25)
  })
  </pre>
    <hr>
    <!------------------------------------------------------------------------------------------------------>
    <h4 style="color:darkblue;"><u> <mark>expect.assertions()</mark> / <mark>expect.hasAssertions()</mark> TEST </u></h4>
    <pre>
  const myTimeout = new Promise(function(res, rej){
    setTimeout(function(){
      res('timeout promise OK!')
    }, 2000)
  })
  
  test('assert test-1', async function(){
    expect.assertions(2)                                                               // 2 assertions in this test => test passes 
    
    expect(2**2).toBe(4)
    await expect(myTimeout).resolves.toBe('timeout promise OK!')                       // assertios() also works with async code 
  })
  
  test('assert test-1', async function(){
    expect.hasAssertions()                                                             // test should have at least 1 assertion
    
    expect(2**2).toBe(4)
    expect(2**4).toBe(16)
    await expect(myTimeout).resolves.toBe('timeout promise OK!')                       // assertios() also works with async code 
  })
  </pre>
    <hr>
    <!------------------------------------------------------------------------------------------------------>
    <h4 style="color:darkblue;"><u> <mark>expect.stringContaining()</mark> / <mark>expect.StringMatching()</mark> TEST </u></h4>
    <pre>
  test('some test-1', function(){
    expect('Kicsi kutya tarka').toEqual(expect.stringContaining('kutya'))              // test passes 
    expect('Kicsi kutya tarka').toEqual(expect.stringContaining('macka'))              // test fails 
  })
  
  test('some test-2', function(){
    expect('Kicsi kutya tarka').toEqual(expect.stringMatching('ta'))                   // test passes 
    expect('Kicsi kutya tarka').toEqual(expect.stringMatching(/k.cs.\s/i))             // test passes 
    
    expect('Kicsi kutya tarka').toEqual(expect.stringMatching('farka'))                // test fails
    expect('Kicsi kutya tarka').toEqual(expect.stringMatching(/k.cs.\s/))              // test fails 
  })
  
  const mock = jest.fn()
  
  function testFn(a, b, cb){
    cb(a, b)
  }
  
  test('mock called with', function(){
    testFn('one', 'two', mock)
    
    expect(mock).toBeCalledWith(expect.stringContaining('one'), expect.stringContaining('two'))   // test passes 
  })
  </pre>
    <hr>
    <!------------------------------------------------------------------------------------------------------>
    <h4 style="color:darkblue;"><u> <mark>expect.objectContaining()</mark> / <mark>expectArrayContaining()</mark> TEST </u></h4>
    <pre>
// expect.objectContaining() ----------------------------------------------------------
  test('obj containing-1', function(){
    expect({p1:21, p2:22}).toEqual(expect.objectContaining({p2:22}))                   // test passes 
  })
  
  test('obj containing-2', function(){
    expect({p1:21, p2:22}).toEqual(expect.objectContaining({p1:21, p2:22, p3:23}))     // test fails (expected object does not contain 'p3:23')
  })
  
  test('obj containing-3', function(){
    expect({p1:21, p2:{nest:22}}).toEqual(expect.objectContaining({nest:22}))          // test fails 
  })
  
  test('obj containing-4', function(){
    expect({p1:21, p2:{nest:22}}).toEqual(expect.objectContaining({p2:{nest:22}}))     // test passes  
  })
  
  // expect.arrayContaining() ---------------------------------------------------------
  test('array containing-1', function(){
    expect([1, 2, 3, 4, 5]).toEqual(expect.arrayContaining([2, 5]))                    // test passes  
  }) 
  
  test('array containing-2', function(){
    expect([1, 2, 3, 4, 5]).toEqual(expect.arrayContaining([2, 5]))                    // test passes  
  })
  </pre>
    <hr>
    <!------------------------------------------------------------------------------------------------------>
    <h4 style="color:darkblue;"><u> <mark>expect.anything()</mark> / <mark>expect.any()</mark> TEST </u></h4>
    <pre>
// expect.anything() ------------------------------------------------------------------
  test('anything-1', function(){
    expect(0).toEqual(expect.anything())                                               // test passes
    expect('str').toEqual(expect.anything())                                           // test passes 
  })
  
  test('anything-2', function(){
    expect(undefined).toEqual(expect.anything())                                       // test fails
  })
  
  test('anything-3', function(){
    expect(null).toEqual(expect.anything())                                            // test fails
  })
    
// expect.any() -----------------------------------------------------------------------
  test('any-1', function(){
    expect(12).toEqual(expect.any(Number))                                             // test passes 
  })
  
  test('any-2', function(){
    function Animal(race){
      this.race = race
    }
    
    var cat = new Animal('cat')
    
    expect(cat).toEqual(expect.any(Animal))                                            // test passes 
  })
  
  test('any-3', function(){
    expect(/r/).toEqual(expect.any(RegExp))                                            // test passes 
  })
  </pre>
    <hr>
    <!------------------------------------------------------------------------------------------------------>
    <h4 style="color:darkblue;"><u> <mark>toBe()</mark> / <mark>toEqual()</mark> / <mark>toStrictEqual()</mark> TEST </u></h4>
    <pre>
  test('test-1', function(){
    expect(2).toBe('2')                                                                // test fails because the toBe() uses the same value comparison operator (===)
  })
  
  test('test-2', function(){
    expect(2).toBe(2)                                                                  // test passes 
  })
  
  test('test-3', function(){
    expect({p1:21, p2:22}).toBe({p1:21, p2:22})                                        // test fails because the toBe() can compare only values   
  })
  
  test('test-3', function(){
    expect({p1:21, p2:22}).toEqual({p1:21, p2:22})                                     // test passes because the toEqual() recursively compares object properties 
  })
  
  test('test-4', function(){
    expect([1, 2, 3]).toBe([1, 2, 3])                                                  // test fails because the toBe() can compare only values
  })
  
  test('test-', function(){
    expect([1, 2, 3]).toEqual([1, 2, 3])                                               // test fails because the toBe() can compare only values   
  })
  </pre>
    <p> - <mark>toEqual()</mark> VS <mark>toStrictEqual()</mark> </p>
    <pre>
  class TestClass {
    constructor(a, b){
      this.a = a
      this.b = b;
    }
  }
  
  var myObj = new TestClass(21, 22)
  
// toEqual() --------------------------------------------------------------------------
  test('test-1', function(){
    expect({}).toEqual({p1:undefined})                                                 // test passes 
    
    expect([,1]).toEqual([undefined,1])                                                // test passes 
    
    expect({a:21, b:22}).toEqual(myObj)
  })
  
  
// toStrictEqual() --------------------------------------------------------------------
  test('test-2', function(){
    expect({}).toStrictEqual({p1:undefined})                                           // test fails  
  })
  
  test('test-3', function(){
    expect([,1]).toStrictEqual([undefined,1])                                          // test fails
  })

  test('test-4', function(){
    expect({a:21, b:22}).toStrictEqual(myObj)                                          // test fails
  })
  </pre>
    <hr>
    <!------------------------------------------------------------------------------------------------------>
    <h4 style="color:darkblue;"><u> <mark>.not</mark> TEST </u></h4>
    <pre>
  test('test-1', function(){
    expect(2).not.toBe(3)                                                              // test passes 
  })
  
  test('test-2', function(){
    expect(2).not.toBe(2)                                                              // test fails 
  })
  </pre>
    <hr>
    <!------------------------------------------------------------------------------------------------------>
    <h4 style="color:darkblue;"><u> <mark>.toThrow()</mark> TEST </u></h4>
    <pre>
  function testFn(){
    throw new Error('someError')
  }
    
  test('test-1', function(){
    expect(testFn).toThrow()                                                           // the function instance is not called!
    
    expect(testFn).toThrow('someError')
    
    expect(testFn).toThrow(/someError/)
    
    expect(testFn).toThrow(Error)
  })
  </pre>
    <h4 style="color:darkblue;"><u> <mark>toBeNull()</mark> / <mark>toBeNaN()</mark> / <mark>toBeUndefined()</mark> / <mark>toBeDefined()</mark> / <mark>toBeTruthy()</mark> / <mark>toBeFalsy()</mark> TEST </u></h4>
    <pre>
  test('test-1', function(){
    expect(null).toBeNull()  
    
    expect(NaN).toBeNaN()
    
    expect(undefined).toBeUndefined()
    expect('').toBeDefined()                                                           // any value which is not undefined 
    
    expect(1).toBeTruthy()
    expect(0).toBeFalsy()
  })
  </pre>
    <hr>
    <!------------------------------------------------------------------------------------------------------>
    <h4 style="color:darkblue;"><u> <mark>toBeGreaterThan()</mark> / <mark>toBeGreaterThanOrEqual()</mark> / <mark>toBeLessThan()</mark> / <mark>toBeLessThanOrEqual()</mark> / <mark>toBeCloseTo()</mark> TEST </u></h4>
    <pre>
  test('test-1', function(){
    expect(5).toBeGreaterThan(3)  
    expect(5).toBeGreaterThanOrEqual(3)  
    expect(5).toBeGreaterThanOrEqual(5)  
    
    expect(5).toBeLessThan(7)
    expect(5).toBeLessThanOrEqual(7)
    expect(5).toBeLessThanOrEqual(5)
    
    expect(0.1 + 0.2).toBeCloseTo(0.3)                                                 // for double floating comparison 
  })
  </pre>
    <hr>
    <!------------------------------------------------------------------------------------------------------>
    <h4 style="color:darkblue;"><u> <mark>toMatch()</mark> / <mark>toMatchObject()</mark> TEST </u></h4>
    <pre>
// toMatch() --------------------------------------------------------------------------
  test('test-1', function(){
    expect('some test').toMatch('some test')
    expect('some test').toMatch(/SOME TEST/i)                                          // also accepts regular expressions  
  })
  
// toMatchObject() --------------------------------------------------------------------
  test('test-2', function(){
    expect({p1:21, p2:{a:1, b:2}, p3:{nest1:111, nest2:222, nest3:['str']}}).toMatchObject({p1:21})
    
    expect({p1:21, p2:{a:1, b:2}, p3:{nest1:111, nest2:222, nest3:['str']}}).toMatchObject({p2:{b:2}})
    
    expect({p1:21, p2:{a:1, b:2}, p3:{nest1:111, nest2:222, nest3:['str']}}).toMatchObject({p3:{nest2:222}})
  })
  
  test('test-3', function(){
    expect({p1:[1, 2, 3]}).toMatchObject({p1:[1, 2]})                                  // test fails (this matcher works with nested objects only) 
  })
  
  test('test-4', function(){
    expect({p1:[1, 2, 3]}).toMatchObject({p1:[1, 2, 3]})                               // test passes (the nested item has the same structure as in the expected object) 
  })
  </pre>
    <hr>
    <!------------------------------------------------------------------------------------------------------>
    <h4 style="color:darkblue;"><u> <mark>toHaveLength()</mark> / <mark>toContain()</mark> / <mark>toContainEqual()</mark> TEST </u></h4>
    <pre>
// toHaveLength() ---------------------------------------------------------------------
  test('test-1', function(){
    expect([1, 2, 3]).toHaveLength(3)
    
    expect('some string').toHaveLength(11)
  })
  
// toContain() ------------------------------------------------------------------------
  test('test-2', function(){
    expect([1, 2, 3]).toContain(2)
    
    expect(['egy', 'ketto', 'harom']).toContain('ketto')
    
    expect('some string').toContain(' ')
  })
  
// toContainEqual() -------------------------------------------------------------------
  test('test-3', function(){
    expect([{p1:21, p2:22}, {nest:[1, 2]}, {p3:33}]).toContainEqual({p3:33})
    
    expect([{p1:21, p2:22}, {nest:[1, 2]}, {p3:33}]).toContainEqual({nest:[1, 2]})
    
    expect([{p1:21, p2:22}, {nest:[1, 2]}, {p3:33}]).toContainEqual({p1:21, p2:22})
  })
  
  test('test-4', function(){
    expect([{p1:21, p2:22}, {nest:[1, 2]}, {p3:33}]).toContainEqual({p1:21})           // test fails the array item must have a specific structure 
  })
  
  test('test-5', function(){
    expect({p1:21, p2:22, p3:[1, 2]}).toContainEqual({p2:22})                          // test fails this matcher expects an Array 
  })
  </pre>
    <hr>
    <!------------------------------------------------------------------------------------------------------>
    <h4 style="color:darkblue;"><u> <mark>toHaveProperty()</mark> / <mark>toBeInstanceOf()</mark> TEST </u></h4>
    <pre>
  // toHaveProperty() ---------------------------------------------------------
  test('test-1', function(){
    expect({p1:21, p2:{n1:33}}).toHaveProperty('p1')
    expect({p1:21, p2:{n1:33}}).toHaveProperty('p2.n1')
    expect({p1:21, p2:{n1:33, n2:{d1:true}}}).toHaveProperty('p2.n2.d1')
  })
  
// toBeInstanceOf() ---------------------------------------------------------
  test('test-2', function(){
    expect({p1:21}).toBeInstanceOf(Object)
    expect([1, 2]).toBeInstanceOf(Array)
    
    class SomeClass {}
    let myInstance = new SomeClass()
    
    expect(myInstance).toBeInstanceOf(SomeClass)
  })
  </pre>
  </details>
  <hr>
  <!------------------------------------------------------------------------------------------------------>
  <h2 style="color:darkblue;"><u> Fake Timers <mark>useFakeTimers()</mark> / <mark>useRealTimers()</mark> / <mark>runAllTimers()</mark> / <mark>advanceTimersByTime()</mark> / <mark>advanceTimeToNextTimer()</mark> / <mark>runOnlyPendingTimers()</mark> / <mark>runAllTicks()</mark> / <mark>getTimerCount()</mark> / <mark>clearAllTimers()</mark> / <mark>setSystemTime()</mark> / <mark>getRealSystemTime()</mark> </u></h2>
  <p> - Testing timers are not ideal because they rely on real time to be elapsed, Jest allows us to use 'fake' (virtual time) </p>
  <p> - <u>real timers cannot be tested in Jest</u> </p>
  <p> - with fake timers we can control a virtual time so the behaviour of <mark>setTimeout</mark> / <mark>setInterval</mark> / <mark>setImmediate</mark> (timers), <mark>process.nextTick</mark> (exhaust the callback queue) and <mark>Date</mark> (system time) can be controled </p>
  <p> - unfortunately <mark>Date</mark> instances don't track the virtually elapsed time! They only show the virtual time at the moment when they are created </p>
  <details class="example">
    <summary> DEMO </summary>
    <p> - <mark>useFakeTimers()</mark> / <mark>useRealTimers()</mark> </p>
    <pre>
  test('some test', () => {
    jest.useFakeTimers();                                                              // allows to use 'fake' virtual time in Jest (the virtual time is not elapsing when this function is called)    
    
    setTimeout(() => console.log( 'timed out!' ), 1500);
    setInterval(() => console.log( 'intervaled out!' ), 5500);
    setImmediate(() => console.log( 'intervaled out!' ), 10000);
    process.nextTick( ()=> console.log('next tiked out!') );
  })
  
  test('some other test', () => {
    jest.useRealTimers();                                                              // prevents jest from using fake timers 
    
    // setInterval(() => console.log( 'intervaled out!' ), 5500);                      // -! would throw an error -> virutal time is disabled 
  })
  </pre>
    <p> - <mark>runAllTimers()</mark> / <mark>advanceTimersByTime()</mark> / <mark>advanceTimersToNextTimer()</mark> / <mark>runOnlyPendingTimers()</mark> / <mark>runAllTicks()</mark> / <mark>getTimerCount()</mark> / <mark>clearAllTimers()</mark> </p>
    <pre>
  jest.useFakeTimers();
  
  const promiseTimer = new Promise(function(res, rej){
    setTimeout(() => { res('promise timeout!') }, 5000);
  })
  
// runAllTimers() ---------------------------------------------------------------------
  test('some test', () => {
    setTimeout(() => console.log( 'time out!' ), 1500);                                // elapsed   
    setImmediate(() => console.log( 'immediate out!' ));                               // elapsed 
    
    process.nextTick( ()=> console.log('next tik-1 out!') );                           // elapsed 
    promiseTimer.then((res) => console.log(res) );                                     // elapsed 
    
    setTimeout(() => {
      setTimeout(() => console.log( 'nested timeout'), 10000);                         // elapsed (nested timers are also elapsed)
    }, 10000)
    
    jest.runAllTimers();                                                               // exhausts all timers (the virtual time is advanced by 20000 in this case)    
  
  // --------------------------------------------------
    setInterval(() => console.log( 'interval' ), 1000);                                // -! will run infinitely
    jest.runAllTimers();                                                               // because the each intervaltimer cycle calls anodther cycle   
  })  
  
  
// advanceTimersBy() ------------------------------------------------------------------
  test('some test', () => {
    setTimeout(() => console.log( 'time out!' ), 1500);                                // elapsed 
    setTimeout(() => console.log( 'time out!' ), 9500);                                // not elapsed 
    setImmediate(() => console.log( 'immediate out!' ));                               // elapsed 
    setInterval(() => console.log( 'interval' ), 1000);                                // elapsed 5 times 
    setInterval(() => console.log( 'interval' ), 6000);                                // not elapsed 
    
    process.nextTick( ()=> console.log('next tik!') );                                 // elapsed 
    promiseTimer.then((res) => console.log(res) );                                     // elapsed 
    
    setTimeout(() => {                                                                 // elapsed  
      setTimeout(() => console.log( 'nested timeout'), 4000);                          // not elapsed (nested timer)    
    }, 4000)
    
    jest.advanceTimersBy();                                                            // advances the virtual time by 5000 ms 
  })  
  
  
// advanceTimersToNextTimer() ---------------------------------------------------------
  test('some test', () => {
    setTimeout(() => console.log( 'time out!' ), 1500);                                // not elapsed 
    setImmediate(() => console.log( 'immediate out!' ));                               // elapsed 
    setInterval(() => console.log( 'interval' ), 1000);                                // not elapsed 
    
    process.nextTick( ()=> console.log('next tik!') );                                 // elapsed 
    promiseTimer.then((res) => console.log(res) );                                     // not elapsed 
    
    setTimeout(() => {                                                                 // not elapsed  
      setTimeout(() => console.log( 'nested timeout'), 4000);                          // not elapsed (nested timer)    
    }, 4000)
    
    jest.advanceTimersToNextTimer();                                                   // elapses the virtual time until the shortes scheduled timer is elapsed (0 ms in this situation)     
    
  // --------------------------------------------------
    setInterval(() => console.log( 'interval' ), 1000);                                // elapsed once (only the first cycle length is taken)   
    jest.advanceTimersToNextTimer();                                                   // advances the virtual time by 1000 ms
  
  // --------------------------------------------------
    setInterval(() => console.log( 'interval' ), 1000);                                // elapsed 2 times 
    setTimeout(() => console.log( 'time out!' ), 1500);                                // elapsed 
    setTimeout(() => console.log( 'time out!' ), 2500);                                // not elapsed 
    
    jest.advanceTimersToNextTimer(2);                                                  // advances the virtual time by 2 interval cycle length (2000 ms in this situation)
  })  
  
  
// runOnlyPendingTimers() -------------------------------------------------------------
  test('some test', () => {
    setTimeout(() => console.log( 'time out!' ), 1500);                                // elapsed 
    setImmediate(() => console.log( 'immediate out!' ));                               // elapsed 
    setInterval(() => console.log( 'interval' ), 1000);                                // elapsed 5 times 
    
    process.nextTick( ()=> console.log('next tik!') );                                 // elapsed 
    promiseTimer.then((res) => console.log(res) );                                     // elapsed 
    
    setTimeout(() => {                                                                 // elapsed  
      setTimeout(() => console.log( 'nested timeout'), 4000);                          // not elapsed (nested timer not elapsed because it was not scheduled when 'jest.runOnlyPendingTimers()' was called)   
    }, 4000)
    
    jest.runOnlyPendingTimers();                                                       // elapses the virtual time until the longes scheduled timer is elapsed (5000 ms in this situation)   
    
  // --------------------------------------------------
    setInterval(() => console.log( 'interval' ), 6000);                                // elapsed once (only the first cycle length is taken)   
    jest.runOnlyPendingTimers();                                                       // advances the virtual time by 6000 ms in this situation   
  }) 
  
  
// runAllTicks() ----------------------------------------------------------------------
  test('some test', () => {
    setTimeout(() => console.log( 'time out!' ), 1500);                                // not elapsed 
    setImmediate(() => console.log( 'immediate out!' ));                               // not elapsed 
    setInterval(() => console.log( 'interval' ), 1000);                                // not elapsed 
    
    process.nextTick( ()=> console.log('next tik!') );                                 // elapsed 
    promiseTimer.then((res) => console.log(res) );                                     // not elapsed 
    
    setTimeout(() => {                                                                 // not elapsed  
      setTimeout(() => console.log( 'nested timeout'), 4000);                          // not elapsed (nested timer)   
    }, 4000)
    
    jest.runAllTicks();                                                                // runs functions scheduled by process.nextTick() 
  }) 
  
  
// getTimerCount() / clearAllTimers() -------------------------------------------------
  test('some test', () => {
    setTimeout(() => console.log( 'time out!' ), 1500); 
    setImmediate(() => console.log( 'immediate out!' )); 
    setInterval(() => console.log( 'interval' ), 1000); 
    
    process.nextTick( ()=> console.log('next tik!') ); 
    promiseTimer.then((res) => console.log(res) ); 
    
    setTimeout(() => { 
      setTimeout(() => console.log( 'nested timeout'), 4000);                          // not scheduled when 'jest.getTimerCount()' is called (nested timer)    
    }, 4000)
    
    jest.getTimerCount();                                                              // -> 6
    
    jest.clearAllTimers();                                                             // removes all pending timers from the system   
    jest.getTimerCount();                                                              // -> 0
    
    jest.runAllTimers();                                                               // does nothing because there isn't any pending timer in the system anymore     
  }) 
  </pre>
    <p> - <mark>setSystemTime()</mark> / <mark>getRealSystemTime()</mark> </p>
    <pre>
  jest.useFakeTimers();
  
  test('some test', () => {
    const virtualTime = new Date(); 
    virtualTime.getFullYear();                                                         // -> 2021     
    
    jest.setSystemTime(0);                                                             // setting the virtual time to 0 time (1970)   
    
    const virtualTime2 = new Date(); 
    virtualTime2.getFullYear();                                                        // -> 1970
    virtualTime.getFullYear();                                                         // -> 2021            // -! Date instances don't track the virtual time :/    
    
    Date.now();                                                                        // -> 0               // current virtual time 
    jest.getRealSystemTime();                                                          // -> 1630741044868   // real current time 
  })
  
  test('some test', () => {
    setTimeout(() => console.log('timed out!'), 1000);                                 // not elapsed 
    process.nextTick(() => console.log( 'next tick') );                                // not elapsed 
    
    jest.setSystemTime(2000000000000);                                                 // advancing the virtual time by using this function does not trigger any timers   
  })
  </pre>
  </details>
  <details class="example">
    <summary> Example: </summary>
    <h4 style="color:darkblue;"><u> <mark>jest.useFakeTimers()</mark> / <mark>jest.useRealTimers()</mark> TEST </u></h4>
    <pre>
  test('some test', () => {
    setTimeout(() => console.log( 'timed out!' ), 1500);
    setInterval(() => console.log( 'intervaled out!' ), 5500);
    setImmediate(() => console.log( 'intervaled out!' ), 10000);
    process.nextTick( ()=> console.log('next tiked out!') );
  })
  
  // -! jest.useFakeTimers() calls are hoisted!  
  jest.useFakeTimers();                                                                // allows to use 'fake' virtual time (the virtual time is not elapsing)
  </pre>
    <pre>
  test('some test', () => {
    setTimeout(() => console.log( 'timed out!' ), 1500);
    setInterval(() => console.log( 'intervaled out!' ), 5500);
    setImmediate(() => console.log( 'intervaled out!' ), 10000);
    process.nextTick( ()=> console.log('next tiked out!') );
  })
  
  // -! jest.useFakeTimers() and jest.useRealTimers() calls are hoisted!  
  jest.useFakeTimers(); 
  jest.useRealTimers();                                                                // prevents jest from using fake timers 
  </pre>
    <hr>
    <!----------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> <mark>jest.runAllTimers()</mark> / <mark>jest.runAllTicks()</mark> TEST </u></h4>
    <pre>
  jest.useFakeTimers();
  
  const testTimer = new Promise(function(res, rej){
    setTimeout(function(){
      res('promise timeout!')
    }, 5000);
  })
  
  test('some test', () => {
    setTimeout(() => console.log( 'time out!' ), 1500);                                // exhausted   
    // setInterval(() => console.log( 'interval out!' ), 5500);                        // -! jest.runAllTimers() starts the virtual time but never ends is so intervalled timers would run endlessly   
    setImmediate(() => console.log( 'immediate out!' ));                               // exhausted 
    
    process.nextTick( ()=> console.log('next tik-1 out!') );                           // exhausted 
    process.nextTick( ()=> console.log('next tik-2 out!') );                           // exhausted 
    testTimer.then((res) => console.log(res) );                                        // exhausted 
    
    setTimeout(() => {
      setTimeout(() => console.log( 'nested timeout'), 10000);                         // exhausted (nested chain scheduled tasks are also exhausted)
    }, 10000)
    
    jest.runAllTimers();                                                               // exhaust all virtualy scheduled tasks (starts the virutal timer but nerver end it)
  })
  
  test('some test', () => {
    setTimeout(() => console.log( 'time out!' ), 1500); 
    setInterval(() => console.log( 'interval out!' ), 5500); 
    setImmediate(() => console.log( 'immediate out!' )); 
    
    process.nextTick( ()=> console.log('next tik-1 out!') );                           // exhausted 
    process.nextTick( ()=> console.log('next tik-2 out!') );                           // exhausted 
    testTimer.then((res) => console.log(res) ); 
    
    jest.runAllTicks();                                                                // only exhaust process.nextTick() scheduled callbacks 
  })
  </pre>
    <hr>
    <!----------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> <mark>jest.advanceTimersByTime()</mark> / <mark>jest.advanceTimersToNextTimer()</mark> / <mark>jest.runOnlyPendingTimers()</mark> TEST </u></h4>
    <pre>
  jest.useFakeTimers();
  
  const testTimer = new Promise(function(res, rej){
    setTimeout(function(){
      res('promise timeout!')
    }, 5000);
  })
  
// advanceTimersByTime() --------------------------------------------------------------
  test('some test', () => {
    setTimeout(() => console.log( 'time out!' ), 1500);                                // elapsed 
    setTimeout(() => console.log( 'time out!' ), 5500);                                // not elapsed 
    setInterval(() => console.log( 'interval out!' ), 1500);                           // elapsed 3 times 
    setImmediate(() => console.log( 'immediate out!' ));                               // elapsed 
    
    process.nextTick( ()=> console.log('next tik-1 out!') );                           // elapsed 
    process.nextTick( ()=> console.log('next tik-2 out!') );                           // elapsed 
    testTimer.then((res) => console.log(res) );                                        // elapsed 
    
    jest.advanceTimersByTime(5000);                                                    // advances the virtual time by 5 seconds (then stops it)  
  
  // ---------------------------------------------
    setInterval(() => console.log( 'interval out!' ), 100);                            // elapsed 10 times 
    setTimeout(() => console.log( 'time out!' ), 1001);                                // not elapsed 
    
    jest.advanceTimersByTime(1000);
  })
  
  
// advanceTimersToNextTimer() ---------------------------------------------------------
  test('some test', () => {
    setTimeout(() => console.log( 'time out!' ), 1500);                                // elapsed 
    setTimeout(() => console.log( 'time out!' ), 5500);                                // not elapsed 
    setInterval(() => console.log( 'interval out!' ), 1500);                           // elapsed once 
    
    testTimer.then((res) => console.log(res) );                                        // not elapsed 
    
    jest.advanceTimersToNextTimer();                                                   // advances the virtual time till the next timer is scheduled (then stops it)
                                                                                       // in this situation advances the time by 1500 (takes the shortest pending timer)
  
  // ---------------------------------------------
    setInterval(() => console.log( 'interval out!' ), 500);                            // elapsed once (shortest pending timer)
    testTimer.then((res) => console.log(res) );                                        // not elapsed 
    
    jest.advanceTimersToNextTimer();                                                   // advances the time by 500 ms 
  
  // ---------------------------------------------
    setInterval(() => console.count( 'interval out!' ), 5500);                         // not elapsed  
    testTimer.then((res) => console.log(res) );                                        // elapsed 
    
    jest.advanceTimersToNextTimer();                                                   // advances the time by 5500 ms 
  })
  
  
// runOnlyPendingTimers() -------------------------------------------------------------
  test('some test', () => {
    setTimeout(() => console.log( 'time out!' ), 1500);                                // elapsed 
    setTimeout(() => console.log( 'time out!' ), 5500);                                // elapsed 
    setInterval(() => console.count( 'interval out!' ), 1500);                         // elapsed 3 times because   
    setImmediate(() => console.log( 'immediate out!' ));                               // elapsed 
    
    process.nextTick( ()=> console.log('next tik-1 out!') );                           // elapsed 
    process.nextTick( ()=> console.log('next tik-2 out!') );                           // elapsed 
    testTimer.then((res) => console.log(res) );                                        // elapsed 
    
    setTimeout(() => {                                                                 // elapsed 
      console.log( 'timed out!' );
      setTimeout(() => console.log('nested timeout'), 4000);                           // nested timer is not elapsed because it was not pending when 'jest.runOnlyPendingtimers()' was called    
    }, 5000)
    
    jest.runOnlyPendingTimers();                                                       // in this situation advances the virtual time by 5500 ms because it takes the longest pending timer 
  
  // ---------------------------------------------
    setInterval(() => console.count( 'interval out!' ), 500);                          // elapsed 1 time 
    
    jest.runOnlyPendingTimers();                                                       // in this situation advances the virtual time by 5000 ms    
  
  // ---------------------------------------------
    setInterval(() => console.count( 'interval out!' ), 5100);                         // elapsed 1 time 
    
    jest.runOnlyPendingTimers();                                                       // in this situation advances the virtual time by 5100 ms    
  })
  </pre>
    <hr>
    <!----------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> <mark>jest.advanceTimersToNextTimer()</mark> steps TEST </u></h4>
    <pre>
  jest.useFakeTimers();
  
  test('some test', () => {
    setInterval(() => console.count('interval'), 100);                                 // elapses 11 times 
    setTimeout(() => console.count('timeout'), 500)                                    // elapses 
    
    jest.advanceTimersToNextTimer(11);                                                 // setInterval will take 11 cycles 
  })
  
  test('some test', () => {
    setInterval(() => console.count('interval'), 100);                                 // elapses 2 times 
    setTimeout(() => console.count('timeout'), 500)                                    // not elapses 
    
    jest.advanceTimersToNextTimer(2);                                                  // setInterval will take 2 cycles 
  })
  </pre>
    <hr>
    <!----------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> <mark>jest.getTimerCount()</mark> / <mark>jest.clearAllTimers()</mark> TEST </u></h4>
    <pre>
  jest.useFakeTimers();
  
  const testTimer = new Promise(function(res, rej){
      setTimeout(function(){
        res('promise timeout!')
      }, 5000);
    })
  
  test('some test', () => {
    setTimeout(() => console.log( 'time out!' ), 5500);
    setInterval(() => console.log( 'interval out!' ), 1500);
    setImmediate(() => console.log( 'immediate out!' ));
    
    process.nextTick( ()=> console.log('next tik-1 out!') ); 
    testTimer.then((res) => console.log(res) );              
    
    console.log( jest.getTimerCount() );                                               // -> 5   // number of pending timers   
    
    jest.clearAllTimers();                                                             // clears all pending timers 
    console.log( jest.getTimerCount() );                                               // -> 0  
    
    jest.runAllTimers();                                                               // doesn't do anything because there's no pending timer    
  })
  </pre>
    <hr>
    <!----------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> <mark>Date</mark> instances don't track the virtually elapsed time TEST </u></h4>
    <pre>
  jest.useFakeTimers();

  test('some test', () => {
    const virtualTime = new Date();                                                    // virtual time (which shows the current time since the virtual time was not modified)   
    console.log( virtualTime.getHours() );                                             // -> 8     
    console.log( virtualTime.getMinutes() );                                           // -> 4     
    
    jest.advanceTimersByTime(4200000);                                                 // the virtual time was advanced by 1 hour and 10 minutes   
    
    console.log( virtualTime.getHours() );                                             // -> 8     // -! the virtually elapsed time is not tracked by Date instances  
    console.log( virtualTime.getMinutes() );                                           // -> 4  
    
    const virtualTime2 = new Date();                                                   // a new Date instance shows the current virtual time 
    console.log( virtualTime2.getHours() );                                            // -> 9      
    console.log( virtualTime2.getMinutes() );                                          // -> 14   
  })
  </pre>
    <!----------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> <mark>jest.setSystemTime()</mark> / <mark>jest.getRealSystemTime()</mark> TEST </u></h4>
    <pre>
  jest.useFakeTimers();
  
  test('some test', () => {
// setSystemTime() --------------------------------------------------------------------
    const virtualTime = new Date(); 
    console.log( virtualTime.getFullYear() );                                          // -> 2021     
    
    jest.setSystemTime(0);                                                             // setting the virtual time to 0 time (1970)   
    
    const virtualTime2 = new Date(); 
    console.log( virtualTime2.getFullYear() );                                         // -> 1970
    
// getRealSystemTime() ----------------------------------------------------------------
    console.log( Date.now() );                                                         // -> 0               // current virtual time 
    console.log( jest.getRealSystemTime() );                                           // -> 1630741044868   // real current time 
  })
  
  test('some test', () => {
    setTimeout(() => console.log('timed out!'), 1000);                                 // not elapsed 
    process.nextTick(() => console.log( 'next tick') );                                // not elapsed 
    
    jest.setSystemTime(2630741044868);                                                 // the modified virtual time by this function does not trigger any timers  
  })
  </pre>
  </details>



  <br><br>
</body>

</html>