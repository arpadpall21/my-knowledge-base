<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title> Zod </title>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../../Assets/stylesPages.css">
    <script src="../../../Assets/scriptPages.js"></script>
  </head>

  <body>
    <h1> Zod </h1>
    <p> Updated ( 2025-01-30 ) </p>
    <nav class="sitenav">
      <a href="../../../index.html">MySite > </a>
      <a href="../../index.html">Node.js > </a> Zod
    </nav>
    <p class="subSite"><a href="./Server Request Validation/index.html"> Server Request validation > </a></p>
    <table class="table">
      <caption> Data Type Validation </caption>
      <tr>
        <th style="width:30%;"> Type </th>
        <th> Description </th>
      </tr>
      <tr>
        <td>
          union
        </td>
        <td>
          - <a href="https://zod.dev/?id=unions" target="_blank">[link]</a> unions are very useful to describe multiple possbile types
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2"> primitive types </td>
      </tr>
      <tr>
        <td>
          string
        </td>
        <td>
          - <a href="https://zod.dev/?id=strings" target="_blank">[link]</a> strings have a bunch of useful types, (like: email, date, time, url, etc...)
        </td>
      </tr>
      <tr>
        <td>
          number
        </td>
        <td>
          - <a href="https://zod.dev/?id=numbers" target="_blank">[link] </a>
        </td>
      </tr>
      <tr>
        <td>
          BigInt
        </td>
        <td>
          - <a href="https://zod.dev/?id=bigints" target="_blank">[link] </a>
        </td>
      </tr>
      <tr>
        <td>
          boolean
        </td>
        <td>
          - <a href="https://zod.dev/?id=booleans" target="_blank">[link] </a>
        </td>
      </tr>
      <tr>
        <td>
          NaN
        </td>
        <td>
          - <a href="https://zod.dev/?id=nans" target="_blank">[link] </a>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          literal
        </td>
        <td>
          - <a href="https://zod.dev/?id=literals" target="_blank">[link]</a> literal value
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2"> complex types </td>
      </tr>
      <tr>
        <td>
          object
        </td>
        <td>
          - <a href="https://zod.dev/?id=objects" target="_blank">[link]</a> object have a bunch of utility methods
        </td>
      </tr>
      <tr>
        <td>
          Array
        </td>
        <td>
          - <a href="https://zod.dev/?id=arrays" target="_blank">[link] </a>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          Map
        </td>
        <td>
          - <a href="https://zod.dev/?id=maps" target="_blank">[link]</a>
        </td>
      </tr>
      <tr>
        <td>
          Set
        </td>
        <td>
          - <a href="https://zod.dev/?id=sets" target="_blank">[link]</a>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          Enum
        </td>
        <td>
          - <a href="https://zod.dev/?id=native-enums" target="_blank">[link]</a> (native enum = TypeScrypt Enum)
        </td>
      </tr>
      <tr>
        <td>
          tuple
        </td>
        <td>
          - <a href="https://zod.dev/?id=tuples" target="_blank">[link] </a>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          Date
        </td>
        <td>
          - <a href="https://zod.dev/?id=dates-1" target="_blank">[link] </a>
        </td>
      </tr>
    </table>
    <br>
    <details class="example" id="notes">
      <summary> Notes & Tips :</summary>
      <!-- <p> - paragraph removes the 'empty' message from the detail TAG -->
    </details>
    <h2 class="headerSection"> Useful Links : </h2>

    <h2 class="headerSection"> Remember This : </h2>
    <p> - in case of objects we can send through additional keys, the schema will remove extra data sliently (like FastAPI validation does) </p>
    <h2 class="headerSection"> Description and Demonstration : </h2>
    <p> - Zod is a data validation library, we create scheams that describe the data validation 'shema' </p>
    <p> - requires Typescript v4.5, but also works in plain JavaScript [tested] </p>
    <p> - this thing is great for server data validation, and also can generate openApi json (that was the reason I choose it) </p>
    <pre class="syntax">
    import { z } from 'zod';
    
    const <reqval>zodSchema</reqval> = z.<reqval>shemaMethod</reqval>()<optval>...</optval>          // schema describes accepted data format
                                                                                                     // shema methods are chainable for fine grained validation (ex: <mark>z.string().optional().min(3)</mark>)
    
  // validation ------------------------
    <reqval>zodSchema</reqval>.parse(<reqval>data</reqval>)                       // (valid -> return <reqval>data</reqval>) (invalid -> throws a ZodError describing validation error) 
    <reqval>zodSchema</reqval>.safeParse(<reqval>data</reqval>)                   // (valid -> return <mark>{ success: true, data: <reqval>data</reqval> }</mark>) (invalid -> return <mark>{ success: false, data: <reqval>ZodError</reqval> }</mark>)
    
    <reqval>zodSchema</reqval>.parseAsync(<reqval>data</reqval>)                  // (valid -> promise resolves with <reqval>data</reqval>) (valid -> promise rejects with <reqval>ZodError</reqval>)
    <reqval>zodSchema</reqval>.safeParseAsync(<reqval>data</reqval>)              // (valid -> promise resolves with <mark>{ success: true, data: <reqval>data</reqval> }</mark>) (valid -> promise rejects with <mark>{ success: false, data: <reqval>ZodError</reqval> }</mark>)
    </pre>
    <details class="example">
      <summary> DEMO (can be pseudocode) </summary>
      <pre>
    import { z } from 'zod';
    
    const stringSchema = z.string();
    
    
    stringSchema.parse('Hello World!');         // -> 'Hello World!'
    stringSchema.parse(32n);                    // throws Zod error
    
    stringSchema.safeParse('Hello World');      // -> { success: true, data: 'Hello World' }
    stringSchema.safeParse(32n);                // -> { success: false, error: ZodError }
    
    
    stringSchema.parseAsync('Hello Wold!')            // resolves 
      .then((res) => console.log(res))                // -> 'Hello World!'
      .catch((e) => console.error(e));
    stringSchema.parseAsync(false)                    // rejects
      .then((res) => console.log(res))
      .catch((e) => console.error(e));                // -> { success: false, error: ZodError }
    
    stringSchema.safeParseAsync('Hello Wold!')        // resolves (never rejects)
      .then((res) => console.log(res))                // -> { success: true, data: 'Hello Wold!' }
    stringSchema.safeParseAsync(false)                // resolves (never rejects)
      .then((res) => console.log(res))                // -> { success: false, error: ZodError }
    </pre>
      <hr>
      <!------------------------------------------------------------------------------------------->
      <h4 class="header"> Fine Grained data validation </h4>
      <pre>
    import { z } from 'zod';
    
    const personSchema = z.object({
      name: z.string().min(3).max(15),
      age: z.number().min(1).max(100),
      email: z.string().email().optional(),           // optional
    })
    
    const person = personSchema.parse({               // -> { name: 'Pall', age: 39 }
      name: 'Pall',
      age: 39,
      email: 'a.pall21@yahoo.fr',
      sex: 'M'
    });
    const person2 = personSchema.parse({              // throws ZodError
      name: 'P',
      age: 139,
    });
    </pre>
      <hr>
      <!------------------------------------------------------------------------------------------->
      <h4 class="header"> Data Types </h4>
      <pre>
    import { z } from 'zod';
    
    
// optional & nullable --------------------
    const optionalStringSchema = z.string().optional();
    const nullableStringSchema = z.string().nullable();
    const nullishStringSchema = z.string().nullish();            // optional & nullable
    
    optionalStringSchema.parse('Hello World!');               // pass
    optionalStringSchema.parse(undefined);                    // pass
    optionalStringSchema.parse(false)                         // throws Zod error
    
    nullableStringSchema.parse('Hello World!');               // pass
    nullableStringSchema.parse(null);                          // pass
    nullableStringSchema.parse(false)                         // throws Zod error
    
    nullishStringSchema.parse(undefined);                              // pass
    nullishStringSchema.parse(null);                                   // pass
    
    
// primitives --------------------------------
    // literal -------------------------
    const twelveSchema = z.literal(12);
    
    twelveSchema.parse(12);                       // pass
    twelveSchema.parse(13);                       // throws a Zod validation error
    
    
    // string --------------------------
    const myStringSchema = z.string().min(3).max(15);
    
    myStringSchema.parse('Hello Wolrd');            // pass
    myStringSchema.parse('H');                      // throws a Zod validation error
    
    
    // number --------------------------
    const myNumberSchema = z.number().min(0).max(1000);
    
    myNumberSchema.parse(21);                         // pass
    myNumberSchema.parse(1001);                       // throws a Zod validation error
    
    
    // BigInt --------------------------
    const myBigIntSchema = z.bigint().min(0n).max(1000n);
    
    myBigIntSchema.parse(21n);                         // pass
    myBigIntSchema.parse(1001n);                       // throws a Zod validation error
    
    
    // NaN -----------------------------
    const myNanSchema = z.nan();
    
    myNanSchema.parse(NaN);                         // pass
    myNanSchema.parse(32);                          // throws a Zod validation error
    
    
    // boolean -------------------------
    const myBoolSchema = z.boolean();
    
    myBoolSchema.parse(false);                           // pass
    myBoolSchema.parse('not a boolean');                 // throws a Zod validation error
    
    
// object -------------------------------------
    const myObjSchema = z.object({
      name: z.string(),
      age: z.number().min(0),
      email: z.string().email(),
    });
    
    myObjSchema.parse({                       // pass
      name: 'Pall',
      age: 39,
      email: 'a.pall21@yahoo.fr'
    });
    myObjSchema.parse({                       // throws a Zod validation error
      name: 'Pall',
      age: 39,
      email: 'someMal'                        // invalid email
    });
    
    
// Array -------------------------------------
    const myArraySchema = z.string().array();                 // aray of strings
    const myArraySchema2 = z.array(z.string());               // same as above
    const myArraySchema3 = z.array(z.union([z.boolean(), z.number(), z.literal('e')]));      // accepts boolean, number or lteral 'e' members
    
    myArraySchema.parse(['one', 'two']);                      // all pass
    myArraySchema2.parse(['one', 'two']);
    myArraySchema3.parse([false, 3, 'e']);
    
    
// Map & Set -------------------------------------
    const myMapSchema = z.map(z.string(), z.number())
    const mySetSchema = z.set(z.string())
    
    myMapSchema.parse(new Map([['age', 21], ['score', 2]]));              // pass
    mySetSchema.parse(new Set(['Hello', 'World!']));                      // pass
    
    
// Date -------------------------------------
    const myDateSchema = z.date();
    
    myDateSchema.parse(new Date());                             // pass
    myDateSchema.parse('not a data');                           // throws a Zod validation error
    
    
// enum -------------------------------------
    enum Status {
      SUCCESS = 'success',
      FAIL = 'fail',
    }
    
    const myEnumSchema = z.nativeEnum(Status);
    
    myEnumSchema.parse(Status.SUCCESS);         // pass
    myEnumSchema.parse('fail');                 // also accept enum value
    
    myEnumSchema.parse('no enum member');         // throws a Zod validation error
    
    
// tuple -------------------------------------
    const myTuple = z.tuple([z.string(), z.string(), z.number()]);
    
    myTuple.parse(['Hello', 'World', 21])                 // pass
    
    
// union --------------------------------------
    const myUnionSchema = z.union([z.number(), z.boolean(), z.literal('x')])
    
    myUnionSchema.parse(23);                            // pass
    myUnionSchema.parse(false);                         // pass
    myUnionSchema.parse('x');                           // pass
    </pre>
    </details>
    <hr>
    <!-------------------------------------------------------------------------------------------------->
    <h2 class="header"> Primitive coercion and transform </h2>
    <p> - with coercion we basically transform the data type </p>
    <p> - transorm basically alter the end primitive going through the schema </p>
    <pre class="syntax">
    import { z } from 'zod';
    
    const <reqval>zodCoerceSchema</reqval> = z.coerce.<reqval>shemaMethod</reqval>()            // coerces the passed data into <reqval>shemaMethod</reqval> data type
    const <reqval>zodTransformSchema</reqval> = z.<reqval>shemaMethod</reqval>().transform(<reqval>fn(val)</reqval>)    // transforms the data to the callback return value (<reqval>fn(val)</reqval>)
    
    <reqval>zodCoerceSchema</reqval>.parse(<reqval>data</reqval>)                 // -> coerced <reqval>data</reqval>
    <reqval>zodCoerceSchema</reqval>.parse(<reqval>data</reqval>)                 // -> transformed <reqval>data</reqval>
    </pre>
    <details class="example">
      <summary> DEMO (can be pseudocode) </summary>
      <pre>
    import { z } from 'zod';
    
    const numberCoerceSchema = z.coerce.number();
    const nameSchema = z.string().transform((val) => val.charAt(0).toUpperCase() + val.slice(1));     // capitalizes the 1st letter of the string
    
    numberCoerceSchema.parse('3234');                 // -> 3234
    nameSchema.parse('justin');                       // -> 'Justin'
      </pre>
    </details>
    <hr>
    <!-------------------------------------------------------------------------------------------------->
    <h2 class="header"> Custom type and custom validation </h2>
    <p> - with both these approaches we can basically write our custom data validation logic </p>
    <pre class="syntax">
    import { z } from 'zod';
    
    const <reqval>customSchemaType</reqval> = z.custom(<reqval>fn(val)</reqval>)          // we can write our custom validation logic in <reqval>fn(val)</reqval> callback
    const <reqval>customSchemaType2</reqval> = z.<reqval>shemaMethod</reqval>().refine(<reqval>fn(val)</reqval>)     // same as above but we can do pre validation (we refine the validated data)
    
    <reqval>customSchemaType</reqval>.parse(<reqval>data</reqval>)
    <reqval>customSchemaType2</reqval>.parse(<reqval>data</reqval>)
    </pre>
    <details class="example">
      <summary> DEMO (can be pseudocode) </summary>
      <h4 class="header"> Custom Type </h4>
      <pre>
    import { z } from 'zod';
    
    const myPx = z.custom((val) => {
      return typeof val === "string" ? /^\d+px$/.test(val) : false;         // custom type logci
    });
    
    myPx.parse('32px');                 // pass
    myPx.parse('32vw');                 // throws ZodError
      </pre>
      <hr>
      <!-------------------------------------------------------------------------------->
      <h4 class="header"> Custom Validation </h4>
      <pre>
    import { z } from 'zod';
    
    const nameSchema = z.string().refine((v) => /^[A-Z].*/.test(v));     // custom validation logic
    
    nameSchema.parse('Pall')              // pass
    nameSchema.parse('pall')              // throws ZoeError
      </pre>
    </details>
    <hr>
    <!-------------------------------------------------------------------------------------------------->
    <h2 class="header"> Type Inference </h2>
    <p> - with type inference we can extract the TypeScript type from the Zod schema </p>
    <pre class="syntax">
    import { z } from 'zod';
    
    type <reqval>tsType</reqval> = z.infer&lt;typeof <reqval>zodSchema</reqval>&gt;;
    </pre>
    <details class="example">
      <summary> DEMO (can be pseudocode) </summary>
      <pre>
    import { z } from 'zod';
    
    const personSchema = z.object({
      name: z.string(),
      age: z.number().optional(),
    });
    
    type Person = z.infer&lt;typeof personSchema&gt;                  // TypeScript type extracted
    
    const person: Person = { name: 'Pall' };
    const person2: Person = { name: 'Pall', age: 39 };
    const person3: Person = { name: 'Pall', age: 39, sex: 'M' };          // invalid
    </pre>
    </details>
    <hr>
    <!-------------------------------------------------------------------------------------------------->
    <h2 class="header"> Custom Error Message </h2>
    <p> - we can write out custom error messages in zod validation methods (this is particularly useful if we don't wnat to expose errors to the client) </p>
    <pre>
    import { z } from 'zod';
    
    const myString = z
      .string({ message: 'not a string' })
      .min(3, { message: 'too short' })
      .max(13, { message: 'too long' })
    
    myString.parse(32)                                                // throws 'not a string'
    myString.parse('A')                                               // throws 'too short'
    myString.parse('this is a longer string that 13 characters')      // throws 'too long'
    </pre>

    <br><br>
  </body>

</html>