<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title> Zod </title>
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <link rel="stylesheet" href="../../../Assets/stylesPages.css">
  <script src="../../../Assets/scriptPages.js"></script>
</head>

<body>
  <h1> Zod </h1>
  <p> Updated ( 2025-01-30 ) </p>
  <nav class="sitenav">
    <a href="../../../index.html">MySite > </a>
    <a href="../../index.html">Node.js > </a> Zod
  </nav>

  <p class="subSite"><a href="./Server Request Validation & Open Api/index.html"> Server Request validation & Open Api
      support > </a></p>

  <table class="table">
    <tr>
      <th style="width:30%;"> Type </th>
      <th> Description </th>
    </tr>
    <tr>
      <td>
        union
      </td>
      <td>
        - <a href="https://zod.dev/?id=unions" target="_blank">[link]</a> unions are very useful to describe multiple
        possbile types
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td colspan="2"> primitive types </td>
    </tr>
    <tr>
      <td>
        string
      </td>
      <td>
        - <a href="https://zod.dev/?id=strings" target="_blank">[link]</a> strings have a bunch of useful types,
        (like: email, date, time, url, etc...)
      </td>
    </tr>
    <tr>
      <td>
        number
      </td>
      <td>
        - <a href="https://zod.dev/?id=numbers" target="_blank">[link] </a>
      </td>
    </tr>
    <tr>
      <td>
        BigInt
      </td>
      <td>
        - <a href="https://zod.dev/?id=bigints" target="_blank">[link] </a>
      </td>
    </tr>
    <tr>
      <td>
        boolean
      </td>
      <td>
        - <a href="https://zod.dev/?id=booleans" target="_blank">[link] </a>
      </td>
    </tr>
    <tr>
      <td>
        NaN
      </td>
      <td>
        - <a href="https://zod.dev/?id=nans" target="_blank">[link] </a>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        literal
      </td>
      <td>
        - <a href="https://zod.dev/?id=literals" target="_blank">[link]</a> literal value
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td colspan="2"> complex types </td>
    </tr>
    <tr>
      <td>
        object
      </td>
      <td>
        - <a href="https://zod.dev/?id=objects" target="_blank">[link]</a> object have a bunch of utility methods
      </td>
    </tr>
    <tr>
      <td>
        Array
      </td>
      <td>
        - <a href="https://zod.dev/?id=arrays" target="_blank">[link] </a>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        Map
      </td>
      <td>
        - <a href="https://zod.dev/?id=maps" target="_blank">[link]</a>
      </td>
    </tr>
    <tr>
      <td>
        Set
      </td>
      <td>
        - <a href="https://zod.dev/?id=sets" target="_blank">[link]</a>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        Enum
      </td>
      <td>
        - <a href="https://zod.dev/?id=native-enums" target="_blank">[link]</a> (native enum = TypeScrypt Enum)
      </td>
    </tr>
    <tr>
      <td>
        tuple
      </td>
      <td>
        - <a href="https://zod.dev/?id=tuples" target="_blank">[link] </a>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        Date
      </td>
      <td>
        - <a href="https://zod.dev/?id=dates-1" target="_blank">[link] </a>
      </td>
    </tr>
  </table>
  <br>
  <details class="example" id="notes">
    <summary> Notes & Tips :</summary>
    <!-- <p> - paragraph removes the 'empty' message from the detail TAG -->
  </details>
  <h2 style="color:green;"><u> Useful Links : </u></h2>

  <h2 style="color:green;"><u> Remember This : </u></h2>
  <p> - in case of objects we can send through additional keys, the schema will remove extra data sliently (like FastAPI validation does) </p>
  <h2 style="color:green;"><u> Description and Demonstration : </u></h2>
  <p> - Zod is a data validation library, we create scheams that describe the data validation 'shema' </p>
  <p> - requires Typescript v4.5, but also works in plain JavaScript [tested] </p>
  <p> - this thing is great for server data validation, and also can generate openApi json (that was the reason I
    choose it) </p>
  <pre class="syntax">
    import { z } from 'zod';
    
    const <reqval>zodSchema</reqval> = z.<reqval>shemaMethod</reqval>()<optval>...</optval>          // schema describes accepted data format
                                                                                                     // shema methods are chainable for fine grained validation (ex: <mark>z.string().optional().min(3)</mark>)
    
  // validation ------------------------
    <reqval>zodSchema</reqval>.parse(<reqval>data</reqval>)                       // (valid -> return <reqval>data</reqval>) (invalid -> throws a ZodError describing validation error) 
    <reqval>zodSchema</reqval>.safeParse(<reqval>data</reqval>)                   // (valid -> return <mark>{ success: true, data: <reqval>data</reqval> }</mark>) (invalid -> return <mark>{ success: false, data: <reqval>ZodError</reqval> }</mark>)
    
    <reqval>zodSchema</reqval>.parseAsync(<reqval>data</reqval>)                  // (valid -> promise resolves with <reqval>data</reqval>) (valid -> promise rejects with <reqval>ZodError</reqval>)
    <reqval>zodSchema</reqval>.safeParseAsync(<reqval>data</reqval>)              // (valid -> promise resolves with <mark>{ success: true, data: <reqval>data</reqval> }</mark>) (valid -> promise rejects with <mark>{ success: false, data: <reqval>ZodError</reqval> }</mark>)
    </pre>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <pre>
    import { z } from 'zod';
    
    const stringSchema = z.string();
    
    
    stringSchema.parse('Hello World!');         // -> 'Hello World!'
    stringSchema.parse(32n);                    // throws Zod error
    
    stringSchema.safeParse('Hello World');      // -> { success: true, data: 'Hello World' }
    stringSchema.safeParse(32n);                // -> { success: false, error: ZodError }
    
    
    stringSchema.parseAsync('Hello Wold!')            // resolves 
      .then((res) => console.log(res))                // -> 'Hello World!'
      .catch((e) => console.error(e));
    stringSchema.parseAsync(false)                    // rejects
      .then((res) => console.log(res))
      .catch((e) => console.error(e));                // -> { success: false, error: ZodError }
    
    stringSchema.safeParseAsync('Hello Wold!')        // resolves (never rejects)
      .then((res) => console.log(res))                // -> { success: true, data: 'Hello Wold!' }
    stringSchema.safeParseAsync(false)                // resolves (never rejects)
      .then((res) => console.log(res))                // -> { success: false, error: ZodError }
    </pre>
    <hr>
    <!------------------------------------------------------------------------------------------->
    <h4 class="header"> Fine Grained data validation </h4>
    <pre>
    import { z } from 'zod';
    
    const personSchema = z.object({
      name: z.string().min(3).max(15),
      age: z.number().min(1).max(100),
      email: z.string().email().optional(),           // optional
    })
    
    const person = personSchema.parse({               // -> { name: 'Pall', age: 39 }
      name: 'Pall',
      age: 39,
      email: 'a.pall21@yahoo.fr',
      sex: 'M'
    });
    const person2 = personSchema.parse({              // throws ZodError
      name: 'P',
      age: 139,
    });
    </pre>
    <hr>
    <!------------------------------------------------------------------------------------------->
    <h4 class="header"> Data Types </h4>
    <pre>
    import { z } from 'zod';
    
    
// optional & nullable --------------------
    const optionalStringSchema = z.string().optional();
    const nullableStringSchema = z.string().nullable();
    const nullishStringSchema = z.string().nullish();            // optional & nullable
    
    optionalStringSchema.parse('Hello World!');               // pass
    optionalStringSchema.parse(undefined);                    // pass
    optionalStringSchema.parse(false)                         // throws Zod error
    
    nullableStringSchema.parse('Hello World!');               // pass
    nullableStringSchema.parse(null);                          // pass
    nullableStringSchema.parse(false)                         // throws Zod error
    
    nullishStringSchema.parse(undefined);                              // pass
    nullishStringSchema.parse(null);                                   // pass
    
    
// primitives --------------------------------
    // literal -------------------------
    const twelveSchema = z.literal(12);
    
    twelveSchema.parse(12);                       // pass
    twelveSchema.parse(13);                       // throws a Zod validation error
    
    
    // string --------------------------
    const myStringSchema = z.string().min(3).max(15);
    
    myStringSchema.parse('Hello Wolrd');            // pass
    myStringSchema.parse('H');                      // throws a Zod validation error
    
    
    // number --------------------------
    const myNumberSchema = z.number().min(0).max(1000);
    
    myNumberSchema.parse(21);                         // pass
    myNumberSchema.parse(1001);                       // throws a Zod validation error
    
    
    // BigInt --------------------------
    const myBigIntSchema = z.bigint().min(0n).max(1000n);
    
    myBigIntSchema.parse(21n);                         // pass
    myBigIntSchema.parse(1001n);                       // throws a Zod validation error
    
    
    // NaN -----------------------------
    const myNanSchema = z.nan();
    
    myNanSchema.parse(NaN);                         // pass
    myNanSchema.parse(32);                          // throws a Zod validation error
    
    
    // boolean -------------------------
    const myBoolSchema = z.boolean();
    
    myBoolSchema.parse(false);                           // pass
    myBoolSchema.parse('not a boolean');                 // throws a Zod validation error
    
    
// object -------------------------------------
    const myObjSchema = z.object({
      name: z.string(),
      age: z.number().min(0),
      email: z.string().email(),
    });
    
    myObjSchema.parse({                       // pass
      name: 'Pall',
      age: 39,
      email: 'a.pall21@yahoo.fr'
    });
    myObjSchema.parse({                       // throws a Zod validation error
      name: 'Pall',
      age: 39,
      email: 'someMal'                        // invalid email
    });
    
    
// Array -------------------------------------
    const myArraySchema = z.string().array();                 // aray of strings
    const myArraySchema2 = z.array(z.string());               // same as above
    const myArraySchema3 = z.array(z.union([z.boolean(), z.number(), z.literal('e')]));      // accepts boolean, number or lteral 'e' members
    
    myArraySchema.parse(['one', 'two']);                      // all pass
    myArraySchema2.parse(['one', 'two']);
    myArraySchema3.parse([false, 3, 'e']);
    
    
// Map & Set -------------------------------------
    const myMapSchema = z.map(z.string(), z.number())
    const mySetSchema = z.set(z.string())
    
    myMapSchema.parse(new Map([['age', 21], ['score', 2]]));              // pass
    mySetSchema.parse(new Set(['Hello', 'World!']));                      // pass
    
    
// Date -------------------------------------
    const myDateSchema = z.date();
    
    myDateSchema.parse(new Date());                             // pass
    myDateSchema.parse('not a data');                           // throws a Zod validation error
    
    
// enum -------------------------------------
    enum Status {
      SUCCESS = 'success',
      FAIL = 'fail',
    }
    
    const myEnumSchema = z.nativeEnum(Status);
    
    myEnumSchema.parse(Status.SUCCESS);         // pass
    myEnumSchema.parse('fail');                 // also accept enum value
    
    myEnumSchema.parse('no enum member');         // throws a Zod validation error
    
    
// tuple -------------------------------------
    const myTuple = z.tuple([z.string(), z.string(), z.number()]);
    
    myTuple.parse(['Hello', 'World', 21])                 // pass
    
    
// union --------------------------------------
    const myUnionSchema = z.union([z.number(), z.boolean(), z.literal('x')])
    
    myUnionSchema.parse(23);                            // pass
    myUnionSchema.parse(false);                         // pass
    myUnionSchema.parse('x');                           // pass
    </pre>
  </details>
  <hr>
  <!-------------------------------------------------------------------------------------------------->
  <h3 class="header"> Primitive coercion and transform </h3>
  <p> - with coercion we basically transform the data type </p>
  <p> - transorm basically alter the end primitive going through the schema </p>
  <pre class="syntax">
    import { z } from 'zod';
    
    const <reqval>zodCoerceSchema</reqval> = z.coerce.<reqval>shemaMethod</reqval>()            // coerces the passed data into <reqval>shemaMethod</reqval> data type
    const <reqval>zodTransformSchema</reqval> = z.<reqval>shemaMethod</reqval>().transform(<reqval>fn(val)</reqval>)    // transforms the data to the callback return value (<reqval>fn(val)</reqval>)
    
    <reqval>zodCoerceSchema</reqval>.parse(<reqval>data</reqval>)                 // -> coerced <reqval>data</reqval>
    <reqval>zodCoerceSchema</reqval>.parse(<reqval>data</reqval>)                 // -> transformed <reqval>data</reqval>
    </pre>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <pre>
    import { z } from 'zod';
    
    const numberCoerceSchema = z.coerce.number();
    const nameSchema = z.string().transform((val) => val.charAt(0).toUpperCase() + val.slice(1));     // capitalizes the 1st letter of the string
    
    numberCoerceSchema.parse('3234');                 // -> 3234
    nameSchema.parse('justin');                       // -> 'Justin'
      </pre>
  </details>
  <hr>
  <!-------------------------------------------------------------------------------------------------->
  <h3 class="header"> Custom type and custom validation </h3>
  <p> - with both these approaches we can basically write our custom data validation logic </p>
  <pre class="syntax">
    import { z } from 'zod';
    
    const <reqval>customSchemaType</reqval> = z.custom(<reqval>fn(val)</reqval>)          // we can write our custom validation logic in <reqval>fn(val)</reqval> callback
    const <reqval>customSchemaType2</reqval> = z.<reqval>shemaMethod</reqval>().refine(<reqval>fn(val)</reqval>)     // same as above but we can do pre validation (we refine the validated data)
    
    <reqval>customSchemaType</reqval>.parse(<reqval>data</reqval>)
    <reqval>customSchemaType2</reqval>.parse(<reqval>data</reqval>)
    </pre>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <h4 class="header"> Custom Type </h4>
    <pre>
    import { z } from 'zod';
    
    const myPx = z.custom((val) => {
      return typeof val === "string" ? /^\d+px$/.test(val) : false;         // custom type logci
    });
    
    myPx.parse('32px');                 // pass
    myPx.parse('32vw');                 // throws ZodError
      </pre>
    <hr>
    <!-------------------------------------------------------------------------------->
    <h4 class="header"> Custom Validation </h4>
    <pre>
    import { z } from 'zod';
    
    const nameSchema = z.string().refine((v) => /^[A-Z].*/.test(v));     // custom validation logic
    
    nameSchema.parse('Pall')              // pass
    nameSchema.parse('pall')              // throws ZoeError
      </pre>
  </details>
  <hr>
  <!-------------------------------------------------------------------------------------------------->
  <h3 class="header"> Type Inference </h3>
  <p> - with type inference we can extract the TypeScript type from the Zod schema </p>
  <pre class="syntax">
    import { z } from 'zod';
    
    type <reqval>tsType</reqval> = z.infer&lt;typeof <reqval>zodSchema</reqval>&gt;;
    </pre>
  <details class="example">
    <summary> DEMO (can be pseudocode) </summary>
    <pre>
    import { z } from 'zod';
    
    const personSchema = z.object({
      name: z.string(),
      age: z.number().optional(),
    });
    
    type Person = z.infer&lt;typeof personSchema&gt;                  // TypeScript type extracted
    
    const person: Person = { name: 'Pall' };
    const person2: Person = { name: 'Pall', age: 39 };
    const person3: Person = { name: 'Pall', age: 39, sex: 'M' };          // invalid
    </pre>
  </details>
  <hr>
  <!-------------------------------------------------------------------------------------------------->
  <h3 class="header"> Custom Error Message </h3>
  <p> - we can write out custom error messages in zod validation methods (this is particularly useful if we don't wnat to expose errors to the client) </p>
  <pre>
    import { z } from 'zod';
    
    const myString = z
      .string({ message: 'not a string' })
      .min(3, { message: 'too short' })
      .max(13, { message: 'too long' })
    
    myString.parse(32)                                                // throws 'not a string'
    myString.parse('A')                                               // throws 'too short'
    myString.parse('this is a longer string that 13 characters')      // throws 'too long'
    </pre>

  <br><br>
</body>

</html>