<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title> Compatibility API </title> 
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous"> 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../../Assets/stylesPages.css"> 
    <script src="../../../Assets/scriptPages.js"></script> 
</head>
<body>
<h1> Compatibility API (ver 3.4.1) </h1>
    <p> Updated ( 2020-06-13 )</p>
    <p class="sitenav"> <a href="../../../index.html">MySite></a>
        <a href="../../index.html">Node.js></a>  
        <a href="../index.html">HTTP/2></a> Compatibility API  
    </p>
<table class="table">
<caption> Http2ServerRequest (Compatibility API) </caption>
    <tr>
        <th style="width:30%;"> Method / Property </th>
        <th> Description </th>
    </tr>
    <tr>
        <td> <strong>h2SrvReq</strong> </td>
        <td> represents a received request (operates on top of a <strong>stream</strong>), extends the <mark>stream.Readable</mark> class
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvReq</strong>.aborted </td>
        <td> returns <mark>true</mark> if the request is aborted, otherwise returns <mark>false</mark> 
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvReq</strong>.authority </td>
        <td> returns the request authority pseudo header filed (same as <mark><strong>h2SrvReq</strong>.headers[':authority']</mark>)
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvReq</strong>.complete </td>
        <td> returns <mark>true</mark> if the request has been completed, aborted or destroyed, otherwise returns <mark>false</mark>   
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 12.10.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvReq</strong>.connection </td>
        <td> <u>[Deprecated since node v.13.0.0 use <mark>socket</mark> instead]</u> returns the underlying socket 
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td>
            <strong>h2SrvReq</strong>.destroy(<i class="openable">err<div>
                <p> - once underlying strem is destroyed it emits the <mark>error</mark> event with the passed error (<mark>close</mark> event not emitted in this case) </p>
            </div></i>) 
        </td>
        <td> immediately destroys the underlying <strong>stream</strong> (once the stream is destoryed it emits the <mark>close</mark> event)
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvReq</strong>.headers </td>
        <td> returns the received headers in a <strong>h2Headers</strong> object
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvReq</strong>.httpVersion </td>
        <td> returns the request http protocol version in a string
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvReq</strong>.method </td>
        <td> returns the request method in a string
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvReq</strong>.rawHeaders </td>
        <td> eturns the received raw headers (exactly as the message header was received) in an Array
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvReq</strong>.rawTrailers </td>
        <td> returns the received raw trailers (exactly as the message header was received) in an Array <u>(populated only in the <mark>end</mark> event)</u>
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvReq</strong>.scheme </td>
        <td> returns the request scheme pseudo header filed (same as <mark><strong>h2SrvReq</strong>.headers[':scheme']</mark>)
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td>  
            <strong>h2SrvReq</strong>.setTimeout(<strong>nr:ms</strong>, <i class="openable">fn<div>
                <p> - <mark>timeout</mark> listener callback on this <strong>stream</strong> </p>
            </div></i>)
        </td>
        <td> 
            - sets a counter (timeout) on the underlying <strong>stream</strong> (<mark>0</mark> = Infinity) <br>
            - the counter starts when the connection estabilished and restarts at every data trafic <br>
            - once the timer expires the <mark>timeout</mark> event is <span class="openable">emitted on the underlying socket<div> 
                <p> - the set <mark>timeout</mark> event can be listened on the underlying <strong>stream</strong> or <strong>h2SrvResp</strong> or <strong>h2SrvReq</strong> object </p>
            </div></span> (session not destoryed regardless the timeout event is listened or not) <br>
            - returns this <strong>h2SrvReq</strong> object 
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvReq</strong>.socket </td>
        <td> 
            returns an object that acts as a <mark>net.Socket</mark> or <mark>tls.Socket</mark> <span class="openable">but with limited socket functionalities<div>
                <p> - <mark>destroyed</mark> / <mark>readable</mark> / <mark>writable</mark> are retrieved from <mark><strong>h2SrvReq</strong>.stream</mark> </p>
                <p> - <mark>destroy</mark> / <mark>emit</mark> / <mark>end</mark> / <mark>on</mark> / <mark>once</mark> called on <mark><strong>h2SrvReq</strong>.stream</mark> </p>
                <p> - <mark>setTimeout</mark> called on <mark><strong>h2SrvReq</strong>.stream.session</mark> </p>
                <p> - <mark>pause</mark> / <mark>read</mark> / <mark>resume</mark> / <mark>write</mark> throws an error </p>
                <p> - all other interactions will be routed to the socket </p>
            </div></span>
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvReq</strong>.stream </td>
        <td> returns the underlying <strong>stream</strong> which backs the request
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvReq</strong>.trailers </td>
        <td> returns the received trailers in an object (not a <strong>h2Headers</strong> object) <u>(populated only in the <mark>end</mark> event)</u>
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvReq</strong>.url </td>
        <td> returns the request url in a string
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td colspan="2"> events </td>
    </tr>
    <tr>
        <td> <strong>h2SrvReq.listener</strong>('aborted', <strong>fn</strong>) </td>
        <td> emitted when the request is abnormally aborted in mid-communication
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvReq.listener</strong>('close', <strong>fn</strong>) </td>
        <td> emitted when the underlying <strong>stream</strong> is destroyed
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
</table>
    <br>
<table class="table">
<caption> Http2ServerResponse (Compatibility API) </caption>
    <tr>
        <th style="width:30%;"> Method / Property </th>
        <th> Description </th>
    </tr>
    <tr>
        <td> <strong>h2SrvResp</strong> </td>
        <td> represents the server response (operates on top o a <strong>stream</strong>), extends the <mark>Stream</mark> class   
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td>  
            <strong>h2SrvResp</strong>.addTrailers(<strong class="openable">headers:obj<div>
                <p> ex: <mark>{'header1':'val1', 'header2':21}</mark> (keys are lowercased) </p>
            </div></strong>)
        </td>
        <td> 
            - adds http trailers to the message (headers but at the end of the message) (trailers are supported only by chunked http protocols <mark>HTTP/1.1</mark> and <mark>HTTP/2</mark>) <br>
            - must be sent after the message body (otherwise it's silently discarded) 
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvResp</strong>.connection </td>
        <td> <u>[Deprecated since node v.13.0.0 use <mark>socket</mark> instead]</u> returns the underlying socket 
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvResp</strong>.createPushResponse(<strong>h2Headers:obj</strong>, <strong>fn(err, h2SrvSersp)</strong>) </td>
        <td> 
            - creates a new "push" stream in order to push data to the client (sends unrequested data to a HTTP/2 client (HTTP/1.* does not support server push)) <br>
            - the newly created push stream is returned in the callback and wrapped in a <u>new <strong>h2SrvResp</strong></u> object (which is used to send (push) data to the client) 
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvResp</strong>.end(<i>chunk:str|buf|uint8Arr, encode:str, fn(err)</i>) </td>
        <td> 
            - finishes sending the response (optionally sends a last data chunk to the message body) <a href="../../Stream/index.html#endR" target="_blank">(Stream method)</a> <br>
            - callback called when the response stream is finished <br>
            - returns this <strong>h2srvResp</strong> object
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
                <span><i class="fab fa-node-js"></i> 10.0.0 returns <strong>h2srvResp</strong> </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvResp</strong>.finished </td>
        <td> <u>[Deprecated since node v.12.16.0 use <mark>writableEnded</mark> instead]</u> returns <mark>true</mark> if the <mark>end()</mark> method was called, otherwise returns <mark>false</mark>
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvResp</strong>.getHeader(<strong>headerName:str</strong>) </td>
        <td> returns the specified response header value
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvResp</strong>.getHeaderNames() </td>
        <td> returns an array which contains all outgoing header keys (lowercased)
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2srvResp</strong>.getHeaders() </td>
        <td> returns an object which contains a shallow copy of the outgoing headers (key, value) (object has no prototype)   
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvResp</strong>.hasHeader(<strong>headerName:str</strong>) </td>
        <td> returns <mark>ture</mark> if the specified header key exist in the outgoing header, otherwise returns <mark>false</mark> (case-insensitive)
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvResp</strong>.headersSent </td>
        <td> returns <mark>true</mark> if the headers are sent, otherwise returns <mark>false</mark>
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvResp</strong>.removeHeader(<strong>headerName:str</strong>) </td>
        <td> removes the specified header from the outgoing message header (case-insensitive)
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvResp</strong>.sendDate </td>
        <td> automatically sets the date header in the response (Default: <mark>true</mark>)
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> 
            <strong>h2SrvResp</strong>.setHeader(<strong>headerName:str</strong>, <strong class="openable">val:any<div>
                <p> - any data type can be set, so we can get back the set data type with the <mark>getHeader()</mark> method, <u>however once the header is sent through the network the value is converted to string</u></p>
                <p> - if the header has multiple values we can specify those in an Array (ex: <mark>'Cookie': ['type=ninja', 'langugage=javascript']</mark>) </p>
            </div></strong>) 
        </td>
        <td> sets a response header (if the header already exist its value will be reset)
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td>  
            <strong>h2SrvResp</strong>.setTimeout(<strong>nr:ms</strong>, <i class="openable">fn<div>
                <p> - <mark>timeout</mark> listener callback on this <strong>stream</strong> </p>
            </div></i>)
        </td>
        <td> 
            - sets a counter (timeout) on the underlying <strong>stream</strong> (<mark>0</mark> = Infinity) <br>
            - the counter starts when the connection estabilished and restarts at every data trafic <br>
            - once the timer expires the <mark>timeout</mark> event is <span class="openable">emitted on the underlying socket<div>
                <p> - the set <mark>timeout</mark> event can be listened on the underlying <strong>stream</strong> or <strong>h2SrvResp</strong> or <strong>h2SrvReq</strong> object </p>
            </div></span> (session not destoryed regardless the timeout event is listened or not) <br>
            - returns this <strong>h2SrvResp</strong> object  
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvResp</strong>.socket </td>
        <td> 
            returns an object that acts as a <mark>net.Socket</mark> or <mark>tls.Socket</mark> <span class="openable">but with limited socket functionalities<div>
                <p> - <mark>destroyed</mark> / <mark>readable</mark> / <mark>writable</mark> are retrieved from <mark><strong>h2SrvReq</strong>.stream</mark> </p>
                <p> - <mark>destroy</mark> / <mark>emit</mark> / <mark>end</mark> / <mark>on</mark> / <mark>once</mark> called on <mark><strong>h2SrvReq</strong>.stream</mark> </p>
                <p> - <mark>setTimeout</mark> called on <mark><strong>h2SrvReq</strong>.stream.session</mark> </p>
                <p> - <mark>pause</mark> / <mark>read</mark> / <mark>resume</mark> / <mark>write</mark> throws an error </p>
                <p> - all other interactions will be routed to the socket </p>
            </div></span>
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvResp</strong>.statusCode </td>
        <td> gets or sets the response status code
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvResp</strong>.statusMessage </td>
        <td> gets or sets the response status message <u>(not supported when HTTP/2 protocol is used, returns an empty string and emits a Warning)</u>
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvResp</strong>.stream </td>
        <td> returns the underlying <strong>stream</strong> which backs the response 
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvResp</strong>.writableEnded </td>
        <td> returns <mark>true</mark> if the <mark>end()</mark> method was called, otherwise returns <mark>false</mark> <u>(does not indicate if the data has been flushed to the underlying system)</u>    
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 12.9.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvResp</strong>.write(<strong>chunk:str|buf|uint8Arr</strong>, <i>encode:str, fn(err)</i>) </td>
        <td> 
            - streams a data chunk to the response message body <a href="../../Stream/index.html#write" target="_blank">(Stream method)</a> <br>
            - returns <mark>true</mark> if the entire chunk is flushed to the underlying kernel buffer, <mark>false</mark> if the chunk is queued in memory (emits the <mark>drain</mark> event is the buffer is free again) <br>
            - callback called when the data chunk is successfully flushed to the kernel buffer
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvResp</strong>.writeContinue() </td>
        <td> sends a <mark>100 Continue</mark> status message to the client (indicates that the client should send the body) (used in with the server object <mark>checkContinue</mark> event)
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> 
            <strong>h2srvResp</strong>.writeHead(<strong>stCode:nr</strong>, <i class="openable">stMsg:str<div>
                <p> - not supported when HTTP/2 protocol is used, returns an empty string and emits a Warning </p>
            </div></i>, <i class="openable">headers:obj<div>
                <p> ex: <mark>{'header1': val1', 'header2':21}</mark> (keys are lowercased) </p>
            </div></i>) </td>
        <td> 
            - sets the message header <u>and sends</u> it to the remote client (header cannon be modified after this) (must be called before the <mark>write()</mark> and <mark>end()</mark> methods) <br>
            - returns this <strong>h2SrvResp</strong> object
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
                <span><i class="fab fa-node-js"></i> 10.17.0 returns <strong>h2SrvResp</strong> </span>
            </span>
        </td>
    </tr>
    <tr>
        <td colspan="2"> events </td>
    </tr>
    <tr>
        <td> <strong>h2SrvResp.listener</strong>('close' <strong>fn</strong>) </td>
        <td> emitted when the underlying <strong>stream</strong> is destroyed
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>h2SrvResp.listener</strong>('finish' <strong>fn</strong>) </td>
        <td> emitted when all response data is flushed to the underlying system
            <span class="browserSupport" title="updated : 2020-06-15">
                <span><i class="fab fa-node-js"></i> 8.4.0 </span>
            </span>
        </td>
    </tr>
</table>
<h2 style="color:green;"><u> Notes : </u></h2>
    <details class="example" id="notes">
    <summary> Notes :</summary>
        <!-- <p> - paragraph removes the 'empty' message from the detail TAG -->
    </details>
<h2 style="color:green;"><u> Useful Links : </u></h2>
    
<h2 style="color:green;"><u> Remember This : </u></h2>
    <p> - only the server returned by the <mark>createSecureServer()</mark> method can serve both HTTP/2 and HTTP/1.* clients <u>(over TLS connection)</u>, the none TLS version can only serve HTTP/2 clients (<mark>createServer()</mark>) </p>
<h2 style="color:green;"><u> Description and Demonstration : </u></h2>
    <p> - the Compatibility API offers <mark>http</mark> module-like tools, it can be used to develop HTTP/2 servers by using <mark>http</mark>-like tools basically</p>
    <p> - but most impportantly the Compatibility API (server) supports both HTTP/2 and HTTP/1.* protocols <span style="color:yellow;">over TLS connection only!</span> </p>
    <pre>
    var http2 = require('http2');
    var fs = require('fs');
    
// createSecureServer() ---------------------------------------------------------------
    var options = {
        key:fs.readFileSync('cert/privkey.pem'), 
        cert:fs.readFileSync('cert/cert.pem'),
        allowHTTP1:true};                                                              // server can also serve HTTP/1.* requests  
    
    var server = http2.createSecureServer(options);                                    // can server both HTTP/2 or HTTP/1.* clients over TLS  
    server.listen(1000, 'localhost', ()=>console.log('server listening!')); 
    
    server.on('request', function(srvReq, srvResp){                                    // 'request' event is used by the Compatibility API   
        srvReq.httpVersion;                                                            // -> 2.0 | 1.1         // depending requesting client 
        // serving HTTP/2 or HTTP/1.* clients...
    });
    
// createsServer() --------------------------------------------------------------------
    var server = http2.createServer();                                                 // can server HTTP/2 clients only (non TLS)  
    server.listen(1000, 'localhost', ()=>console.log('server listening!')); 
    
    server.on('request', function(srvReq, srvResp){                                    // 'request' event is used by the Compatibility API   
        srvReq.httpVersion;                                                            // -> 1.1          
        // serving HTTP/2 clients...
    });
    </pre>
<details class="example">
<summary> Example : </summary>
<h4 style="color:darkblue;"><u> Coppatibility Server over TLS </u></h4>
    <p> - the <mark>createSecureServer()</mark> returns an HTTP/2 server which can serve both HTTP/2 and HTTP/1.* clients </p>
    <pre>
    var http2 = require('http2');
    var fs = require('fs');
    
    var options = {
        key:fs.readFileSync('cert/privkey.pem'), 
        cert:fs.readFileSync('cert/cert.pem'),
        allowHTTP1:true};                                                              // server allows to server HTTP/1.* request too 
    
    var server = http2.createSecureServer(options);                                    // can server both HTTP/2 or HTTP/1.* clients through secure connection 
    server.listen(1000, 'localhost', ()=>console.log('server listening!')); 
    
    server.on('request', function(srvReq, srvResp){
        console.log( srvReq.httpVersion );                                             // -> 2.0 | 1.1         // depending requesting client 
        
        srvResp.statusCode = 200;
        srvResp.end('server response');
    });
    </pre>
</details>
<hr>
<!-------------------------------------------------------------------------------------------------------------->
<h2 style="color:darkblue;"><u> http2ServerRequest <mark>aborted</mark> / <mark>complete</mark> / <mark>connection</mark> / <mark>socket</mark> / <mark>stream</mark> / <mark>destroy()</mark> / <mark>headers</mark> / <mark>rawHeaders</mark> / <mark>trailers</mark> / <mark>rawTrailers</mark> / <mark>httpVersion</mark> / <mark>method</mark> / <mark>url</mark> / <mark>authority</mark> / <mark>scheme</mark> / <mark>setTimeout()</mark> </u></h2>
<h3 style="color:darkblue;"><u> Events: <mark>aborted</mark> / <mark>close</mark> </u></h3>
    <pre class="syntax">
SYNTAX:     <strong>h2SrvReq</strong>                                                                   // represents a received request (operates on top of a <strong>stream</strong>), extends the <mark>stream.Readable</mark> class    
            
            <strong>h2SrvReq</strong>.aborted                                                           // returns <mark>true</mark> if the request is aborted, otherwise returns <mark>false</mark>    
            <strong>h2SrvReq</strong>.complete                                                          // returns <mark>true</mark> if the request has been completed, aborted or destroyed, otherwise returns <mark>false</mark>   
            
            <strong>h2SrvReq</strong>.connection                                                        // <u>[Deprecated since node v.13.0.0 use <mark>socket</mark> instead]</u> returns the underlying socket 
            <strong>h2SrvReq</strong>.socket                                                            // returns an object that acts as a <mark>net.Socket</mark> or <mark>tls.Socket</mark> <span class="openable">but with limited socket functionalities<div>
                <p> - <mark>destroyed</mark> / <mark>readable</mark> / <mark>writable</mark> are retrieved from <mark><strong>h2SrvReq</strong>.stream</mark> </p>
                <p> - <mark>destroy</mark> / <mark>emit</mark> / <mark>end</mark> / <mark>on</mark> / <mark>once</mark> called on <mark><strong>h2SrvReq</strong>.stream</mark> </p>
                <p> - <mark>setTimeout</mark> called on <mark><strong>h2SrvReq</strong>.stream.session</mark> </p>
                <p> - <mark>pause</mark> / <mark>read</mark> / <mark>resume</mark> / <mark>write</mark> throws an error </p>
                <p> - all other interactions will be routed to the socket </p>
            </div></span>
            <strong>h2SrvReq</strong>.stream                                                            // returns the underlying <strong>stream</strong> which backs the request    
            
            <strong>h2SrvReq</strong>.destroy(<i class="openable">err<div>
                <p> - once underlying strem is destroyed it emits the <mark>error</mark> event with the passed error (<mark>close</mark> event not emitted in this case) </p>
            </div></i>)                                                     // immediately destroys the underlying <strong>stream</strong> (once the stream is destoryed it emits the <mark>close</mark> event)
            
            <strong>h2SrvReq</strong>.headers                                                           // returns the received headers in a <strong>h2Headers</strong> object 
            <strong>h2SrvReq</strong>.rawHeaders                                                        // returns the received raw headers (exactly as the message header was received) in an Array   
            <strong>h2SrvReq</strong>.trailers                                                          // returns the received trailers in an object (not a <strong>h2Headers</strong> object) <u>(populated only in the <mark>end</mark> event)</u>
            <strong>h2SrvReq</strong>.rawTrailers                                                       // returns the received raw trailers (exactly as the message header was received) in an Array <u>(populated only in the <mark>end</mark> event)</u>
            
            <strong>h2SrvReq</strong>.httpVersion                                                       // returns the request http protocol version in a string    
            <strong>h2SrvReq</strong>.method                                                            // returns the request method in a string   
            <strong>h2SrvReq</strong>.url                                                               // returns the request url in a string 
            <strong>h2SrvReq</strong>.authority                                                         // returns the request authority pseudo header filed (same as <mark><strong>h2SrvReq</strong>.headers[':authority']</mark>)
            <strong>h2SrvReq</strong>.scheme                                                            // returns the request scheme pseudo header filed (same as <mark><strong>h2SrvReq</strong>.headers[':scheme']</mark>)
            
            <strong>h2SrvReq</strong>.setTimeout(<strong>nr:ms</strong>, <i class="openable">fn<div>
                <p> - <mark>timeout</mark> listener callback on this <strong>stream</strong> </p>
            </div></i>)                                            // sets a counter (timeout) on the underlying <strong>stream</strong> (<mark>0</mark> = Infinity)    
                                                                                          the counter starts when the connection estabilished and restarts at every data trafic  
                                                                                          once the timer expires the <mark>timeout</mark> event is <span class="openable">emitted on the underlying socket<div>
                <p> - the set <mark>timeout</mark> event can be listened on the underlying <strong>stream</strong> or <strong>h2SrvResp</strong> or <strong>h2SrvReq</strong> object </p>
            </div></span> (session not destoryed regardless the timeout event is listened or not)    
                                                                                          returns this <strong>h2SrvReq</strong> object   
            
    <span style="color:darkgray">// Events -------------------------------------------------------------------------</span>
            <strong>h2SrvReq.listener</strong>('aborted', <strong>fn</strong>)                                           // emitted when the request is abnormally aborted in mid-communication   
            <strong>h2SrvReq.listener</strong>('close', <strong>fn</strong>)                                             // emitted when the underlying <strong>stream</strong> is destroyed  
    </pre>
<details class="example">
<summary> DEMO </summary> 
    <pre>
    var http2 = require('http2');
    var fs = require('fs');
    
    var server = http2.createSecureServer({key:fs.readFileSync('cert/privkey.pem'), cert:fs.readFileSync('cert/cert.pem'), allowHTTP1:true});
    server.listen(1000, 'localhost', ()=>console.log('server listening!')); 
    
    server.on('request', function(srvReq, srvResp){
    
// aborted / complete -----------------------------------------------------------------
        srvReq.aborted;                                                                // -> false             // request not aborted 
        srvReq.complete;                                                               // -> false             // request not completed aborted or destroyed   
        
// socket / stream --------------------------------------------------------------------
        srvReq.socket;                                                                 // -> returns an object which acts as the underlying tls.Socket object with some limitiations    
        srvReq.stream;                                                                 // -> returns the underlying stream    
        
// destory() --------------------------------------------------------------------------
        srvReq.destroy();                                                              // destroys the underlying stream 
        
// headers / rawHeaders / trailers / rawTrailers --------------------------------------
        srvReq.headers;                                                                // -> {':method':'POST', ':path':'/'}        // h2Headers object 
        srvReq.rawHeaders;                                                             // -> [':method', 'POST', ':path', '/']      // headers as they are received
        
        srvReq.on('end', function(){                                                   // -! trailers populated only in the 'end' event 
            srvReq.trailers;                                                           // -> {trail:'21'}                           // not a h2Headers object 
            console.log( srvReq.rawTrailers );                                         // -> ['trail', '21']
        };
        
// httpVersion / method / authority / url / scheme ------------------------------------
        srvReq.httpVersion;                                                            // -> '2.0''
        srvReq.method;                                                                 // -> 'POST'
        srvReq.authority;                                                              // -> 'localhost:1000'
        srvReq.url;                                                                    // -> '/'
        srvReq.scheme;                                                                 // -> 'https'
        
// setTimeout() -----------------------------------------------------------------------
        srvReq.setTimeout(4000, ()=>{});                                               // set the timeout on the underlying stream (socket simply emits the 'timeout' event (not destroyed if the 'timeout' event is not listened))    
        
// aborted / close (events) -----------------------------------------------------------
        srvReq.on('aborted', ()=>{});                                                  // emitted when the request is aborted 
        srvReq.on('aborted', ()=>{});                                                  // emitted when the underlying socket is destroyed 
    });
    </pre>
</details>
<details class="example">
<summary> Example : </summary>
<h4 style="color:darkblue;"><u> <mark>complete</mark> TEST </u></h4>
    <pre>
    var http2 = require('http2');
    var fs = require('fs');
    
    var options = {
        key:fs.readFileSync('cert/privkey.pem'), 
        cert:fs.readFileSync('cert/cert.pem'),
        allowHTTP1:true};  
    
    var server = http2.createSecureServer(options);
    server.listen(1000, 'localhost', ()=>console.log('server listening!')); 
    
    server.on('request', function(srvReq, srvResp){
        console.log( srvReq.complete );                                                // -> false         // request not yet complete 
        
        setTimeout(function(){
            console.log( srvReq.complete );                                            // -> true          // request completed 
        }, 1000);
        
        srvResp.statusCode = 200;
        srvResp.end('server response');
    });
    
    </pre>
<hr>
<!-------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> <mark>headers</mark> / <mark>rawHeaders</mark> / <mark>trailers</mark> / <mark>rawTrailers</mark> TEST </u></h4>
    <pre>
    var http2 = require('http2');
    var fs = require('fs');
    
    var options = {
        key:fs.readFileSync('cert/privkey.pem'), 
        cert:fs.readFileSync('cert/cert.pem'),
        allowHTTP1:true};  
    
    var server = http2.createSecureServer(options);
    server.listen(1000, 'localhost', ()=>console.log('server listening!')); 
    
    server.on('request', function(srvReq, srvResp){
        console.log( srvReq.method );
        
        console.log( srvReq.headers );                                                 // -> {':path':'/', ':scheme':'https', ':authority':'localhost:1000', ':method':'POST'}
        console.log( srvReq.rawHeaders );                                              // -> [':path', '/', ':scheme', 'https', ':authority', 'localhost:1000', ':method', 'POST']   
        
        srvReq.on('end', function(){                                                   // -! trailers populated only in the 'end' event 
            console.log( srvReq.trailers );                                            // -> {cometrailer:'21', anothertrailer:'22' }          // not a n2Headers object 
            console.log( srvReq.rawTrailers );                                         // -> ['cometrailer','21', 'anothertrailer','22']
        });
        
        srvResp.statusCode = 200;
        srvResp.end('server response');
    });
    </pre>
<!-------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> <mark>setTimeout()</mark> TEST </u></h4>
    <pre>
    var http2 = require('http2');
    var fs = require('fs');
    
    var options = {
        key:fs.readFileSync('cert/privkey.pem'), 
        cert:fs.readFileSync('cert/cert.pem'),
        allowHTTP1:true};  
    
    var server = http2.createSecureServer(options);
    server.listen(1000, 'localhost', ()=>console.log('server listening!')); 
    
    server.on('request', function(srvReq, srvResp){
        srvReq.setTimeout(4000, function(){                                            // emitted after 4 seconds 
            console.log( 'timeout on srvResp object! (1)' );
        }) 
        
        srvResp.stream.on('timeout', function(){                                       // emitted after 4 seconds 
            console.log( 'timeout on srvResp object! (2)' );
        });
        
        srvReq.stream.on('timeout', function(){                                        // emitted after 4 seconds 
            console.log( 'timeout on srvReq object!' );
        });
        
        srvResp.statusCode = 200;
        srvResp.write('server response');
    });
    </pre>
<!-------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> <mark>setTimeout()</mark> does the strem is destroyed if the <mark>timeout</mark> event is not listened TEST </u></h4>
    <pre>
    var http2 = require('http2');
    var fs = require('fs');
    
    var options = {
        key:fs.readFileSync('cert/privkey.pem'), 
        cert:fs.readFileSync('cert/cert.pem'),
        allowHTTP1:true};  
    
    var server = http2.createSecureServer(options);
    server.listen(1000, 'localhost', ()=>console.log('server listening!')); 
    
    server.on('request', function(srvReq, srvResp){
        srvReq.setTimeout(3000);                                                       // underlying stream times out after 3 seconds 
        
        setTimeout(function(){
            console.log(srvResp.stream.destroyed );                                    // -> false             // not destroyed after emitting the 'timeout' 
        }, 5000);
        
        
        srvResp.statusCode = 200;
        srvResp.write('server response');
    });
    </pre>
<!-------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> <mark>scheme</mark> / <mark>authority</mark> / <mark>stream</mark> TEST </u></h4>
    <pre>
    var http2 = require('http2');
    var fs = require('fs');
    
    var options = {
        key:fs.readFileSync('cert/privkey.pem'), 
        cert:fs.readFileSync('cert/cert.pem'),
        allowHTTP1:true};  
    
    var server = http2.createSecureServer(options);
    server.listen(1000, 'localhost', ()=>console.log('server listening!')); 
    
    server.on('request', function(srvReq, srvResp){
        console.log( srvReq.authority );                                               // -> 'localhost:1000'
        console.log( srvReq.scheme );                                                  // -> 'https'
        console.log( srvReq.stream === srvResp.stream);                                // true         // because both object is the extension of this stream 
        
        srvResp.statusCode = 200;
        srvResp.write('server response');
    });
    </pre>
<!-------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> <mark>destroy()</mark> / <mark>close</mark> (event) TEST </u></h4>
    <pre>
    var http2 = require('http2');
    var fs = require('fs');
    
    var options = {
        key:fs.readFileSync('cert/privkey.pem'), 
        cert:fs.readFileSync('cert/cert.pem'),
        allowHTTP1:true};  
    
    var server = http2.createSecureServer(options);
    server.listen(1000, 'localhost', ()=>console.log('server listening!')); 
    
    server.on('request', function(srvReq, srvResp){
        
        console.log( srvResp.stream.destroyed );                                       // -> false 
        srvResp.destroy();                                                             // destroys the underlying stream 
        console.log( srvResp.stream.destroyed );                                       // -> true
                
        srvResp.on('close', function(){                                                // underlying stream emits the 'close' event because the steram is destroyed   
            console.log( 'stream emitted the close event!' );
        });
        
        srvResp.statusCode = 200;
        srvResp.write('server response');
    });
    </pre>
</details>
<hr>
<!-------------------------------------------------------------------------------------------------------------->
<h2 style="color:darkblue;"><u> http2ServerResponse <mark>connection</mark> / <mark>socket</mark> / <mark>stream</mark> / <mark>write()</mark> / <mark>end()</mark> / <mark>finished</mark> / <mark>writableEnded</mark> / <mark>setHeader()</mark> / <mark>getHeader()</mark> / <mark>getHeaderNames()</mark> / <mark>getHeaders()</mark> / <mark>hasHeader()</mark> / <mark>removeHeader()</mark> / <mark>headersSent</mark> / <mark>statusCode</mark> / <mark>statusMessage</mark> / <mark>sendDate</mark> / <mark>writeHead()</mark> / <mark>writeContinue()</mark> / <mark>addTrailers()</mark> / <mark>setTimeout()</mark> / <mark>createPushResponse()</mark> </u></h2>
<h3 style="color:darkblue;"><u> Events: <mark>close</mark> / <mark>finish</mark> </u></h3>
    <pre class="syntax">
SYNTAX:     <strong>h2SrvResp</strong>                                                                  // represents the server response (operates on top o a <strong>stream</strong>), extends the <mark>Stream</mark> class   
            
            <strong>h2SrvResp</strong>.connection                                                       // <u>[Deprecated since node v.13.0.0 use <mark>socket</mark> instead]</u> returns the underlying socket 
            <strong>h2SrvResp</strong>.socket                                                           // returns an object that acts as a <mark>net.Socket</mark> or <mark>tls.Socket</mark> <span class="openable">but with limited socket functionalities<div>
                <p> - <mark>destroyed</mark> / <mark>readable</mark> / <mark>writable</mark> are retrieved from <mark><strong>h2SrvReq</strong>.stream</mark> </p>
                <p> - <mark>destroy</mark> / <mark>emit</mark> / <mark>end</mark> / <mark>on</mark> / <mark>once</mark> called on <mark><strong>h2SrvReq</strong>.stream</mark> </p>
                <p> - <mark>setTimeout</mark> called on <mark><strong>h2SrvReq</strong>.stream.session</mark> </p>
                <p> - <mark>pause</mark> / <mark>read</mark> / <mark>resume</mark> / <mark>write</mark> throws an error </p>
                <p> - all other interactions will be routed to the socket </p>
            </div></span>
            <strong>h2SrvResp</strong>.stream                                                           // returns the underlying <strong>stream</strong> which backs the response   
            
            
            <strong>h2SrvResp</strong>.write(<strong>chunk:str|buf|uint8Arr</strong>, <i>encode:str, fn(err)</i>)               // streams a data chunk to the response message body <a href="../../Stream/index.html#write" target="_blank">(Stream method)</a>
                                                                                          returns <mark>true</mark> if the entire chunk is flushed to the underlying kernel buffer, <mark>false</mark> if the chunk is queued in memory (emits the <mark>drain</mark> event is the buffer is free again)    
                                                                                          callback called when the data chunk is successfully flushed to the kernel buffer
            <strong>h2SrvResp</strong>.end(<i>chunk:str|buf|uint8Arr, encode:str, fn(err)</i>)                 // finishes sending the response (optionally sends a last data chunk to the message body) <a href="../../Stream/index.html#endR" target="_blank">(Stream method)</a>    
                                                                                          callback called when the response stream is finished
                                                                                          returns this <strong>h2srvResp</strong> object
            
            <strong>h2SrvResp</strong>.finished                                                         // <u>[Deprecated since node v.12.16.0 use <mark>writableEnded</mark> instead]</u> returns <mark>true</mark> if the <mark>end()</mark> method was called, otherwise returns <mark>false</mark>    
            <strong>h2SrvResp</strong>.writableEnded                                                    // returns <mark>true</mark> if the <mark>end()</mark> method was called, otherwise returns <mark>false</mark> <u>(does not indicate if the data has been flushed to the underlying system)</u>    
            
            <strong>h2SrvResp</strong>.setHeader(<strong>headerName:str</strong>, <strong class="openable">val:any<div>
                <p> - any data type can be set, so we can get back the set data type with the <mark>getHeader()</mark> method, <u>however once the header is sent through the network the value is converted to string</u></p>
                <p> - if the header has multiple values we can specify those in an Array (ex: <mark>'Cookie': ['type=ninja', 'langugage=javascript']</mark>) </p>
            </div></strong>)                              // sets a response header (if the header already exist its value will be reset)
            <strong>h2SrvResp</strong>.getHeader(<strong>headerName:str</strong>)                                        // returns the specified response header value 
            <strong>h2SrvResp</strong>.getHeaderNames()                                                 // returns an array which contains all outgoing header keys (lowercased)   
            <strong>h2srvResp</strong>.getHeaders()                                                     // returns an object which contains a shallow copy of the outgoing headers (key, value) (object has no prototype)   
            <strong>h2SrvResp</strong>.hasHeader(<strong>headerName:str</strong>)                                        // returns <mark>ture</mark> if the specified header key exist in the outgoing header, otherwise returns <mark>false</mark> (case-insensitive)    
            <strong>h2SrvResp</strong>.removeHeader(<strong>headerName:str</strong>)                                     // removes the specified header from the outgoing message header (case-insensitive)   
            <strong>h2SrvResp</strong>.headersSent                                                      // returns <mark>true</mark> if the headers are sent, otherwise returns <mark>false</mark>
            
            <strong>h2SrvResp</strong>.statusCode                                                       // gets or sets the response status code 
            <strong>h2SrvResp</strong>.statusMessage                                                    // gets or sets the response status message <u>(not supported when HTTP/2 protocol is used, returns an empty string and emits a Warning)</u>    
            <strong>h2SrvResp</strong>.sendDate                                                         // automatically sets the date header in the response (Default: <mark>true</mark>)    
            
            <strong>h2srvResp</strong>.writeHead(<strong>stCode:nr</strong>, <i class="openable">stMsg:str<div>
                <p> - not supported when HTTP/2 protocol is used, returns an empty string and emits a Warning </p>
            </div></i>, <i class="openable">headers:obj<div>
                <p> ex: <mark>{'header1': val1', 'header2':21}</mark> (keys are lowercased) </p>
            </div></i>)                   // sets the message header <u>and sends</u> it to the remote client (header cannon be modified after this) (must be called before the <mark>write()</mark> and <mark>end()</mark> methods)    
                                                                                          returns this <strong>h2SrvResp</strong> object 
            
            <strong>h2SrvResp</strong>.writeContinue()                                                  // sends a <mark>100 Continue</mark> status message to the client (indicates that the client should send the body) (used in with the server object <mark>checkContinue</mark> event)    
            
            <strong>h2SrvResp</strong>.addTrailers(<strong class="openable">headers:obj<div>
                <p> ex: <mark>{'header1':'val1', 'header2':21}</mark> (keys are lowercased) </p>
            </div></strong>)                                        // adds http trailers to the message (headers but at the end of the message) (trailers are supported only by chunked http protocols <mark>HTTP/1.1</mark> and <mark>HTTP/2</mark>)    
                                                                                          must be sent after the message body (otherwise it's silently discarded)   
            
            <strong>h2SrvResp</strong>.setTimeout(<strong>nr:ms</strong>, <i class="openable">fn<div>
                <p> - <mark>timeout</mark> listener callback on this <strong>stream</strong> </p>
            </div></i>)                                           // sets a counter (timeout) on the underlying <strong>stream</strong> (<mark>0</mark> = Infinity)    
                                                                                          the counter starts when the connection estabilished and restarts at every data trafic  
                                                                                          once the timer expires the <mark>timeout</mark> event is <span class="openable">emitted on the underlying socket<div>
                <p> - the set <mark>timeout</mark> event can be listened on the underlying <strong>stream</strong> or <strong>h2SrvResp</strong> or <strong>h2SrvReq</strong> object </p>
            </div></span> (session not destoryed regardless the timeout event is listened or not)    
                                                                                          returns this <strong>h2SrvResp</strong> object   
            
            <strong>h2SrvResp</strong>.createPushResponse(<strong>h2Headers:obj</strong>, <strong>fn(err, h2SrvSersp)</strong>)           // creates a new "push" stream in order to push data to the client (sends unrequested data to a HTTP/2 client (HTTP/1.* does not support server push)) 
                                                                                          the newly created push stream is returned in the callback and wrapped in a <u>new <strong>h2SrvResp</strong></u> object (which is used to send (push) data to the client)   
                
    <span style="color:darkgray">// Events -------------------------------------------------------------------------</span>
            <strong>h2SrvResp.listener</strong>('close' <strong>fn</strong>)                                             // emitted when the underlying <strong>stream</strong> is destroyed 
            <strong>h2SrvResp.listener</strong>('finish' <strong>fn</strong>)                                            // emitted when all response data is flushed to the underlying system
    </pre>
<details class="example">
<summary> DEMO </summary> 
    <pre>
    var http2 = require('http2');
    var fs = require('fs');
    
    var server = http2.createSecureServer({key:fs.readFileSync('cert/privkey.pem'), cert:fs.readFileSync('cert/cert.pem'), allowHTTP1:true});
    server.listen(1000, 'localhost', ()=>console.log('server listening!')); 
    
    server.on('request', function(srvReq, srvResp){
    
// socket / stream --------------------------------------------------------------------
        srvResp.socket;                                                                // -> returns an object which acts as the underlying tls.Socket object with some limitiations    
        srvResp.stream;                                                                // -> returns the underlying stream        
    
// write() / end() --------------------------------------------------------------------
        srvResp.write('server response');                                              // writes data to the stream 
        srvResp.end();                                                                 // finishes the stream 
    
// writableEnded ----------------------------------------------------------------------
        srvResp.writableEnded;                                                         // -> true           // the 'end()' method was called 
        
// setHeader() / getHeader() / getHeaderNames() / getHeaders() ------------------------
// hasHeader() / removeHeader() / headersSent -----------------------------------------
        srvResp.setHeader('myHeader-1', 21);                                           // sets a response header 
        srvResp.setHeader('myHeader-2', 'val');
        
        srvResp.getHeader('myHeader-1');                                               // -> 21                 // the set data type is returned 
        
        srvResp.getHeaderNames();                                                      // -> ['myheader-1', 'myheader-2']
        srvResp.getHeaders();                                                          // -> {'myheader-1':21, 'myheader-2':'val'}
        
        srvResp.hasHeader('myHeader-2');                                               // -> true
            srvResp.removeHeader('myHeader-2');                                        // removes the specified header 
        srvResp.hasHeader('myHeader-2');                                               // -> false
    
        srvResp.headersSent;                                                           // -> false              // headers not yet sent to the connected peer    
        
// statusCode / statusMessage / sendDate ----------------------------------------------
        srvResp.statusCode = 200;                                                      // sets the response status code 
        srvResp.statusMessage = 'OK'                                                   // sets the response status message (for HTTP/1.* clients only1 )
        srvResp.sendDate = true;                                                       // response date header is automatically generated and sent  
        
// writeHead() ------------------------------------------------------------------------
        srvResp.writeHead(200, 'OK', {'myheader-1':21, 'myheader-2':'val'});           // sets and sents the response header to the remote client    // -! aftter this method the response header cannot be modified (error will be thrown)    
        
/ writeContinue() ---------------------------------------------------------------------
        srvResp.writeContinue();                                                       // sends a '100 Continue' response     
        
// addTrailers() ----------------------------------------------------------------------
        srvResp.addTrailers({'tr1':1, 'tr2':2});                                       // set trailers (http headers but at the end of the message)    
        srvResp.end();                                                                 // -! trailers must be added in the end of the message         
        
// setTimeout() -----------------------------------------------------------------------
        srvResp.setTimeout(4000, ()=>{});                                              // set the timeout on the underlying stream (socket simply emits the 'timeout' event (not destroyed if the 'timeout' event is not listened))   
        
// createPushStream() -----------------------------------------------------------------
        srvResp.createPushResponse({}, function(err, srvResp){                         // creates a new push stream and wraps it in a new 'srvResp' object (for HTTP/2 clients only)
            srvResp.write('push some data');                                           // newly created push stream is used to push data to the client   
        });
        
// close / finish (events) ------------------------------------------------------------
        srvResp.on('finish', ()=>{});                                                  // emitted when all data is successfully flushed to the underlying system 
        srvResp.on('close', ()=>{});                                                   // emitted when the underlying stream is destroyed 
    });
    </pre>
</details>
<details class="example">
<summary> Example : </summary>
<h4 style="color:darkblue;"><u> <mark>statusMessage</mark> TEST </u></h4>
    <pre>
    var http2 = require('http2');
    var fs = require('fs');
    
    var options = {
        key:fs.readFileSync('cert/privkey.pem'), 
        cert:fs.readFileSync('cert/cert.pem'),
        allowHTTP1:true};  
    
    var server = http2.createSecureServer(options);
    server.listen(1000, 'localhost', ()=>console.log('server listening!')); 
    
    server.on('request', function(srvReq, srvResp){
        
        srvResp.statusCode = 200;
        srvResp.statusMessage = 'custom status message';                               // for HTTP/2 clients this will emit a warning (for HTTP/1.* clients works as expected)    
        
        srvResp.write('server response');
    });
    
    </pre>
<hr>
<!-------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> <mark>writeContinue()</mark> TEST </u></h4>
    <pre>
    var http2 = require('http2');
    var fs = require('fs');
    
    var options = {
        key:fs.readFileSync('cert/privkey.pem'), 
        cert:fs.readFileSync('cert/cert.pem'),
        allowHTTP1:true};  
    
    var server = http2.createSecureServer(options);
    server.listen(1000, 'localhost', ()=>console.log('server listening!')); 
    
    server.on('request', function(srvReq, srvResp){
        
        srvResp.writeContinue();                                                       // writes '100 Continue' to the requested client (HTTP/1.* and HTTP/2)
    });
    </pre>
<hr>
<!-------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> <mark>addTrailers()</mark> TEST </u></h4>
    <pre>
    var http2 = require('http2');
    var fs = require('fs');
    
    var options = {
        key:fs.readFileSync('cert/privkey.pem'), 
        cert:fs.readFileSync('cert/cert.pem'),
        allowHTTP1:true};  
    
    var server = http2.createSecureServer(options);
    server.listen(1000, 'localhost', ()=>console.log('server listening!')); 
    
    server.on('request', function(srvReq, srvResp){
        
        srvResp.statusCode = 200;
        srvResp.end('server response');
        srvResp.addTrailers({'trail-1':1, 'trail-2':2});                               // sendns trailers (after the message body)
    });
    </pre>
<hr>
<!-------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> <mark>createPushResponse()</mark> TEST </u></h4>
    <pre>
    var http2 = require('http2');
    var fs = require('fs');
    
    var options = {
        key:fs.readFileSync('cert/privkey.pem'), 
        cert:fs.readFileSync('cert/cert.pem'),
        allowHTTP1:true};  
    
    var server = http2.createSecureServer(options);
    server.listen(1000, 'localhost', ()=>console.log('server listening!')); 
    
    server.on('request', function(srvReq, srvResp){
        srvResp.createPushResponse({}, function(err, srvRespPush){                     // creaates a new push stream which is wrapped in the 'srvRespPush' object (Http2ServerResponse object)  
            srvRespPush.statusCode = 200;                                              // the new push response object is used to push data to the client just as a normal http2ServerResponse object 
            srvRespPush.end('pushed data');
        });
        
        srvResp.statusCode = 200;
        srvResp.end('server response');
    });
    </pre>
<hr>
<!-------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> <mark>close</mark> (event) TEST </u></h4>
    <pre>
    var http2 = require('http2');
    var fs = require('fs');
    
    var options = {
        key:fs.readFileSync('cert/privkey.pem'), 
        cert:fs.readFileSync('cert/cert.pem'),
        allowHTTP1:true};  
    
    var server = http2.createSecureServer(options);
    server.listen(1000, 'localhost', ()=>console.log('server listening!')); 
    
    server.on('request', function(srvReq, srvResp){
        srvResp.on('close', function(){
            console.log( 'sream destoryed');
            console.log( srvResp.stream.destroyed );                                   // -> true          // underlying stream is desroyed
        });
        
        srvResp.end('server response!');                                               // ending the respose destroys the stream 
    });
    </pre>
<!-------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> <mark>writeHead()</mark> TEST </u></h4>
    <pre>
    var http2 = require('http2');
    var fs = require('fs');
    
    var options = {
        key:fs.readFileSync('cert/privkey.pem'), 
        cert:fs.readFileSync('cert/cert.pem'),
        allowHTTP1:true};  
    
    var server = http2.createSecureServer(options);
    server.listen(1000, 'localhost', ()=>console.log('server listening!')); 
    
    server.on('request', function(srvReq, srvResp){
        srvResp.writeHead(200, {'custHead':21});                                       // sends this header to the client (after this we cannos send more headers)
        
    });
    </pre>





</details>
    
<br><br>
</body>
</html>