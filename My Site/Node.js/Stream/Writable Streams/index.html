<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title> Writable Streams </title> 
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous"> 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../../Assets/stylesPages.css"> 
    <script src="../../../Assets/scriptPages.js"></script>
</head>
<body>
<h1> Writable Streams (ver 3.2) </h1>
    <p> Updated ( 2019-07-12 )</p>
    <p class="sitenav"> <a href="../../../index.html">MySite></a>
        <a href="../../index.html">Node.js></a> 
        <a href="../index.html">Streams></a> Writable Streams    
    </p>
<table class="table">
    <tr>
        <th style="width:30%;"> Method / Property </th>
        <th> Description </th>
    </tr>
    <tr>
        <td id="cork"> <strong>writableStream</strong>.cork() </td>
        <td> - data chunks written after this method will be forces to be buffered in the stream buffer memory<br>
             - data is kept in the memory utill eigther the <mark>uncork()</mark> or the <mark>end()</mark> method flushes it in the underlying system)
            <span id="browserSupport" title="updated : 2019-06-28">
                <span><i class="fab fa-node-js"></i> 0.11.2 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td id="destroy"> <strong>writableStream</strong>.destroy(<i>error:str</i><small>, function(<i>err</i>)</small>) </td>
        <td> - immediately destroys the stream <u>(destroys pending data)</u> and emits the <mark>close</mark> event <br>
             - emits the <mark>close</mark> event <br>
             - returns the stream itself<br>
             - optionally throws a custom error what can be handled directly in the callback function <u>(this is not in the Node.js specification but it works fine)</u> or by the <mark>error</mark> event listener<br>
             - if an error is passed the <mark>close</mark> event is not emitted
            <span id="browserSupport" title="updated : 2019-06-27">
                <span><i class="fab fa-node-js"></i> 8.0.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td id="end"> <strong>writableStream</strong>.end(<i>chunk:any, encode:str, fn</i>) </td>
        <td> signals that no more data will be written to the stream and emits the 'finish' event (optionally writes a last chunk)
            <span id="browserSupport" title="updated : 2019-06-27">
                <span><i class="fab fa-node-js"></i> 0.9.4 </span>
                <span><i class="fab fa-node-js"></i> 8.0.0 Uint8Array </span>
                <span><i class="fab fa-node-js"></i> 10.0.0 retuns the Stream </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>writableStream</strong>.writableBuffer </td>
        <td> returns the <u>current</u> buffer of the writable stream
            <span id="browserSupport" title="updated : 2019-06-27">
                <span><i class="fab fa-node-js"></i> ?.?.? </span>
            </span>
        </td>
    </tr>
    <tr>
        <td id="write"> <strong>writableStream</strong>.write(<strong>chunk:any</strong><i>, encode:str, fn(err)</i>) </td>
        <td> - writes a data chunk in the internal buffer memory <br>
             - the callback function is fired once the data successfully flushed in the underlying system <u>(if an error occurs the callback function is NOT garanteed to fire)</u><br>
             - returns <mark>true</mark> if the data chunk size is smaller than the buffer size specified by the <mark>highWaterMark</mark> when the stream was created <br>
             - returns <mark>false</mark> if the data chunk is bigger than <mark>highWaterMark</mark> and fires the <mark>drain</mark> event<br> - returns <mark>false</mark> if the stream is not draining
            <span id="browserSupport" title="updated : 2019-06-27">
                <span><i class="fab fa-node-js"></i> 0.9.4 </span>
                <span><i class="fab fa-node-js"></i> 8.0.0 Uint8Array </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>writableStream</strong>.setDefaultEncoding(<strong>encode:str</strong>) </td>
        <td> sets the default encoding for the writable stream and returns the stream itself
            <span id="browserSupport" title="updated : 2019-06-27">
                <span><i class="fab fa-node-js"></i> 0.11.15 </span>
                <span><i class="fab fa-node-js"></i> 6.1.0 returns the Stream </span>
            </span>
        </td>
    </tr>
    <tr>
        <td id="uncork"> <strong>writableStream</strong>.uncork() </td>
        <td> flushes all data from the buffer to the underlying system since the <mark>cork()</mark> method (this method must be called the number of times the <mark>cork()</mark> method was called)
            <span id="browserSupport" title="updated : 2019-06-28">
                <span><i class="fab fa-node-js"></i> 0.11.2 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>writableStream</strong>.writable </td>
        <td> returns <mark>true</mark> if it's safe to call the <mark>write()</mark> method
            <span id="browserSupport" title="updated : 2019-06-29">
                <span><i class="fab fa-node-js"></i> 11.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>writableStream</strong>.writableHighWaterMark </td>
        <td> returns the value of the <mark>HighWaterMark</mark> when the stream was constructed (default: 16384)
            <span id="browserSupport" title="updated : 2019-06-29">
                <span><i class="fab fa-node-js"></i> 9.3.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>writableStream</strong>.writableLength </td>
        <td> returns the number of bytes (or objects if the stream is in object mode) in the buffer memory queue 
            <span id="browserSupport" title="updated : 2019-06-29">
                <span><i class="fab fa-node-js"></i> 9.4.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>writableStream</strong>.writableObjectMode </td>
        <td> returns a boolean indicating if the stream is operating in object mode
            <span id="browserSupport" title="updated : 2019-06-29">
                <span><i class="fab fa-node-js"></i> 12.3.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td colspan="2"> Events </td>
    </tr>
    <tr>
        <td> <strong>writableStream.listener</strong><em>(</em>'close', function()<em>)</em> </td>
        <td> event emitted when the stream and the underlying recource is closed, indicates that no more events will be emitted and no further computation will occur
            <span id="browserSupport" title="updated : 2019-06-29">
                <span><i class="fab fa-node-js"></i> 0.9.4 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>writableStream.listener</strong><em>(</em>'drain' <strong>fn</strong><em>)</em> </td>
        <td> when the <mark>write()</mark> method returns <mark>false</mark> the stream buffer is overflown, once the buffer is freed up this event is emitted to signal that the stream can be written again
            <span id="browserSupport" title="updated : 2019-06-29">
                <span><i class="fab fa-node-js"></i> 0.9.4 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>writableStream.listener</strong><em>(</em>'error' function(<strong>error</strong>)<em>)</em> </td>
        <td> - event emitted if an error occured while writing or piping the data <u>(the stream is NOT closed when this event is emitted)</u> <br>
             - error event handler handles the thrown error by the stream (allowing the program to continue)
            <span id="browserSupport" title="updated : 2019-06-29">
                <span><i class="fab fa-node-js"></i> 0.9.4 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>writableStream.listener</strong><em>(</em>'finish', function()<em>)</em> </td>
        <td> event emitted when the <mark>end()</mark> method is called and the data is flushed to the underlying system 
            <span id="browserSupport" title="updated : 2019-06-29">
                <span><i class="fab fa-node-js"></i> 0.9.4 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>writableStream.listener</strong><em>(</em>'pipe', function(<strong>readableStream</strong>)<em>)</em> </td>
        <td> event emitted when the <mark>pipe()</mark> method is called
            <span id="browserSupport" title="updated : 2019-06-29">
                <span><i class="fab fa-node-js"></i> 0.9.4 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>writableStream.listener</strong><em>(</em>'unpipe', function(<strong>readableStream</strong>)<em>)</em> </td>
        <td> - event emited when the <mark>unpipe()</mark> method is called <br>
             - emitted when the writable stream emits an error during piping <br>
             - emitted when when the writable stream is unpiped <u style="color:orangered;">(this is not in the Node.js specification but in my test this is clearly the case! [2019-07-12])</u>   
            <span id="browserSupport" title="updated : 2019-06-29">
                <span><i class="fab fa-node-js"></i> 0.9.4 </span>
            </span>
        </td>
    </tr>
</table>
<h2 style="color:green;"><u> Notes : </u></h2>
    <details class="example" id="notes">
    <summary> Notes :</summary>
    </details>
<h2 style="color:green;"><u> Useful Links : </u></h2>
<h2 style="color:green;"><u> Remember This : </u></h2>
    <p> - the Node.js specification says that the <mark>unpipe</mark> event is emitted when we call the <mark>unpipe()</mark> method or when an error occurs, BUT in my tests it is also emitted at the end of streaming (I suppose it is emmited when the writable stream is unpiped) [TESTED 2019-06-29]</p>
<h2 style="color:green;"><u> Description and Demonstration : </u></h2>
    <p> - writable streams are destinations when the data is written </p>
    <p> - writing larger data chunks than the <mark>highWaterMark</mark> (buffer size) is allowed (the extra data is written in the memory) but it is not recommended to abuse this practice because this <u>could lead to vulnerability and poor garbage collection</u>, the <mark>drain</mark> event is fired when this happes </p>
<!--------------------------------------------------------------------------------------------------------->
<hr>
<h2 class="headerExtra"><h2 class="headerExtra"><u> Methods and Properties </u></h2>
<h2 style="color:darkblue;"><u> <mark>writableBuffer</mark> / <mark>write()</mark> / <mark>end()</mark> / <mark>setDefaultEncoding()</mark> / <mark>destroy()</mark> property and methods </u></h2>
    <pre class="syntax">
SYNTAX:     <strong>writableStream</strong>.writableBuffer                                      // returns the <u>current</u> buffer of the writable stream 
            
            <strong>writableStream</strong>.write(<strong>chunk:any</strong><i>, encode:str, fn(err)</i>)               // writes a data chunk in the internal buffer memory
                                                                                  the callback function is fired once the data successfully flushed in the underlying system <u>(if an error occurs the callback function is NOT garanteed to fire)</u>   
                                                                                  returns <mark>true</mark> if the data chunk size is smaller than the buffer size specified by the <mark>highWaterMark</mark> when the stream was created
                                                                                  returns <mark>false</mark> if the data chunk is bigger t<mark>highWaterMark</mark> and fires the <mark>drain</mark> event 
                                                                                  returns <mark>false</mark> if the stream is not draining
            
            <strong>writableStream</strong>.end(<i>chunk:any, encode:str, fn</i>)                      // signals that no more data will be written to the stream and emits the 'finish' event (optionally writes a last chunk)   
                - <strong>chunk:any</strong> : data to write (string | Buffer | Uint8Array for normal stream, any (except null) for sterams operating in object mode)   
                - <i>encode:str</i> : encoding if the data is a string (object mode streams ignore this)
                - <i>fn(err)</i> : callback function fires when the data is fulshed <u style="color:orange;">error NOT called reliably! (accodring to Node.js.org)</u>
            
            <strong>writableStream</strong>.setDefaultEncoding(<strong>encode:str</strong>)                      // sets the default encoding for the writable stream and returns the stream itself   
            
            <strong>writableStream</strong>.destroy(<i>error:str</i><small>, function(<i>err</i>)</small>)                   // immediately destroys the stream <u>(destroys pending data)</u> and emits the <mark>close</mark> event 
                                                                                  returns the stream itself 
                                                                                  optionally throws a custom error what can be handled directly in the callback function <u>(this is not in the Node.js specification but it works fine)</u> or by the <mark>error</mark> event listener   
                                                                                  if an error is passed the <mark>close</mark> event is not emitted    
    </pre>
    <pre>
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
        
// setDefaultEncoding ---------------------------------------------------------
    writeStream.setDefaultEncoding('utf-8');                                   // -> WriteStream{ ... }   // sets the default encoding and returns the stream itself   
    
// write() / end() ------------------------------------------------------------
    writeStream.write('some data', 'utf-8',                                    // -> true                 // data written to the stream  // -! false returned when the buffer size exceeded and the 'drain' event emitted   
        function(){});                                                         // callback function fired after successfull drain 
    writeStream.end();                                                         // -> WriteStream{ ... }   // no more data will be written to the stream, 'finish' event emitted   // -! we could pass a last data chunk to the stream just like the 'write()' method    
                                                                               // -! try to write the stream after 'end()' will throw an error 
// destroy() ------------------------------------------------------------------
    writeStream.destroy('someERROR', function(err){                            // -> WriteStream{ ... }   // immediately destroys the stream (destroys the peding data)    
        err;                                                                   // -> 'someERROR'          // the passed error handled here (error can be handled by the 'error' event listener too)
    });                                                           
    
// writableBuffer -------------------------------------------------------------
    writableStream.writableBuffer;                                             // -> [{...}]              // returns the current buffer 
    </pre>
<details class="example">
<summary> Example : </summary>
<h3 style="color:darkblue;"><u> <mark>writableBuffer</mark> TEST </u></h3>
    <p style="color:yellow;"> - for some reson the first chunk is not displayed in the buffer</p>
    <pre style="margin-bottom:1px;">
    const fs = require('fs');var {fork} = require('child_process');
    var writeStream = fs.createWriteStream('write.txt');    
        
    writeStream.write('1st line \n', 'utf8');                                  // writing on the stream 
    writeStream.write('2nd line \n', 'utf8');
    writeStream.end('last line','utf8');
    
    console.log( writeStream.writableBuffer );
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\My Site\03 improuve\learn Webdesign\04 node.js\stream\01 writableBuffer TEST> node main
        [
        {
            chunk: &lt;Buffer 32 6e 64 20 6c 69 6e 65 20 0a&gt;,                     // -! '2nd line \n'
            encoding: 'buffer',
            isBuf: true,
            callback: [Function: nop],
            next: {
            chunk: &lt;Buffer 6c 61 73 74 20 6c 69 6e 65&gt;,                        // -! '3rd line \n'
            encoding: 'buffer',
            isBuf: true,
            callback: [Function: nop],
            next: null
            }
        },
        {
            chunk: &lt;Buffer 6c 61 73 74 20 6c 69 6e 65&gt;,                        // -! '3rd line \n'
            encoding: 'buffer',
            isBuf: true,
            callback: [Function: nop],
            next: null
        }
        ]
    PS D:\safe\code +\My Site\03 improuve\learn Webdesign\04 node.js\stream\01 writableBuffer TEST>    
    </pre>
<!--------------------------------------------------------------------------------------------------------->
<hr>
<h3 style="color:darkblue;"><u> <mark>write()</mark> / <mark>end()</mark> TEST </u></h3>
    <p style="color:yellow;"> - the 'drain' event does not fire when I use the 'end()' method to finish the stream for some reason [TESTED 2019-27] </p>
    <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    
    var dummyText = 'ontrary to popular...'                                    // text is longer than 16Kb (larger than the defautl buffer size)
    
// events ---------------------------------------------------------------------
    writeStream.on('drain', function(){                                        // !! event fires only when I don't use the 'end()' method for some reason (data chunk larger than de default buffer size)   
        console.log( 'drain event called!' );
    });
    writeStream.on('finish', function(){                                       // event is called by the 'end()' method when it finished writing 
        console.log( 'finish event called!' );
    })
    
// writing data to the writable stream ----------------------------------------
    console.log(                                                               // -> true   // because the data chunk is smaller than 16kb 
        writeStream.write('some text', 'utf-8', function(){ 
            console.log( 'first data chunk successfully streamed!' );          // callback function fires when the method finishes writing the data 
        }));
    
    console.log( writeStream.write(dummyText) );                               // -> false  // because the data chunk is larger than 16kb 
    
    writeStream.end('last piece of data', 'utf-8', function(){
        console.log( 'streaming finished!' );                                  // callback function fires when the method finishes writing the data 
    });
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\My Site\03 improuve\learn Webdesign\04 node.js\stream\02 write() end() TEST> node main
        true                                                                   // -! writeStream.write()        (first)
        false                                                                  // -! writeStream.write()        (second)
        first data chunk successfully streamed!                                // -! callback function of the first 'write()' method 
        finish event called!                                                   // 'finish' event called 
        streaming finished!                                                    // -! callback function ot the 'end()' method 
    PS D:\safe\code +\My Site\03 improuve\learn Webdesign\04 node.js\stream\02 write() end() TEST>    
    </pre>
<!--------------------------------------------------------------------------------------------------------->
<hr>
<h3 style="color:darkblue;"><u> <mark>setDefaultEncoding()</mark> / <mark>destroy()</mark> TEST </u></h3>
    <pre style="margin-bottom:1px;">
const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
        
    writeStream.on('close', function(){                                        // this would fire if there wouldn't be an error passed to the 'destroy()' method 
        console.log( 'stream has closed!' );
    });
    writeStream.on('error', function(err){                                     // handles the passed error (error must be handled otherwise an exception is thrown by Node) 
        console.log( err );
    });
        
    console.log( writeStream.setDefaultEncoding('utf-8') );                    // sets the default encoding and returns the stream itself 
    
    writeStream.write('some data \n');
    writeStream.destroy('destroyed!');                                         // destroys the stream immediately and passes ane error message  
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 Node.js\stream\03 defaultEncoding() destroy() TEST> node main
        WriteStream { ... }                                                    // returned by the 'setDefaultEncoding' method 
        destroyed!                                                             // -! returned error message 
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 Node.js\stream\03 defaultEncoding() destroy() TEST>    
    </pre>
<!--------------------------------------------------------------------------------------------------------->
<hr>
<h3 style="color:darkblue;"><u> <mark>destroy()</mark> callback function handles the thrown error TEST </u></h3>
    <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');
    
    writeStream.destroy('myError', function(err){
        console.log( "error thrown = " + err);                                 // we can handle the thrown error here 
    });                                                                        // -! this is not in the Node.js specification but it works fine!
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\writable streams\03.1 destroy() callback function handles the thrown error TEST> node main
        error thrown = myError
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\writable streams\03.1 destroy() callback function handles the thrown error TEST>    
    </pre>
</details>
<!--------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue;"><u> <mark>cork()</mark> / <mark>uncork()</mark> methods </u></h2>
    <pre class="syntax">
SYNTAX:     <strong>writableStream</strong>.cork()                                              // data chunks written after this method will be forces to be buffered in the stream buffer memory 
                                                                                  data is kept in the memory utill eigther the <mark>uncork()</mark> or the <mark>end()</mark> method flushes it in the underlying system)
            <strong>writableStream</strong>.uncork()                                            // flushes all data from the buffer to the underlying system since the <mark>cork()</mark> method (this method must be called the number of times the <mark>cork()</mark> method was called)    
    </pre>
    <pre>
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    
    writeStream.cork();                                                        // from this point all written data will be kept and stored in the buffer (nothing is written in the underlying system!)    
        writeStream.write('some data');                                            // writing data in the buffer 
        writeStream.write('some other data');
    writeStream.uncork();                                                      // flushes all data from the buffer in the underlying system since the 'cork()' method  // -! if this is omitted the data is never written to the target, the 'end()' method aslo flushes the data  
    writeStream.writableBuffer;                                                // -> []        // buffer empty because the above method flushed the data in the underlying system  
    </pre>
<details class="example">
<summary> Example : </summary>
<h3 style="color:darkblue;"><u> <mark>cork()</mark> / <mark>uncork()</mark> TEST </u></h3>
    <pre style="margin-bottom:1px;">
    writeStream.cork();                                                        // all data from this point will be buffered in the stream buffer memory 
        writeStream.write(' first data ');
        writeStream.write(' second data ');
        console.log( writeStream.writableBuffer );
    writeStream.uncork();
        console.log( writeStream.writableBuffer );                             // at this point the buffer is empty 
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 Node.js\stream\04 cork() uncork() TEST> node main
    [{                                                                         // -! writableStream.writableBuffer (first)
        chunk: &lt;Buffer 20 66 69 72 73 74 20 64 61 74 61 20&gt;,
        encoding: 'buffer',
        isBuf: true,
        callback: [Function: nop],
        next: {
        chunk: &lt;Buffer 20 73 65 63 6f 6e 64 20 64 61 74 61 20&gt;,
        encoding: 'buffer',
        isBuf: true,
        callback: [Function: nop],
        next: null
    }},
    {
        chunk: &lt;Buffer 20 73 65 63 6f 6e 64 20 64 61 74 61 20&gt;,
        encoding: 'buffer',
        isBuf: true,
        callback: [Function: nop],
        next: null
    }]
    []                                                                         // -! writableStream.writableBuffer (second) Empty because the data is flused in the file    
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 Node.js\stream\04 cork() uncork() TEST>    
    </pre>
<!--------------------------------------------------------------------------------------------------------->
<hr>
<h3 style="color:darkblue;"><u> <mark>cork()</mark> / <mark>uncork()</mark> TEST-2 </u></h3>
    <p> - I generate some content for 10 seconds and after that I'll flush all data in the file, during that 10 seconds nothing is written in the file since the data is kept in the buffer </p>
    <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    
    writeStream.cork();                                                        // all data from this point will be kept in the buffer 
    var currentInterval = setInterval(function(){                              // we generate some content for 10 seconds
        if(currentInterval._idleStart > 10000) {
            writeStream.uncork();                                              // after 10 seconds we flush the data from the buffer to the file 
            clearInterval(currentInterval);                                     
        } else {
            writeStream.write( 'generated data \n' );
        }    
    }, 250);
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\05 cork() uncork() TEST 2> node main
        // we wait 10 seconds for the program to finish (during these 10 seconds the 'write.txt' file is not written) 
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\05 cork() uncork() TEST 2>
    </pre>
<!--------------------------------------------------------------------------------------------------------->
<hr>
<h3 style="color:darkblue;"><u> overflow buffer size TEST </u></h3>
    <p> - in this test I overflowed the buffer like more than 10 times than the buffer size, I expected some data loss but it never occured </p>
    <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    
    writeStream.on('drain', function(){                                        // drain even fires only once (and at the end of the data flush apparently, that's also something what is strange here what kind of contol gives it like that)   
        console.log( 'drain event fired!' );
    })
    
    var data = 10;
    writeStream.cork();
    var currentInterval = setInterval(function(){
        if(currentInterval._idleStart > 10000) {
            writeStream.uncork();                                              // at this point a 400000 character string is flushed in the file (I expected that the lates data will override the previouses but it didn't happened)
            clearInterval(currentInterval);
        } else {
            data ++
            var printData = ((data * 100).toString() + ' ').repeat(2000);      // this generates a 10000 character string every time 
            writeStream.write( printData ); 
        }    
    }, 250);
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\06 overflow buffer size TEST> node main
        drain event fired!                                                     // fires right before the program closes (I expected to fire this as soon as the buffer overflows)
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\06 overflow buffer size TEST>    
    </pre>
</details>
<!--------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue;"><u> <mark>writable</mark> / <mark>writableLength</mark> / <mark>writableHighWaterMark</mark> / <mark>writableObjectMode</mark> promeprties  </u></h2>
    <pre class="syntax">
SYNTAX:     <strong>writableStream</strong>.writable                                            // returns <mark>true</mark> if it's safe to call the <mark>write()</mark> method   
            <strong>writableStream</strong>.writableLength                                      // returns the number of bytes (or objects if the stream is in object mode) in the buffer memory queue    
            
            <strong>writableStream</strong>.writableHighWaterMark                               // returns the value of the <mark>HighWaterMark</mark> when the stream was constructed (default: 16384)   
            
            <strong>writableStream</strong>.writableObjectMode                                  // returns a boolean indicating if the stream is operating in object mode   
    </pre>
    <pre>
const fs = require('fs');
var writeStream = fs.createWriteStream('write.txt');    
    
// writableObjectMode / writableHighWaterMark ------------------------------------------
    writeStream.writableObjectMode;                                            // -> false    // stream is not operating in object mode  
    writeStream.writableHighWaterMark;                                         // -> 16384    // buffer memory size 
    
// writableLenth / writable ---------------------------------------------------
    writeStream.write('write some data to the stream');
    writeStream.writableLength;                                                // -> 29       // 29 bytes are currently in the buffer memory 
    writeStream.writable;                                                      // -> true     // it is safe to call the 'write()' method again   // -! I tested this below with overflowing buffer memory but it still returned true [2019-06-29]    
    </pre>
<details class="example">
<summary> Example : </summary>
<h3 style="color:darkblue;"><u> <mark>writable</mark> TEST </u></h3>
    <p style="color:yellow;"> - I don't know when the <mark>writable</mark> property should return false, in this test even when the buffer memory oferflows it still returns true </p>
    <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
        
    console.log( writeStream.writable );                                       // -> true 
    var dummyText = "is simply dummy text ..."                                 // 67207 character long text 
    
    writeStream.cork();
    writeStream.write(dummyText);                                              // the buffer memory is definietly overflown here (I tested even the 'drain' event fires but still the 'writable' property returns false)    
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    // writeStream.uncork();                                                   // with or without 'uncork()' the 'writable' property returns true (I don't know why)
        
    console.log( writeStream.writable );                                       // -> true 
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\07 writable TEST> node main
        true                                                                   // -! writeStream.writable (first)
        true                                                                   // -! writeStream.writable (second)
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\07 writable TEST>    
    </pre>
<!--------------------------------------------------------------------------------------------------------->
<hr>
<h3 style="color:darkblue;"><u> <mark>writableLength</mark> / <mark>writableHighWaterMark</mark> TEST </u></h3>
    <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    
        console.log( writeStream.writableHighWaterMark );                      // return the buffer size basically 
    
        console.log( writeStream.writableLength );                             // -> 0          // empty becuase nothing is written on the buffer yet 
    writeStream.write('first text \n');                             
        console.log( writeStream.writableLength );                             // -> 12         
    writeStream.cork();
    writeStream.write('second text \n')
    writeStream.write('third text \n')
        console.log( writeStream.writableLength );                             // -> 37
    writeStream.uncork();                                                      // this should flush the buffer memory 
        console.log( writeStream.writableLength );                             // -> 37         // -! I expected here that the buffer memory if flushed but it's not 
        console.log( writeStream.writableBuffer );                             // -> [{...}]    // data is still in the buffer memory (I don't know why)  
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\08 writableLength writableHighWaterMark TEST> node main
        16384                                                                  // -! writableStream.writableHighWaterMark 
        0                                                                      // -! writableStream.writableLength  (first)
        12                                                                     // -! writableStream.writableLength  (second)
        37                                                                     // -! writableStream.writableLength  (third)
        37                                                                     // -! writableStream.writableLength  (fourth)
        [{                                                                     // -! buffer not flushed (in spite the 'uncork()' method was called)
            chunk: &lt;Buffer 73 65 63 6f 6e 64 20 74 65 78 74 20 0a&gt;,
            encoding: 'buffer',
            isBuf: true,
            callback: [Function: nop],
            next: {
            chunk: &lt;Buffer 74 68 69 72 64 20 74 65 78 74 20 0a&gt;,
            encoding: 'buffer',
            isBuf: true,
            callback: [Function: nop],
            next: null
            }
        },
        {
            chunk: &lt;Buffer 74 68 69 72 64 20 74 65 78 74 20 0a&gt;,
            encoding: 'buffer',
            isBuf: true,
            callback: [Function: nop],
            next: null
        }]
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\08 writableLength writableHighWaterMark TEST>    
    </pre>
<!--------------------------------------------------------------------------------------------------------->
<hr>
<h3 style="color:darkblue;"><u> <mark>writableObjectMode</mark> TEST </u></h3>
    <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    
    console.log( writeStream.writableObjectMode );                             // -> false         // stream is not in object mode 
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\09 writableObjectMode TEST> node main
        false                                                                  // -! writableStream.writableObjectMode 
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\09 writableObjectMode TEST>
    </pre>
</details>
<!--------------------------------------------------------------------------------------------------------->
<hr>
<h2 class="headerExtra"><u> Events </u></h2>
<h2 style="color:darkblue;"><u> <mark>close</mark> / <mark>finish</mark> events </u></h2>
    <pre class="syntax">
SYNTAX:     <strong>writableStream.listener</strong><em>(</em>'close', function()<em>)</em>                       // event emitted when the stream and the underlying recource is closed, indicates that no more events will be emitted and no further computation will occur  
            <strong>writableStream.listener</strong><em>(</em>'finish', function()<em>)</em>                      // event emitted when the <mark>end()</mark> method is called and the data is flushed to the underlying system     
    </pre>
    <pre>
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    

    writeStream.on('close', function(){ });                                    // event emitted in both situation because this indicates that no more event will happen in any situation 
    writeStream.on('finish', function(){ });                                   // -! event emited only when the stream is closed by the 'end()' method  
    
    writeStream.write(' write something to the stream' );
    writeStream.end();                                                         // this triggers both events
    // writableStream.destroy();                                               // this would trigger only the 'close' event 
    </pre>
<details class="example">
<summary> Example : </summary>
<h3 style="color:darkblue;"><u> <mark>close</mark> / <mark>finish</mark> events TEST </u></h3>
    <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    
    writeStream.on('finish', function(e){
        console.log( 'finish event called' );
    });
    writeStream.on('close', function(e){
        console.log( 'close event called' );
    });
    
    writeStream.write(' write some data ');
    // writeStream.end();                                                      // -! if we end the stream by this 'end()' method both events are called! 
    writeStream.destroy();    
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\10 close finish events TEST> node main
        close event called                                                     // -! the 'finish' event would be called if the stream ended by the 'end()' method  
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\10 close finish events TEST>    
    </pre>
</details>
<!--------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue;"><u> <mark>drain</mark> / <mark>error</mark> events </u></h2>
    <pre class="syntax">
SYNTAX:     <strong>writableStream.listener</strong><em>(</em>'drain' function()<em>)</em>                        // when the <mark>write()</mark> method returns <mark>false</mark> the stream buffer is overflown, once the buffer is freed up this event is emitted to signal that the stream can be written again    
            
            <strong>writableStream.listener</strong><em>(</em>'error' function(<strong>error</strong>)<em>)</em>                   // event emitted if an error occured while writing or piping the data <u>(the stream is NOT closed when this event is emitted)</u>
                                                                                  error event handler handles the thrown error by the stream (allowing the program to continue)
    </pre>
    <pre>   
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    
// drain ----------------------------------------------------------------------
    writeStream.on('drain', function(){ });                                    // the 'write()' method below overflows the buffer memory, once the buffer memory is freed up this event indicates that it's ok to write the stream again    
    write(' some string bigger than 16kb..' );                                 // pretend this string is longer than 16Kb, (overflows the maximum buffer memory)
        
// error ----------------------------------------------------------------------
    writeStream.on('error', function(error){                                   // listener handles the occured error    // -! handled error here wont' block the program 
        error;                                                                 // describes the occured error  
    });
    writeStream.write(41);                                                     // exception raised because the passed data is not a string (triggers the 'error' event)    
    </pre>
<details class="example">
<summary> Example : </summary>
<h3 style="color:darkblue;"><u> <mark>drain</mark> event TEST </u></h3>
    <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    
    writeStream.on('drain', function(){                                        // event emitted because we exceed the maximum buffer memory size
        console.log( 'drain event emitted' );
    });
    
    var dummyText = "Lorem Ipsum ..."                                          // 2865 character long text 
    
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    writeStream.write(dummyText);                                              // buffer memory overflows at this point (this calls the 'drain event')
        
    console.log( writeStream.writableLength );    
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\11 drain event TEST>  node main
        17190                                                                  // -! writeStream.writableLength
        drain event emitted                                                    // 'drain' event 
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\11 drain event TEST>    
    </pre>
<!--------------------------------------------------------------------------------------------------------->
<hr>
<h3 style="color:darkblue;"><u> <mark>error</mark> event TEST </u></h3>
    <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
        
    writeStream.on('error', function(err) {                                    // handles the raised error 
        console.log( err );
    });
    writeStream.on('close', function(){                                        // event never emitted because the stream is not closed  
        console.log( 'close event emitted!' );
    });
        
    writeStream.write(' some data ');
    writeStream.write( 415 );                                                  // raises an error because we cannot pass numbers 
    // writeStream.destroy( 'stream destroyed!' );                             // this wolud also trigger the 'error' event and print the passed argument as error 
        
    console.log( 'module fully loaded!' );                                     // monitoring if the program continues working (it does)
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\12 error event TEST> node main
        TypeError [ERR_INVALID_ARG_TYPE]: The "chunk" argument must be one of type string or Buffer. Received type number
            at validChunk (_stream_writable.js:265:10)
            at WriteStream.Writable.write (_stream_writable.js:299:21)
            at Object.<anonymous> (D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\12 error event TEST\main.js:9:13)
            at Module._compile (internal/modules/cjs/loader.js:774:30)
            at Object.Module._extensions..js (internal/modules/cjs/loader.js:785:10)
            at Module.load (internal/modules/cjs/loader.js:641:32)
            at Function.Module._load (internal/modules/cjs/loader.js:556:12)
            at Function.Module.runMain (internal/modules/cjs/loader.js:837:10)
            at internal/main/run_main_module.js:17:11
        module fully loaded!                                                   // !! because we handle the error the program can continue working 
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\12 error event TEST>    
    </pre>
    
    
    
</details>
<!--------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue;"><u> <mark>pipe</mark> / <mark>unpipe</mark> events </u></h2>
    <pre class="syntax">
SYNTAX:     <strong>writableStream.listener</strong><em>(</em>'pipe', function(<strong>readableStream</strong>)<em>)</em>          // event emitted when the <mark>pipe()</mark> method is called 
            <strong>writableStream.listener</strong><em>(</em>'unpipe', function(<strong>readableStream</strong>)<em>)</em>        // event emited when the <mark>unpipe()</mark> method is called 
                                                                                  emitted when the writable stream emits an error during piping
                                                                                  emitted when when the writable stream is unpiped <u style="color:orange;">(this is not in the Node.js specification but in my test this is clearly the case! [2019-07-12])</u>   
    </pre>
    <pre>
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    var readStream = fs.createReadStream('read.txt');    
    
    writeStream.on('pipe', function(stream){                                   // called with the 'pipe()' method
        stream;                                                                // -> ReadStream{...}       // this readable stream 
    });
    writeStream.on('unpipe', function(stream){                                 // -! 'unpipe()' method never called   
        stream;                                                                // -> ReadStream{...}       // this readable stream 
    });
    
    readStream.pipe(writeStream);
                                                                               // -! 'unpipe()' method never called 
    </pre>
<details class="example">
<summary> Example : </summary>
<h3 style="color:darkblue;"><u> <mark>pipe</mark> / <mark>unpipe</mark> events TEST </u></h3>
    <p style="color:yellow;"> - for some very strange reason the <mark>unpipe</mark> event is emitted in this test without calling the <mark>unpipe()</mark> method, I don't know why [TESTED 2019-06-29] </p>
    <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    var readStream = fs.createReadStream('read.txt');
    
    writeStream.on('pipe', function(stream){
        console.log( 'pipe event emitted' );
    });
    writeStream.on('unpipe', function(stream){                                 // !! I never call teh 'unpipe()' method but this event is emitted??? 
        console.log( 'unpipe event emitted' );
    });
    
    readStream.pipe(writeStream);                                              // piping data 
                                                                               // !! 'unpipe()' method is NOT called
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\13 pipe unpipe events TEST> node main
        pipe event emitted
        unpipe event emitted                                                   // !! 'unpipe' event is clearly NOT called here (WTF)
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\13 pipe unpipe events TEST>    
    </pre>
</details>

    <br><br>
</body>
</html>