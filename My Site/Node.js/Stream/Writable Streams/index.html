<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title> Writable Streams </title>
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <link rel="stylesheet" href="../../../Assets/stylesPages.css">
  <script src="../../../Assets/scriptPages.js"></script>
</head>

<body>
  <h1> Writable Streams </h1>
  <p> Updated ( 2019-07-12 / 2024-02-11 )</p>
    <nav class="sitenav">
      <a href="../../../index.html">MySite > </a>
      <a href="../../index.html">Node.js > </a>
      <a href="../index.html">Streams > </a> Writable Streams
    </nav>
  <table class="table">
    <tr>
      <th style="width:30%;"> Method / Property </th>
      <th> Description </th>
    </tr>
    <tr>
      <td id="write"> <strong>writableStream</strong>.write(<strong>chunk:any</strong><i>, encode:str, fn(err)</i>) </td>
      <td>
        - writes a data chunk in the internal buffer memory <br>
        - the callback function is fired once the data successfully flushed in the underlying system <u>(if an error occurs the callback function is NOT garanteed to fire)</u><br>
        - returns <mark>true</mark> if the data chunk size is smaller than the buffer size specified by the <mark>highWaterMark</mark> when the stream was created <br>
        - returns <mark>false</mark> if the data chunk is bigger than <mark>highWaterMark</mark> and fires the <mark>drain</mark> event<br>
        <span id="browserSupport" title="updated : 2019-06-27">
          <span><i class="fab fa-node-js"></i> 0.9.4 </span>
          <span><i class="fab fa-node-js"></i> 8.0.0 Uint8Array </span>
        </span>
      </td>
    </tr>
    <tr>
      <td id="end"> <strong>writableStream</strong>.end(<optval>chunk:any, encode:str, fn</optval>) </td>
      <td>
        - signals that no more data will be written to the stream and emits the <mark>finish</mark> event (optionally writes a last chunk)
        <span id="browserSupport" title="updated : 2019-06-27">
          <span><i class="fab fa-node-js"></i> 0.9.4 </span>
          <span><i class="fab fa-node-js"></i> 8.0.0 Uint8Array </span>
          <span><i class="fab fa-node-js"></i> 10.0.0 retuns the Stream </span>
          <span><i class="fab fa-node-js"></i> 15.0.0 callback invoked before 'finish' or 'error' emitted </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td> <strong>writableStream</strong>.setDefaultEncoding(<strong>encode:str</strong>) </td>
      <td>
        - sets the default encoding for the stream and returns the stream itself
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 0.11.15 </span>
          <span><i class="fab fa-node-js"></i> 6.1.0 returns the Stream </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td id="cork"> <strong>writableStream</strong>.cork() </td>
      <td>
        - causes the written data to be kept in the internal buffer (prevents writing the data to the underlying system) <br>
        - the data is kept in memory utill eigther the <mark>uncork()</mark> or the <mark>end()</mark> method is called (flushes the data to the underlying system)
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 0.11.2 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td id="uncork"> <strong>writableStream</strong>.uncork() </td>
      <td>
        - flushes all data from the buffer to the underlying system <br>
        - must be called as many times as the <mark>cork()</mark> method previously was called
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 0.11.2 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td> <strong>writableStream</strong>.writableHighWaterMark </td>
      <td>
        - returns the value of the <mark>HighWaterMark</mark> when the stream was created (default: 16384)
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 9.3.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td> <strong>writableStream</strong>.writableLength </td>
      <td>
        - returns the current number of byes in the buffer <br>
        - in object mode returns the number of objects
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 9.4.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td id="destroy"> <strong>writableStream</strong>.destroy(<i>error:str</i><small>, function(<i>err</i>)</small>) </td>
      <td>
        - immediately destroys the stream <u>(destroys all pending data)</u> and emits the <mark>close</mark> event <br>
        - returns the stream itself<br>
        - optionally throws a custom error what can be handled directly in the callback function <br>
        - if an error is passed the <mark>close</mark> event is not emitted
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 8.0.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td> <strong>writableStream</strong>.writable </td>
      <td> 
        - returns <mark>true</mark> if it's safe to call the <mark>write()</mark> method (if the stream was not destroeyd or errored)
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 11.4.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td> <strong>writableStream</strong>.writableObjectMode </td>
      <td>
        - returns <mark>true</mark> if the stream operates in object mode, <mark>false</mark> otherwise
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 12.3.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td> <strong>writableStream</strong>.close </td>
      <td>
        - returns <mark>true</mark> if the <mark>close</mark> event was emitted, <mark>false</mark> otherwise
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 18.0.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td> <strong>writableStream</strong>.destroyed </td>
      <td>
        - returns <mark>true</mark> if the stream was destroyed, <mark>false</mark> otherwise
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 8.0.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td> <strong>writableStream</strong>.writableEnded </td>
      <td>
        - returns <mark>true</mark> if the <mark>end()</mark> method was called, <mark>false</mark> otherwise <br>
        - doesn't necessary means the data is flushed to the underlying system
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 8.0.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td> <strong>writableStream</strong>.writableCorked </td>
      <td>
        - returns the number of time the stream was cored (the number of times we need to call <mark>uncork()</mark> in order to uncork the stream)
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 13.2.0 </span>
          <span><i class="fab fa-node-js"></i> 12.16.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td> <strong>writableStream</strong>.errored </td>
      <td>
        - returns the error if the stream was destroyed by error
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 18.0.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td> <strong>writableStream</strong>.writableFinished </td>
      <td>
        - returns <mark>true</mark> right before the <mark>finish</mark> event was emitted, <mark>false</mark> otherwise <br>
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 18.0.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td> <strong>writableStream</strong>.writableNeedDrain </td>
      <td>
        - returns <mark>true</mark> if the stream buffer is full and the <mark>drain</mark> event was emitted, <mark>false</mark> otherwise <br>
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 15.2.0 </span>
          <span><i class="fab fa-node-js"></i> 14.7.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td colspan="2"> Events </td>
    </tr>
    <tr>
      <td> <strong>writableStream.listener</strong>('close', <reqval>fn</reqval>) </td>
      <td>
        - emitted when the stream and the underlying recource is closed, indicates that no more events will be emitted and no further computation will occur
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 0.9.4 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td> <strong>writableStream.listener</strong>('finish', <reqval>fn</reqval>)</td>
      <td>
        - event emitted when the <mark>end()</mark> method is called and the data is flushed to the underlying system
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 0.9.4 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td> <strong>writableStream.listener</strong>('pipe', <strong>fn(readableStream)</strong>) </td>
      <td>
        - event emitted when the <mark>pipe()</mark> method is called
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 0.9.4 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td> <strong>writableStream.listener</strong>('unpipe', <strong>fn(readableStream)</strong>) </td>
      <td>
        - event emited when the <mark>unpipe()</mark> method is called <br>
        - emitted when the <reqval>writableStream</reqval> emits an error during piping <br>
        - emitted when the <reqval>writableStream</reqval> is unpiped
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 0.9.4 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td> <strong>writableStream.listener</strong>('drain' <strong>fn</strong>) </td>
      <td>
        - when the <mark>write()</mark> method returns <mark>false</mark> (the stream buffer HighWaterMark is overflown), once the buffer is freed up this event is emitted to signal that the stream can be written again
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 0.9.4 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td> <strong>writableStream.listener</strong>('error' <strong>fn(error)</strong> </td>
      <td>
        - event emitted when an error occured while writing the stream <u>(not indication that the stream is closed)</u> <br>
        - error event handler handles the thrown error by the stream (allowing the program to continue)
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 0.9.4 </span>
        </span>
      </td>
    </tr>
  </table>
  <h2 class="headerSection"> Notes : </h2>
  
  <h2 class="headerSection"> Useful Links : </h2>
  <h2 class="headerSection"> Remember This : </h2>
  <h2 class="headerSection"> Description and Demonstration : </h2>
  <p> - a Writable stream is an abstraction of a destination </p>




  <!--------------------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="headerExtra">
    <h2 class="headerExtra"><u> Methods and Properties </u></h2>
    <h3 class="header"> The <mark>write()</mark> / <mark>end()</mark> / <mark>setDefaultEncoding()</mark> / <mark>destroy()</mark> methods </h3>
    <details class="example">
      <summary> Example : </summary>
      <pre>
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
        
// setDefaultEncoding ---------------------------------------------------------
    writeStream.setDefaultEncoding('utf-8');                                   // -> WriteStream{ ... }   // sets the default encoding and returns the stream itself   
    
// write() / end() ------------------------------------------------------------
    writeStream.write('some data', 'utf-8',                                    // -> true                 // data written to the stream  // -! false returned when the buffer size exceeded and the 'drain' event emitted   
        function(){});                                                         // callback function fired after successfull drain 
    writeStream.end();                                                         // -> WriteStream{ ... }   // no more data will be written to the stream, 'finish' event emitted   // -! we could pass a last data chunk to the stream just like the 'write()' method    
                                                                               // -! try to write the stream after 'end()' will throw an error 
// destroy() ------------------------------------------------------------------
    writeStream.destroy('someERROR', function(err){                            // -> WriteStream{ ... }   // immediately destroys the stream (destroys the peding data)    
        err;                                                                   // -> 'someERROR'          // the passed error handled here (error can be handled by the 'error' event listener too)
    });                                                           
    
// writableBuffer -------------------------------------------------------------
    writableStream.writableBuffer;                                             // -> [{...}]              // returns the current buffer 
    </pre>
      <h3 style="color:darkblue;"><u> <mark>writableBuffer</mark> TEST </u></h3>
      <p style="color:yellow;"> - for some reson the first chunk is not displayed in the buffer</p>
      <pre style="margin-bottom:1px;">
    const fs = require('fs');var {fork} = require('child_process');
    var writeStream = fs.createWriteStream('write.txt');    
        
    writeStream.write('1st line \n', 'utf8');                                  // writing on the stream 
    writeStream.write('2nd line \n', 'utf8');
    writeStream.end('last line','utf8');
    
    console.log( writeStream.writableBuffer );
    </pre>
      <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\My Site\03 improuve\learn Webdesign\04 node.js\stream\01 writableBuffer TEST> node main
        [
        {
            chunk: &lt;Buffer 32 6e 64 20 6c 69 6e 65 20 0a&gt;,                     // -! '2nd line \n'
            encoding: 'buffer',
            isBuf: true,
            callback: [Function: nop],
            next: {
            chunk: &lt;Buffer 6c 61 73 74 20 6c 69 6e 65&gt;,                        // -! '3rd line \n'
            encoding: 'buffer',
            isBuf: true,
            callback: [Function: nop],
            next: null
            }
        },
        {
            chunk: &lt;Buffer 6c 61 73 74 20 6c 69 6e 65&gt;,                        // -! '3rd line \n'
            encoding: 'buffer',
            isBuf: true,
            callback: [Function: nop],
            next: null
        }
        ]
    PS D:\safe\code +\My Site\03 improuve\learn Webdesign\04 node.js\stream\01 writableBuffer TEST>    
    </pre>
      <!--------------------------------------------------------------------------------------------------------->
      <hr>
      <h3 style="color:darkblue;"><u> <mark>write()</mark> / <mark>end()</mark> TEST </u></h3>
      <p style="color:yellow;"> - the 'drain' event does not fire when I use the 'end()' method to finish the stream for some reason [TESTED 2019-27] </p>
      <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    
    var dummyText = 'ontrary to popular...'                                    // text is longer than 16Kb (larger than the defautl buffer size)
    
// events ---------------------------------------------------------------------
    writeStream.on('drain', function(){                                        // !! event fires only when I don't use the 'end()' method for some reason (data chunk larger than de default buffer size)   
        console.log( 'drain event called!' );
    });
    writeStream.on('finish', function(){                                       // event is called by the 'end()' method when it finished writing 
        console.log( 'finish event called!' );
    })
    
// writing data to the writable stream ----------------------------------------
    console.log(                                                               // -> true   // because the data chunk is smaller than 16kb 
        writeStream.write('some text', 'utf-8', function(){ 
            console.log( 'first data chunk successfully streamed!' );          // callback function fires when the method finishes writing the data 
        }));
    
    console.log( writeStream.write(dummyText) );                               // -> false  // because the data chunk is larger than 16kb 
    
    writeStream.end('last piece of data', 'utf-8', function(){
        console.log( 'streaming finished!' );                                  // callback function fires when the method finishes writing the data 
    });
    </pre>
      <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\My Site\03 improuve\learn Webdesign\04 node.js\stream\02 write() end() TEST> node main
        true                                                                   // -! writeStream.write()        (first)
        false                                                                  // -! writeStream.write()        (second)
        first data chunk successfully streamed!                                // -! callback function of the first 'write()' method 
        finish event called!                                                   // 'finish' event called 
        streaming finished!                                                    // -! callback function ot the 'end()' method 
    PS D:\safe\code +\My Site\03 improuve\learn Webdesign\04 node.js\stream\02 write() end() TEST>    
    </pre>
      <!--------------------------------------------------------------------------------------------------------->
      <hr>
      <h3 style="color:darkblue;"><u> <mark>setDefaultEncoding()</mark> / <mark>destroy()</mark> TEST </u></h3>
      <pre style="margin-bottom:1px;">
const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
        
    writeStream.on('close', function(){                                        // this would fire if there wouldn't be an error passed to the 'destroy()' method 
        console.log( 'stream has closed!' );
    });
    writeStream.on('error', function(err){                                     // handles the passed error (error must be handled otherwise an exception is thrown by Node) 
        console.log( err );
    });
        
    console.log( writeStream.setDefaultEncoding('utf-8') );                    // sets the default encoding and returns the stream itself 
    
    writeStream.write('some data \n');
    writeStream.destroy('destroyed!');                                         // destroys the stream immediately and passes ane error message  
    </pre>
      <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 Node.js\stream\03 defaultEncoding() destroy() TEST> node main
        WriteStream { ... }                                                    // returned by the 'setDefaultEncoding' method 
        destroyed!                                                             // -! returned error message 
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 Node.js\stream\03 defaultEncoding() destroy() TEST>    
    </pre>
      <!--------------------------------------------------------------------------------------------------------->
      <hr>
      <h3 style="color:darkblue;"><u> <mark>destroy()</mark> callback function handles the thrown error TEST </u></h3>
      <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');
    
    writeStream.destroy('myError', function(err){
        console.log( "error thrown = " + err);                                 // we can handle the thrown error here 
    });                                                                        // -! this is not in the Node.js specification but it works fine!
    </pre>
      <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\writable streams\03.1 destroy() callback function handles the thrown error TEST> node main
        error thrown = myError
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\writable streams\03.1 destroy() callback function handles the thrown error TEST>    
    </pre>
    </details>
    <!--------------------------------------------------------------------------------------------------------->
    <hr>
    <h3 class="header"> The <mark>cork()</mark> / <mark>uncork()</mark> methods </h3>
    <details class="example">
      <summary> Example : </summary>
      <h3 style="color:darkblue;"><u> <mark>cork()</mark> / <mark>uncork()</mark> TEST </u></h3>
      <pre>
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    
    writeStream.cork();                                                        // from this point all written data will be kept and stored in the buffer (nothing is written in the underlying system!)    
        writeStream.write('some data');                                            // writing data in the buffer 
        writeStream.write('some other data');
    writeStream.uncork();                                                      // flushes all data from the buffer in the underlying system since the 'cork()' method  // -! if this is omitted the data is never written to the target, the 'end()' method aslo flushes the data  
    writeStream.writableBuffer;                                                // -> []        // buffer empty because the above method flushed the data in the underlying system  
    </pre>
      <pre style="margin-bottom:1px;">
    writeStream.cork();                                                        // all data from this point will be buffered in the stream buffer memory 
        writeStream.write(' first data ');
        writeStream.write(' second data ');
        console.log( writeStream.writableBuffer );
    writeStream.uncork();
        console.log( writeStream.writableBuffer );                             // at this point the buffer is empty 
    </pre>
      <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 Node.js\stream\04 cork() uncork() TEST> node main
    [{                                                                         // -! writableStream.writableBuffer (first)
        chunk: &lt;Buffer 20 66 69 72 73 74 20 64 61 74 61 20&gt;,
        encoding: 'buffer',
        isBuf: true,
        callback: [Function: nop],
        next: {
        chunk: &lt;Buffer 20 73 65 63 6f 6e 64 20 64 61 74 61 20&gt;,
        encoding: 'buffer',
        isBuf: true,
        callback: [Function: nop],
        next: null
    }},
    {
        chunk: &lt;Buffer 20 73 65 63 6f 6e 64 20 64 61 74 61 20&gt;,
        encoding: 'buffer',
        isBuf: true,
        callback: [Function: nop],
        next: null
    }]
    []                                                                         // -! writableStream.writableBuffer (second) Empty because the data is flused in the file    
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 Node.js\stream\04 cork() uncork() TEST>    
    </pre>
      <!--------------------------------------------------------------------------------------------------------->
      <hr>
      <h3 style="color:darkblue;"><u> <mark>cork()</mark> / <mark>uncork()</mark> TEST-2 </u></h3>
      <p> - I generate some content for 10 seconds and after that I'll flush all data in the file, during that 10 seconds nothing is written in the file since the data is kept in the buffer </p>
      <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    
    writeStream.cork();                                                        // all data from this point will be kept in the buffer 
    var currentInterval = setInterval(function(){                              // we generate some content for 10 seconds
        if(currentInterval._idleStart > 10000) {
            writeStream.uncork();                                              // after 10 seconds we flush the data from the buffer to the file 
            clearInterval(currentInterval);                                     
        } else {
            writeStream.write( 'generated data \n' );
        }    
    }, 250);
    </pre>
      <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\05 cork() uncork() TEST 2> node main
        // we wait 10 seconds for the program to finish (during these 10 seconds the 'write.txt' file is not written) 
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\05 cork() uncork() TEST 2>
    </pre>
      <!--------------------------------------------------------------------------------------------------------->
      <hr>
      <h3 style="color:darkblue;"><u> overflow buffer size TEST </u></h3>
      <p> - in this test I overflowed the buffer like more than 10 times than the buffer size, I expected some data loss but it never occured </p>
      <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    
    writeStream.on('drain', function(){                                        // drain even fires only once (and at the end of the data flush apparently, that's also something what is strange here what kind of contol gives it like that)   
        console.log( 'drain event fired!' );
    })
    
    var data = 10;
    writeStream.cork();
    var currentInterval = setInterval(function(){
        if(currentInterval._idleStart > 10000) {
            writeStream.uncork();                                              // at this point a 400000 character string is flushed in the file (I expected that the lates data will override the previouses but it didn't happened)
            clearInterval(currentInterval);
        } else {
            data ++
            var printData = ((data * 100).toString() + ' ').repeat(2000);      // this generates a 10000 character string every time 
            writeStream.write( printData ); 
        }    
    }, 250);
    </pre>
      <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\06 overflow buffer size TEST> node main
        drain event fired!                                                     // fires right before the program closes (I expected to fire this as soon as the buffer overflows)
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\06 overflow buffer size TEST>    
    </pre>
    </details>
    <!--------------------------------------------------------------------------------------------------------->
    <hr>
    <h3 class="header"> The <mark>writable</mark> / <mark>writableLength</mark> / <mark>writableHighWaterMark</mark> / <mark>writableObjectMode</mark> promeprties </h3>
    <details class="example">
      <summary> Example : </summary>
      <pre>
const fs = require('fs');
var writeStream = fs.createWriteStream('write.txt');    
    
// writableObjectMode / writableHighWaterMark ------------------------------------------
    writeStream.writableObjectMode;                                            // -> false    // stream is not operating in object mode  
    writeStream.writableHighWaterMark;                                         // -> 16384    // buffer memory size 
    
// writableLenth / writable ---------------------------------------------------
    writeStream.write('write some data to the stream');
    writeStream.writableLength;                                                // -> 29       // 29 bytes are currently in the buffer memory 
    writeStream.writable;                                                      // -> true     // it is safe to call the 'write()' method again   // -! I tested this below with overflowing buffer memory but it still returned true [2019-06-29]    
    </pre>

      <h3 style="color:darkblue;"><u> <mark>writable</mark> TEST </u></h3>
      <p style="color:yellow;"> - I don't know when the <mark>writable</mark> property should return false, in this test even when the buffer memory oferflows it still returns true </p>
      <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
        
    console.log( writeStream.writable );                                       // -> true 
    var dummyText = "is simply dummy text ..."                                 // 67207 character long text 
    
    writeStream.cork();
    writeStream.write(dummyText);                                              // the buffer memory is definietly overflown here (I tested even the 'drain' event fires but still the 'writable' property returns false)    
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    // writeStream.uncork();                                                   // with or without 'uncork()' the 'writable' property returns true (I don't know why)
        
    console.log( writeStream.writable );                                       // -> true 
    </pre>
      <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\07 writable TEST> node main
        true                                                                   // -! writeStream.writable (first)
        true                                                                   // -! writeStream.writable (second)
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\07 writable TEST>    
    </pre>
      <!--------------------------------------------------------------------------------------------------------->
      <hr>
      <h3 style="color:darkblue;"><u> <mark>writableLength</mark> / <mark>writableHighWaterMark</mark> TEST </u></h3>
      <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    
        console.log( writeStream.writableHighWaterMark );                      // return the buffer size basically 
    
        console.log( writeStream.writableLength );                             // -> 0          // empty becuase nothing is written on the buffer yet 
    writeStream.write('first text \n');                             
        console.log( writeStream.writableLength );                             // -> 12         
    writeStream.cork();
    writeStream.write('second text \n')
    writeStream.write('third text \n')
        console.log( writeStream.writableLength );                             // -> 37
    writeStream.uncork();                                                      // this should flush the buffer memory 
        console.log( writeStream.writableLength );                             // -> 37         // -! I expected here that the buffer memory if flushed but it's not 
        console.log( writeStream.writableBuffer );                             // -> [{...}]    // data is still in the buffer memory (I don't know why)  
    </pre>
      <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\08 writableLength writableHighWaterMark TEST> node main
        16384                                                                  // -! writableStream.writableHighWaterMark 
        0                                                                      // -! writableStream.writableLength  (first)
        12                                                                     // -! writableStream.writableLength  (second)
        37                                                                     // -! writableStream.writableLength  (third)
        37                                                                     // -! writableStream.writableLength  (fourth)
        [{                                                                     // -! buffer not flushed (in spite the 'uncork()' method was called)
            chunk: &lt;Buffer 73 65 63 6f 6e 64 20 74 65 78 74 20 0a&gt;,
            encoding: 'buffer',
            isBuf: true,
            callback: [Function: nop],
            next: {
            chunk: &lt;Buffer 74 68 69 72 64 20 74 65 78 74 20 0a&gt;,
            encoding: 'buffer',
            isBuf: true,
            callback: [Function: nop],
            next: null
            }
        },
        {
            chunk: &lt;Buffer 74 68 69 72 64 20 74 65 78 74 20 0a&gt;,
            encoding: 'buffer',
            isBuf: true,
            callback: [Function: nop],
            next: null
        }]
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\08 writableLength writableHighWaterMark TEST>    
    </pre>
      <!--------------------------------------------------------------------------------------------------------->
      <hr>
      <h3 style="color:darkblue;"><u> <mark>writableObjectMode</mark> TEST </u></h3>
      <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    
    console.log( writeStream.writableObjectMode );                             // -> false         // stream is not in object mode 
    </pre>
      <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\09 writableObjectMode TEST> node main
        false                                                                  // -! writableStream.writableObjectMode 
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\09 writableObjectMode TEST>
    </pre>
    </details>
    <!--------------------------------------------------------------------------------------------------------->
    <hr>
    <h2 class="headerExtra"><u> Events </u></h2>
    <h3 class="header"> The <mark>close</mark> / <mark>finish</mark> events </h3>
    <details class="example">
      <summary> Example : </summary>
      <pre>
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    

    writeStream.on('close', function(){ });                                    // event emitted in both situation because this indicates that no more event will happen in any situation 
    writeStream.on('finish', function(){ });                                   // -! event emited only when the stream is closed by the 'end()' method  
    
    writeStream.write(' write something to the stream' );
    writeStream.end();                                                         // this triggers both events
    // writableStream.destroy();                                               // this would trigger only the 'close' event 
    </pre>
      <h3 style="color:darkblue;"><u> <mark>close</mark> / <mark>finish</mark> events TEST </u></h3>
      <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    
    writeStream.on('finish', function(e){
        console.log( 'finish event called' );
    });
    writeStream.on('close', function(e){
        console.log( 'close event called' );
    });
    
    writeStream.write(' write some data ');
    // writeStream.end();                                                      // -! if we end the stream by this 'end()' method both events are called! 
    writeStream.destroy();    
    </pre>
      <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\10 close finish events TEST> node main
        close event called                                                     // -! the 'finish' event would be called if the stream ended by the 'end()' method  
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\10 close finish events TEST>    
    </pre>
    </details>
    <!--------------------------------------------------------------------------------------------------------->
    <hr>
    <h3 class="header"> The <mark>drain</mark> / <mark>error</mark> events </h3>
    <details class="example">
      <summary> Example : </summary>
      <pre>
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    
// drain ----------------------------------------------------------------------
    writeStream.on('drain', function(){ });                                    // the 'write()' method below overflows the buffer memory, once the buffer memory is freed up this event indicates that it's ok to write the stream again    
    write(' some string bigger than 16kb..' );                                 // pretend this string is longer than 16Kb, (overflows the maximum buffer memory)
        
// error ----------------------------------------------------------------------
    writeStream.on('error', function(error){                                   // listener handles the occured error    // -! handled error here wont' block the program 
        error;                                                                 // describes the occured error  
    });
    writeStream.write(41);                                                     // exception raised because the passed data is not a string (triggers the 'error' event)    
    </pre>
      <h3 style="color:darkblue;"><u> <mark>drain</mark> event TEST </u></h3>
      <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    
    writeStream.on('drain', function(){                                        // event emitted because we exceed the maximum buffer memory size
        console.log( 'drain event emitted' );
    });
    
    var dummyText = "Lorem Ipsum ..."                                          // 2865 character long text 
    
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    writeStream.write(dummyText);
    writeStream.write(dummyText);                                              // buffer memory overflows at this point (this calls the 'drain event')
        
    console.log( writeStream.writableLength );    
    </pre>
      <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\11 drain event TEST>  node main
        17190                                                                  // -! writeStream.writableLength
        drain event emitted                                                    // 'drain' event 
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\11 drain event TEST>    
    </pre>
      <!--------------------------------------------------------------------------------------------------------->
      <hr>
      <h3 style="color:darkblue;"><u> <mark>error</mark> event TEST </u></h3>
      <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
        
    writeStream.on('error', function(err) {                                    // handles the raised error 
        console.log( err );
    });
    writeStream.on('close', function(){                                        // event never emitted because the stream is not closed  
        console.log( 'close event emitted!' );
    });
        
    writeStream.write(' some data ');
    writeStream.write( 415 );                                                  // raises an error because we cannot pass numbers 
    // writeStream.destroy( 'stream destroyed!' );                             // this wolud also trigger the 'error' event and print the passed argument as error 
        
    console.log( 'module fully loaded!' );                                     // monitoring if the program continues working (it does)
    </pre>
      <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\12 error event TEST> node main
        TypeError [ERR_INVALID_ARG_TYPE]: The "chunk" argument must be one of type string or Buffer. Received type number
            at validChunk (_stream_writable.js:265:10)
            at WriteStream.Writable.write (_stream_writable.js:299:21)
            at Object.<anonymous> (D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\12 error event TEST\main.js:9:13)
            at Module._compile (internal/modules/cjs/loader.js:774:30)
            at Object.Module._extensions..js (internal/modules/cjs/loader.js:785:10)
            at Module.load (internal/modules/cjs/loader.js:641:32)
            at Function.Module._load (internal/modules/cjs/loader.js:556:12)
            at Function.Module.runMain (internal/modules/cjs/loader.js:837:10)
            at internal/main/run_main_module.js:17:11
        module fully loaded!                                                   // !! because we handle the error the program can continue working 
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\12 error event TEST>    
    </pre>
    </details>
    <!--------------------------------------------------------------------------------------------------------->
    <hr>
    <h3 class="header"> The <mark>pipe</mark> / <mark>unpipe</mark> events </h3>
    <details class="example">
      <summary> Example : </summary>
      <pre>
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    var readStream = fs.createReadStream('read.txt');    
    
    writeStream.on('pipe', function(stream){                                   // called with the 'pipe()' method
        stream;                                                                // -> ReadStream{...}       // this readable stream 
    });
    writeStream.on('unpipe', function(stream){                                 // -! 'unpipe()' method never called   
        stream;                                                                // -> ReadStream{...}       // this readable stream 
    });
    
    readStream.pipe(writeStream);
                                                                               // -! 'unpipe()' method never called 
    </pre>
      <h3 style="color:darkblue;"><u> <mark>pipe</mark> / <mark>unpipe</mark> events TEST </u></h3>
      <p style="color:yellow;"> - for some very strange reason the <mark>unpipe</mark> event is emitted in this test without calling the <mark>unpipe()</mark> method, I don't know why [TESTED 2019-06-29] </p>
      <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    var readStream = fs.createReadStream('read.txt');
    
    writeStream.on('pipe', function(stream){
        console.log( 'pipe event emitted' );
    });
    writeStream.on('unpipe', function(stream){                                 // !! I never call teh 'unpipe()' method but this event is emitted??? 
        console.log( 'unpipe event emitted' );
    });
    
    readStream.pipe(writeStream);                                              // piping data 
                                                                               // !! 'unpipe()' method is NOT called
    </pre>
      <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\13 pipe unpipe events TEST> node main
        pipe event emitted
        unpipe event emitted                                                   // !! 'unpipe' event is clearly NOT called here (WTF)
    PS D:\safe\code +\my site\03 improuve\Learn webdesign\04 node.js\stream\13 pipe unpipe events TEST>    
    </pre>
    </details>

    <br><br>
</body>

</html>