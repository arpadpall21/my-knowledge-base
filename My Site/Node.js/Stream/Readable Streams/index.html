<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title> Readable Streams </title>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../../Assets/stylesPages.css">
    <script src="../../../Assets/scriptPages.js"></script>
  </head>

  <body>
    <h1> Readable Streams </h1>
    <p> Updated ( 2019-07-12 / 2024-03-11 )</p>
    <nav class="sitenav">
      <a href="../../../index.html">MySite > </a>
      <a href="../../index.html">Node.js > </a>
      <a href="../index.html">Streams > </a> Readable Streams
    </nav>
    <table class="table">
      <tr>
        <th style="width:30%;"> Method / Property </th>
        <th> Description </th>
      </tr>
      <tr>
        <td> <strong>readableStream</strong>.read(<i>chunkSize:nr</i>) </td>
        <td>
          - <u>(for stream in pause mode)</u> removes and returns a data chunk from the internal buffer <br>
          - emints the <mark>data</mark> event if successfully removes data from the buffer<br>
          - if there is no data available in the buffer returns <mark>null</mark>
          <span id="browserSupport" title="updated : 2019-07-09">
            <span><i class="fab fa-node-js"></i> 0.9.4 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <strong>readableStream</strong>.readableFlowing </td>
        <td>
          - indicates the state of <strong>readableStream</strong> <br>
          - <mark>null</mark> -> no mechanism consumes the provided data <br>
          - <mark>true</mark> -> Flowing <br>
          - <mark>false</mark> -> Paused
          <span id="browserSupport">
            <span><i class="fab fa-node-js"></i> 9.4.0 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td> <strong>readableStream</strong>.setEncoding(<i>encode:str</i>) </td>
        <td>
          - sets the character encoding for the read data <br>
          - ex: if <optval>encode</optval> set to <mark>utf8</mark> the read data will be utf8 encoded string (not <reqval>buf</reqval> which is the default)
          <span id="browserSupport" title="updated : 2019-07-09">
            <span><i class="fab fa-node-js"></i> 0.9.4 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td> <strong>readableStream</strong>.readableEncoding </td>
        <td>
          - returns the encoding of the stream
          <span id="browserSupport">
            <span><i class="fab fa-node-js"></i> 12.7.0 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <strong>readableStream</strong>.unshift(<strong>chunk:any</strong><i>, encode:str</i>) </td>
        <td>
          - pushes a chunk of data <u>in the internal buffer</u> <br>
          - pushing <mark>null</mark> signal the end of the stream <br>
          - cannot be called after the <mark>end</mark> event
          <span id="browserSupport" title="updated : 2019-07-09">
            <span><i class="fab fa-node-js"></i> 0.9.11 </span>
            <span><i class="fab fa-node-js"></i> 8.0.0 chunk can be Uint8Array </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <strong>readableStream</strong>.pause() </td>
        <td>
          - switches the <strong>readableStream</strong> in Paused mode (available data will remain in the buffer)
          <span id="browserSupport" title="updated : 2019-07-09">
            <span><i class="fab fa-node-js"></i> 0.9.4 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td> <strong>readableStream</strong>.isPaused() </td>
        <td>
          - returns <mark>true</mark> if the <strong>readableStream</strong> is in Paused mode, <mark>false</mark> otherwiser
          <span id="browserSupport" title="updated : 2019-07-09">
            <span><i class="fab fa-node-js"></i> 0.11.14 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td> <strong>readableStream</strong>.resume() </td>
        <td>
          - switches the <strong>readableStream</strong> in Flowing mode
          <span id="browserSupport" title="updated : 2019-07-09">
            <span><i class="fab fa-node-js"></i> 0.9.4 </span>
            <span><i class="fab fa-node-js"></i> 10.0.0 has no effect if the <mark>readable</mark> event listener is set </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <strong>readableStream</strong>.pipe(<strong>writableStream</strong>, <optval class="openable">option:obj<div>
              <p> <mark>end</mark>: <reqval>bool</reqval> -> ends the writable stream when the reader ends (Default: <mark>true</mark>) </p>
            </div></optval><small>) </td>
          <td>
            - pipes the data from <strong>readableStream</strong> to <strong>writableStream</strong> <br>
            - switches the <strong>readableStream</strong> into Readable mode and manages the data flow automatically<br>
            - returns the destination <strong>writableStream</strong>, this allows chaining multiple sources to the same destination <br>
            - if the <strong>readableStream</strong> throws an exception the writable stream is never closed!
            <span id="browserSupport" title="updated : 2019-07-09">
              <span><i class="fab fa-node-js"></i> 0.9.8 </span>
            </span>
          </td>
        </tr>
        <tr>
          <td> <strong>readableStream</strong>.unpipe(<i>writableStream</i>) </td>
          <td>
            - detaches all <optval>writableStram</optval> destination (no argument) or the specified one <br>
            - switches the <strong>readableStream</strong> into Paused mode <br>
            - returns the <strong>readableStream</strong> itself
            <span id="browserSupport">
              <span><i class="fab fa-node-js"></i> 0.9.4 </span>
            </span>
          </td>
        </tr>
        <tr>
          <td>|</td>
          <td></td>
        </tr>
        <tr>
          <td> <strong>readableStream</strong>.readableHighWaterMark </td>
          <td>
            - returns the streams <mark>HighWaterMark</mark> size (default: 65536)
            <span id="browserSupport" title="updated : 2019-07-10">
              <span><i class="fab fa-node-js"></i> 9.3.0 </span>
            </span>
          </td>
        </tr>
        <tr>
          <td> <strong>readableStream</strong>.readableLength </td>
          <td>
            - returns the current number of bytes in the buffer <br>
            - in object mode returns the number of objects
            <span id="browserSupport" title="updated : 2019-07-10">
              <span><i class="fab fa-node-js"></i> 9.4.0 </span>
            </span>
          </td>
        </tr>
        <tr>
          <td>|</td>
          <td></td>
        </tr>
        <tr>
          <td> <strong>readableStream</strong>.destroy(<i>error:str</i>, <reqval>fn(err)</reqval>) </td>
          <td>
            - immediately destroys the stream (with all pending data) <br>
            - emits the <mark>close</mark> event <br>
            - returns the stream itself <br>
            - optionally throws a custom error that can be handled directly in the callback function
            - if an error is passed the <mark>close</mark> event is not emitted
            <span id="browserSupport">
              <span><i class="fab fa-node-js"></i> 8.0.0 </span>
              <span><i class="fab fa-node-js"></i> 14.0.0 no-op behaviour if the stream is already destroyed </span>
            </span>
          </td>
        </tr>
        <tr>
          <td>|</td>
          <td></td>
        </tr>
        <tr>
          <td> <strong>readableStream</strong>.readable </td>
          <td>
            - returns <mark>true</mark> if it is safe to call the <mark>read()</mark> method (if the stream is not destroyed or errored)
            <span id="browserSupport" title="updated : 2019-07-10">
              <span><i class="fab fa-node-js"></i> 11.4.0 </span>
            </span>
          </td>
        </tr>
        <tr>
          <td> <strong>readableStream</strong>.readableObjectMode </td>
          <td>
            - returns <mark>true</mark> if the stream is in object mode, <mark>false</mark> otherwise
            <span id="browserSupport" title="updated : 2019-07-10">
              <span><i class="fab fa-node-js"></i> 12.3.0 </span>
            </span>
          </td>
        </tr>
        <tr>
          <td> <strong>readableStream</strong>.destroyed </td>
          <td>
            - returns <mark>true</mark> if the <mark>destroy()</mark> method was called, <mark>false</mark> otherwise
            <span id="browserSupport">
              <span><i class="fab fa-node-js"></i> 8.0.0 </span>
            </span>
          </td>
        </tr>
        <tr>
          <td> <strong>readableStream</strong>.closed </td>
          <td>
            - returns <mark>true</mark> if the <mark>close</mark> event was emitted, <mark>false</mark> otherwise
            <span id="browserSupport">
              <span><i class="fab fa-node-js"></i> 8.0.0 </span>
            </span>
          </td>
        </tr>
        <tr>
          <td> <strong>readableStream</strong>.readableEnded </td>
          <td>
            - returns <mark>true</mark> if the <mark>end</mark> event was emitted, <mark>false</mark> otherwise
            <span id="browserSupport">
              <span><i class="fab fa-node-js"></i> 12.9.0 </span>
            </span>
          </td>
        </tr>
        <tr>
          <td> <strong>readableStream</strong>.errored </td>
          <td>
            - returns the error if the stream was destroyed with an error
            <span id="browserSupport">
              <span><i class="fab fa-node-js"></i> 18.0.0 </span>
            </span>
          </td>
        </tr>
        <tr>
          <td>|</td>
          <td></td>
        </tr>
        <tr>
          <td colspan="2"> Events </td>
        </tr>
        <tr>
          <td> <strong>readableStream.listener</strong>('readable', <reqval>fn</reqval>) </td>
          <td>
            - causes the <reqval>readableStream</reqval> to switch in Paused mode <br>
            - repeteadly calls its callback when there are 'enough' data in the <reqval>readableStream</reqval>'s' internal buffer <br>
            - once the stream is fully consumed and the buffer is empty the callback is called for the last time before the <mark>end</mark> event<br>
            - takes precedence over the <mark>data</mark> event (so attaching the <mark>data</mark> event to <mark>readableStream</mark> won't switch the <reqval>readableStream</reqval> into Flowing mode)
            <span id="browserSupport" title="updated : 2019-07-10">
              <span><i class="fab fa-node-js"></i> 0.9.4 </span>
              <span><i class="fab fa-node-js"></i> 10.0.0 requires calling <mark>read()</mark> / emitted in the next tick after <mark>push()</mark></span>
            </span>
          </td>
        </tr>
        <tr>
          <td>|</td>
          <td></td>
        </tr>
        <tr>
          <td> <strong>readableStream.listener</strong>('data', <strong>fn(dataChunk:buf)</strong>) </td>
          <td>
            - causes the <strong>readableStream</strong> to switch in Flowing mode <br>
            - returns the data chunks in the callback (callback called as many times as necessary) <br>
            - event emitted by the <mark>pipe()</mark> and <mark>resume()</mark> methods <br>
            - the <mark>read()</mark> method only emits this event if it returns a data chunk <br>
            - removing this even does NOT pauses the stream (for backward compatibility reasons)
            <span id="browserSupport" title="updated : 2019-07-12">
              <span><i class="fab fa-node-js"></i> 0.9.4 </span>
            </span>
          </td>
        </tr>
        <tr>
          <td>|</td>
          <td></td>
        </tr>
        <tr>
          <td> <strong>readableStream.listener</strong>('pause', <reqval>fn</reqval>) </td>
          <td>
            - event emited when the <mark>pause()</mark> method is called and the <mark>reaableFlowing</mark> property is not false
            <span id="browserSupport" title="updated : 2019-07-10">
              <span><i class="fab fa-node-js"></i> 0.9.4 </span>
            </span>
          </td>
        </tr>
        <tr>
          <td> <strong>readableStream.listener</strong>('resume', <reqval>fn</reqval>) </td>
          <td>
            - event emited when the <mark>resume()</mark> method is called and the <mark>readableFlowing</mark> is not true
            <span id="browserSupport" title="updated : 2019-07-10">
              <span><i class="fab fa-node-js"></i> 0.9.4 </span>
            </span>
          </td>
        </tr>
        <tr>
          <td>|</td>
          <td></td>
        </tr>
        <tr>
          <td> <strong>readableStream.listener</strong>('end', <reqval>fn</reqval>) </td>
          <td>
            - event emitted when the available data is <u>fully consumed</u> from the stream (indicates that no more data is available to consume)
            <span id="browserSupport" title="updated : 2019-07-10">
              <span><i class="fab fa-node-js"></i> 0.9.4 </span>
            </span>
          </td>
        </tr>
        <tr>
          <td> <strong>readableStream.listener</strong>('close', <reqval>fn</reqval>) </td>
          <td>
            - event emitted when the stream and the underlying system is closed (indicates that there won't be any further computation)
            <span id="browserSupport" title="updated : 2019-07-10">
              <span><i class="fab fa-node-js"></i> 0.9.4 </span>
            </span>
          </td>
        </tr>
        <tr>
          <td>|</td>
          <td></td>
        </tr>
        <tr>
          <td> <strong>readableStream.listener</strong>('end', <reqval>fn(err)</reqval>) </td>
          <td>
            - event emitted <u>and handled</u> when some error occured during the reading process
            <span id="browserSupport" title="updated : 2019-07-10">
              <span><i class="fab fa-node-js"></i> 0.9.4 </span>
            </span>
          </td>
        </tr>
      </table>
      <h2 class="headerSection"> Notes : </h2>
      
      <h2 class="headerSection"> Useful Links : </h2>
      <h2 class="headerSection"> Remember This : </h2>
      <h2 class="headerSection"> Description and Demonstration : </h2>
      <p> - a Readable stream is an abstraction of a source </p>
      <p> - Readable streams can operate in 2 modes: <u>(when the stream is created it's always in Paused mode)</u> </p>
      <p class="indent-lv1"> <mark class="mark">Flowing</mark> -> continuouously reads data from the underlying system and provides the application with data as fast as possible </p>
      <p class="indent-lv1"> <mark class="mark">Paused</mark> -> explicity must be called with <mark>
          <reqval>readableStream</reqval>.read()
        </mark> to get data chunks </p>
      <p> - a Paused readableStream can be switched from <mark class="mark">Paused</mark> to <mark class="mark">Flowing</mark> mode by: </p>
      <p class="indent-lv1"> - attaching the <mark>data</mark> event on it </p>
      <p class="indent-lv1"> - calling <mark>
          <reqval>readableStream</reqval>.resume()
        </mark> on it </p>
      <p class="indent-lv1"> - calling <mark>
          <reqval>readableStream</reqval>.pipe()
        </mark> on it </p>
      <p class="indent-lv1"> - in general the readable stream does not generate data untill some reading mechanism calls for it and stops as soon as the request stops </p>
      <p> - a Flowing readableStream can be switched from <mark class="mark">Flowing</mark> to <mark class="mark">Paused</mark> mode by: </p>
      <p class="indent-lv1"> - calling <mark>
          <reqval>readableStream</reqval>.pause()
        </mark> on it </p>
      <p class="indent-lv1"> - removing reader destinations from it <mark>
          <reqval>readableStream</reqval>.unpipe()
        </mark> </p>
      <p> - the stream API provides multiple reading techniques, however it's recommended to use one of them (don't mix reading techniques) </p>
      <hr>
      <!------------------------------------------------------------------------------->
      <h2 class="headerExtra"> Reading a Paused stream chunk by chunk </h2>
      <h3 class="header"> Using <mark>for await</mark> loop </h3>
      <pre class="syntax">
    async function <strong>someFunction</strong>() {
        for await(const <strong>chunk</strong> of <strong>readableStream</strong>) {
            <strong>chunk</strong>                           // -> <reqval>buf</reqval>    // chunk of data (size corresponds to the <mark>highWaterMark</mark> of the stream)
        }
    }
  </pre>
      <details class="example">
        <summary> Example : </summary>
        <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var readStream = fs.createReadStream('read.txt');    
    
    async function generate() {                                                // this returns a promise basically (asynchronous)
        for await (const i of readStream) {                                    // iterating through the stream asynchronously
            console.log( i );
        }
    }
    generate();                                                                // call
    </pre>
        <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\Learn WebDesign\04 Node.js\stream\14 Symbol.asyncIterator TEST> node main
        &lt;Buffer 4c 6f 72 65 6d 20 49 70 73 75 6d 20 69 73 20 73 69 6d 70 6c 79 20 64 75 6d 6d 79 20 74 65 78 74 20 6f 66 20 74 68 65 20 70 72 69 6e 74 69 6e 67 20 61 ... 65486 more bytes&gt;   // -! chunk corresponds the maximum buffer size (65536 bytes)   
        &lt;Buffer 69 6e 64 75 73 74 72 79 27 73 20 73 74 61 6e 64 61 72 64 20 64 75 6d 6d 79 20 74 65 78 74 20 65 76 65 72 20 73 69 6e 63 65 20 74 68 65 20 31 35 30 30 ... 65486 more bytes&gt;
        &lt;Buffer 20 61 6e 64 20 73 63 72 61 6d 62 6c 65 64 20 69 74 20 74 6f 20 6d 61 6b 65 20 61 20 74 79 70 65 20 73 70 65 63 69 6d 65 6e 20 62 6f 6f 6b 2e 20 49 74 ... 39936 more bytes&gt;
    PS D:\safe\code +\my site\03 improuve\Learn WebDesign\04 Node.js\stream\14 Symbol.asyncIterator TEST>    
    </pre>
      </details>
      <hr>
      <!------------------------------------------------------------------------------->
      <h3 class="header"> Using <mark>readable</mark> event and <mark>read()</mark> method </h3>
      <pre class="syntax">
    <reqval>readableStream</reqval>.on('readable', () => {    // calls its callback once the internal buffer is full and the last read data chunk
        <reqval>readableStream</reqval>.read();               // -> <reqval>buf</reqval> containing the read data chunk (returns <mark>null</mark> on no data)
    });
  </pre>
      <details class="example">
        <summary> Example : </summary>
        <pre>
  import { createReadStream } from 'node:fs';
  
  const rStreamFile = createReadStream('./test.txt');
  
  rStreamFile.on('readable', () => {
    rStreamFile.read()                  // -> <reqval>buf</reqval> | ... | <mark>null</mark>
  });
  </pre>
      </details>
      <hr>
      <!------------------------------------------------------------------------------->
      <h2 class="headerExtra"> Methods and Properties </h2>
      <h3 class="header"> The <mark>readableFlowing</mark> / <mark>setEncoding()</mark> properties and method </h3>
      <details class="example">
        <summary> Example : </summary>
        <pre>
    const fs = require('fs');
    var readStream = fs.createReadStream('read.txt');    
        
// readableFlowing() -----------------------------------------------------------

    readStream.readableFlowing;                                                // -> null               // the stream is not in readable mode at this point 
    readStream.on('data', function(chunk){                                     // 'data' listener switches the stream in flowing reading mode 
        readStream.readableFlowing;                                            // -> true               // the stream is in flowing readable mode at this point 
        readStream.readableBuffer;                                             // -> BufferList { head: null, tail: null, length: 0 }   // -! interestingly the internal buffer is empty if I don't write explicitly data in it (might be for security I don't know)   
        chunk;                                                                 // -> &lt;Buffer&gt;           // data read from the readable stream (Buffer object if no 'setEncoding()' method is set)   
        
        readStream.pause();                                                    // we switches in reading paused reading mode here 
        readStream.readableFlowing;                                            // -> false              // the stream is in paused reading mode now     
    });
    
// setEncoding() --------------------------------------------------------------
    readStream.setEncoding();                                                  // -> ReadStream { ... } // returns the stream itself, if no argument passed data from the stream is read as string   
    readStream.on('data', function(chunk){
        chunk;                                                                 // -> 'some data from the stream' 
    });
    
    readStream.setEncoding('hex');                                             // -> ReadStream { ... } // data is encoded in hexadecimal values  
    readStream.on('data', function(chunk){
        chunk;                                                                 // -> '736f6d6520646174612066726f6d207468652073747265616d0d0a0d0a' 
    });
    </pre>
        <!--------------------------------------------------------------------------------------------------------->
        <hr>
        <h3 style="color:darkblue;"><u> <mark>readableFlowing</mark> TEST </u></h3>
        <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var readStream = fs.createReadStream('read.txt');
    var writeStream = fs.createWriteStream('write.txt');
    
    console.log( readStream.readableFlowing );                                 // -> null   // stream is not in reading mode
    
    readStream.on('data', function(){
        console.log( readStream.readableFlowing );                             // -> true   // stream is in flowing reading mode
        
        readStream.pause();
        console.log( readStream.readableFlowing );                             // -> false  // stream is in paused reading mode 
    });
    </pre>
        <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\16 readableflowing> node main
        null
        true
        false
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\16 readableflowing>   
    </pre>
        <!--------------------------------------------------------------------------------------------------------->
        <hr>
        <h3 style="color:darkblue;"><u> <mark>setEncoding()</mark> TEST </u></h3>
        <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var readStream = fs.createReadStream('read.txt');
        
    readStream.on('data', function(chunk){
        console.log( chunk );
    });    
    
// return value with no argument passed -----------------------------------------
    console.log( readStream.setEncoding() );                                     // returns the stream and sets the encoding to string 
    
// encoding set to 'utf-8' ------------------------------------------------------
    readStream.setEncoding('utf-8');                                             
        
// encoding set to hexadecimal (converts to unicode points) ---------------------
    readStream.setEncoding('hex');                                               // encodes to hexadecimal values                                            
    </pre>
        <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\17 setEncoding() TEST> node main
// return value with no argument passed -----------------------------------------
        ReadStream { ... }
        some text read from the "read.txt" file
        
// encoding set to 'utf-8' ------------------------------------------------------
        some text read from the "read.txt" file
        
// encoding set to hexadecimal (converts to unicode points) ---------------------
        736f6d65207465787420726561642066726f6d207468652022726561642e747874222066696c650d0a0d0a
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\17 setEncoding() TEST>    
    </pre>
      </details>
      <hr>
      <!------------------------------------------------------------------------------->
      <h3 class="header"> The <mark>unshift()</mark> / <mark>read()</mark> / <mark>pause()</mark> / <mark>isPaused()</mark> / <mark>resume()</mark> / <mark>destroy()</mark> methods </h3>
      <details class="example">
        <summary> Example : </summary>
        <pre>
    const fs = require('fs');
    var readStream = fs.createReadStream('read.txt');    
    
// unshift() / read() ---------------------------------------------------------
    readStream.unshift('unshifted data');                                      // we explicitly write some data in the internal buffer 
    readStream.read();                                                         // -> &lt;Buffer 75 6e 73 68 69 66 74 65 64 20 64 61 74 61&gt;       // reading the written data directly from the internal buffer     
    
// pause() / isPaused() / resume() --------------------------------------------
    readStream.on('data', function(chunk){
        chunk;                                                                 
        readStream.pause();                                                    // expliclty pauses the stream (stops emitting the 'data' event)
        readStream.isPaused();                                                 // -> true 
        readStream.resume();                                                   // switches the explicitly paused stream to flowing readable mode again (resumes emitting the 'data' event)   
    });    
    
// destroy() ------------------------------------------------------------------
    readStream.destroy();                                                      // -> ReadStream { ... }     // this destroys immediately the stream and emits the 'close' event  
    </pre>
        <h3 style="color:darkblue;"><u> <mark>unshift()</mark> / <mark>read()</mark> TEST </u></h3>
        <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var readStream = fs.createReadStream('read.txt');
    
// data read from readable stream is not available for the 'read()' method ----
    readStream.on('data', function(chunk){                                     // listener runs 3 times (data size is as large that it can be bufferen in 3 times)
        console.log( readStream.read() );                                      // -> null       // -! for some reasons the streaming data is not available here (maybe for security reasons?)  
    });
    
// unshift() ------------------------------------------------------------------
    readStream.unshift('---');                                                // write data in the internal buffer expliclty 
    readStream.read();                                                        // explicitly written data above is available here! 
    </pre>
        <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\18 unshift() read() TEST> node main
// data read from readable stream is not available for the 'read()' method ----
        null                                                                   // -! readStream.read() 
        null
        null
        
// unshift() ------------------------------------------------------------------
        &lt;Buffer 2d 2d 2d&gt;                                                      // -> this is '---' 
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\18 unshift() read() TEST>    
    </pre>
        <!--------------------------------------------------------------------------------------------------------->
        <hr>
        <h3 style="color:darkblue;"><u> <mark>pause()</mark> / <mark>resume()</mark> / <mark>isPaused()</mark> TEST </u></h3>
        <p style="color:yellow;"> - Careful! in this test the stream is NOT closed (see nor the 'end' neither the 'close' events are emitted), this is because when we resume the stream is paused again! </p>
        <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var readStream = fs.createReadStream('read.txt');
    var writeStream = fs.createWriteStream('write.txt');
        
    console.log( readStream.isPaused() );                                     // -> false       // stream is not explicitly paused  
            
    readStream.on('data', function(chunk){
        console.log( readStream.isPaused() );                                 // -> false       // stream is not explicitly paused 
        writeStream.write(chunk);
        readStream.pause();                                                   // pausing the stream explicitly    
        console.log( readStream.isPaused() );                                 // -> true        // stream explicitly paused 
    });
        
    readStream.on('end', function(){                                           // -! event never emitted because the stream never closes 
        console.log( 'end event emitted!' );
    });
        
    readStream.on('close', function(){                                         // -! event never emitted because the stream never closes
        console.log( 'close event emitted!' );
    });
    
    setTimeout(function(){                                                     // after 5 seconds the stream resumes from paused flowing mode 
        readStream.resume();
    }, 5000);
    </pre>
        <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\19 pause() resume() isPaused() TEST> node main
        false
        false
        true
        false                                                                  // this is returned after 5 seconds   
        true                                                                   // pausing the stream again (stream is not closed becuase the 3rd chunk is never sent through)   
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\19 pause() resume() isPaused() TEST>    
    </pre>
        <!--------------------------------------------------------------------------------------------------------->
        <hr>
        <h3 style="color:darkblue;"><u> <mark>destroy()</mark> TEST </u></h3>
        <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var readStream = fs.createReadStream('read.txt');
        
    readStream.on('close', function(){                                         // event emitted by the 'destroy()' method  
        console.log('close event emitted');
    });
    
    readStream.on('data', function(chunk){
        console.log( chunk );
        readStream.destroy();                                                  // only the first chunk of data is streamed because we destroy the stream here 
    });
    </pre>
        <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\20 destroy() TEST> node main
        &lt;Buffer 4c 6f 72 65 6d 20 49 70 73 75 6d 20 69 73 20 73 69 6d 70 6c 79 20 64 75 6d 6d 79 20 74 65 78 74 20 6f 66 20 74 68 65 20 70 72 69 6e 74 69 6e 67 20 61 ... 65486 more bytes&gt;
        close event emitted                                                    // -! 'close' event emitted by the 'destroy()' method
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\20 destroy() TEST>    
    </pre>
        <!--------------------------------------------------------------------------------------------------------->
        <hr>
        <h3 style="color:darkblue;"><u> <mark>pause()</mark> method with the <mark>pipe()</mark> method TEST </u></h3>
        <p> - pauses the readable stream as expected (destination file is empty which proves that the stream is paused) </p>
        <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var readStream = fs.createReadStream('read.txt');
    var writeStream = fs.createWriteStream('write.txt');
    
    readStream.pipe(writeStream);
    readStream.pause();
    
    console.log( readStream.isPaused() );    
    </pre>
        <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\20.1 pause() with pipe() TEST> node main
        true                                                                   // -! readStream.isPaused()
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\20.1 pause() with pipe() TEST>    
    </pre>
      </details>
      <hr>
      <!------------------------------------------------------------------------------->
      <h3 class="header"> The <mark>pipe()</mark> / <mark>unpipe()</mark> methods </h3>
      <details class="example">
        <summary> Example : </summary>
        <pre>
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    var readStream = fs.createReadStream('read.txt');    
    
    readStream.pipe(writeStream);                                              // -> WriteStream { ... }    // pipes the data automatically to the destination                                      
    readStream.unpipe(writeStream);                                            // -> ReadStream { ... }     // detaches the target writable stream 
    readStream.isPaused()                                                      // -> true                   // readable stream is in paused reading mode after the 'unpipe()' method is called  
    </pre>
        <h3 style="color:darkblue;"><u> <mark>pipe()</mark> TEST </u></h3>
        <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var readStream1 = fs.createReadStream('read1.txt');    
    var readStream2 = fs.createReadStream('read2.txt');    
    var writeStream = fs.createWriteStream('write.txt');    
    
    readStream2.pipe(readStream1.pipe(writeStream));                           // because the 'pipe()' method returns the destination stream this allows us to use multiple sources (readable streams) to write on destination   
    </pre>
        <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\21 pipe() TEST> node main
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\21 pipe() TEST>    
    </pre>
        <!--------------------------------------------------------------------------------------------------------->
        <hr>
        <h3 style="color:darkblue;"><u> <mark>pipe()</mark> option TEST </u></h3>
        <p> - the 'close' event is not emitted because the writable stream is not closed </p>
        <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var readStream = fs.createReadStream('read.txt');    
    var writeStream = fs.createWriteStream('write.txt');    
    
    writeStream.on('close', function(){                                        // event would be emitted if the stream closes (the option prevent that here)   
        console.log( 'close event emitted' );
    });
    
    readStream.pipe(writeStream, {end:false});                                 // writable stream does not end 
    </pre>
        <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\22 pipe() option TEST> node main
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\22 pipe() option TEST>    
    </pre>
        <!--------------------------------------------------------------------------------------------------------->
        <hr>
        <h3 style="color:darkblue;"><u> <mark>unpipe()</mark> TEST </u></h3>
        <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var readStream = fs.createReadStream('read.txt');    
    var writeStream1 = fs.createWriteStream('write1.txt');    
    var writeStream2 = fs.createWriteStream('write2.txt');    
        
    writeStream1.on('close', function(){                                       // stream never closes because it wasn't piped any data to it at the first place   
        console.log( 'close event emitted' );
    });
        
    readStream.pipe(writeStream1);
    readStream.unpipe(writeStream1);                                           // unpiped the targed stream (no data is piped to the 'writeStream1' at this point) 
    
    console.log( readStream.isPaused() );                                      // -> true           // stream is in paused readable mode 
    readStream.pipe(writeStream2);                                             // piping the data to a different destination    
    console.log( readStream.isPaused() );                                      // -> false          // stream is in flowing readable mode
    </pre>
        <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\23 unpipe() TEST> node main
        true                                                                   // -! readStream.isPaused()
        false                                                                  // -! readStream.isPaused()
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\23 unpipe() TEST>    
    </pre>
      </details>
      <hr>
      <!------------------------------------------------------------------------------->
      <h3 class="header"> The <mark>readableHighWaterMark</mark> / <mark>readableLength</mark> / <mark>readableObjectMode</mark> / <mark>readable</mark> properties and method </h3>
      <details class="example">
        <summary> Example : </summary>
        <pre>
    const fs = require('fs');
    var readStream = fs.createReadStream('read.txt');    
    
// readableHighWaterMark / readableObjectMode ---------------------------------
    readStream.readableHighWaterMark;                                          // -> 65536          // internam buffer memory is 65536 bytes 
    readStream.readableObjectMode;                                             // -> false          // stream is not operating in object mode 
    
// readableLength -------------------------------------------------------------
    readStream.readableLength;                                                 // -> 0              // there's no data in the internal buffer memory 
    readStream.unshift('unshifting some data');                                // putting some data in the buffer 
    readStream.readableLength;                                                 // -> 20             // 20 bytes are in the internal buffer memory now   
    
// readable -------------------------------------------------------------------
    readStream.readable;                                                       // -> true           // it is safe to call the 'read()' method 
    </pre>
        <h3 style="color:darkblue;"><u> <mark>readableHighWaterMark</mark> / <mark>readableObjectMode</mark> / <mark>readableLength</mark> TEST </u></h3>
        <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var readStream = fs.createReadStream('read.txt');    
    var writeStream = fs.createWriteStream('write.txt');    
    
    console.log( readStream.readableHighWaterMark );                    
    console.log( readStream.readableObjectMode );
    
    console.log( readStream.readableLength );
    
    readStream.unshift('some data');                                           // write some data directly in the buffer memory 
    console.log( readStream.readableLength );                                  // -> 9 
    
    </pre>
        <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 Node.js\stream\25 readableHighWaterMark readableObjectMode readableLength TEST> node main
        65536                                                                  // -! readStream.readableHighWaterMark
        false                                                                  // -! readStream.readableObjectMode
        0                                                                      // -! readStream.readableLength      // write some data in the buffer after this 
        9                                                                      // -! readStream.readableLength
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 Node.js\stream\25 readableHighWaterMark readableObjectMode readableLength TEST>    
    </pre>
        <!--------------------------------------------------------------------------------------------------------->
        <h3 style="color:darkblue;"><u> <mark>readable</mark> TEST </u></h3>
        <p style="color:yellow;"> - in this test I overflowed the internal buffer memory size but still the 'readable' property returns <mark>true</mark> (indicating that it's safe to call the <mark>read()</mark> method) I don't know when it sholud return <mark>false</mark></p>
        <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var readStream = fs.createReadStream('read.txt');    
    var writeStream = fs.createWriteStream('write.txt');    
    
    var someTxt = "Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum."
    
    for(let i = 0; i &lt; 1000; i++) {                                            // this loop makes the buffer memory to overflow 
        readStream.unshift(someTxt);
        console.log( readStream.readable );
    }
    
    console.log( readStream.readableHighWaterMark );
    console.log( readStream.readableLength );
    </pre>
        <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 Node.js\stream\26 readable TEST> node main    
        true ... (1000 times)
        65536                                                                   // -! readStream.readableHighWaterMark      // buffer memory size
        574000                                                                  // -! readStream.readableLength             // bytes in the buffer memory (overflows)
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 Node.js\stream\26 readable TEST>    
    </pre>
      </details>
      <!--------------------------------------------------------------------------------------------------------->
      <hr>
      <h2 class="headerExtra"><u> Events </u></h2>
      <h3 class="header"> The <mark>data</mark> / <mark>readable</mark> / <mark>error</mark> events </h3>
      <details class="example">
        <summary> Example : </summary>
        <pre>
    const fs = require('fs');
    var readStream = fs.createReadStream('read.txt');    
        
// data VS readable (reading techniquies) ------------------------------------
  // data ------------------------------------
    readStream.on('data', function(chunk){                                    // switches the stream into flowing reading mode (called as many times as necessary to return the whole data till the end of the stream)   
        readStream.readableLength;                                            // -> 0           // there is nothing in the internal buffer already (maybe this event calls the 'write()' event automatically)  
        chunk;                                                                // data (returned chunk by chunk) 
    });
  // readable --------------------------------
    readStream.on('readable', function(){                                     // called once there is readable data in the stream    // -! once the stream is fully consumed this listener will be called at the end (so at least it will be called 2 times)  
        readStream.readableLength;                                            // -> 20          // this event put the data in the internal buffer 
        readStream.read();                                                    // -> 'some data from the stream'   // we read the data from the buffer (once the buffer is empty and there is more data available in the stream the listener will be called again)  // -! this method emits the 'data' event   
    });    
    
// error ---------------------------------------------------------------------
    readStream.on('error', function(error){                                   // event fired when an error occures during the reading 
        error;                                                                // -! error is returned and handled here (won't block the module)   
    });    
  </pre>
        <h2 style="color:darkblue;"><u> <mark>data</mark> event TEST </u></h2>
        <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var readStream = fs.createReadStream('read.txt');    
    var writeStream = fs.createWriteStream('write.txt');    
    
    readStream.on('data', function(chunk){
        console.log( chunk );
        readStream.pause();                                                    // the 'data' event switches the stream into flowing readable mode but we pauuse the stream here 
    });
    
    readStream.pipe(writeStream);                                              // the 'pipe' method keeps calling the 'data' event that's why the 'data' event is called 3 times   
    </pre>
        <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 Node.js\stream\27 data event TEST> node main
        &lt;Buffer 4c 6f 72 65 6d 20 49 70 73 75 6d 20 69 73 20 73 69 6d 70 6c 79 20 64 75 6d 6d 79 20 74 65 78 74 20 6f 66 20 74 68 65 20 70 72 69 6e 74 69 6e 67 20 61 ... 65486 more bytes&gt;
        &lt;Buffer 69 6e 64 75 73 74 72 79 27 73 20 73 74 61 6e 64 61 72 64 20 64 75 6d 6d 79 20 74 65 78 74 20 65 76 65 72 20 73 69 6e 63 65 20 74 68 65 20 31 35 30 30 ... 65486 more bytes&gt;
        &lt;Buffer 20 61 6e 64 20 73 63 72 61 6d 62 6c 65 64 20 69 74 20 74 6f 20 6d 61 6b 65 20 61 20 74 79 70 65 20 73 70 65 63 69 6d 65 6e 20 62 6f 6f 6b 2e 20 49 74 ... 39938 more bytes&gt;
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 Node.js\stream\27 data event TEST>    
    </pre>
        <!--------------------------------------------------------------------------------------------------------->
        <hr>
        <h2 style="color:darkblue;"><u> <mark>readable</mark> VS <mark>data</mark> events TEST </u></h2>
        <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var readStream = fs.createReadStream('read.txt');    
    var writeStream = fs.createWriteStream('write.txt');    
    
// readable -------------------------------------------------------------------
    readStream.on('readable', function(){
        console.log( readStream.readableLength );                             // this returns the number of bytes available in the internal buffer at each call 
        console.log( readStream.read() );                                     // reading data from the internal buffer (once it is empty the 'readable' event emited again in order to repeat the proces)   // -! the 'read()' method emits the 'data' event!   
    });
    
// data -----------------------------------------------------------------------
    readStream.on('data', function(chunk){
        console.log( readStream.readableLength );                             // always returns 0 (I'm not sure exactly but I suppose this is because of the 'read()' method is called internaly)   
        console.log( chunk );
    });
    </pre>
        <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 Node.js\stream\28 readable VS data events TEST>node main
// readable -------------------------------------------------------------------
        65536                                                                  // call 1
        &lt;Buffer 4c 6f 72 65 6d 20 49 70 73 75 6d 20 69 73 20 73 69 6d 70 6c 79 20 64 75 6d 6d 79 20 74 65 78 74 20 6f 66 20 74 68 65 20 70 72 69 6e 74 69 6e 67 20 61 ... 65486 more bytes&gt;
        65536                                                                  // call 2
        &lt;Buffer 69 6e 64 75 73 74 72 79 27 73 20 73 74 61 6e 64 61 72 64 20 64 75 6d 6d 79 20 74 65 78 74 20 65 76 65 72 20 73 69 6e 63 65 20 74 68 65 20 31 35 30 30 ... 65486 more bytes&gt;
        39988                                                                  // call 3 
        &lt;Buffer 20 61 6e 64 20 73 63 72 61 6d 62 6c 65 64 20 69 74 20 74 6f 20 6d 61 6b 65 20 61 20 74 79 70 65 20 73 70 65 63 69 6d 65 6e 20 62 6f 6f 6b 2e 20 49 74 ... 39938 more bytes&gt;
        0                                                                      // -! call 4 (called at the end of the stream) 
        null                                                                   // no data in the internal buffer at this point  
    
// data -----------------------------------------------------------------------
        0                                                                      // call 1    
        &lt;Buffer 4c 6f 72 65 6d 20 49 70 73 75 6d 20 69 73 20 73 69 6d 70 6c 79 20 64 75 6d 6d 79 20 74 65 78 74 20 6f 66 20 74 68 65 20 70 72 69 6e 74 69 6e 67 20 61 ... 65486 more bytes&gt;   
        0                                                                      // call 2
        &lt;Buffer 69 6e 64 75 73 74 72 79 27 73 20 73 74 61 6e 64 61 72 64 20 64 75 6d 6d 79 20 74 65 78 74 20 65 76 65 72 20 73 69 6e 63 65 20 74 68 65 20 31 35 30 30 ... 65486 more bytes&gt;
        0                                                                      // call 3
        &lt;Buffer 20 61 6e 64 20 73 63 72 61 6d 62 6c 65 64 20 69 74 20 74 6f 20 6d 61 6b 65 20 61 20 74 79 70 65 20 73 70 65 63 69 6d 65 6e 20 62 6f 6f 6b 2e 20 49 74 ... 39938 more bytes&gt;
    </pre>
        <!--------------------------------------------------------------------------------------------------------->
        <hr>
        <h2 style="color:darkblue;"><u> <mark>error</mark> event TEST </u></h2>
        <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var readStream = fs.createReadStream('read.txt');    
    
    readStream.on('error', function(err){                                      // thrown error is handled here 
        console.log( typeof err );
    });
    
    console.log( 'end of module' );                                            // because the error is handled the module is not blocked!  
    </pre>
        <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 Node.js\stream\29 error event TEST> node main
        end of module                                                          // module finished 
        object                                                                 // handled thrown error 
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 Node.js\stream\29 error event TEST>    
    </pre>
        <!--------------------------------------------------------------------------------------------------------->
        <hr>
        <h2 style="color:darkblue;"><u> stream is not paused when we remove the <mark>data</mark> event TEST </u></h2>
        <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var readStream = fs.createReadStream('read.txt');    
    
    readStream.on('data', function(chunk){
        console.log( chunk );
    });
    readStream.removeAllListeners('data');                                     // remove 'data' evetn listener 
    
    console.log( readStream.readableFlowing );                                 // -> true        // stream stays in flowing readable mode 
    console.log( readStream.isPaused() );                                      // -> false       // not paused 
    </pre>
        <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\21.1 stream is not paused when we remove the data event TEST> node main
        true                                                                   // -! readStream.readableFlowing
        false                                                                  // -! readStream.isPaused()
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\21.1 stream is not paused when we remove the data event TEST>    
    </pre>
      </details>
      <!--------------------------------------------------------------------------------------------------------->
      <hr>
      <h3 class="header"> The <mark>pause</mark> / <mark>resume</mark> events </h3>
      <details class="example">
        <summary> Example : </summary>
        <pre>
    const fs = require('fs');
    var readStream = fs.createReadStream('read.txt');    
    
    readStream.on('pause', function(){ });                                    // event emitted because the 'pause()' method is called below 
    readStream.on('resume', function(){ });                                   // event emitted because the 'resume()' method is called below   
    
    readStream.pause();
    readStream.resume();
  </pre>
        <h3 style="color:darkblue;"><u> <mark>pause</mark> / <mark>resume</mark> events TEST </u></h3>
        <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var readStream = fs.createReadStream('read.txt');    
    
    readStream.on('pause', function(){                                        // event emitted because the 'pause()' method was called   
        console.log( 'pause event emitted' );
    });
    readStream.on('resume', function(){                                       // event emitted because the 'resume()' method was called 
        console.log( 'resume event emitted' );
    });
    
    readStream.pause();
    readStream.resume();    
    </pre>
        <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 Node.js\stream\30 pause resume events TEST> node main
        pause event emitted
        resume event emitted
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 Node.js\stream\30 pause resume events TEST>    
    </pre>
      </details>
      <!--------------------------------------------------------------------------------------------------------->
      <hr>
      <h3 class="header"> The <mark>close</mark> / <mark>end</mark> events </h3>
      <details class="example">
        <summary> Example : </summary>
        <pre>
    const fs = require('fs');
    var writeStream = fs.createWriteStream('write.txt');    
    var readStream = fs.createReadStream('read.txt');    
    
    readStream.on('close', function(){ });                                    // event emitted when the stream is closed (last event)
    readStream.on('end', function(){ });                                      // event emitted when no more data is available in the 'readStream'
    
    readStream.pipe(writeStream);
  </pre>
        <h3 style="color:darkblue;"><u> <mark>close</mark> / <mark>end</mark> events TEST </u></h3>
        <pre style="margin-bottom:1px;">
    const fs = require('fs');
    var readStream = fs.createReadStream('read.txt');    
        
    readStream.on('end', function(){                                          // in this situation this event is not emited (stream is no fully consumed) 
        console.log( 'end event emitted!' );
    });
    readStream.on('close', function(){
        console.log( 'close event emitted!' );
    });
    
    readStream.on('readable', function(){
        console.log( readStream.read() );
        readStream.destroy();                                                 // stream is destroyed after reading the first data chunk (stream is not fully consumed)
    });                                                                       // -! if the 'destroy()' method is removed the 'end' event is emitted because all data will be consumed from the stream [TESTED]   
    </pre>
        <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 Improuve\Learn WebDesign\04 node.js\stream\31 close end events TEST> node main
        &lt;Buffer 4c 6f 72 65 6d 20 49 70 73 75 6d 20 69 73 20 73 69 6d 70 6c 79 20 64 75 6d 6d 79 20 74 65 78 74 20 6f 66 20 74 68 65 20 70 72 69 6e 74 69 6e 67 20 61 ... 65486 more bytes&gt;
        close event emitted!                                                  // 'close' event emitted only 
    PS D:\safe\code +\my site\03 Improuve\Learn WebDesign\04 node.js\stream\31 close end events TEST>    
    </pre>
      </details>

      <br><br>
    </body>

  </html>