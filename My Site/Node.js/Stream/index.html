<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title> Streams </title>
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <link rel="stylesheet" href="../../Assets/stylesPages.css">
  <script src="../../Assets/scriptPages.js"></script>
</head>

<body>
  <h1> Streams </h1>
  <p> Updated ( 2019-06-25 / 2019-07-23 / 2024-03-11 )</p>
    <nav class="sitenav">
      <a href="../../index.html">MySite > </a>
      <a href="../index.html">Node.js > </a> Streams
    </nav>
  <p class="subSite"><a href="Readable Streams/index.html"> Readable Streams > </a></p>
  <p class="subSite"><a href="Writable Streams/index.html"> Writable Streams > </a></p>
  <p class="subSite"><a href="Duplex and Transform Streams/index.html"> Duplex and Transform Streams > </a></p>
  <p class="subSite"><a href="Stream Implementers API/index.html"> Stream Implementers API > </a></p>
  <table class="table">
    <caption> Utility Methods </caption>
    <tr>
      <th style="width:30%;"> Method / Property </th>
      <th> Description </th>
    </tr>
    <tr>
      <td> stream.finished(<strong>readable|writableStream</strong>, <i class="openable">option:obj<div>
            <p> <a href="https://nodejs.org/docs/latest/api/stream.html#streamfinishedstream-options-callback" target="_blank">[link]</a></p>
          </div></i>, <reqval>fn(err)</reqval>) </td>
      <td>
        - invokes the callback when the stream is no longer writable|readable or an error occured
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 10.0.0 </span>
          <span><i class="fab fa-node-js"></i> 15.11.0 signal option </span>
        </span>
      </td>
    </tr>
    <tr>
      <td> stream.pipeline(<strong>readableStream, ..., wriatbleStram</strong>, <reqval>fn(err)</reqval>) </td>
      <td>
        - pipes the data through the streams pipeline <br>
        - callback invoked if the data is fully piped through the pipeline or on error
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 10.0.0 </span>
          <span><i class="fab fa-node-js"></i> 13.10.0 async generators support </span>
          <span><i class="fab fa-node-js"></i> 19.7.0 18.16.0 webstreams support </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td> stream.getDefaultHighWaterMark(<reqval class="openable">objectMode:bool<div>
            <p> - high whater mark in object mode </p>
          </div>
        </reqval>) </td>
      <td>
        - returns the default <mark>HighWaterMark</mark> value (Default: 16384 (16 KiB), or 16 for objectMode)
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 19.9.0 / 18.17.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td> stream.setDefaultHighWaterMark(<reqval class="openable">objectMode:bool<div>
            <p> - high whater mark in object mode </p>
          </div>
        </reqval>
        <reqval>, val:number</reqval>)
      </td>
      <td>
        - sets the default <mark>HighWaterMark</mark> value (Default: 16384 (16 KiB), or 16 for objectMode)
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 19.9.0 / 18.17.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td> stream.Readable.from(<reqval class="openable">iterable, option:obj<div>
        <p> - <a href="https://nodejs.org/docs/latest/api/stream.html#streamreadablefromiterable-options" target="_blank">iterable, option:obj</a> </p>
      </div></reqval>)
      </td>
      <td>
        - creates an retuns a <reqval>readableStream</reqval> from an iterable
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 12.3.0 / 10.17.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td> stream.Duplex.from(<reqval class="openable">source<div>
        <p> - <a href="https://nodejs.org/docs/latest/api/stream.html#streamduplexfromsrc" target="_blank">iterable, option:obj</a> </p>
      </div></reqval>)
      </td>
      <td>
        - creates an retuns a <reqval>duplexStream</reqval> from the passed <reqval>source</reqval>
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 16.8.0 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td> stream.addAbortSignal(<reqval>abortSignal</reqval>, <reqval>readableStream|readableStream</reqval>)
      </td>
      <td>
        - attaches an <mark>AbortSignal</mark> to the passed stream <br>
        - the passed <reqval>abortSignal</reqval> can destroy the <reqval>readableStream|readableStream</reqval>
        <span id="browserSupport">
          <span><i class="fab fa-node-js"></i> 15.4.0 </span>
        </span>
      </td>
    </tr>
  </table>
  <br>
  <h2 class="headerSection"> Notes : </h2>
  <details class="example" id="notes">
    <summary> Notes :</summary>
  </details>
  <h2 class="headerSection"> Useful Links : </h2>
  <p><a href="https://nodejs.org/docs/latest/api/stream.html" target="_blank">Stream Nodejs docs (nodejs.com) </a></p>
  <h2 class="headerSection"> Remember This : </h2>
  <p> - I tested to overflow a buffer and I expected some data loss but it never occured here [2019-06-28] </p>
  <h2 class="headerSection"> Description and Demonstration : </h2>
  <p> - the stream moduel provides an abstrat iinterface for streaming data (writing/consuming <u>large data</u> chunk by chunk) </p>
  <p> - a stream can be Readable, Writable or both (Duplex, Transform), all node streams are instance of <mark>EventEmitter</mark> </p>
  <p> - almost all node APIs use streams (http socker, file, etc...), but we also can implement our own (rarely used) </p>
  <p> - streams can operate on: </p>
  <p class="indent-lv1"> - string, <mark>Buffer</mark> or <mark>Uint8Array</mark> (default) </p>
  <p class="indent-lv1"> - object mode (object instead serialized data), all data type supported <u>except null</u> <u>(switching an existing stream into object mode is not safe!)</u> </p>
  <h2 class="header"> Buffering </h2>
  <p> - streams use an internal buffer for temporarily store data, the limit of this buffer is described as <mark>highWaterMark</mark>, its size indicates the stored bytes (or stored objects in object mode) (Duplex and Transform streams have 2 buffers (one on each side) </p>
  <p> - the <mark>highWaterMark</mark> is a treshold <u>not a hard memory limiter</u>, so the buffer can be fored to store more data (risky game) </p>
  <p> - behaviour on <mark>highWaterMark</mark> limit overflow: </p>
  <p class="indent-lv1"> - ReadableStream -> stop reading the underlying resource untill buffer space freed up </p>
  <p class="indent-lv1"> - WritableStream -> the <mark>
      <reqval>readableStream</reqval>.read()
    </mark> returns <mark>false</mark> (returns <mark>true</mark> if treshold is under the limit again) </p>
  <h2 class="header"> Promise API </h2>
  <p> - from v15.0.0 a Promise based approach is possible for using the same stream tools <a href="https://nodejs.org/docs/latest/api/stream.html#streams-promises-api" target="_blank">[link]</a></p>
  <hr>
  <!---------------------------------------------------------------------------------------------------------->
  <h2 class="headerExtra"><u> Utility methods </u></h2>
  <h3 class="header"> The <mark>finished()</mark> / <mark>pipeline()</mark> methods </h3>
  <details class="example">
    <summary> Example : </summary>
    <pre>
    const stream = require("stream");
    const fs = require('fs');
    
    var readStream = fs.createReadStream('read.txt');
    var writeStream = fs.createWriteStream('write.txt');
    
    var duplexStream = new stream.Duplex({read(size){}, write(chunk, encode, callback){ callback(); }});
    var transformStream = new stream.PassThrough();
    
// finished() ------------------------------------------------------------------------
    readStream.pipe(writeStream);
    
    stream.finished(readStream, function(err){ err })                                 // callback is invoked when the stream is not readable any more (if an error occurs it can be handled here)   
    stream.finished(writeStream, {error:false}, function(){})                         // callback is invoked when the stream is not writable any more   // -! callback function does not hanlde any occured error in this case   
    
// pipeline() ------------------------------------------------------------------------
    stream.pipeline(readStream, transformStream, writeStream, function(err) {         // callback is invoked because the data can be piped from the'readStream' all the way to the 'writeStream'   
        err;                                                                          // -! if an error occurs the callback is invoked and the error is returned and handled in it (this is an awesome way to avoid registering an error listener to all streams)  
    });
    
    stream.pipeline(readStream, transformStream, duplexStream, writeStream, function(){ });  // callback is not invoked here because the 'duplexStream' does not transfer the data (data is still piped till the 'duplexStream' though)   
    </pre>

    <h4 style="color:darkblue;"><u> <mark>finished()</mark> TEST </u></h4>
    <pre style="margin-bottom:1px;">
    const stream = require('stream');
    const fs = require('fs');
    
    var readStream = fs.createReadStream('read.txt');
    var writeStream = fs.createWriteStream('write.txt');
    var writeStream2 = fs.createWriteStream('write.txt');
    
// test end writable -----------------------------------------------------------------
    stream.finished(writeStream, function(err){                                       // once the writable stream finishes writing the callback function is invoked  
        console.log( 'writable ended' );
    });
    
    writeStream.write('write some data');
    writeStream.end();
    
// test end readable -----------------------------------------------------------------
    stream.finished(readStream, function(err){                                        // once the readable stream finishes reading the callback function is invoked 
        console.log( 'readable ended' );
    });
    
    readStream.on('readable', function(){
        this.read();
    });
    
// threating errors -----------------------------------------------------------------
    stream.finished(writeStream2, {error:false}, err => {                             // we basically switched off the error handling feature here  
        console.log( err );                                                           // -> undefined 
    });
    writeStream2.on('error', err => {});                                              // we handle the thrown error here (because the 'finish()' method does not handle it)   
    
    writeStream2.write(21);                                                           // wrong data type given (stream is not in object mode)
    writeStream2.end();
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\01 finished() TEST> node main
        undefined                                                                     // writeStream2 'finish()' method 
        writable ended                                                                // writeStream 'finish()' method
        readable ended                                                                // readStream 'finish()' method
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\01 finished() TEST>    
    </pre>
    <hr>
    <!--------------------------------------------------------------------------------------------------------------------->
    <h4 style="color:darkblue;"><u> <mark>pipeline()</mark> TEST </u></h4>
    <pre style="margin-bottom:1px;">
    const stream = require('stream');   
    const fs = require('fs');
    
// piping data all the way through successfully the line -----------------------------------
    var readStream = fs.createReadStream('read.txt');
    var writeStream = fs.createWriteStream('write.txt');
    
    var passThrough = new stream.PassThrough();
    var transformStream = new stream.Transform({transform(chunk, encode, callback){ callback(null, chunk)}});
    
    stream.pipeline(readStream, passThrough, transformStream, writeStream, function(){
        console.log( 'PIPELINE 1 = data piped through successfully!' );               // callback function fires because the streams in the pipeline allows the data piping through all the way to the 'writeStream'   
    });
    
// data not piped through ------------------------------------------------------------------
    var readStream2 = fs.createReadStream('read2.txt');
    var writeStream2 = fs.createWriteStream('write2.txt');
    
    var passThrough2 = new stream.PassThrough();
    var duplexStream = new stream.Duplex({read(){}, write(chunk, encode, callback){ callback()}});
    
    stream.pipeline(readStream2, passThrough2, duplexStream, writeStream2, function(){ 
        console.log( 'PIPELINE 2 = data piped through successfully!' );               // callback function does NOT fire because the 'duplexStream' prevent the data passing through   
    });                                                                               // -! data is still piped till 'duplexStream' but not any further
    
// error handling --------------------------------------------------------------------------
    var readStream3 = fs.createReadStream('read3.txt');
    var writeStream3 = fs.createWriteStream('write3.txt');
    
    var passThrough3 = new stream.PassThrough();
    
    stream.pipeline(readStream3, passThrough3, writeStream3, function(err){
        console.log( 'an error occured = ' + err.name );                              // the thrown error is handled here 
    });
    
    passThrough3.write(21);                                                           // passing a non string or Buffer data throws an error 
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\02 pipeline() TEST> node main
        an error occured = TypeError                                                  // handled error 
        PIPELINE 1 = data piped through successfully!                                 // successful pipeline callback message 
                                                                                      // pipeline 2 callback is not invoked because the data isn't piped throug and no errors are thrown eigther 
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\stream\02 pipeline() TEST>    
    </pre>
  </details>
  <!-------------------------------------------------------------------------------------------->
  <hr>
  <h3 class="header"> The <mark>Readable.from()</mark> / <mark>Duplex.from()</mark> methods </h3>
  <details class="example">
    <summary> Example : </summary>
    <h3 class="header"> The <mark>from()</mark> method </h3>
    <pre>
    const stream = require("stream");
    
    var str = 'myString';                                                      // string is not an object but we still can use it because it has the 'Symbol.iterator' protocol 
    var arr = [1, 'two', true];
    
    async function* generateData() {                                           // asynchronous generator function (generates data asynchronously)
        yield 43;
        yield 'fourty two';
        yield false;
    }
    
    var readString1 = stream.Readable.from(str, {objectMode:false});           // -! stream is not operating in object mode
    var readString2 = stream.Readable.from(arr);
    var readString3 = stream.Readable.from(generateData());
    </pre>
    <h3 class="header"> The <mark>Duplex.from()</mark> method </h3>
    <pre>
    import stream from 'node:stream';
    
    const duplex = stream.Duplex.from('Hello World!');
    
    duplex.on('data', (chunk) => console.log(chunk))    // -> 'Helo World!'
    </pre>
  </details>
  <!-------------------------------------------------------------------------------------------->
  <hr>
  <h3 class="header"> The <mark>addAbortSignal()</mark> method </h3>
  <details class="example">
    <summary> Example : </summary>
    <pre>
    import fs from 'node:fs';
    import { addAbortSignal } from 'node:stream';
    
    const controller = new AbortController();
    const fileReaderStream = addAbortSignal(
      controller.signal,
      fs.createReadStream(('./test.txt')),
    );
    
    fileReaderStream.on('readable', () => {
      fileReaderStream.read();                // -> <reqval>buf</reqval>
      controller.abort();                     // aborting stream
    })
    </pre>
  </details>


  <br><br>
</body>

</html>