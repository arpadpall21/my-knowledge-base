<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title> Child Process </title>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../Assets/stylesPages.css">
    <script src="../../Assets/scriptPages.js"></script>
  </head>
  <body>
    <h1> Child Process </h1>
    <p> Updated: ( 2019-06-16 / 2020-02-04 / 2020-07-09 / 2025-02-23 )</p>
    <p class="sitenav"> <a href="../../index.html">MySite > </a>
      <a href="../index.html">Node.js > </a> Child Process
    </p>
    <table class="table">
      <tr>
        <th style="width:30%;"> Method / Property </th>
        <th> Description </th>
      </tr>
      <tr>
        <td colspan="2"> Child Processes </td>
      </tr>
      <tr>
        <td>
          <lit>child_process</lit>.exec(<strong>cmd:str</strong>, <a href="https://nodejs.org/docs/latest/api/child_process.html#child_processexeccommand-options-callback" target="_blank">option:obj</a>, <i>fn(err, stdout, stderr)</i>)
        </td>
        <td>
          - asynchronously spawns a shell (by default: <mark>/bin/sh'</mark> on Unix, <mark>process.env.ComSpec</mark> on Windows) and executes <strong>cmd</strong> in it <br>
          - on child process finish returns a single result (in the callback), <span class="openable">with limited size<div>
              <p> - default max size 1024*1024 (can be configured) </p>
              <p> - if the returned data size is larger than allowed then the data is trunkated and the process is terminated! </p>
            </div></span> <br>
          - returns a <reqval>childProcess</reqval>
        </td>
      </tr>
      <tr>
        <td>
          <lit>child_process</lit>.execSync(<strong>cmd:str</strong>, <a href="https://nodejs.org/docs/latest/api/child_process.html#child_processexecsynccommand-options" target="_blank">option:obj</a>)
        </td>
        <td>
          - synchronous version of <mark>exec()</mark> <u>(blocks the parent process until finishes)</u> <br>
          - returns the result in a <reqval>buf</reqval>, <span class="openable">with limited size<div>
              <p> - default max size 1024*1024 in bytes (can be configured) </p>
              <p> - if the returned data size is larger than allowed then the data is trunkated and the process is terminated! </p>
            </div></span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <lit>child_process</lit>.execFile(<strong>exePath:str</strong>, <i class="openable">[cmdArg, ...]<div>
              <p> - command argument(s) </p>
            </div></i>, <a href="https://nodejs.org/docs/latest/api/child_process.html#child_processexecfilefile-args-options-callback" target="_blank">options:obj</a>, <i>fn(err, stdout, stderr)</i>)
        </td>
        <td>
          - asynchronously executes an executable file (directly without shell by default) <br>
          - on child process finish returns a single result (in the callback), <span class="openable">with limited size<div>
              <p> - default max size 1024*1024 (can be configured) </p>
              <p> - if the returned data size is larger than allowed then the data is trunkated and the process is terminated! </p>
            </div></span> <br>
          - returns a <reqval>childProcess</reqval>
        </td>
      </tr>
      <tr>
        <td>
          <lit>child_process</lit>.execFileSync(<strong>exePath:str</strong>, <i class="openable">[cmdArg, ...]<div>
              <p> - command argument(s) </p>
            </div></i>, <a href="https://nodejs.org/docs/latest/api/child_process.html#child_processexecfilesyncfile-args-options" target="_blank">options:obj</a>)
        </td>
        <td>
          - synchronous version of <mark>execFile()</mark> <u>(blocks the parent process until finishes)</u> <br>
          - returns the result in a <reqval>buf</reqval>, <span class="openable">with limited size<div>
              <p> - default max size 1024*1024 in bytes (can be configured) </p>
              <p> - if the returned data size is larger than allowed then the data is trunkated and the process is terminated! </p>
            </div></span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <lit>child_process</lit>.spawn(<strong>cmd|exePath:str</strong>, <i class="openable">[cmdArg, ...]<div>
              <p> - command argument(s) </p>
            </div></i> <a href="https://nodejs.org/docs/latest/api/child_process.html#child_processspawncommand-args-options" target="_blank">options:obj</a>)
        </td>
        <td>
          - asynchronously executes an executable file or command (directly without shell by default) <br>
          - returns a <reqval>childProcess</reqval> which streams the data between the parrent and child process <br>
          - designed to keep the child process running and actively communicate with the parent process
        </td>
      </tr>
      <tr>
        <td>
          <lit>child_process</lit>.spawnSync(<strong>cmd|exePath:str</strong>, <i class="openable">[cmdArg, ...]<div>
              <p> - command argument(s) </p>
            </div></i> <a href="https://nodejs.org/docs/latest/api/child_process.html#child_processspawnsynccommand-args-options" target="_blank">options:obj</a>)
        </td>
        <td>
          - synchronous version of <mark>spawn()</mark> <u>(blocks the parent process until finishes)</u><br>
          - returns an <span class="openable">object<div>
              <p> - pid: <strong>nr</strong> - child process id </p>
              <p> - output: <strong>arr</strong> - stdio in an Array </p>
              <p> - stdout: <strong>buff|str</strong> - standard out </p>
              <p> - stderr: <strong>buff|str</strong> - standard error </p>
              <p> - status: <strong>nr|null</strong> - exit code or null if the subprocess terminated due to a signal </p>
              <p> - signal: <strong>str|null</strong> - signal used to kill ths subprocess, null = subprocess did not terminated due to a signal </p>
              <p> - error: <strong>err</strong> - error </p>
            </div></span> with the child process result, <span class="openable">the returned data size is limited<div>
              <p> - default max size 1024*1024 in bytes (by default) </p>
              <p> - if the returned data size is larger than allowed then the data is trunkated and the process is terminated! </p>
            </div></span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr id="fork">
        <td>
          <lit>child_process</lit>.fork(<strong>modulePath:str</strong>, <i class="openable">[cmdArg, ...]<div>
              <p> - command argument(s) </p>
            </div></i>, <a href="https://nodejs.org/docs/latest/api/child_process.html#child_processforkmodulepath-args-options" target="_blank">options:obj</a>)
        </td>
        <td>
          - asynchronously launches a node.js process (directly without shell) <br>
          - streams the data, communicates by an IPC channel with the parent process <u>(required)</u>, (Default: stdio set to <mark>'inherit'</mark> = uses its parent stdio) <br>
          - returns a <reqval>childProcess</reqval> which streams the data between the parrent and child process
        </td>
      </tr>
      <tr>
        <td colspan="2"> Methods and Properties </td>
      </tr>
      <tr>
        <td> <strong>childProcess</strong>.channel </td>
        <td> - references the IPC channel between the parent and the child process
          <span id="browserSupport" title="updated : 2019-06-19">
            <span><i class="fab fa-node-js"></i> 7.1.0 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td> <strong>childProcess</strong>.connected </td>
        <td> - returns a boolean indicating if the IPC channel is connected to the parent process </td>
      </tr>
      <tr>
        <td>
          <strong>childProcess</strong>.send(<strong>msg</strong>, <a href="https://nodejs.org/docs/latest/api/child_process.html#subprocesssendmessage-sendhandle-options-callback" target="_blank">handle, options:obj</a>, <strong class="openable">fn(err)<div>
              <p> - <strong>err</strong> - (if sending successful = <mark>null</mark>) (if sending fails = <mark>null</mark>) </p>
            </div></strong>)
        </td>
        <td> 
          - sends a message through the IPC channel to this <strong>childProcess</strong> and returns a boolean indicating if the sending was successfull
          <span id="browserSupport" title="updated : 2020-07-09">
            <span><i class="fab fa-node-js"></i> 0.5.9 </span>
            <span class="openable"><i class="fab fa-node-js"></i> more... <div>
                <p> - 4.0.0 - callback supported </p>
                <p> - 5.0.0 - return a boolean </p>
                <p> - 5.8.0 - <i>option</i> argument </p>
              </div></span>
          </span>
        </td>
      </tr>
      <tr>
        <td> <strong>childProcess</strong>.disconnect() </td>
        <td> 
          - <u>gracefully</u> disconnects the IPC channel from the parent process (emits the <mark>disconnect</mark> event if no message is pending) (can be invoked within the <mark>fork()</mark> child process module)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <strong>childProcess</strong>.pid </td>
        <td> 
          - returns the process identifier of the child process
        </td>
      </tr>
      <tr>
        <td>
          <strong>childProcess</strong>.kill(<strong>signal:str|nr</strong>)
        </td>
        <td> 
          - sends a signal to the child process (default <mark>SIGTERM</mark>) <a href="https://nodejs.org/dist/latest-v12.x/docs/api/process.html#process_signal_events" target="_blank">(Node.js.org signal events)</a>
        </td>
      </tr>
      <tr>
        <td>
          <strong>childProcess</strong>.killed
        </td>
        <td> 
          - returns a boolean inidcating the child process has successfully received the kill signal by the <mark>kill()</mark> method (does NOT indicate the child process closure)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <strong>childProcess</strong>.unref() </td>
        <td> 
          - removes the child process from the parent event loop, so the parent process won't wait for the child process to close <u>(if there is an IPC channel between the parent and child the parent process cannot be closed!)</u>
        </td>
      </tr>
      <tr>
        <td>
          <strong>childProcess</strong>.ref()
        </td>
        <td>
          - reataches the removed child process in the parent event loop (reverses the <mark>unref()</mark> method's effect)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <strong>childProcess</strong>.stdio </td>
        <td> - references the child process's streams in an Array (<mark>[stdin, stdout, stderr]</mark>) </td>
      </tr>
      <tr>
        <td> <strong>childProcess</strong>.stderr </td>
        <td> - references the child process's standard error readable stream </td>
      </tr>
      <tr>
        <td> <strong>childProcess</strong>.stdin </td>
        <td> - references the child process's standard in writable stream </td>
      </tr>
      <tr>
        <td> <strong>childProcess</strong>.stdout </td>
        <td> - references the child process's standard out readable stream </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <strong>childProcess</strong>.signalCode </td>
        <td> - signal received by the <strong>childProcess</strong> if any, else <mark>null</mark> </td>
      </tr>
      <tr>
        <td> <strong>childProcess</strong>.spawnargs </td>
        <td> - list of command-line arguments the <strong>childProcess</strong> was launched with </td>
      </tr>
      <tr>
        <td> <strong>childProcess</strong>.spawnfile </td>
        <td> - executable file name of the child process that is launched </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2"> events </td>
      </tr>
      <tr>
        <td>
          <strong>childProcess.listener</strong>('message' <strong>fn(msg, <strong class="openable">handle<div>
                <p> - running server object (server which is listening) </p>
                <p> - server socket <u>which is connected</u> </p>
                <p> - in not an active server or server socket was sent = <mark>undefined</mark> </p>
              </div></strong>)</strong>)
        </td>
        <td> 
          - emitted when the child process recieves a message through the IPC channel
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <strong>childPorcess.listener</strong>('close', <reqval>fn(exitCode, signal)</reqval>) </td>
        <td> 
          - event emitted when the stdio streams are closed <u>(not emited when the process ends)</u>
        </td>
      </tr>
      <tr>
        <td> <strong>childProcess.listener</strong>('disconnect' <reqval>fn()</reqval>) </td>
        <td> 
          - event emitted when the IPC channel is disconnected (also fired when the process ends)
        </td>
      </tr>
      <tr>
        <td> <strong>childProcess.listener</strong>('exit', <strong>fn(extiCode, signal)</strong>) </td>
        <td> 
          - event emitted when when the process ends (stdio streams might still be open)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <strong>childProcess.listener</strong>('error', <reqval>fn(err)</reqval>) </td>
        <td> 
          - emitted when the child process cannot be spawned, cannot be killed or message sending fails
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <strong>childProcess.listener</strong>('spawn', <reqval>fn()</reqval>) </td>
        <td> 
          - emitted when the child process is spawned (created)
          <span id="browserSupport" title="updated : 2025-02-23">
            <span><i class="fab fa-node-js"></i> 14.17.0 </span>
          </span>
        </td>
      </tr>
    </table>
    <h2 style="color:green;"><u> Notes : </u></h2>
    <details class="example" id="notes">
      <summary> Notes :</summary>
    </details>
    <h2 style="color:green;"><u> Useful Links : </u></h2>
    <p><a href="https://nodejs.org/docs/latest/api/child_process.html" target="_blank"> Node.js Child Process </a></p>
    <h2 style="color:green;"><u> Remember This : </u></h2>
    <p> - detaching child processes supported on Windows [TESTED: 2020-02-09], but according to the Node.js specification this feature is not supported on POSIX <u>(however if there's an IPC channel between the parent and the child process the parent process cannot be closed!)</u> </p>
    <h2 style="color:green;"><u> Description and Demonstration : </u></h2>
    <p> - child processes are designed to run OS functionalities (running commands is shell or directly executables) </p>
    <p> - the spawned child processes an individual process on OS level, we can detach it from its parent process (On Windows only!) [TESTED: 2020-02-09] </p>
    <h2 class="header"> The <mark>exec()</mark> / <mark>execSync()</mark> / <mark>execFile()</mark> / <mark>execFileSync()</mark> / <mark>spawn()</mark> / <mark>spawnSync()</mark> / <mark>fork()</mark> child processes </h2>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
    const {
      exec, execSync,
      execFile, execFileSync,
      spawn, spawnSync,
      fork,
    } = require('node:child_process');
    
// ------------------------------------------------------
// exec() / execSync() -------------------------
    exec('dir', (err, stdout, stder) => {          // asycnhronously spawns a shell (command prompt) to execute 'dir' command in it 
        err;                                       // process errors are outputed here 
        stdout;                                    // -> 'lists the current directory ...'      // the returned result is a string 
        stderr;                                    // child process errors are printed here 
    });
    
    
    execSync('ls', {shell:'C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe'});   // -> &lt;Buffer ...&gt; 
                                                                                                // powershell configured as sheel to execute the passed command 
                                                                                                // synchronous -> parent process blocked until the child process finishes!
    
    
// ------------------------------------------------------
// execFile() / execFileSync() ---------------------------
    execFile('C:\\Windows\\System32\\notepad.exe', ['test.txt'], function(err, stdout, stderr) {   // asynchronously launches the notepad and passes the 'test.txt' file to it    
        err;                                                                                      // process errors are outputed here 
        stdout;                                                                                   // child process output is returned here (nothing in this situation becuase the notepad doesn't output anything)   
        stderr;                                                                                   // child process errors are printed here 
    });
    
    execFile('node', ['module.js'], (err, stdout, stderr) => {                                // the comand refers to the 'node.exe' (executable)
      // ...
    });
    
    
    execFileSync('C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe', ['date']);     // -> &lt;Buffer ...&gt;     // launches the PowerShell executable with the 'date' argument 
    
    var result = execFileSync('node', ['module.js']);                         // the comand refers to the 'node.exe' (executable)
    result.toString();                                                        // -> 'some result...'
    
    
// ------------------------------------------------------
// spawn() / spawnSync() --------------------------------
    var mySpawn = spawn('C:\\Program Files\\nodejs\\node.exe', ['.\\child_1.js']);
    
    mySpawn.stdout.on('data', function(data){                                        // the data is streamed between the parrent and child process, so there's a live message communication
        data;
    });
    
    
    spawnSync('C:\\Program Files\\nodejs\\node.exe', ['.\\child_1.js']);             // -> { stdout: &lt;Buffer ...&gt;, ... }   // returns an object with the child prcess data
    
    
// ------------------------------------------------------
// fork() --------------------------------
    var frk = fork('module1.js');                  // asynchronously launches and returns a node child process
    
    frk.send({msg:'data to send'});                // sending a message to the child process through the IPC channel 
    frk.on('message', function(message){ ... });       // listening for messages on the IPC channel 
    
    
    // module1.js (file)-------------------------------
    process.on('message', function(message){ });   // sending a message to the parent process through the IPC channel
    process.send({msg:'child data to send'});      // listening for messages on the IPC channel 
    </pre>
    </details>
    <hr>
    <!------------------------------------------------------------------------------------------------------>
    <h3 class="header" id="stdioConfig"> Options <mark>stdio</mark> for <mark>fork()</mark> child process <a href="https://nodejs.org/docs/latest/api/child_process.html#optionsstdio" target="_blank">[link]</a> </h3>
    <p> - <mark>undefined</mark>, <mark>null</mark> same as <mark>'pipe'</mark> </p>
    <pre class="syntax">
    <strong>childProcessCreator</strong>(<strong>cmd</strong>, <i>...</i>,  <i class="openable">option:obj<div>
    <p> - <mark>stdio</mark> options: </p>
    <p class="indent-lv1"> <mark>['pipe', 'pipe','pipe']</mark> : (Default) child process has its own stdio (<u>same as <mark>stdio:'pipe'</mark></u>) </p>
    <p class="indent-lv1"> <mark>['ignore', 'ignore', 'ignore']</mark> : stdio are attached to <mark>dev/null</mark> (pit-bucked, leads nowhere) (<u>same as <mark>stdio:'ignore'</mark></u>) </p>
    <p class="indent-lv1"> <mark>['inherit', 'inherit', 'inherit']</mark> : uses its parent's stdio (<u>same as <mark>stdio:'inherit'</mark></u> </p>
    <p class="indent-lv1"> <mark>[<strong>stdin, stdout, stderr</strong>, 'ipc']</mark> : creates an IPC channel between the child and the process </p>
    <p class="indent-lv1"> <mark>[<strong>stream:obj, ...</strong>]</mark> : a stream object can be attached to any of the channel </p>
    </div></i>)
    </pre>
    <details class="example">
      <summary> Example : </summary>
      <pre style="margin-bottom:1px;">
// main.js (file) ---------------------------------------------------------------------------------
    var { spawn } = require('child_process');
    var fs = require('fs');
        
    var out = fs.openSync('out.txt', 'a');
        
    var spawn1 = spawn('node', ['module1.js'], {stdio:'pipe'});                // child process has its own streams but not connecte to the parent 
    var spawn2 = spawn('node', ['module2.js'], {stdio:'ignore'});              // child process IOs are dumped in 'dev/null'
    var spawn3 = spawn('node', ['module3.js'], {stdio:'inherit'});             // child process uses the parent's streams (does not have it own streams)    // -! data is printed directly in the parent module   
    var spawn4 = spawn('node', ['module4.js'], {stdio:['ignore', out, 'ignore']});  // the stdout is piped into a stream file 
    var spawn5 = spawn('node', ['module5.js'], {stdio:[null, null, null, 'ipc']});  // an IPC channel is estabilished between the parent and the child   
    
    spawn1.stdio;                                                          // -> [Socket{...}, Socket{...}, Socket{...}]    // child has its own streams   
    spawn2.stdio;                                                          // -> [null, null, null ]                        // child does not have its own streams 
    spawn3.stdio;                                                          // -> [null, null, null ]                        // child does not have its own streams 
    spawn4.stdio;                                                          // -> [null, null, null ]                        // child does not have its own streams 
    spawn5.stdio;                                                          // -> [Socket{...}, Socket{...}, Socket{...}, null]  // has an IPC channel 
    
    spawn5.on('message', function(msg) {
        console.log( msg );                                                    // receive the message passed throug the IPC channel   
    });
    
// module1.js - module4.js (files) ----------------------------------------------------------------
    setInterval(function(){
        console.log('module1 is running!');
    }, 1000);
    
// module5.js (file) ------------------------------------------------------------------------------
    setInterval(function(){
        process.send('module5 is running!');                                   // sending message through the IPC channel 
    }, 1000);    
    
// out.log (file) ---------------------------------------------------------------------------------
    module4 is running!                                                        // stdout of module4.js is collected here 
    module4 is running!
    module4 is running!
    module4 is running!
    module4 is running!
    module4 is running!    
    </pre>
      <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 Node.js\child process\19 options.stdio TEST> node main
        [Socket{...}, Socket{...}, Socket{...}]                                // -! spawn1.stdio
        [null, null, null ]                                                    // -! spawn2.stdio
        [null, null, null ]                                                    // -! spawn3.stdio
        [null, null, null ]                                                    // -! spawn4.stdio
        [Socket{...}, Socket{...}, Socket{...}, null]                          // -! spawn5.stdio
        module3 is running!                                                    // module3 and module5 are connected to the main module 
        module5 is running!
        module3 is running!
        module5 is running!
        module3 is running!
        module5 is running!                                                    // CTRL + C pressed (exiting the program)
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 Node.js\child process\19 options.stdio TEST>    
    </pre>
      <hr>
      <!------------------------------------------------------------------------------------------------------>
      <h3 class="header"> The <mark>options.silent</mark> option </h3>
      <pre style="margin-bottom:1px;">
// main.js (file) ---------------------------------------------------------------------------------
    var {fork} = require('child_process');
    var fork = fork('module1.js', {silent:true});                              // this is basically same as (stdio:'pipe')
    
    console.log( fork.stdio );                                                 // -> [Socket {...}, Socket {...}, Socket {...}, null]
    
// module1.js (file) ------------------------------------------------------------------------------
    </pre>
      <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 Node.js\child process\20 option.silet TEST> node main.js
        [Socket {...}, Socket {...}, Socket {...}, null]
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 Node.js\child process\20 option.silet TEST>    
    </pre>
    </details>
    <hr>
    <!------------------------------------------------------------------------------------------------------>
    <h2 class="headerExtra"><u> Properties and Methods </u></h2>
    <h3 class="header"> The <mark>channel</mark> / <mark>connected</mark> / <mark>disconnect()</mark> / <mark>send()</mark> methods and properties </h3>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
// main.js (file) ---------------------------------------------------------------------
// ------------------------------------------------------------------------------------
    var {fork} = require('child_process');
    var frk = fork('module1.js');
    
// connected / channel ----------------------------------------------------------------
    frk.connected;                                                                     // -> true               // IPC channel connected 
    frk.channel;                                                                       // -> Pipe{..}           // IPC channel returned 
    
// send() -----------------------------------------------------------------------------
    frk.send('my message', function(err){                                              // -> true               // callback function feeds back (message sending successful)
        err;                                                                           // -> null               // would be an error if the sending fails 
    })
    
// disconnect() / connected -----------------------------------------------------------
    frk.disconnect();                                                                  // this disconnects the IPC channel 
    frk.connected;                                                                     // -> false              // IPC channel not connected any more
    
// module1.js (file) ------------------------------------------------------------------
// ------------------------------------------------------------------------------------
    process.on('message', function(message){ message });                               // sent message handled here 
    </pre>
    </details>
    <hr>
    <!------------------------------------------------------------------------------------------------------>
    <h3 class="header"> The <mark>pid</mark> / <mark>kill()</mark> / <mark>killed</mark> methods and properties </h3>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
// main.js (file) ---------------------------------------------------------------------------
    var {fork} = require('child_process');
    var frk = fork('module1.js');
    
    frk.pid;                                                                   // -> 7772           // child process id
    frk.kill('SIGINT');                                                        // sending a signal to the child process in order to terminate it
    frk.killed;                                                                // -> true           // signal sent successfully by the 'kill()' method
    
    frk.on('exit', function(code, signal) {
        signal                                                                 // -> 'SIGINT'       // the sent signal 
    }) 
    
    
// module1.js (file) ------------------------------------------------------------------------
    process.on('message', function(message){ });                               // listening to the IPC channel keeps the child process alive 
    </pre>
    </details>
    <hr>
    <!------------------------------------------------------------------------------------------------------>
    <h3 class="header"> The <mark>unref()</mark> / <mark>ref()</mark> methods </h3>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
// main.js (file) ---------------------------------------------------------------------------
    var {spawn} = require('child_process');
    
    var fs = require('fs');
    var out = fs.openSync('out.txt', 'a');                                     // the stdout of the child process is collected in this file (I couldn't output the data in the terminal [TESTED 2019-06-21])   
    
    var spawn = spawn('node', ['module1.js'],
      {
        stdio: ['ignore', out, 'ignore'],                                      // redirecting the stdout of the created child process  
        detached: true
      },
    );                                                                         // -! required if we want to detach the child process 
    
    spawn.unref();                                                             // child process is removed from the parent's event loop (parent process can be closed even if the child process is still running)     
    spawn.ref();                                                            // reatach the child process in the parent event loop
    
    
// module1.js (file) ------------------------------------------------------------------------
  // -! this module will run in the background infinitely careful!
    setInterval(function(){                                                    // continous task will keep alive the child process (without its parent at this point)
        console.log( 'module is running!' );
    }, 500);
    </pre>
    </details>
    <hr>
    <!------------------------------------------------------------------------------------------------------>
    <h3 class="header"> The <mark>stdio</mark> / <mark>stdin</mark> / <mark>stdout</mark> / <mark>stderr</mark> properties </h3>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
    var {exec} = require('child_process');
    var exec = exec('dir');
    
// stdin / stdout / stderr ----------------------------------------------------
    exec.stdin;                                                                // -> Socket { ... }         // writable stream 
    exec.stdout;                                                               // -> Socket { ... }         // readable stream 
    exec.stderr;                                                               // -> Socket { ... }         // readable stream 
    
// stdio ----------------------------------------------------------------------
    exec.stdio;                                                                // -> [Socket { ... }, Socket { ... }, Socket { ... }]       // [stdin, stdout, stderr]
    exec.stdio[0] === exec.stdin                                               // -> true 
    exec.stdio[1] === exec.stdout                                              // -> true 
    exec.stdio[2] === exec.stderr                                              // -> true 
    </pre>
    </details>
    <hr>
    <!------------------------------------------------------------------------------------------------------>
    <h2 class="headerExtra"> Events </h2>
    <h3 class="header"> The <mark>exit</mark> / <mark>close</mark> / <mark>disconnect</mark> / <mark>error</mark> / <mark>message</mark> events </h3>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
// main.js (file) ---------------------------------------------------------------------------
    var { fork, spawn } = require('node:child_process');
    var fork = fork('module1.js');
    
// exit -----------------------------------------------------------------------
    fork.on('exit', function(code, signal){                                    // fires when this process ends 
        code;                                                                  // -> 0                  // exit code (anything above 0 means some problem)
        signal;                                                                // -> null               // signal recieved by this process 
    });
    
// close ---------------------------------------------------------------------- 
    fork.on('close', function(code, signal){                                   // fires when the standard input output streams are closed of this process 
        code;                                                                  // -> 0                  // exit code (anything above 0 means some problem)
        signal;                                                                // -> null               // signal recieved by this process 
    });
    
// disconnect -----------------------------------------------------------------
    fork.on('disconnect', function(){ })                                       // fires when the IPC channel closes between the processes // -! also fired when the process closes 
    
// error ----------------------------------------------------------------------
    fork.on('error', function(error){                                          // fires when an error occures (like message sending)
        error;                                                                 // -> Error              // error object of the thrown corresponding error
    });
    
// message --------------------------------------------------------------------
    fork.on('message', function(message, serverObj){                           // fires when the child process sends a message through the IPC channel   
        message;                                                               // -> 'child data sent'  // message sent by the child process
        serverObj;                                                             // [NOT TESTED]        
    });
    
    
// module1.js (file) ------------------------------------------------------------------------
    process.send('child data sent');
    </pre>
    </details>
    <hr>
    <!------------------------------------------------------------------------------------------------------>
    <h3 class="header"> The <mark>spawn</mark> event </h3>
    <details class="example">
    <summary> DEMO </summary>
    <pre>
    import { fork, exec } from 'node:child_process';
    
    
    const forkChildProces = fork('module1.mjs');
    const execChildProcess = exec('ls -la', (err, stdout, stderr) => {
      if (err) console.log(err);
      
      console.log(stdout);
    })
    
    forkChildProces.on('spawn', () => {
      console.log('fork child proces spawned!')
    })
    
    execChildProcess.on('spawn', () => {
      console.log('exec child proces spawned!')
    })
    </pre>
    </details>


    <br><br>
  </body>
</html>