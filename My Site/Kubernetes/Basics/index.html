<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title> Demo </title>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../Assets/stylesPages.css">
    <script src="../../Assets/scriptPages.js"></script>
  </head>

  <body>
    <h1> Basics </h1>
    <p> Updated: ( 2025-09-17 ) </p>
    <nav class="sitenav">
      <a href="../../index.html">MySite > </a> 
      <a href="../index.html">Kubernetes > </a> Basics
    </nav>
    <table class="table">
      <tr>
        <th style="width:30%;"> CMD </th>
        <th> Description </th>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> get nodes
        </td>
        <td>
          - list running nodes
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> get all <opt>[options]</opt>
        </td>
        <td>
          - list all resources in the current namespace<br>
          <opt>[options]</opt> <br>
          - (<opt>-n <optval>nameSpace</optval></opt>) on the specified namespace<br>
          - (<opt>-o wide</opt>) outputs extra info<br>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> apply -f <reqval>configFilePath</reqval>
        </td>
        <td>
          - applies configurations described in the config file to the kubernetes cluster (idempontent -> updates resources based on config changes) 
        </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> delete -f <reqval>configFilePath</reqval>
        </td>
        <td>
          - removes resources described in the config file from the kubernetes cluster 
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2"> Namespace </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> get namespace <reqval>namespaceName</reqval> <opt>[options]</opt>
        </td>
        <td>
          - list namespaces (or the specified namespace) <br>
          <opt>[options]</opt> <br>
          - (<opt>-o yaml</opt>) output in yaml format (retrieved directly from etcd) <br>
        </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> create namespace <reqval>namespaceName</reqval>
        </td>
        <td>
          - creates a new namespace 
        </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> delete namespace <reqval>namespaceName</reqval>
        </td>
        <td>
          - deletes the specified namespace 
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> config set-context --current --namespace=<reqval>namespaceName</reqval>
        </td>
        <td>
          - set (selects) the current namespace
        </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> config view --minify | grep namespace
        </td>
        <td>
          - returns the currently selected namespace
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2"> Deployment </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> get deployment <optval>deploymentName</optval> <opt>[options]</opt>
        </td>
        <td>
          - list all deployments (or the specified one)<br>
          <opt>[options]</opt> <br>
          - (<opt>-n <optval>nameSpace</optval></opt>) on the specified namespace<br>
          - (<opt>-o wide</opt>) outputs extra info<br>
          - (<opt>-o yaml</opt>) output in yaml format (retrieved directly from etcd) <br>
        </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> create deployment <optval>deploymentName</optval> --image=<reqval>dockerImage</reqval>
        </td>
        <td>
          - creates a deployment from <reqval>dockerImage</reqval>
        </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> delete deployment <optval>deploymentName</optval>
        </td>
        <td>
          - deletes the specified deployment
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> edit deployment <optval>deploymentName</optval>
        </td>
        <td>
          - in terminal editor opens the deployment config file (directly from etcd), once saved kubernetes applies the changes
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2"> Pod </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> get pod <optval>podName</optval> <opt>[options]</opt>
        </td>
        <td>
          - list all pods (or the specified one)<br>
          <opt>[options]</opt> <br>
          - (<opt>-n <optval>nameSpace</optval></opt>) on the specified namespace<br>
          - (<opt>-o wide</opt>) outputs extra info<br>
          - (<opt>-o yaml</opt>) output in yaml format (retrieved directly from etcd) <br>
        </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> describe pod <optval>podName</optval>
        </td>
        <td>
          - prints detailed info about all pods (or the specified one)<br>
        </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> delete pod <reqval>podName</reqval>
        </td>
        <td>
          - deletes the specified pod
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> exec -it <reqval>podName</reqval> <opt>[options]</opt> -- bash
        </td>
        <td>
          - opens the 1st container's shell in the pod (just like in Docker)<br>
          <opt>[options]</opt><br>
          - (<opt>-c <optval>containerName</optval></opt>) specify which container's shell to open (if pod has multiple)
        </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> logs <reqval>podName</reqval> <opt>[options]</opt>
        </td>
        <td>
          - prints the 1st container's logs in the pod (just like in Docker)<br>
          <opt>[options]</opt><br>
          - (<opt>-f</opt>) follows the logs in real-time<br>
          - (<opt>-c <optval>containerName</optval></opt>) specify which container's shell to open (if pod has multiple)<br>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2"> Replicaset </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> get replicaset <optval>replicasetName</optval> <opt>[options]</opt>
        </td>
        <td>
          - list all replicasets (or the specified one)<br>
          <opt>[options]</opt> <br>
          - (<opt>-n <optval>nameSpace</optval></opt>) on the specified namespace<br>
          - (<opt>-o wide</opt>) outputs extra info<br>
          - (<opt>-o yaml</opt>) output in yaml format (retrieved directly from etcd) <br>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      
      
      
      <tr>
        <td colspan="2"> Service </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> get service <optval>serviceName</optval> <opt>[options]</opt>
        </td>
        <td>
          - list all services (or the specified one)<br>
          <opt>[options]</opt> <br>
          - (<opt>-n <optval>nameSpace</optval></opt>) on the specified namespace<br>
          - (<opt>-o wide</opt>) outputs extra info<br>
          - (<opt>-o yaml</opt>) output in yaml format (retrieved directly from etcd) <br>
        </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> describe service <optval>serviceName</optval>
        </td>
        <td>
          - prints detailed info about all services (or the specified one)<br>
        </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> delete service <reqval>serviceName</reqval>
        </td>
        <td>
          - deletes the specified service
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2"> Ingress </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> get ingress <optval>ingressName</optval> <opt>[options]</opt>
        </td>
        <td>
          - list all ingresses (or the specified one)<br>
          <opt>[options]</opt> <br>
          - (<opt>-n <optval>nameSpace</optval></opt>) on the specified namespace<br>
          - (<opt>-o yaml</opt>) output in yaml format (retrieved directly from etcd) <br>
        </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> describe ingress <optval>ingressName</optval>
        </td>
        <td>
          - prints detailed info about all services (or the specified one)<br>
        </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> delete ingress <reqval>ingressName</reqval>
        </td>
        <td>
          - deletes the specified ingress
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2"> Configmap & Secret </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> get configmap <optval>configmapName</optval> <opt>[options]</opt>
        </td>
        <td>
          - list all configmaps (or the specified one)<br>
          <opt>[options]</opt> <br>
          - (<opt>-n <optval>nameSpace</optval></opt>) on the specified namespace<br>
          - (<opt>-o yaml</opt>) output in yaml format (retrieved directly from etcd) <br>
        </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> describe configmap <optval>configmapName</optval>
        </td>
        <td>
          - prints detailed info about all configmaps (or the specified one)<br>
        </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> delete configmap <reqval>configmapName</reqval>
        </td>
        <td>
          - deletes the specified configmap
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> get secret <optval>secretName</optval> <opt>[options]</opt>
        </td>
        <td>
          - list all secrets (or the specified one)<br>
          <opt>[options]</opt> <br>
          - (<opt>-n <optval>nameSpace</optval></opt>) on the specified namespace<br>
          - (<opt>-o yaml</opt>) output in yaml format (retrieved directly from etcd) <br>
        </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> describe secret <optval>secretName</optval>
        </td>
        <td>
          - prints detailed info about all secrets (or the specified one)<br>
        </td>
      </tr>
      <tr>
        <td>
          <lit>kubectl</lit> delete secret <reqval>secretName</reqval>
        </td>
        <td>
          - deletes the specified secret
        </td>
      </tr>
    </table>
    <br>
    <p> - Minikube is a single-node Kubernetes cluster on a local machine for development and testing </p>
    <table class="table">
      <caption> Minikube </caption>
      <tr>
        <th style="width:30%;"> CMD </th>
        <th> Description </th>
      </tr>
      <tr>
        <td>
          <lit>minikube</lit> status
        </td>
        <td>
          - prints the munikube's status
        </td>
      </tr>
        <td>
          <lit>minikube</lit> dashboard
        </td>
        <td>
          - launches a web-based UI for managing the cluster 
        </td>
      </tr>
      <tr>
        <td>
          <lit>minikube</lit> start --driver=<reqval>vmDriver</reqval>
        </td>
        <td>
          - starts minikube with <reqval>vmDriver</reqval> (ex: <mark>minikube start --driver=docker</mark>) <br>
          - minikube needs virtualization (VM) to run but docker is also supported
        </td>
      </tr>
      <tr>
        <td>
          <lit>minikube</lit> stop
        </td>
        <td>
          - stops minikube
        </td>
      </tr>
      <tr>
        <td>
          <lit>minikube</lit> delete
        </td>
        <td>
          - deletes all configurations and data from minikube
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <lit>minikube</lit> service <reqval>service</reqval>
        </td>
        <td>
          - exposes the service to the outside world (must be an external service)
        </td>
      </tr>
      <tr>
        <td>
          <lit>minikube</lit> tunnel
        </td>
        <td>
          - creates a tunnel for ingresses
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <lit>minikube</lit> addons list
        </td>
        <td>
          - list available minikube addons (with their status) 
        </td>
      </tr>
      <tr>
        <td>
          <lit>minikube</lit> addons enable|disable <reqval>addon</reqval>
        </td>
        <td>
          - enable|disable minikube addon (ex: <mark>minikube addons enable ingress</mark> enables minikube ingress)
        </td>
      </tr>
    </table>
    <h2 class="headerSection"> Notes : </h2>

    <h2 class="headerSection"> Useful Links : </h2>

    <h2 class="headerSection"> Remember This : </h2>
    <p> - minikube running on docker driver in order to expose external service run the <mark>minikube service &lt;service&gt;</mark> command, in order to expose ingresses run the <mark>minikube tunnel</mark> command </p>
    <h2 class="headerSection"> Description and Demonstration : </h2>
    <p> - Kubernetes (K8s) is an open source conatiner orchestration freamework developed by Google, it's designed to work in cloud environments but can also run on-premises </p>
    <p> - in configurations, components are interconnected by assigning names to them and referencing these names wherever needed (ex: referencing a configmap value), this feature is also supported for network abstraction (ex: referencing pod names from a service) </p>
    <!-------------------------------------------------------------------->
    <hr>
    <h2 class="header"> Kubernetes Components: </h2>
    <p> - <mark class="mark">Cluster</mark> -> namespace for all </p>
    <p> - <mark class="mark">Namespace</mark> -> a namespace within the cluster in order to isolate resources </p>
    <p class="indent-lv1"> - however there are some resources that are available cluster wide, like Persistent Volumes, Ingress, etc... </p>
    <p> - <mark class="mark">Node</mark> -> a physical or virtual machine </p>
    <p class="indent-lv1"> - <mark class="mark">Master Node</mark> -> control plane that manages the Kubernetes cluster, responsible for maintaining the desired state of the cluster </p>
    <p class="indent-lv2"> - <mark class="mark">API Server</mark> -> central hub for all communication within the cluster </p>
    <p class="indent-lv2"> - <mark class="mark">Scheduler</mark> -> assigns workloads to worker nodes based on resource availability </p>
    <p class="indent-lv2"> - <mark class="mark">Controller Manager</mark> -> maintains the desired state of the cluster, monitors component states, and requests changes from the API Server if any component is not in its desired state </p>
    <p class="indent-lv2"> - <mark class="mark">etcd</mark> -> distributed key-value store that holds the cluster's state data </p>
    <p class="indent-lv3"> - open source implementation of <a href="https://etcd.io/" target="_blanc">etcd</a>, in prod it's the DevOps developer's responsibility to set it up </p>
    <p class="indent-lv1"> - <mark class="mark">Worker Node</mark> -> data plane that is running the actual applications </p>
    <p class="indent-lv2"> - <mark class="mark">Kubelet</mark> -> agent that ensures that contaienrs are running as expected, communicates with the Master Node to receive instructions and report back the status of the node </p>
    <p class="indent-lv2"> - <mark class="mark">Kube-Proxy</mark> -> provides network communication for the Node </p>
    <p class="indent-lv2"> - <mark class="mark">Container Runtime</mark> -> responsible for running containers </p>
    <p class="indent-lv1"> - <mark class="mark">Deployment</mark> -> a blueprint for pod configurations (to deploy pods we describe them as deployment) </p>
    <p class="indent-lv2"> - <mark class="mark">ReplicaSet</mark> -> sets the number of (replica) pod running at any given time (set by Deployment) </p>
    <p class="indent-lv3"> - <mark class="mark">Pod</mark> -> abstraction over a group of containers (set by Deployment) </p>
    <p class="indent-lv4"> - pods in the kubernetes cluster are designed to be ephemeral (easily replacable) </p>
    <p class="indent-lv1"> - <mark class="mark">StatefulSet</mark> -> Deployment for stateful pods (like DB) </p>
    <p class="indent-lv2"> - pods have sticky identity so when the container inside fails and recreated the same id is reatached to the same pod </p>
    <p class="indent-lv2"> - Remember: StatefulSets only provide connectivity features, but the acutal underlying logic must be implemented by the developer (like: DB WORM strategy) </p>
    <p class="indent-lv1"> - <mark class="mark">ConfigMap</mark> -> contains external configuration </p>
    <p class="indent-lv2"> - can be mounthed as volume inside the pod </p>
    <p class="indent-lv2"> - namespace scoped (cannot be referenced from another namespace) </p>
    <p class="indent-lv1"> - <mark class="mark">Secret</mark> -> contains secrets <u>(secret values are base64 encoded)</u> </p>
    <p class="indent-lv2"> - namespace scoped (cannot be referenced from another namespace) </p>
    <p class="indent-lv1"> - <mark class="mark">Service</mark> -> stable traffic bridge, it provides a static IP address for pods (also acts as load balancer) </p>
    <p class="indent-lv2"> - thie main idea is that if the routed pods are recreated they are reachable on the same IP </p>
    <p class="indent-lv2"> - Types: </p>
    <p class="indent-lv3"> - <mark class="mark">ClusterIP</mark> -> internal (cluster) traffic routing (Default) </p>
    <p class="indent-lv3"> - <mark class="mark">Headless</mark> -> routes direct communication with pods (used for StatefulSets) </p>
    <p class="indent-lv3"> - <mark class="mark">NodePort</mark> -> opens an external access (used for dev pupuses only) (available port range 30000 - 32767) </p>
    <p class="indent-lv3"> - <mark class="mark">LoadBalancer</mark> -> exposes the traffic for an external load balancer (like to Azure load balancer) </p>
    <p class="indent-lv1"> - <mark class="mark">NetworkPolicy</mark> -> defines how groups of pods can communicate with each other and with other network endpoints <a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/" target="_blank">[link]</a> </p>
    <p class="indent-lv1"> - <mark class="mark">Ingress</mark> -> routes external traffic to internal resources </p>
    <p class="indent-lv2"> - acts as cluster gateway, but also as TLS termination </p>
    <p class="indent-lv2"> - deployed as pod, so it be deployed on specific nodes as ReplicaSet </p>
    <p class="indent-lv2"> - <mark class="mark">Ingress Controller</mark> -> it's an implementation of Ingress, we can install different ingresses such as NGINX, HAProxy, etc... </p>
    <p class="indent-lv2"> - <mark class="mark">Ingress Class</mark> -> maps an Ingress Controller (Ingress Implementation) to a name, it's useful if several controllers are installed, so we can reference them by name </p>
    <p class="indent-lv1"> - <mark class="mark">Volume</mark> -> storage attached to a pod <a href="https://kubernetes.io/docs/concepts/storage/" target="_blank">[link]</a> </p>
    <p class="indent-lv2"> - <mark class="mark">Persistent Volume (PV)</mark> -> abstraction over a real storage (disk, remote storage, etc...) (tipically configured by the cluster admin) </p>
    <p class="indent-lv2"> - <mark class="mark">Persistent Volume Claim (PVC)</mark> -> a request for storage describing sotrage caracteristics </p>
    <p class="indent-lv3"> - a Persistent Volume Claim (PVC) is created out of the available Persistent Volume (PV), then it can be attached to a pod as volume </p>
    <p class="indent-lv2"> - <mark class="mark">Storage Class</mark> -> dynamically provisions Persistent Volume (PV) when the Persistent Volume Claim (PVC) is created </p>
    <!-------------------------------------------------------------------->
    <hr>
    <h2 class="header"> Cluster Network </h2>
    <p> - Kubernetes has its own internal virtual network and DNS service (flat networking model is used, meaning there's no NAT) </p>
    <p> - names are automatically assigned when components are created (ex: pod name syntax <mark>&lt;pod-ip-address&gt;.&lt;namespace&gt;.pod.cluster.local</mark>) </p>
    <p> - when setting up the cluster, we typically configure using component names directly rather than referencing IP addresses or DNS names in most situations (ex: referencing pod names from a service) </p>
    <!-------------------------------------------------------------------->
    <hr>
    <h2 class="header"> General Knowledge </h2>
    <p> The concepts of <mark class="mark">Control Plane</mark> VS <mark class="mark">Data Plane</mark> </p>
    <p class="indent-lv1"> - Control Plane: </p>
    <p class="indent-lv2"> - Manages the overall state and configuration of the Kubernetes cluster </p>
    <p class="indent-lv2"> - Ensures the cluster operates according to the desired state, making decisions and orchestrating workloads </p>
    <p class="indent-lv2"> - Master Nodes </p>
    <p class="indent-lv1"> - Data Plane: </p>
    <p class="indent-lv2"> - Executes workloads and handles network traffic within the cluster </p>
    <p class="indent-lv2"> - Runs application containers, manages resources, and facilitates communication between services </p>
    <p class="indent-lv2"> - Worker Nodes </p>
    <p> Access Control </p>
    <p class="indent-lv1"> - Kubernetes supports <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/" target="_blank">RBAC</a> (Role Based Access Control), so we can control who can access what </p>
    <p class="indent-lv1"> - The following athentication strategies are supported: <a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#authentication-strategies" target="_blank">Client Cert, Bearer Tokens, OpenID Connect or Webhook Token</a> </p>
    <p class="indent-lv1"> - <mark>kubectl</mark> connection is configured through the <mark>~/.kube/config</mark> file </p>
    <p> Secure network communication inside the cluster </p>
    <p class="indent-lv1"> - When creating cluster components Kubernetes automatically handles certificate creation in order to ensure TLS communication inside the cluster </p>
    <p> Multi Container Pods </p>
    <p class="indent-lv1"> - multiple containers within the same pod easily communicate with each other through <mark>localhost</mark> (ex: cont-1 listens on <mark>localhost:8080</mark> cont-2 listens on <mark>localhost:8081</mark>) </p>
    <p class="indent-lv1"> - a pod has one IP address (pod name), multiple containers can be exposed each on its own port </p>
    <p> Assign Pods to Nodes <a href="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/" target="_blank">[link]</a> </p>
    <p class="indent-lv1"> - by default the scheduler tries to distribute pods evenly on worker nodes (takes into consideration the nodes resources (CPU, RAM, etc...) </p>
    <p class="indent-lv1"> - however we can control this behaviour with the follwoing strategies: <mark class="mark">Node Selector</mark>, <mark class="mark">Node Affinity</mark>, <mark class="mark">Taints and Tolerations</mark> (configures to which pods not to deploy to) </p>
    <p> Load Balancing </p>
    <p class="indent-lv1"> - by default the load is distributed in round-robin fashion among ReplicaSets </p>
    <p class="indent-lv1"> - we can configure different load balancing strategies depending the installed Ingress Controller (implementation of ingress) </p>


    <br><br>
  </body>

</html>