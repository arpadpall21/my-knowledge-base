<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title> Numbers </title>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../Assets/stylesPages.css">
    <script src="../../Assets/scriptPages.js"></script>
  </head>
  <body>
    <h1> Numbers </h1>
    <p> Updated ( 2022-04-02 )</p>
    <nav class="sitenav"> <a href="../../index.html">MySite > </a>
      <a href="../index.html">Python > </a> Numbers
    </nav>
    <table class="table">
      <caption>
        Methods
      </caption>
      <tr>
        <th style="width:30%;"> Method </th>
        <th> Description </th>
      </tr>
      <tr>
        <td>
          bin(<strong>int</strong>)
        </td>
        <td>
          - converts tha passed integer into <u>unsigned</u> binary notation (simply prefixes <mark>-</mark> the result when negative integer is passed)
        </td>
      </tr>
      <tr>
        <td>
          oct(<strong>int</strong>)
        </td>
        <td>
          - converts tha passed integer into <u>unsigned</u> octal notation (simply prefixes <mark>-</mark> the result when negative integer is passed)
        </td>
      </tr>
      <tr>
        <td>
          hex(<strong>int</strong>)
        </td>
        <td>
          - converts tha passed integer into <u>unsigned</u> hexadecimal notation (simply prefixes <mark>-</mark> the result when negative integer is passed)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          abs(<strong>int|float|complex</strong>)
        </td>
        <td>
          - for <strong>int|float</strong> returns the absolute value of the number (always the positive value) <br>
          - for <strong>complex</strong> returns the magnitude of the complex number
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          pow(<strong>base:int|float|complex</strong>, <strong>exp:int|float|complex</strong>)
        </td>
        <td>
          - takes the <strong>base</strong> to the power of <strong>exp</strong> and returns the result
        </td>
      </tr>
      <tr>
        <td>
          pow(<strong>base:int</strong>, <strong>exp:int</strong>, <strong>mod:int</strong>)
        </td>
        <td>
          - takes the <strong>base</strong> to the power of <strong>exp</strong> and the result is modulo divided by <strong>mod</strong>, the result is returned (faster than <mark><strong>a</strong> / <strong>b</strong> % <strong>c</strong></mark>)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          round(<strong>float</strong>, <i>decLimit:int</i>)
        </td>
        <td>
          - rounds floating points (to the closes value, does not simply chops decimals)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          divmod(<strong>int|float</strong>, <strong>int|float</strong>)
        </td>
        <td>
          - performs a modulo division (<mark>%</mark>) and returns the quotioent and the reminder in a tuple
        </td>
      </tr>
    </table>
    <br>
    <table class="table">
      <caption>
        Integer
      </caption>
      <tr>
        <th style="width:30%;"> Class / Methods </th>
        <th> Description </th>
      </tr>
      <tr>
        <td>
          int(<i>val:any</i>)
        </td>
        <td>
          - returns an integer from the passed value (returns <mark>0</mark> if no argument passed)
        </td>
      </tr>
      <tr>
        <td>
          int(<strong>str|bytes|bytesArr</strong>, <strong>base(2-32):int</strong>)
        </td>
        <td>
          - interprets the passed <strong>str|byte|byteArr</strong> in <strong>base</strong> (<mark>2</mark>-<mark>32</mark> / Default <mark>10</mark>) and returns the integer result
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2"> Methods </td>
      </tr>
      <tr>
        <td>
          <strong>int</strong>.bit_length()
        </td>
        <td>
          - returns how many bits the integer takes up in memory (as integer) (excludes signs and leading zeros)
          <span id="browserSupport" title="updated: 2022-04-07">
            <span><i class="fab fa-python"></i> 3.1 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>
          <strong>int</strong>.bit_count()
        </td>
        <td>
          - returns how many <mark>1</mark> bits are (out of the integer's <mark>bit_length()</mark>) (as integer)
          <span id="browserSupport" title="updated: 2022-04-07">
            <span><i class="fab fa-python"></i> 3.1 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>int</strong>.to_bytes(<strong class="openable">length:int<div>
              <p> - the <mark>bytes</mark> object length (if the <strong>int</strong> is too big to be stored in the passed length <mark>OverflowError</mark> raised) </p>
            </div></strong>, <em class="openable">byteorder="big|little"<div>
              <p> - <mark>big</mark> - stored as big endianes (most significant bytes first) </p>
              <p> - <mark>little</mark> - stored as little endianes (most significant bytes last) </p>
            </div></em>, <small class="openable">signed=<i>bol</i><div>
              <p> - <mark>False</mark> - sotred as unsigned integer (Default) </p>
              <p> - <mark>True</mark> - sotred as signed integer </p>
            </div></small>)
        </td>
        <td>
          - creates and returns a <strong>bytes</strong> object of the <strong>int</strong>
          <span id="browserSupport" title="updated: 2022-04-07">
            <span><i class="fab fa-python"></i> 3.2 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>
          <em>int</em>.from_bytes(<strong class="openable">byteLike<div>
              <p> - a bites-like object </p>
              <p> - <strong>bytes</strong> / <strong>bytesArr</strong> / <strong>array.array</strong> / <strong>memoryview</strong> </p>
            </div></strong>, <em class="openable">byteorder="big|little"<div>
              <p> - <mark>big</mark> - interpreted as big endianes (most significant bytes first) </p>
              <p> - <mark>little</mark> - interpreted as little endianes (most significant bytes last) </p>
            </div></em>, <small class="openable">signed=<i>bol</i><div>
              <p> - <mark>False</mark> - interpreted as unsigned integer (Default) </p>
              <p> - <mark>True</mark> - interpreted as signed integer </p>
            </div></small>)
        </td>
        <td>
          - the passed <strong>byteLike</strong> object is interpreted as integer and returned
          <span id="browserSupport" title="updated: 2022-04-07">
            <span><i class="fab fa-python"></i> 3.2 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>int</strong>.as_integer_ratio()
        </td>
        <td>
          - returns a tuple cotaining 2 integers which ratio is equalt to <strong>int</strong> <br>
          - this method follows the logic of <mark><strong>float</strong>.as_integer_ratio()</mark> but it's not really useful for integers because the result is always <mark>(<strong>int</strong>, 1)</strong></mark>
        <span id="browserSupport" title="updated: 2022-04-010">
          <span><i class="fab fa-python"></i> 3.8 </span>
        </span>
      </td>
    </tr>
  </table>
  <br>
  <table class="table">
    <caption>
      Float
    </caption>
    <tr>
      <th style="width:30%;"> Class / Methods </th>
      <th> Description </th>
    </tr>
    <tr>
      <td>
        float(<i>val:any</i>)
      </td>
      <td>
        - returns an double from the passed value (returns <mark>0.0</mark> if no argument passed)
      </td>
    </tr>
    <tr>
      <td>
        float('nan|inf|-inf')
      </td>
      <td>
        - creates and returns a not a number / positive or negative infinity undefined numeric type
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td colspan="2"> Methods </td>
    </tr>
    <tr>
      <td>
        <strong>float</strong>.hex()
      </td>
      <td>
        - returns the exact hexadecimal representation of the <strong>float</strong> as hexadecimal notation
      </td>
    </tr>
    <tr>
      <td>
        <strong>float</strong>.is_integer()
      </td>
      <td>
        - returns <mark>True</mark> if the float is an integer (has <mark>.0</mark> decimals), otherwise returns <mark>False</mark>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>float</strong>.as_integer_ratio()
      </td>
      <td>
        - returns a tuple cotaining 2 integers which ratio is equalt to <strong>int</strong> (retunred <mark>(<strong>a</strong>, <strong>b</strong>), <strong>a</strong> / <strong>b</strong> = <strong>int</strong></mark>)
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <em>float</em>.fromhex(<strong>hexNotation</strong>)
      </td>
      <td>
        - returns a floating point number from the passed hexadecimal notation
      </td>
    </tr>
  </table>
  <br>
  <table class="table">
    <caption>
      Complex
    </caption>
    <tr>
      <th style="width:30%;"> Class / Methods / Attributes </th>
      <th> Description </th>
    </tr>
    <tr>
      <td>
        complex(<i>str</i>)
      </td>
      <td>
        - returns a complex number of the passed string (no argument = <mark>0.0+0.0j</mark>)
      </td>
    </tr>
    <tr>
      <td>
        complex(<i>float|int</i>, <i>float|int</i>)
      </td>
      <td>
        - returns a complex number of the passed numbers (no argument = <mark>0.0+0.0j</mark>)
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td colspan="2"> Methods </td>
    </tr>
    <tr>
      <td>
        <strong>complex</strong>.real
      </td>
      <td>
        - returns the real part of the complex number
      </td>
    </tr>
    <tr>
      <td>
        <strong>complex</strong>.imag
      </td>
      <td>
        - returns the imaginary part of the complex number
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>complex</strong>.conjugate()
      </td>
      <td>
        - flips the sign of the imaginary part of the complex number and returns the result in a new <strong>complex</strong>
      </td>
    </tr>
  </table>
  <br>
   <h2 class="headerSection"> Description and Demonstration </h2>
  <h2 class="headerSection"> Useful Links : </h2>

  <h2 class="headerSection"> Remember This : </h2>

  <h2 class="headerSection"> Description and Demonstration : </h2>
  <p> - Python supports <mark class="mark">integer</mark>, <mark class="mark">double</mark> and <mark class="mark">complex</mark> numeric data types, however there are other standard (build in) numeric types as well, such as <mark class="mark">fraction</mark> and <mark class="mark">decimal</mark> </p>
  <pre class="syntax">
    <strong>nr</strong>                                                                                 // integer literal    
    <strong>nr</strong>.<strong>nr</strong>                                                                              // floating point literal    
    <strong>nr</strong>+|-<strong>nr</strong>j|J                                                                         // complex literal
    
// notations -------------------
    <strong>nr</strong>e+<strong>nr</strong>  |  <strong>nr</strong>e+<strong>nr</strong>       // scientific notation (the number afer <mark>e</mark> basically tells where the decimal dot is compared to its current position)   
    
    0x<strong>nr</strong><i>...</i>                       // hexadecimal notation (<mark>0</mark> - <mark>f</mark>)
    0o<strong>nr</strong><i>...</i>                       // octal notation (<mark>0</mark> - <mark>7</mark>)
    0b<strong>nr</strong><i>...</i>                       // binary notation (<mark>0</mark> - <mark>1</mark>) 
    
// nan / inf / -inf ----------------
    float('nan')                                     // returns not a number numerical type  
    float('inf')                                     // returns positive infinity numerical type 
    float('-inf')                                    // returns negative infinity numerical type 
    </pre>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    import math
    
    nan = float('nan')
    posInf = float('inf')
    negInf = float('-inf')
    
    math.isnan(nan)                                                                    // -> True 
    math.isinf(posInf)                                                                 // -> True 
    math.isinf(negInf)                                                                 // -> True 
    </pre>
  </details>
  <hr>
  <!---------------------------------------------------------------------------------------------------->
  <h2 class="header"> Arithmetic operations between numeric types </h2>
  <p> - Python fully supports arithmetic operations between <mark class="mark">integer</mark>, <mark class="mark">double</mark> and <mark class="mark">complex</mark> types </p>
  <p> - on mixed arithmetic operation the narrowed type is widened to the other type </p>
  <pre class="syntax">
    int   widened to    float   widened to    complex
    
    <strong>nr</strong>        =>        <strong>nr</strong>.0        =>        <strong>nr</strong>.0+0.0j
    </pre>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    <mark>5 + 5.06</mark>         => integer widened to float =>     <mark>5.0 + 5.06</mark>                     // -> 10.06
    
    <mark>5.06 + 5+14j</mark>     => float widened to complex =>     <mark>5.6+0.0j + 5.0+14.0j</mark>           // -> 10.06+14j
    </pre>
  </details>
  <hr>
  <!---------------------------------------------------------------------------------------------------->
  <h3 class="header"> Notations <mark>hex()</mark> / <mark>oct()</mark> / <mark>bin()</mark> </h3>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
// scientific notation ----------------------------------------------------------------
    143e+3                                                                             // -> 143000           // exponent notation (the decimal dot moved relative to its current position)    
    143e-3                                                                             // -> 0.143
    
    143.123e+2                                                                         // -> 14312.3
    143.123e+1                                                                         // -> 1.43123
    
    
// hexadecimal / octal / binary notations ---------------------------------------------
    '0xff'                                                                             // hexadecimal notation of <mark>255</mark>  
    '0o377'                                                                            // octal notation of <mark>255</mark>   
    '0b11111111'                                                                       // binary notation of <mark>255</mark>    
    
    hex(255)                                                                           // -> '0xff'           // returns the hexadecimal notation of the integer  
    oct(255)                                                                           // -> '0o377'          // returns the octal notation of the integer   
    bin(255)                                                                           // -> '0o377'          // returns the binary notation of the integer   
    
    int('0xff', 16)                                                                    // -> 255
    int('0o377', 8)                                                                    // -> 255
    int('0b11111111', 2)                                                               // -> 255
    </pre>
  </details>
  <hr>
  <!---------------------------------------------------------------------------------------------------->
  <h3 class="header"> The <mark>abs()</mark> / <mark>pow()</mark> / <mark>round()</mark> / <mark>divmod()</mark> methods </h3>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
// abs() ------------------------------------------------------------------------------
    abs(21.21)                                                                         // -> 21.21                // absolute number (positive number)
    abs(-21.21)                                                                        // -> 21.21
    
    abs(-84555-422j)                                                                   // -> 84556.05305949421    // for complex numbers the magnitude is returned 
    abs(222+222j)                                                                      // -> 313.9554108468271
    
    
// pow() ------------------------------------------------------------------------------
    pow(2, 8)                                                                          // -> 256
    pow(2.4, 8.1)                                                                      // -> 1201.4648174592842
    pow(2.4+54j, 2.1-011j)                                                             // -> -84232431111.1737-13284746350.41509j
    
    pow(2, 3, 3)                                                                       // -> 2                    // same as <mark>2 ** 3 % 3</mark> but computates faster 
    
    
// round() ----------------------------------------------------------------------------
    round(3.123, 2)                                                                    // -> 3.12                 // limits decimals up to 2 digits   
    
    round(3, 5)                                                                        // -> 3                    // has no effect on integers 
    round(3.12, 3)                                                                     // -> 3.12                 // has no effect because there are less decimals than the limitation here     
    
    round(3.555, 2)                                                                    // -> 3.56                 // -! floating point down rounding so it's a rounding approximation 
    
    
// divmod() ---------------------------------------------------------------------------
    divmod(5, 2)                                                                       // -> (2, 1)               // performs a modulo division and returns the quotioen and the reminder in a tuple    
    5 // 2                                                                             // -> 2
    5 % 2                                                                              // -> 1
    
    divmod(5.3, 2.1)                                                                   // -> (2.0, 1.0999999999999996)
    5.3 // 2.1                                                                         // -> 2.0
    5.3 % 2.1                                                                          // -> 1.0999999999999996
    
    divmod(0.98, 0.21)                                                                 // -> (4.0, 0.14)
    0.98 // 0.21                                                                       // -> 4.0
    0.98 % 0.21                                                                        // -> 0.14
    </pre>
  </details>
  <hr>
  <!---------------------------------------------------------------------------------------------------->
  <h2 class="headerExtra"> Integers <mark>int()</mark> </h2>
  <p> - integers are arbitrary large in Python (as big as we like (memory limited)), they can be created as integer literals or by the <mark>int()</mark> class </p>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    int('254')                                                                         // -> 254
    int(15.22)                                                                         // -> 15
    int(True)                                                                          // -> 1
    int((74))                                                                          // -> 74
    
    
// interpreting values in bases -------------------------------------------------------
    int('ff', 16)                                                                      // -> 255          // as hexadecimal 
    int('255')                                                                         // -> 255          // as decimal (Default)
    int('377', 8)                                                                      // -> 255          // as octal  
    int('11111111', 2)                                                                 // -> 255          // as bynary    
    </pre>
  </details>
  <hr>
  <!---------------------------------------------------------------------------------------------------->
  <h3 class="header"> The <mark>bit_length()</mark> / <mark>bit_count()</mark> / <mark>to_bytes()</mark> / <mark>from_bytes()</mark> / <mark>as_integer_ratio()</mark> methods </h3>
  <details class="example">
    <summary> DEMO </summary>
    <p> - <mark>bit_length()</mark> / <mark>bit_count()</mark> </p>
    <pre>
    myInt = -2
    myInt2 = 200
    myInt3 = 256
    
    bin(myInt)                                                                         // -> '-0b10'              // binary notations   
    bin(myInt2)                                                                        // -> '0b11001000'
    bin(myInt3)                                                                        // -> '0b100000000'
    
    myInt.bit_length()                                                                 // -> 2                    // number of bits taken by the integer (excludes signs and leading zeros)    
    myInt2.bit_length()                                                                // -> 8
    myInt3.bit_length()                                                                // -> 9
    
    myInt.bit_count()                                                                  // -> 1                    // number <mark>1</mark> bits (of of <mark>bit_length()</mark>)    
    myInt2.bit_count()                                                                 // -> 3
    myInt3.bit_count()                                                                 // -> 1
    </pre>
    <p> - <mark>to_bytes()</mark> / <mark>from_bytes()</mark> </p>
    <pre>
    myInt = 255
    myInt2 = 215498733
    
// to_bytes() -------------------------------------------------------------------------
    myInt.to_bytes(1, byteorder='big')                                                 // -> b'\xff'
    
    myInt.to_bytes(1, byteorder='big', signed=True)                                    // -! raises an OverflowError because the 255 integer is out of the 1byte storing range 
    myInt.to_bytes(2, byteorder='big', signed=True)                                    // -> b'\x00\xff'          // in 2 bytes we can store a signed 255 integer 
    
    myInt2.to_bytes(4, byteorder="big", signed=True)                                   // -> b'\x0c\xd8?\xed'     // sotored as big endiannes 
    myInt2.to_bytes(4, byteorder="little", signed=True)                                // -> b'\xed?\xd8\x0c'     // stored as little endiannes 
    
    
// from_bytes() (classmethod) ---------------------------------------------------------
    int.from_bytes(b'\xff', byteorder='big')                                           // -> 255                  // the passed bytes object are interpreted as integer and the result is returned 
    int.from_bytes(b'\x00\xff', byteorder='big', signed=True)                          // -> 255  
    
    int.from_bytes(b'\x0c\xd8?\xed', byteorder='big', signed=True)                     // -> 215498733
    int.from_bytes(b'\xed?\xd8\x0c', byteorder='little', signed=True)                  // -> 215498733
    </pre>
    <p> - <mark>as_integer_ratio()</mark> </p>
    <pre>
    myInt = 24
    myInt2 = 9422
    
    myInt.as_integer_ratio()                                                           // -> (24, 1)              // the returned integers' ration is equal to <mark>24</mark> (<mark>24 / 1 = 24</mark>)   
    myInt2.as_integer_ratio()                                                          // -> (9422, 1) 
                                                                                       // -! for integers this method does not make a big sence, but made to be conform with the original <mark><strong>float</strong>.as_integer_ratio()</mark>
    </pre>
  </details>
  <hr>
  <!---------------------------------------------------------------------------------------------------->
  <h2 class="headerExtra"> Floats <mark>float()</mark> </h2>
  <p> - Python uses the (64bit) double precision floating point number with all its advantages and disadvantages, it's accurate about <mark class="mark">15 significant digits</mark> </p>
  <p> - doubles can safely store an integer range from <mark>-9007199254740991</mark> to <mark>9007199254740991</mark> (higher|lower integers can be respresented as well but at the cost of accuracy, after these integer limits the stored number is an approximation!)</p>
  <p> - decimals are <u>just a close approximate representation,</u> that's how double precision floating points work </p>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    0.1 + 0.2                                                                          // -> 0.30000000000000004        // about accurate 
    0.1 + 0.3                                                                          // -> 0.4                        // accurate in this case (we should never rely on dobule decimal accuracy!)
    </pre>
    <p> - <mark>float()</mark> </p>
    <pre>
    import math
    
    float()                                                                            // -> 0.0
    float(14)                                                                          // -> 14.0
    float('14.21')                                                                     // -> 14.21
    
    nan = float('nan')                                                                 // creates a not a number undefined numeric type 
    math.isnan(nan)                                                                    // -> True
    
    posInf = float('inf')                                                              // creates a positive infinity undefined numeric type 
    negInf = float('-inf')                                                             // creates a negative infinity undefined numeric type 
    math.isinf(posInf)                                                                 // -> True   
    math.isinf(negInf)                                                                 // -> True   
    </pre>
  </details>
  <hr>
  <!---------------------------------------------------------------------------------------------------->
  <h3 class="header"> The <mark>is_integer()</mark> / <mark>as_integer_ratio()</mark> / <mark>hex()</mark> / <mark>fromhex()</mark> methods </h3>
  <details class="example">
    <summary> DEMO </summary>
    <p> - <mark>is_integer()</mark> </p>
    <pre>
    myInt = 21.0
    myInt2 = 21.000000000001
    
    myInt.is_integer()                                                                 // -> True
    myInt2.is_integer()                                                                // -> False
    </pre>
    <p> - <mark>as_integer_ratio() </mark>
      <pre>
    myInt = 21.513
    myInt2 = 478.21
    
    myInt.as_integer_ratio()                                                           // -> (6055371173976343, 281474976710656)       // the ration of <mark>6055371173976343 / 281474976710656</mark> is <mark>21.513
    6055371173976343 / 281474976710656                                                 // -> 21.513
    
    myInt2.as_integer_ratio()                                                          // -> (8412759288300175, 17592186044416)        // the ration of <mark>8412759288300175 / 17592186044416</mark> is <mark> 478.21
    8412759288300175 / 17592186044416                                                  // -> 478.21
    </pre>
      <p> - <mark>hex()</mark> / <mark>fromhex()</mark> </p>
      <pre>
    fixFloat = 0.3
    approxFloat = 0.1 + 0.2                                                            // <mark>0.1 + 0.2 = 0.30000000000000004</mark>
    
    fixFloat.hex()                                                                     // -> '0x1.3333333333333p-2'                    // returns the exact hexadecimal representation of the floating point as hexadecimal notation   
    approxFloat.hex()                                                                  // -> '0x1.3333333333334p-2'
    
    float.fromhex('0x1.3333333333333p-2')                                              // -> 0.3                                       // returns a double floating point from the passed hexadecimal notation  
    float.fromhex('0x1.3333333333334p-2')                                              // -> 0.30000000000000004
    float.fromhex('0xff')                                                              // -> 255.0
    </pre>
    </details>
    <hr>
    <!---------------------------------------------------------------------------------------------------->
    <h2 class="headerExtra"> Complex <mark>complex()</mark> </h2>
    <p> - complex numbers in Python can be created as complex literals or by the <mark>complex()</mark> class </p>
    <p> - both the real and the imaginary part is a double floating precision point type </p>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
    myComplex = 12-4j
    
    isinstance(myComplex.real, float)                                                  // -> True
    isinstance(myComplex.imag, float)                                                  // -> True
    </pre>
      <p> - <mark>complex()</mark> </p>
      <pre>
    complex()                                                                          // -> 0+0j
    
    complex('21')                                                                      // -> 21+0j            // if string argument passed no 2nd argument accepted     
    complex('21-11.2j')                                                                // -> 21-11.2j
    
    complex(21)                                                                        // -> 21+0j
    complex(21, -11.2)                                                                 // -> 21-11.2j
    </pre>
    </details>
    <hr>
    <!---------------------------------------------------------------------------------------------------->
    <h3 class="header"> The <mark>real</mark> / <mark>imag</mark> / <mark>conjugate()</mark> attributes & methods </h3>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
    myComplex = 32.5+45.0021j
    
// real / imag ------------------------------------------------------------------------
    myComplex.real                                                                     // -> 32.5             // returns the real part of the complex number 
    myComplex.imag                                                                     // -> 45.0021          // returns the imaginary part of the complex number 
    
    
// conjugate() ------------------------------------------------------------------------
    myComplex.conjugate()                                                              // -> 32.5-45.0021j    // flips the sign of the imaginary part of the complex and returns the result as a new complex number 
    </pre>
    </details>

    <br><br>
  </body>
</html>
