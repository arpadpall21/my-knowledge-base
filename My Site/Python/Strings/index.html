<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title> Strings </title>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css"
      integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../Assets/stylesPages.css">
    <script src="../../Assets/scriptPages.js"></script>
  </head>

  <body>
    <h1> Strings </h1>
    <p> Updated ( 2022-03-02 )</p>
    <p class="sitenav"> <a href="../../index.html">MySite > </a>
      <a href="../index.html">Python > </a> Strings
    </p>
    <table class="table">
      <tr>
        <th style="width:30%;"> Method / Property / Operator </th>
        <th> Description </th>
      </tr>
      <tr>
        <td>
          str(<strong>data:any</strong>)
        </td>
        <td>
          - serializes to string the passed data
        </td>
      </tr>
      <tr>
        <td>
          repr(<strong>data:any</strong>)
        </td>
        <td>
          - returns a developer friendly printable string of the passed <reqval>data</reqval> <br>
          - a class can control what this function returns for its instances by defining a <mark>__repr__()</mark> method
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2">
          Operators
        </td>
      </tr>
      <tr>
        <td>
          <strong>val:str</strong> <small>not</small> in <strong>str</strong>
        </td>
        <td>
          - returns <mark>True</mark> if <strong>val</strong> is (<small>not</small>) part of <strong>str</strong>,
          otherwise returns <mark>False</mark>
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong> + <strong>str</strong>
        </td>
        <td>
          - joins the two strings together and retuns a new string (does not modify the original strings)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>[<strong>idx</strong>]
        </td>
        <td>
          - returns the letter at the specified index
        </td>
      </tr>
      <tr>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>[-<strong>idx</strong>]
        </td>
        <td>
          - negative indexes are counted from the end (<mark>-1</mark> = last letter / <mark>-2</mark> = second last,
          etc...)
        </td>
      </tr>
      <tr>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>[<i>stIdx(inc)</i>:<i>endIdx(exc)</i>]
        </td>
        <td>
          - returns the specified range in a new <strong>str</strong> (omitting <i>idx</i> = from the start|to the end)
        </td>
      </tr>
      <tr>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>[<i>-endIdx(exc)</i>:<i>-stIdx(inc)</i>]
        </td>
        <td>
          - negative indexes are counted from the end (<mark>:-1</mark> = second last letter / however <mark>:-0</mark>
          doesn't work)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2">
          Global Methods
        </td>
      </tr>
      <tr>
        <td>
          chr(<strong>dec:int</strong>)
        </td>
        <td>
          - references a unicode UTF-16 character by a decimal notation, (can reference only 2 byte long characters,
          raises an OverflowError error otherwise)
          <span id="browserSupport" title="updated : 2022-03-07">
            <span><i class="fab fa-python"></i> 2.7 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>
          ord(<strong>char:str</strong>)
        </td>
        <td>
          - returns the passed character's unicode UTF-16 decimal value, (for 2 byte encoded characters only
          <mark>0-65535</mark>)
          <span id="browserSupport" title="updated : 2022-03-07">
            <span><i class="fab fa-python"></i> 2.7 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2">
          Methods
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.upper()
        </td>
        <td>
          - converts the string into upper case letters and returns the result in a new string (does not modify the
          original)
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.lower()
        </td>
        <td>
          - converts the string into lower case letters and returns the result in a new string (does not modify the
          original)
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.casefold()
        </td>
        <td>
          - converts the string into lower case letters and returns the result in a new string (does not modify the
          original) <br>
          - does the same as <mark>lower()</mark> but more effective lowering unicode letters (however I didn't see any
          difference)
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.swapcase()
        </td>
        <td>
          - swaps letter cases lower to upper and vice versa (returns the resutl in a new string)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.capitalize()
        </td>
        <td>
          - converts the first letter of the string into upper case and returns the result in a new string (does not
          modify the original)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.islower()
        </td>
        <td>
          - return <mark>True</mark> if all letters are lower cases in the string, <mark>False</mark> otherwise
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.isupper()
        </td>
        <td>
          - returns <mark>True</mark> if all letters are upper cases in the string, <mark>False</mark> otherwise
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.strip(<i>srch:str</i>)
        </td>
        <td>
          - removes white spaced (or <i>srch</i>) sequences on both side on the <strong>str</strong> and returns the
          result in a new string (does not modify the original string)
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.lstrip(<i>srch:str</i>)
        </td>
        <td>
          - removes white spaces (or <i>srch</i> sequences) on the left side on the <strong>str</strong> and returns the
          result in a new string (does not modify the orignal string)
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.removeprefix(<strong>srch:str</strong>)
        </td>
        <td>
          - removes <strong>srch</strong> on the right side on the <strong>str</strong> and returns the result in a new
          string (does not modify the orignal string) <br>
          - if there's nothing to remove the string returned unchanged
          <span id="browserSupport" title="Updated : 2022-07-11">
            <span><i class="fab fa-python"></i> 3.9 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.rstrip(<i>srch:str</i>)
        </td>
        <td>
          - removes white spaces (or <i>srch</i>) sequences on the right side on the <strong>str</strong> and returns the
          result in a new string (does not modify the orignal string)
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.removesuffix(<strong>srch:str</strong>)
        </td>
        <td>
          - removes <strong>srch</strong> on the left side on the <strong>str</strong> and returns the result in a new
          string (does not modify the orignal string) <br>
          - if there's nothing to remove the string returned unchanged
          <span id="browserSupport" title="Updated : 2022-07-11">
            <span><i class="fab fa-python"></i> 3.9 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.center(<strong>length:int</strong>, <i>char</i>)
        </td>
        <td>
          - centers the string by filling white spaces (or <i>char</i>) on both sides on the string and returns the result
          in a new string (does not modify the original)
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.ljust(<strong>length:int</strong>, <i>char</i>)
        </td>
        <td>
          - left adjust the string by filling white spaces (or <i>char</i>) <u>on the right side (not left side)</u> on
          the string, returns the result in a new string (does not modify the original)
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.rjust(<strong>length:int</strong>, <i>char</i>)
        </td>
        <td>
          - right adjust the string by filling white spaces (or <i>char</i>) <u>on the left side (not right side)</u> on
          the string, returns the result in a new string (does not modify the original)
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.zfill(<strong>length:int</strong>)
        </td>
        <td>
          - fills <mark>0</mark> characters on the left side on the string untill the specified length is reached, returns
          the result in a new string (does not modify the original)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.startswith(<strong>str|tuple</strong>, <i>stIdx(inc)</i>, <i>endIdx(exc)</i>)
        </td>
        <td>
          - returns <mark>True</mark> if the string (or the range) starts with <strong>str</strong>, <mark>False</mark>
          otherwise
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.endswith(<strong>str|tuple</strong>, <i>stIdx(inc)</i>, <i>endIdx(exc)</i>)
        </td>
        <td>
          - returns <mark>True</mark> if the string (or the range) ends with <strong>str</strong>, <mark>False</mark>
          otherwise
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.isalnum()
        </td>
        <td>
          - returns <mark>True</mark> if the string contains only alphanumerical characters (alphabetical letters (accent
          letters included) and any numerical characters), <mark>False</mark> otherwise
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.isalpha()
        </td>
        <td>
          - returns <mark>True</mark> if the string contains only alphabetical letters (accent letters included),
          <mark>False</mark> otherwise
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.isdecimal()
        </td>
        <td>
          - returns <mark>True</mark> if the string contains only decimal characters (ex: <mark>²</mark> excluded),
          <mark>False</mark> otherwise
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.isdigit()
        </td>
        <td>
          - returns <mark>True</mark> if the string contains only digit characters (ex: <mark>²</mark> included but
          <mark>¾</mark> excluded), <mark>False</mark> otherwise
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.isnumeric()
        </td>
        <td>
          - returns <mark>True</mark> if the string contains only numberic characters (ex: <mark>²</mark> and
          <mark>¾</mark> included), <mark>False</mark> otherwise
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.isidentifier()
        </td>
        <td>
          - returns <mark>True</mark> if the string contains a valid variable name, <mark>False</mark> otherwise
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.isprintable()
        </td>
        <td>
          - returns <mark>True</mark> if the string contains only printalbe characters (ex: <mark>\n</mark> is not
          printable), <mark>False</mark> otherwise
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.istitle()
        </td>
        <td>
          - returns <mark>True</mark> if the string contains words that all starts with a capital letter,
          <mark>False</mark> otherwise
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.isspace()
        </td>
        <td>
          - returns <mark>True</mark> if the string contains only white space characters, <mark>False</mark> otherwise
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.count(<strong>srch:str</strong>)
        </td>
        <td>
          - returns how many times <strong>srch</strong> is found in the text
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.find(<strong>srch:str</strong>, <i>stIdx(inc)</i>, <i>endIdx(exc)</i>)
        </td>
        <td>
          - returns the first found index where <strong>srch</strong> is found in the string (optional search range can be
          specified) <br>
          - returns <mark>-1</mark> if <strong>srch</strong> is not found
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.index(<strong>srch:str</strong>, <i>stIdx(inc)</i>, <i>endIdx(exc)</i>)
        </td>
        <td>
          - returns the first found index where <strong>srch</strong> is found in the string (optional search range can be
          specified) <br>
          - raises a <mark>ValueError</mark> if <strong>srch</strong> is not found
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.rfind(<strong>srch:str</strong>, <i>stIdx(inc)</i>, <i>endIdx(exc)</i>)
        </td>
        <td>
          - returns the index where <strong>srch</strong> is found in the string, searches end-to-start (optional search
          range can be specified) <br>
          - returns <mark>-1</mark> if <strong>srch</strong> is not found
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.rindex(<strong>srch:str</strong>, <i>stIdx(inc)</i>, <i>endIdx(exc)</i>)
        </td>
        <td>
          - returns the index where <strong>srch</strong> is found in the string, searches end-to-start (optional search
          range can be specified) <br>
          - raises a <mark>ValueError</mark> if <strong>srch</strong> is not found
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.join(<strong>iterable</strong>)
        </td>
        <td>
          - parses the <strong>iterable</strong> members into string and joins them together by using the original
          <strong>str</strong> as separator between them, returns the result in a new string (does not modify the original
          string)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.split(<strong>srch:str</strong>, <i class="openable">limit:int<div>
              <p> - split limit </p>
            </div></i>)
        </td>
        <td>
          - splits the string at <strong>srch</strong> and returns the splitted parts in a new list (does not modify the
          original string) (<strong>srch</strong> is removed from the sliptted parts)
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.rsplit(<strong>srch</strong>, <i class="openable">limit:int<div>
              <p> - split limit </p>
            </div></i>)
        </td>
        <td>
          - end-to-start splits the string at <strong>srch:str</strong> and returns the splitted parts in a new list (does
          not modify the original string) (<strong>srch</strong> is removed from the sliptted parts)
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.splitlines(<i class="openable">preserve\n\r:bol<div>
              <p> - preservers the <mark>\r</mark>, <mark>\n</mark> characters on the splitted parts (Default:
                <mark>False</mark>) </p>
            </div></i>)
        </td>
        <td>
          - splits the string at new line characters (<mark>\n</mark>, <mark>\r</mark>) and returns the splitted parts in
          a new list (does not modify the original string) (by default new line characters are removed from the sliptted
          parts)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.partition(<strong>srch:str</strong>)
        </td>
        <td>
          - partition the string into 3 parts at the first found <strong>srch</strong> and returns the result in a new
          tuple (does not modify the original string) <br>
          - partitions = 1) part before <strong>srch</strong> / 2) the <strong>srch</strong> / 3) part after
          <strong>srch</strong>
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.rpartition(<strong>srch:str</strong>)
        </td>
        <td>
          - partition the string into 3 parts at the last found <strong>srch</strong> and returns the result in a new
          tuple (does not modify the original string) <br>
          - partitions = 1) part before <strong>srch</strong> / 2) the <strong>srch</strong> / 3) part after
          <strong>srch</strong>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.replace(<strong>srch:str</strong>, <strong>new:str</strong>)
        </td>
        <td>
          - replaces all <strong>srch</strong> by <strong>new</strong> and returns the result in a new string (does not
          modify the original string)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>"..<em>{}</em>..<em>{}</em>.."</strong>.format(<strong>val:any</strong>, <i>...</i>)
        </td>
        <td>
          - format the string by placing arguments in <em>{}</em> (does not modify the original string) <br>
          - arguments are placed in order in <em>{}</em>
          <span id="browserSupport" title="updated : 2022-05-02">
            <span><i class="fab fa-python"></i> 2.6 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>"..<em>{<strong>idx</strong>}</em>..<em>{<strong>idx</strong>}</em>.."</strong>.format(<strong>val:any</strong>,
          <i>...</i>)
        </td>
        <td>
          - arguments are indexed in <em>{}</em>
          <span id="browserSupport" title="updated : 2022-05-02">
            <span><i class="fab fa-python"></i> 2.6 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>"..<em>{<strong>key</strong>}</em>..<em>{<strong>key</strong>}</em>.."</strong>.format(<strong>key=val:any</strong>,
          <i>...</i>)
        </td>
        <td>
          - arguments are referenced by placeholders in <em>{}</em>
          <span id="browserSupport" title="updated : 2022-05-02">
            <span><i class="fab fa-python"></i> 2.6 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>
          <strong>"..<em>{<strong>key</strong>}</em>..<em>{<strong>key</strong>}</em>.."</strong>.format_map({<strong>key:val:any</strong>,
          <i>...</i>})
        </td>
        <td>
          - format the string by placing arguments in <em>{}</em> (does not modify the original string) <br>
          - the dictionary's keys are referenced by placeholders in <em>{}</em>
          <span id="browserSupport" title="updated : 2022-05-02">
            <span><i class="fab fa-python"></i> 2.6 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.maketrans(<strong class="openable">trg:str, new:str, del:str<div>
              <p> <strong>trg</strong> - contains characters that will be replaced </p>
              <p> <strong>new</strong> - contains new characters </p>
              <p> <strong>del</strong> - containrs characters that will be removed</p>
              <hr>
              <p> ex: </p>
              <p> - replaced characters <mark>a -> s</mark> <mark>b -> x</mark> <mark>c -> y</mark> </p>
              <p> - <mark>_</mark> character is removed from the string </p>
              <pre>
      text = 'abc_'
      
      mappingTable = ''.maketrans('abc', 'sxy', '_')
      text.translate(mappingTable)        // -> 'sxy'     
      </pre>
            </div></strong>)
        </td>
        <td>
          - creates and returns a <strong>mappingTable</strong> which describes characters that will be replaced and
          removed from the string by the <mark>translate()</mark> method <br>
          - the returned <strong>mappingTable</strong> is passed as <mark>translate()</mark> argument (this method does
          not modify the original string)
        </td>
      </tr>
      <tr>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.maketrans(<strong class="openable">dict<div>
              <p> {<strong>trgChar:str</strong>:<strong>newChar:str</strong>, <i>...</i>} </p>
              <p> <strong>trg</strong> - contains characters that will be replaced </p>
              <p> <strong>new</strong> - contains new characters </p>
              <hr>
              <p> ex: </p>
              <p> - replaced characters <mark>a -> s</mark> <mark>b -> x</mark> <mark>c -> y</mark> </p>
              <pre>
      text = 'abc'
      
      mappingTable = ''.maketrans({'a':'s', 'b':'x', 'c':'y'})    
      text.translate(mappingTable)        // -> 'sxy'     
      </pre>
            </div></strong>)
        </td>
        <td>
        </td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.translate(<strong>mappingTable</strong>)
        </td>
        <td>
          - replaces chacters in the string according to the <strong>mappingTable</strong>, returns the result in a new
          string (does not modify the original string)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>str</strong>.encode(<strong class="openable">encoding<div>
              <p> - Default <mark>UTF-8</mark> </p>
            </div></strong>, <i class="openable">errs<div>
              <p> - specifies what to do when an unknown character is encountered </p>
              <p> <mark>'strict'</mark> - (Default) raises an error on failure </p>
              <p> <mark>'backslashreplace'</mark> - uses a backslash instead of the character that could </p> be encoded
              <p> <mark>'ignore'</mark> - ignores the characters that cannot be encoded </p>
              <p> <mark>'namereplace'</mark> - replaces the character with a text explaining the </p>character
              <p> <mark>'replace'</mark> - replaces the character with a questionmark </p>
              <p> <mark>'xmlcharrefreplace'</mark> - replaces the character with an xml character </p>
            </div></i>)
        </td>
        <td>
          - encodes the string according the <i>encoding</i> and returns the result a <strong>bytes</strong> (does not
          modify the original string)
        </td>
      </tr>
    </table>
    <br>
    <table class="table">
      <caption> Escape Notations <mark>\</mark> </caption>
      <tr>
        <th style="width:30%;"> Notation </th>
        <th> Description </th>
      </tr>
      <tr>
        <td> '\<strong>char</strong>' </td>
        <td>
          - character following a backslash is escaped
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> '\<strong>escapeChar</strong>' </td>
        <td>
          - any <span class="openable">escape character<div>
              <p> <mark>\t</mark> - Insert a tab in the text at this point </p>
              <p> <mark>\b</mark> - Insert a backspace in the text at this point </p>
              <p> <mark>\n</mark> - Insert a newline in the text at this point </p>
              <p> <mark>\r</mark> - Insert a carriage return in the text at this point </p>
              <p> <mark>\f</mark> - Insert a formfeed in the text at this point </p>
              <p> <mark>\'</mark> - Insert a single quote character in the text at this point </p>
              <p> <mark>\"</mark> - Insert a double quote character in the text at this point </p>
              <p> <mark>\\</mark> - Insert a backslash character in the text at this point </p>
            </div></span> can be used
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> '\u<strong>HexHexHexHex</strong>' </td>
        <td>
          - references a unicode UTF-16 character by a <u>4</u> hexadecimal notation (hex =>
          <mark>[0123456789abcdef]</mark>) <u>(can reference only 2 byte long characters)</u>
        </td>
      </tr>
      <tr>
        <td> '\x<strong>HexHex</strong>' </td>
        <td>
          - references a latin1 (ISO-8859-1) character by a <u>2</u> hexadecimal notation (hex =>
          <mark>[0123456789abcdef]</mark>)
        </td>
      </tr>
      <tr>
        <td> '\<strong>Oct....</strong>' </td>
        <td>
          - references a latin1 (ISO-8859-1) character by a <u>1 to 3</u> octal notation (octal =>
          <mark>[01234567]</mark>)
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> r'<strong>str</strong>' </td>
        <td>
          - the <mark>r</mark> before a string literal disables escape notations
        </td>
      </tr>
    </table>
    <h2 class="headerSection"> Remember This : </h2>
    <p> - the <mark>expandtabs()</mark> is some useless shit -> I refused to learn it! </p>
    <h2 class="headerSection"> Useful Links : </h2>

    <h2 class="headerSection"> Remember This : </h2>
    <h2 class="headerSection"> Description and Demonstration : </h2>
    <p> - Python encodes strings in UTF-8 (uses 1 to 4 bytes to encode 1 character) </p>
    <p> - strings are iterable, so we can use iterator tools on them (ex: for loop, <mark>in</mark> keyword, etc...) </p>
    <p> - the <mark>len()</mark> returns the number of characters the string contains (not number of 2bytes like
      <mark>length</mark> in JS) </p>
    <pre class="syntax">
    '<strong>string</strong>'                                                                           // single or double quotes can be used 
    "<strong>string</strong>"
    
    
    """                                                                                // multiline string (preservers all characters)  
    <strong>string</strong>                                                                               // also used as multiline comment (because string characters are not parsed)   
      <strong>string</strong>
    """
    
// formating ----------------------------------------------
    '<strong>...</strong><mark>%<strong>f</strong></mark><strong>...</strong>' <em>%</em> <strong>val</strong>                                                                   // <strong>val</strong> is (are) evaluated according to <mark>%<strong>f</strong></mark> and (are) replaced in the string <u class="openable">possible evaluations<div>
        <p> <mark>d</mark> - signed integer decimal </p>
        <p> <mark>i</mark> - signed integer decimal </p>
        <p> <mark>o</mark> - unsigned octal </p>
        <p> <mark>u</mark> - unsigned decimal </p>
        <p> <mark>x</mark> - unsigned hexadecimal (lowercase) </p>
        <p> <mark>X</mark> - unsigned hexadecimal (uppercase) </p>
        <p> <mark>e</mark> - floating point exponential format (lowercase) </p>
        <p> <mark>E</mark> - floating point exponential format (uppercase) </p>
        <p> <mark>f</mark> - floating point decimal format </p>
        <p> <mark>F</mark> - floating point decimal format </p>
        <p> <mark>g</mark> - same as <mark>e</mark> if exponent is greater than -4 or less than precision, <mark>f</mark> otherwise </p>
        <p> <mark>G</mark> - same as <mark>E</mark> if exponent is greater than -4 or less than precision, <mark>F</mark> otherwise </p>
        <p> <mark>c</mark> - single character (accepts integer or single character string) </p>
        <p> <mark>r</mark> - string (converts any python object using <mark>repr()</mark>) </p>
        <p> <mark>s</mark> - string (converts any python object using <mark>str()</mark>) </p>
        <p> <mark>%</mark> - no argument is converted, results in a <mark>%</mark> character in the result </p>
    </div></u>
    '<strong>...</strong><mark>%<strong>f</strong></mark><strong>...</strong><mark>%<strong>f</strong></mark><strong>...</strong>' <em>%</em> (<strong>val</strong>, <i>...</i>)  
    
    
    <span id="browserSupport" title="updated : 2022-05-02" style="color:yellow;"><span><i class="fab fa-python"></i> 3.6 </span></span>
    <em>f|F</em>'<strong>...</strong>{<strong>exp</strong>}<strong>...</strong>'      // (f-string) expressions in curly brackets are evaluated and the result is placed in the stirng (faster than <mark><strong>str</strong>.format()</mark>)
                                                                          // <span id="browserSupport" title="updated : 2022-05-02" style="color:yellow;"><span><i class="fab fa-python"></i> 3.8 </span></span>  <mark>{=<reqval>exp</reqval>}</mark> self documenting expression in f-string expression 
    
    <em>r|R</em>'<strong>...</strong>\<strong>...</strong>'                                                                       // dislables escape notations in ths string
    
// t-string <span id="browserSupport" style="color:yellow;"><span><i class="fab fa-python"></i> 3.14 </span></span> -
    <a href="https:\/\/docs.python.org/3.14/library/string.templatelib.html#template-strings" target="_blank">t_str</a> = <lit>t|T</lit>'<reqval>...</reqval>{<reqval>exp</reqval>}<reqval>...</reqval>'        // (t-string) Template String Literal, returns a Tempalte object which holds literal and interpolated parts separately
                                        // the idea is to process the interpolated part then return some result (can be used for ex: Template engine, SQL escape, input sanitization, HTML processing, etc...)   
    </pre>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
    txt = 'a❤𩸽'                                                                       // some characters need 4 bytes to encode  
    len(txt)                                                                           // -> 3         // number of characters (not underlying bytes)
    
    
// % string formating operator --------------------------------------------------------
    person = "Pall"
    age = 37
    "My name is %s, I'm %d years old" % (person, age)                                  // -> 'My name is Pall, I'm 37 years old'
    
    def awesome():
        return 'Python is awesome'
    '%s' % awesome()                                                                   // -> 'Python is awesome'    
    
    
// f-string ---------------------------------------------------------------------------
    person = "Pall"
    age = 37
    f"My name is {person}, I'm {age} old"                                              // -> 'My name is Pall, I'm 37 years old'
    
    def awesome():
        return 'Python is awesome!'
    f"{awesome()}"                                                                     // -> 'Python is awesome!'
    
    log_1 = 'logged one'                                                               // self documenting expression
    log_2 = 'logged two'
    f"Log results: ({log_1=}) ({log_2=})"                                              // -> Log results: (log_1='logged one') (log_2='logged two')
    
    
// t-string ------------------------------------
    from string.templatelib import Interpolation
    
    name = 'World'
    t_str = t'hello {name}!'
    
    t_str                                    // -> Template(strings=('hello ', '!'), interpolations=(Interpolation('World', 'name', None, ''),))
    list(t_str)                              // -> ['hello ', Interpolation('World', 'name', None, ''), '!']
    
    def upper_interpoated_part(t_str):       // process template string
        parts = []
        for part in t_str:
            if isinstance(part, Interpolation):
                parts.append(str(part.value).upper())
            else:
                parts.append(part)
        return ''.join(parts)
    
    upper_interpoated_part(t_str)               // -> hello WORLD!
      </pre>
    </details>
    <hr>
    <!-------------------------------------------------------------------------------------------->
    <h2 class="header"> escape notation <mark>\</mark> </h2>
    <p> - in strings we can used the <mark>\</mark> escape notation to escape the following character or use any escape
      characters </p>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
    'this is a \'test\''                                                               // the <mark>'</mark> chacters in the string are escaped (printed as <mark>this is a 'test'</mark>)  
    
// referencing characters from latin-1 table ------------------------------------------
    '\x21'                                                                             // -> '!'        // references the <mark>!</mark> character from the latin-1 table as hexadecimal notation    
    '\41'                                                                              // -> '!'        // references the <mark>!</mark> character from the latin-1 table as octal notation    
    
    
// referencing characters from UTF-16 unicode table -----------------------------------
    '\u0021'                                                                           // -> '!'        // references the <mark>!</mark> character from the UTF-16 unicode table as hexadecimal notation    
    chr(33)                                                                            // -> '!'        // references the <mark>!</mark> character from the UTF-16 unicode table as decimal notation    
    ord('!')                                                                           // -> 33         // returns the passed character's decimal notation from the UTF-16 unicode table   
    
    '\u1fa7'                                                                           // -> 'ᾧ'
    chr(8103)                                                                          // -> 'ᾧ'
    ord('ᾧ')                                                                           // -> 8103
    
    
// UTF-16 2 byte character reference limitation ---------------------------------------
    // -! the 💔 character is referenced as <mark>d83ddc94</mark> hexadecimal or <mark>3627932820</mark> decimal in the unicode table (encoded in 4 bytes), so the below tools cannot reference it because they are limited to reference only 2 byte characters   
    '/ud83ddc94'                                                                       // -> '/ud83ddc94'
    chr(3627932820)                                                                    // -! raises an OverflowError  
    
// disabling <mark>\</mark> (escape notation) ------------------------------------------------------
    r'\u1fa7'                                                                          // -> '\u1fa7'   // the <mark>r</mark> before string literal disables the escape notaions 
    r'\x21'                                                                            // -> '\x21'
    </pre>
    </details>
    <hr>
    <!-------------------------------------------------------------------------------------------->
    <h2 class="header"> The <mark>in</mark> keywords, <mark>+</mark> operator and range slicing <mark>[:]</mark> </h2>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
// in operator ------------------------------------------------------------------------
    text = 'Kicsi kutya tarka'
    
    'cs' in text                                                                       // -> True
    'x' not in text                                                                    // -> True
    
// + (operator) -----------------------------------------------------------------------
    size = 'Kicsi '
    animal = 'kutya '
    adjective = 'tarka'
    
    size + animal + adjective                                                          // -> Kicsi kutya tarka    // concateneates strings togehter 
    
    size                                                                               // -> 'Kicsi '             // does not modify originals 
    animal                                                                             // -> 'kutya '
    adjective                                                                          // -> 'tarka'
    
// indexing and range slicing ---------------------------------------------------------
    string = 'this is a test string'
    
    string[0]                                                                          // -> 't'                  // returns the indexed the letter   
    
    string[-1]                                                                         // -> 'g'                  // element order is counted (not indexed) from the back when using negative indexing   
    string[-2]                                                                         // -> 'n'
    
    string[5:7]                                                                        // -> 'is'                 // returns the indexed range 
    string[:4]                                                                         // -> 'this'
    string[10:]                                                                        // -> 'test string'
    
    string[-11:-7]                                                                     // -> 'test'               // indexing from the end 
    string[-6:]                                                                        // -> 'string'
    string[:-7]                                                                        // -> 'this is a test'
    </pre>
    </details>
    <hr>
    <!-------------------------------------------------------------------------------------------->
    <h2 class="header"> The <mark>repr()</mark> method </h2>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
    txt = """
        Lorem ipsum dolor sit amet,
        consectetur adipiscing elit,
    """
    
    class Person:
        def __init__(self, name, age):
            self.name = name
            self.age = age

        def __repr__(self):
            return f"Person('{self.name}', {self.age})"
    
    joe = Person("Joe", 34)
    
    repr(txt)                 // -> '\n    Lorem ipsum dolor sit amet,\n    consectetur adipiscing elit,\n'
    repr(Person)              // -> "&lt;class '__main__.Person'&gt;""
    repr(joe)                 // -> 'Person('Joe', 34)'                 // calls the instance's class __repr__ method
    </pre>
    </details>
    <hr>
    <!-------------------------------------------------------------------------------------------->
    <h2 class="header"> The <mark>char()</mark> / <mark>ord()</mark> methods </h2>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
    'this is a \'test\''                                                               // the <mark>'</mark> chacters in the string are escaped (printed as <mark>this is a 'test'</mark>)  
    
// referencing characters from latin-1 table ------------------------------------------
    '\x21'                                                                             // -> '!'        // references the <mark>!</mark> character from the latin-1 table as hexadecimal notation    
    '\41'                                                                              // -> '!'        // references the <mark>!</mark> character from the latin-1 table as octal notation    
    
    
// referencing characters from UTF-16 unicode table -----------------------------------
    '\u0021'                                                                           // -> '!'        // references the <mark>!</mark> character from the UTF-16 unicode table as hexadecimal notation    
    chr(33)                                                                            // -> '!'        // references the <mark>!</mark> character from the UTF-16 unicode table as decimal notation    
    ord('!')                                                                           // -> 33         // returns the passed character's decimal notation from the UTF-16 unicode table   
    
    '\u1fa7'                                                                           // -> 'ᾧ'
    chr(8103)                                                                          // -> 'ᾧ'
    ord('ᾧ')                                                                           // -> 8103
    
    
// UTF-16 2 byte character reference limitation ---------------------------------------
    // -! the 💔 character is referenced as <mark>d83ddc94</mark> hexadecimal or <mark>3627932820</mark> decimal in the unicode table (encoded in 4 bytes), so the below tools cannot reference it because they are limited to reference only 2 byte characters   
    '/ud83ddc94'                                                                       // -> '/ud83ddc94'
    chr(3627932820)                                                                    // -! raises an OverflowError  
    </pre>
    </details>
    <hr>
    <!-------------------------------------------------------------------------------------------->
    <h2 class="header"> The <mark>upper()</mark> / <mark>lower()</mark> / <mark>casefold()</mark> /
      <mark>capitalize()</mark> / <mark>swapcase()</mark>/ <mark>islower()</mark> / <mark>isupper()</mark> methods </h2>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
// upper() / lower() / casefold() / capitalize() / swapcase() -------------------------
    text = 'test Ӫ tEsT'
    
    text.upper()                                                                       // -> 'TEST Ӫ TEST'
    text.lower()                                                                       // -> 'test ӫ test'
    text.casefold()                                                                    // -> 'test ӫ test'      // does the same as <mark>lower()</mark>, it's more effective when lowering unicode letters, however I don't see any difference here    
    
    text.capitalize()                                                                  // -> 'Test ӫ test'      // upper case the very first letter only  
    text.swapcase()                                                                    // -> 'TEST ӫ TeSt'      // swap letter cases in the string  
    
    text                                                                               // -> 'test Ӫ tEsT'      // none of the above methods modify the original string   
    
    
// islower() / isupper() --------------------------------------------------------------
    'test'.islower()                                                                   // -> True
    'TEST'.isupper()                                                                   // -> True
    </pre>
    </details>
    <hr>
    <!-------------------------------------------------------------------------------------------->
    <h2 class="header"> The <mark>strip()</mark> / <mark>lstrip()</mark> / <mark>rstrip()</mark> / <mark>center()</mark> /
      <mark>ljust()</mark> / <mark>rjust()</mark> / <mark>zfill()</mark> methods </h2>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
    text = '  test  '
    
// strip() / lstrip() / rstrip() ------------------------------------------------------
    
    text.strip()                                                                       // -> 'test'               // removes white spaces from both ends 
    text.lstrip()                                                                      // -> 'test  '             // removes white spaces on the left   
    text.rstrip()                                                                      // -> '  test'             // removes white spaces on the right    
    
    text                                                                               // -> '  test  '           // none of the above methods modify the original string    
    
    
// center() / ljust() / rjust() / zfill() ---------------------------------------------
    text.center(8, '-')                                                                // -> '--test--'           // centers the string by filling the specified character on both sides   
    text.center(7, '-')                                                                // -> '--test-'
    text.center(3, '-')                                                                // -> 'test'               // not modified short length specified    
    
    text.ljust(6, '-')                                                                 // -> 'test--'             // fills the specified character on the rigth untill the specified length reached    
    text.ljust(3, '-')                                                                 // -> 'test'               // not modified short length specified    
    
    text.rjust(6, '-')                                                                 // -> '--test'             // fills the specified character on the left untill the specified length reached    
    text.rjust(3, '-')                                                                 // -> 'test'               // not modified short length specified    
    
    text.zfill(6)                                                                      // -> '00test'             // fills the <mark>0</mark> character on the left untill the specified length reached    
    text.zfill(3)                                                                      // -> 'test'               // not modified short length specified    
    
    text                                                                               // -> '  test  '           // none of the above methods modify the original string     
    </pre>
    </details>
    <hr>
    <!-------------------------------------------------------------------------------------------->
    <h2 class="header"> The <mark>startswith()</mark> / <mark>endswith()</mark> / <mark>isalnum()</mark> /
      <mark>isalpha()</mark> / <mark>isdecimal()</mark> / <mark>isdigit()</mark> / <mark>isnumeric()</mark> /
      <mark>isidentifier()</mark> / <mark>isprintable()</mark> / <mark>istitle()</mark> / <mark>isspace()</mark> methods
    </h2>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
// startswith() / endswith() ----------------------------------------------------------
    text = 'test text'
    
    text.startswith('te')                                                              // -> True
    text.startswith(' t', 4, 7)                                                        // -> True         // between the specified range    
    
    text.endswith('xt')                                                                // -> True
    text.endswith('st', 0, 4)                                                          // -> True         // between the specified range    
    
    
// isalnum() / isalpha() --------------------------------------------------------------
    'Árpád01²¾'.isalnum()                                                              // -> True         // string contains alphanumeric characters (alphabetical letters (accent letters included) and numerical values)
    'Páll Árpád'.isalnum()                                                             // -> False        // the space is not part of alphanumerics   
    
    'Árpád'.isalpha()                                                                  // -> True         // string contains alphabetical letters only (accent letters included)   
    'Páll Árpád'.isalnum()                                                             // -> False        // the space is not part of alphanumerics    
    
    
// isdecimal() / isdigit() / isnumeric() ----------------------------------------------
    '1548'.isdecimal()                                                                 // -> True         // string contains only decimal characters    
    '1548²'.isdecimal()                                                                // -> False        // <mark>²</mark> is not decimal character   
    
    '1548²'.isdigit()                                                                  // -> True         // string containrs only digits 
    '1548¾'.isdigit()                                                                  // -> False        // <mark>¾</mark> is not digit characgter 
    
    '1548²¾'.isnumeric()                                                               // -> True         // string contains only numberical characters (any character that contains numbers)    
    '1548!'.isnumeric()                                                                // -> False        // <mark>!</mark> is not a numeric character    
    
    
// isidentifier() / isprintable() / istitle() / isspace() -----------------------------
    '_varName1'.isidentifier()                                                         // -> True         // valid variable name   
    '1_varName'.isidentifier()                                                         // -> False   
    
    'my name is Árpád'.isprintable()                                                   // -> True         // all chacters are printable  
    'my name is Árpád\n'.isprintable()                                                 // -> False        // <mark>\n</mark> is not printable   
    
    'The Game Player'.istitle()                                                        // -> True         // all words starts with a capital letter  
    'The game player'.istitle()                                                        // -> False
    
    '   '.isspace()                                                                    // -> True         // all characters are white spaces   
    ''.isspace()                                                                       // -> False   
    </pre>
    </details>
    <hr>
    <!-------------------------------------------------------------------------------------------->
    <h2 class="header"> The <mark>count()</mark> / <mark>find()</mark> / <mark>rfind()</mark> / <mark>index()</mark> /
      <mark>rindex()</mark> methods </h2>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
// count() ----------------------------------------------------------------------------
    'kacsa karika'.count('ka')                                                         // -> 3          // the <mark>'ka'</mark> is found 3 times in the text   
    
    
// find() / index() / rfind() / rindex() ----------------------------------------------
    'kacsa karika'.find('ka', 3, 9)                                                    // -> 5          // the <mark>'ka'</mark> is found at index 5 (between the specified range)  
    'kacsa karika'.index('ka', 3, 9)                                                   // -> 5
    
    'kacsa karika'.find('x')                                                           // -> -1         // value not found in the text   
    'kacsa karika'.index('x')                                                          // -! raises a ValueError because the searched value is not found    
    
    'kacsa karika'.rfind('ka')                                                         // -> 9          // the <mark>'ka'</mark> is found at index 9 (searches end-to-start)  
    'kacsa karika'.rindex('ka')                                                        // -> 9
    
    'kacsa karika'.rfind('x')                                                          // -> -1         // value not found in the text    
    'kacsa karika'.rindex('x')                                                         // -! raises a ValueError because the searched value is not found    
    </pre>
    </details>
    <hr>
    <!-------------------------------------------------------------------------------------------->
    <h2 class="header"> The <mark>join()</mark> / <mark>split()</mark> / <mark>splitlines()</mark> / <mark>rsplit()</mark>
      / <mark>partition()</mark> / <mark>rpartition()</mark> methods </h2>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
// join() -----------------------------------------------------------------------------
    separator = ' - '
    
    separator.join(['John', 'Steve', 'Zoran', 'Stewe'])                                // -> 'John - Steve - Zoran - Stewe '            // joins the list memebers togehter by using the original string as separator between them and returns the result    
    
    separator                                                                          // -> ' - '                                      // original string not modified   
    
    
// split() / rsplit() -----------------------------------------------------------------
    names = 'John, Steve, Zoran, Stewe'
    
    names.split(', ')                                                                  // -> ['John', 'Steve', 'Zoran', 'Stewe']        // split the string at <makr>' '</makr> character and returns the split values in a list    
    names.split(', ', 2)                                                               // -> ['John', 'Steve', 'Zoran, Stewe']          // split limited for 2 encounter of the split value, the rest is returned as it is   
    
    names.rsplit(', ')                                                                 // -> ['John', 'Steve', 'Zoran', 'Stewe']        // the right split starts spliting parts end-to-start but, there's no difference when no split limit is specified    
    names.rsplit(', ', 2)                                                              // -> ['John, Steve', 'Zoran', 'Stewe']          // right split limited for 2 encounter of the split value, the rest is returned as it is    
    
    names                                                                              // -> 'John, Steve, Zoran, Stewe'                // none of the above methods modify the original string     
    
    
// splitlintes() ----------------------------------------------------------------------
    names = 'John\nSteve\nZoran\rStewe'
    
    names.splitlines()                                                                 // -> ['John', 'Steve', 'Zoran', 'Stewe']        // splits the string at <mark>\n</mark> and <mark>\r</mark> characters   
    names.splitlines(True)                                                             // -> ['John\n', 'Steve\n', 'Zoran\r', 'Stewe']  // preservers the new line characters   
    
    names                                                                              // -> 'John\nSteve\nZoran\rStewe'                // does not modify the original string     
    
    
// partition() / rpartition() ---------------------------------------------------------
    names = 'John Steve Zoran Steve Bob'
    
    names.partition('Steve')                                                           // -> ('John ', 'Steve', ' Zoran Steve Bob')     // partition the string into 3 parts at the first match  
    names.rpartition('Steve')                                                          // -> ('John Steve Zoran ', 'Steve', ' Bob')     // partition the string into 3 parts at the last match  
    
    names                                                                              // -> 'John Steve Zoran Steve Bob'               // does not modify the original string     
    </pre>
    </details>
    <hr>
    <!-------------------------------------------------------------------------------------------->
    <h2 class="header"> The <mark>replace()</mark> / <mark>format()</mark> / <mark>format_map()</mark> /
      <mark>translate()</mark> / <mark>maketrans()</mark> methods </h2>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
// replace() --------------------------------------------------------------------------
    names = 'John Steve Zoran Steve Bob Stewe'
    
    names.replace(' ', ' - ')                                                          // -> 'John - Steve - Zoran - Steve - Bob - Stewe' // replaces all <mark>' '</mark> characters by <mark>' - '</mark> 
    
    names                                                                              // -> 'John Steve Zoran Steve Bob Stewe'           // does not modify the original string  
    
    
// format() / format_map() ------------------------------------------------------------
    'My name is {} {}'.format('Páll', 'Árpád')                                         // -> 'My name is Páll Árpád'                      // arguments are referenced in order 
    'My name is {1} {0}'.format('Árpád', 'Páll')                                       // -> 'My name is Páll Árpád'                      // index place holders reference arguments   
    'My name is {forename} {name}'.format(name='Árpád', forename='Páll')               // -> 'My name is Páll Árpád'                      // keyword arguments replace placeholders in the string 
    
    'My name is {forename} {name}'.format_map({"name":"Árpád", "forename":"Páll"})     // -> 'My name is Páll Árpád'                      // the passed dictionary keys reference placeholders in the string    
    
    
// translate() / maketrans() ----------------------------------------------------------
    text = "Hello World!"
    
    mappingTable = text.maketrans('W', 'L')                                            // creates and returns a mapping table (argument that <mark>translate()</mark> accepts)   
    mappingTable                                                                       // -> {87:76}    
    text.translate(mappingTable)                                                       // -> 'Hello Lord!'    
    
    mappingTable = text.maketrans('lo', '|@', '!')                                     // all <mark>'l'</mark> characters are changed to <mark>'|'</mark> and <mark>'o'</mark> -> <mark>'@'</mark>, all <mark>'!'</mark> characters are removed 
    mappingTable                                                                       // -> {108: 124, 111: 64, 33: None}     
    text.translate(mappingTable)                                                       // -> 'He||@ W@r|d'    
    
    mappingTable = text.maketrans({'W':'L', 'o':'ߋ'})
    mappingTable                                                                       // -> {87:'L', 111:'ߋ'}   
    text.translate(mappingTable)                                                       // -> // -> 'Hellߋ Lߋrd!'    
    
    
    text.translate({87:76})                                                            // -> 'Hello Lord!'                                // 'W' = Ascii decimal 87 / "L" = Acsii decimal 76 ("W" is replaced by "L")   
                                                                                       // we can use it directly as well (but it's uncommon)    
    
    text                                                                               // ->  'Hello World!'                              // none of the above methods modify the original string   
    </pre>
    </details>
    <hr>
    <!-------------------------------------------------------------------------------------------->
    <h2 class="header"> The <mark>encode()</mark> method </h2>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
    text = 'abc_♥'
    
    text.encode()                                                                      // -> b'abc_\xe2\x99\xa5'                          // encodes the string in UTF-8 (default) and retrns the result in a bytes object    
    text.encode('utf-16')                                                              // -> b'\xff\xfea\x00b\x00c\x00_\x00e&'
    text.encode('latin-1', 'replace')                                                  // -> b'abc_?'                                     // unknown characters are replaced by <mark>?</mark>    
    text.encode('ascii', 'backslashreplace')                                           // -> b'abc_\\u2665'                               // unknown characters are replaced by <mark>\</mark>   
    
    text                                                                               // -> 'abc_♥'                                      // does not modify the original string    
    </pre>
    </details>

    <br><br>
  </body>

</html>