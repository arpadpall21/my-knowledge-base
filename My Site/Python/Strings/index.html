<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title> Strings </title> 
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous"> 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../Assets/stylesPages.css"> 
    <script src="../../Assets/scriptPages.js"></script>
</head>
<body>
<h1> Strings (ver 4.0.0) </h1>
    <p> Updated ( 2022-03-02 )</p>
    <p class="sitenav"> <a href="../../index.html">MySite></a>
        <a href="../index.html">Python></a> Strings  
    </p>
<table class="table">
<caption>
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Method / Property / Operator </th>
        <th> Description </th>
    </tr>
    <tr class="05.01">
        <td> 
            str(<strong>data:any</strong>)
        </td>
        <td> 
            - serializes to string the passed data 
        </td>
    </tr>
    <tr class="10.01">
        <td colspan="2"> 
            Operators 
        </td>
    </tr>
    <tr class="10.02">
        <td> 
            <strong>val:str</strong> <small>not</small> in <strong>str</strong>
        </td>
        <td> 
            - returns <mark>True</mark> if <strong>val</strong> is (<small>not</small>) part of <strong>str</strong>, otherwise returns <mark>False</mark>
        </td>
    </tr>
    <tr class="10.03">
        <td> 
            <strong>str</strong> + <strong>str</strong>
        </td>
        <td> 
            - joins the two strings together and retuns a new string (does not modify the original strings)
        </td>
    </tr>
    <tr class="15.01">
        <td> 
            <strong>str</strong>[<strong>idx</strong>]
        </td>
        <td> 
            - returns the letter at the specified index 
        </td>
    </tr>
        <tr class="15.02"><td></td><td></td></tr>
    <tr class="15.03">
        <td> 
            <strong>str</strong>[-<strong>idx</strong>]
        </td>
        <td> 
            - negative indexes are counted from the end (<mark>-1</mark> = last letter / <mark>-2</mark> = second last, etc...)
        </td>
    </tr>
        <tr class="15.04"><td></td><td></td></tr>
    <tr class="15.05">
        <td> 
            <strong>str</strong>[<i>stIdx(inc)</i>:<i>endIdx(exc)</i>]
        </td>
        <td> 
            - returns the specified range in a new <strong>str</strong> (omitting <i>idx</i> = from the start|to the end)
        </td>
    </tr>
        <tr class="15.06"><td></td><td></td></tr>
    <tr class="15.07">
        <td> 
            <strong>str</strong>[<i>-endIdx(exc)</i>:<i>-stIdx(inc)</i>]
        </td>
        <td> 
            - negative indexes are counted from the end (<mark>:-1</mark> = second last letter / however <mark>:-0</mark> doesn't work)
        </td>
    </tr>
    <tr class="17.01">
        <td colspan="2"> 
            Global Methods 
        </td>
    </tr>
    <tr class="17.02">
        <td> 
            chr(<strong>dec</strong>)
        </td>
        <td> 
            - references a unicode UTF-16 character by a decimal notation, (can reference only 2 byte long characters, raises an OverflowError error otherwise) 
            <span id="browserSupport" title="updated : 2022-03-07">
                <span><i class="fab fa-python"></i> 2.7 </span>
            </span>
        </td>
    </tr>
    <tr class="17.03">
        <td> 
            ord(<strong>char</strong>)
        </td>
        <td> 
            - returns the passed character's unicode UTF-16 decimal value, (for 2 byte encoded characters only <mark>0-65535</mark>)
            <span id="browserSupport" title="updated : 2022-03-07">
                <span><i class="fab fa-python"></i> 2.7 </span>
            </span>
        </td>
    </tr>
    <tr class="20.01">
        <td colspan="2"> 
            Methods 
        </td>
    </tr>
    <tr class="25.01">
        <td> 
            <strong>str</strong>.capitalize()
        </td>
        <td> 
            - converts the first letter of the string into upper case and returns the result in a new string (does not modify the original) 
        </td>
    </tr>
    <tr class="20.04">
        <td> 
            <strong>str</strong>.casefold()
        </td>
        <td> 
            - converts the string into lower case letters and returns the result in a new string (does not modify the original) <br>
            - does the same as <mark>lower()</mark> but more effective lowering unicode letters (however I didn't see any difference)  
        </td>
    </tr>
    <tr class="35.01">
        <td> 
            <strong>str</strong>.center(<strong>length:int</strong>, <i>char</i>)
        </td>
        <td> 
            - centers the string by filling white spaces (or <i>char</i>) on both sides on the string and returns the result in a new string (does not modify the original)
        </td>
    </tr>
    <tr class="40.02">
        <td> 
            <strong>str</strong>.endswith(<strong>str</strong>, <i>stIdx(inc)</i>, <i>endIdx(exc)</i>)
        </td>
        <td> 
            - returns <mark>True</mark> if the string (or the range) ends with <strong>str</strong>, <mark>False</mark> otherwise  
        </td>
    </tr>
    <tr class="50.01">
        <td> 
            <strong>str</strong>.count(<strong>srch:str</strong>)
        </td>
        <td> 
            - returns how many times <strong>srch</strong> is found in the text  
        </td>
    </tr>
    <tr class="90.01">
        <td> 
            <strong>str</strong>.encode(<strong class="openable">encoding<div>
                <p> - Default <mark>UTF-8</mark> </p>
            </div></strong>, <i class="openable">errs<div>
                <p> - specifies what to do when an unknown character is encountered </p>
                <p> <mark>'strict'</mark>	- (Default) raises an error on failure </p>
                <p> <mark>'backslashreplace'</mark>	- uses a backslash instead of the character that could  </p> be encoded
                <p> <mark>'ignore'</mark>	- ignores the characters that cannot be encoded </p>
                <p> <mark>'namereplace'</mark>	- replaces the character with a text explaining the  </p>character
                <p> <mark>'replace'</mark>	- replaces the character with a questionmark </p>
                <p> <mark>'xmlcharrefreplace'</mark>	- replaces the character with an xml character </p>
            </div></i>)
        </td>
        <td> 
            - encodes the string according the <i>encoding</i> and returns the result in a <strong>bytesObj</strong> (does not modify the original string)
        </td>
    </tr>
    <tr class="55.01">
        <td> 
            <strong>str</strong>.find(<strong>srch:str</strong>, <i>stIdx(inc)</i>, <i>endIdx(exc)</i>)
        </td>
        <td> 
            - returns the index where <strong>srch</strong> is found in the string (optional search range can be specified) <br>
            - returns <mark>-1</mark> if <strong>srch</strong> is not found  
        </td>
    </tr>
    <tr class="80.01">
        <td> 
            <strong>"..<em>{}</em>..<em>{}</em>.."</strong>.format(<strong>val:any</strong>, <i>...</i>)
        </td>
        <td> 
            - format the string by placing arguments in <em>{}</em> (does not modify the original string) <br>
            - arguments are placed in order in <em>{}</em>
        </td>
    </tr>
        <tr class="80.02"><td></td><td></td></tr>
    <tr class="80.03">
        <td> 
            <strong>"..<em>{<strong>idx</strong>}</em>..<em>{<strong>idx</strong>}</em>.."</strong>.format(<strong>val:any</strong>, <i>...</i>)
        </td>
        <td> 
            - arguments are indexed in <em>{}</em>
        </td>
    </tr>
        <tr class="80.04"><td></td><td></td></tr>
    <tr class="80.05">
        <td> 
            <strong>"..<em>{<strong>key</strong>}</em>..<em>{<strong>key</strong>}</em>.."</strong>.format(<strong>key=val:any</strong>, <i>...</i>)
        </td>
        <td> 
            - arguments are referenced by placeholders in <em>{}</em>
        </td>
    </tr>
    <tr class="80.06">
        <td> 
            <strong>"..<em>{<strong>key</strong>}</em>..<em>{<strong>key</strong>}</em>.."</strong>.format_map({<strong>key:val:any</strong>, <i>...</i>})
        </td>
        <td> 
            - format the string by placing arguments in <em>{}</em> (does not modify the original string) <br>
            - the dictionary's keys are referenced by placeholders in <em>{}</em>
        </td>
    </tr>
    <tr class="55.02">
        <td> 
            <strong>str</strong>.index(<strong>srch:str</strong>, <i>stIdx(inc)</i>, <i>endIdx(exc)</i>)
        </td>
        <td> 
            - returns the index where <strong>srch</strong> is found in the string (optional search range can be specified) <br>
            - raises a <mark>ValueError</mark> if <strong>srch</strong> is not found  
        </td>
    </tr>
    <tr class="45.01">
        <td> 
            <strong>str</strong>.isalnum()
        </td>
        <td> 
            - returns <mark>True</mark> if the string contains only alphanumerical characters (alphabetical letters (accent letters included) and any numerical characters), <mark>False</mark> otherwise   
        </td>
    </tr>
    <tr class="45.02">
        <td> 
            <strong>str</strong>.isalpha()
        </td>
        <td> 
            - returns <mark>True</mark> if the string contains only alphabetical letters (accent letters included), <mark>False</mark> otherwise   
        </td>
    </tr>
    <tr class="45.03">
        <td> 
            <strong>str</strong>.isdecimal()
        </td>
        <td> 
            - returns <mark>True</mark> if the string contains only decimal characters (ex: <mark>¬≤</mark> excluded), <mark>False</mark> otherwise   
        </td>
    </tr>
    <tr class="45.04">
        <td> 
            <strong>str</strong>.isdigit()
        </td>
        <td> 
            - returns <mark>True</mark> if the string contains only digit characters (ex: <mark>¬≤</mark> included but <mark>¬æ</mark> excluded), <mark>False</mark> otherwise   
        </td>
    </tr>
    <tr class="45.06">
        <td> 
            <strong>str</strong>.isidentifier()
        </td>
        <td> 
            - returns <mark>True</mark> if the string contains a valid variable name, <mark>False</mark> otherwise   
        </td>
    </tr>
    <tr class="27.01">
        <td> 
            <strong>str</strong>.islower()
        </td>
        <td> 
            - return <mark>True</mark> if all letters are lower cases in the string, <mark>False</mark> otherwise   
        </td>
    </tr>
    <tr class="45.05">
        <td> 
            <strong>str</strong>.isnumeric()
        </td>
        <td> 
            - returns <mark>True</mark> if the string contains only numberic characters (ex: <mark>¬≤</mark> and <mark>¬æ</mark> included), <mark>False</mark> otherwise   
        </td>
    </tr>
    <tr class="45.07">
        <td> 
            <strong>str</strong>.isprintable()
        </td>
        <td> 
            - returns <mark>True</mark> if the string contains only printalbe characters (ex: <mark>\n</mark> is not printable), <mark>False</mark> otherwise   
        </td>
    </tr>
    <tr class="45.09">
        <td> 
            <strong>str</strong>.isspace()
        </td>
        <td> 
            - returns <mark>True</mark> if the string contains only white space characters, <mark>False</mark> otherwise   
        </td>
    </tr>
    <tr class="45.08">
        <td> 
            <strong>str</strong>.istitle()
        </td>
        <td> 
            - returns <mark>True</mark> if the string contains words that all starts with a capital letter, <mark>False</mark> otherwise   
        </td>
    </tr>
    <tr class="27.02">
        <td> 
            <strong>str</strong>.isupper()
        </td>
        <td> 
            - return <mark>True</mark> if all letters are upper cases in the string, <mark>False</mark> otherwise   
        </td>
    </tr>
    <tr class="60.01">
        <td> 
            <strong>str</strong>.join(<strong>iterable</strong>)
        </td>
        <td> 
            - parses the <strong>iterable</strong> members into string and joins them together by using the original <strong>str</strong> as separator between them, returns the result in a new string (does not modify the original string) 
        </td>
    </tr>
    <tr class="35.02">
        <td> 
            <strong>str</strong>.ljust(<strong>length:int</strong>, <i>char</i>)
        </td>
        <td> 
            - left adjust the string by filling white spaces (or <i>char</i>) <u>on the right side (not left side)</u> on the string, returns the result in a new string (does not modify the original)
        </td>
    </tr>
    <tr class="20.03">
        <td> 
            <strong>str</strong>.lower()
        </td>
        <td> 
            - converts the string into lower case letters and returns the result in a new string (does not modify the original)
        </td>
    </tr>
    <tr class="30.02">
        <td> 
            <strong>str</strong>.lstrip()
        </td>
        <td> 
            - removes white spaces on the left side on the <strong>str</strong> and returns the result in a new string (does not modify the orignal string)   
        </td>
    </tr>
    <tr class="85.01">
        <td> 
            <strong>str</strong>.maketrans(<strong class="openable">trg:str, new:str, del:str<div>
                <p> <strong>trg</strong> - contains characters that will be replaced </p>
                <p> <strong>new</strong> - contains new characters </p>
                <p> <strong>del</strong> - containrs characters that will be removed</p>
                <hr>
                <p> ex: </p>
                <p> - replaced characters <mark>a -> s</mark> <mark>b -> x</mark> <mark>c -> y</mark> </p>
                <p> - <mark>_</mark> character is removed from the string </p>
      <pre>
      text = 'abc_'
      
      mappingTable = ''.maketrans('abc', 'sxy', '_')
      text.translate(mappingTable)        // -> 'sxy'     
      </pre>
            </div></strong>)
        </td>
        <td> 
            - creates and returns a <strong>mappingTable</strong> which describes characters that will be replaced and removed from the string by the <mark>translate()</mark> method <br>
            - the returned <strong>mappingTable</strong> is passed as <mark>translate()</mark> argument (this method does not modify the original string) 
        </td>
    </tr>
        <tr class="85.02"><td></td><td></td></tr>
    <tr class="85.03">
        <td> 
            <strong>str</strong>.maketrans(<strong class="openable">dict<div>
                <p> {<strong>trgChar:str</strong>:<strong>newChar:str</strong>, <i>...</i>} </p>
                <p> <strong>trg</strong> - contains characters that will be replaced </p>
                <p> <strong>new</strong> - contains new characters </p>
                <hr>
                <p> ex: </p>
                <p> - replaced characters <mark>a -> s</mark> <mark>b -> x</mark> <mark>c -> y</mark> </p>
      <pre>
      text = 'abc'
      
      mappingTable = ''.maketrans({'a':'s', 'b':'x', 'c':'y'})    
      text.translate(mappingTable)        // -> 'sxy'     
      </pre>
            </div></strong>)
        </td>
        <td> 
            
        </td>
    </tr>
    <tr class="70.01">
        <td> 
            <strong>str</strong>.partition(<strong>srch:str</strong>)
        </td>
        <td> 
            - partition the string into 3 parts at the first found <strong>srch</strong> and returns the result in a new tuple (does not modify the original string) <br>
            - partitions = 1) part before <strong>srch</strong> / 2) the <strong>srch</strong> / 3) part after <strong>srch</strong>  
        </td>
    </tr>
    <tr class="75.01">
        <td> 
            <strong>str</strong>.replace(<strong>srch:str</strong>, <strong>new:str</strong>)
        </td>
        <td> 
            - replaces all <strong>srch</strong> by <strong>new</strong> and returns the result in a new string (does not modify the original string)
        </td>
    </tr>
    <tr class="55.03">
        <td> 
            <strong>str</strong>.rfind(<strong>srch:str</strong>, <i>stIdx(inc)</i>, <i>endIdx(exc)</i>)
        </td>
        <td> 
            - returns the index where <strong>srch</strong> is found in the string, searches end-to-start (optional search range can be specified) <br>
            - returns <mark>-1</mark> if <strong>srch</strong> is not found  
        </td>
    </tr>
    <tr class="55.04">
        <td> 
            <strong>str</strong>.rindex(<strong>srch:str</strong>, <i>stIdx(inc)</i>, <i>endIdx(exc)</i>)
        </td>
        <td> 
            - returns the index where <strong>srch</strong> is found in the string, searches end-to-start (optional search range can be specified) <br>
            - raises a <mark>ValueError</mark> if <strong>srch</strong> is not found  
        </td>
    </tr>
    <tr class="35.03">
        <td> 
            <strong>str</strong>.rjust(<strong>length:int</strong>, <i>char</i>)
        </td>
        <td> 
            - right adjust the string by filling white spaces (or <i>char</i>) <u>on the left side (not right side)</u> on the string, returns the result in a new string (does not modify the original)
        </td>
    </tr>
    <tr class="70.02">
        <td> 
            <strong>str</strong>.rpartition(<strong>srch:str</strong>)
        </td>
        <td> 
            - partition the string into 3 parts at the last found <strong>srch</strong> and returns the result in a new tuple (does not modify the original string) <br>
            - partitions = 1) part before <strong>srch</strong> / 2) the <strong>srch</strong> / 3) part after <strong>srch</strong>  
        </td>
    </tr>
    <tr class="65.02">
        <td> 
            <strong>str</strong>.rsplit(<strong>srch</strong>, <i class="openable">limit:int<div>
                <p> - split limit </p>
            </div></i>)
        </td>
        <td> 
            - end-to-start splits the string at <strong>srch:str</strong> and returns the splitted parts in a new list (does not modify the original string) (<strong>srch</strong> is removed from the sliptted parts)
        </td>
    </tr>
    <tr class="30.03">
        <td> 
            <strong>str</strong>.rstrip()
        </td>
        <td> 
            - swaps letter cases in the string (lower -> upper / upper -> lower)  returns the result in a new string (does not modify the original) 
        </td>
    </tr>
    <tr class="40.01">
        <td> 
            <strong>str</strong>.startswith(<strong>str</strong>, <i>stIdx(inc)</i>, <i>endIdx(exc)</i>)
        </td>
        <td> 
            - returns <mark>True</mark> if the string (or the range) starts with <strong>str</strong>, <mark>False</mark> otherwise  
        </td>
    </tr>
    <tr class="65.01">
        <td> 
            <strong>str</strong>.split(<strong>srch:str</strong>, <i class="openable">limit:int<div>
                <p> - split limit </p>
            </div></i>)
        </td>
        <td> 
            - splits the string at <strong>srch</strong> and returns the splitted parts in a new list (does not modify the original string) (<strong>srch</strong> is removed from the sliptted parts)
        </td>
    </tr>
    <tr class="65.03">
        <td> 
            <strong>str</strong>.splitlines(<i class="openable">preserve\n\r:bol<div>
                <p> - preservers the <mark>\r</mark>, <mark>\n</mark> characters on the splitted parts (Default: <mark>False</mark>) </p>
            </div></i>)
        </td>
        <td> 
            - splits the string at new line characters (<mark>\n</mark>, <mark>\r</mark>) and returns the splitted parts in a new list (does not modify the original string) (by default new line characters are removed from the sliptted parts)
        </td>
    </tr>
    <tr class="85.04">
        <td> 
            <strong>str</strong>.translate(<strong>mappingTable</strong>)
        </td>
        <td> 
            - replaces chacters in the string according to the <strong>mappingTable</strong>, returns the result in a new string (does not modify the original string)
        </td>
    </tr>
    <tr class="20.02">
        <td> 
            <strong>str</strong>.upper()
        </td>
        <td> 
            - converts the string into upper case letters and returns the result in a new string (does not modify the original)
        </td>
    </tr>
    <tr class="35.04">
        <td> 
            <strong>str</strong>.zfill(<strong>length:int</strong>)
        </td>
        <td> 
            - fills <mark>0</mark> characters on the left side on the string untill the specified length is reached, returns the result in a new string (does not modify the original)
        </td>
    </tr>
</table>
    <br>
<table class="table">
<caption> Escape Notations <mark>\</mark>
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Notation </th>
        <th> Description </th>
    </tr> 
    <tr class="05.01">
        <td> \<strong>char</strong> </td>
        <td> 
            - character following a backslash is escaped
        </td>
    </tr> 
    <tr class="10.01">
        <td> \<strong>escapeChar</strong> </td>
        <td> 
            - any <span class="openable">escape character<div>
                <p> <mark>\t</mark> - Insert a tab in the text at this point </p>
                <p> <mark>\b</mark> - Insert a backspace in the text at this point </p>
                <p> <mark>\n</mark> - Insert a newline in the text at this point </p>
                <p> <mark>\r</mark> - Insert a carriage return in the text at this point </p>
                <p> <mark>\f</mark> - Insert a formfeed in the text at this point </p>
                <p> <mark>\'</mark> - Insert a single quote character in the text at this point </p>
                <p> <mark>\"</mark> - Insert a double quote character in the text at this point </p>
                <p> <mark>\\</mark> - Insert a backslash character in the text at this point </p>
            </div></span> can be used 
        </td>
    </tr> 
    <tr class="15.01">
        <td> \u<strong>HexHexHexHex</strong> </td>
        <td> 
            - references a unicode UTF-16 character by a <u>4</u> hexadecimal notation (hex => <mark>[0123456789abcdef]</mark>) <u>(can reference only 2 byte long characters)</u>
        </td>
    </tr> 
    <tr class="15.03">
        <td> \x<strong>HexHex</strong> </td>
        <td> 
            - references a latin1 (ISO-8859-1) character by a <u>2</u> hexadecimal notation (hex => <mark>[0123456789abcdef]</mark>)
        </td>
    </tr> 
    <tr class="15.04">
        <td> \<strong>Oct....</strong> </td>
        <td> 
            - references a latin1 (ISO-8859-1) character by a <u>1 to 3</u> octal notation (octal => <mark>[01234567]</mark>) 
        </td>
    </tr> 
</table>
    <br>
    <details class="example" id="notes">
    <summary> Notes :</summary>
        <p> - the <mark>expandtabs()</mark> is some useless shit -> I refused to learn it! </p>
    </details>
<h2 style="color:green;"><u> Useful Links : </u></h2>
    
<h2 style="color:green;"><u> Remember This : </u></h2>
    
<h2 style="color:green;"><u> Description and Demonstration : </u></h2>
    <p> - Python encodes strings in UTF-8 (uses 1 to 4 bytes to encode 1 character) </p>
    <p> - strings are iterable, so we can use iterator tools on them (ex: for loop, <mark>in</mark> keyword, etc...) </p>
    <pre class="syntax">
    '<strong>string</strong>'                                                                           // single or double quotes can be used 
    "<strong>string</strong>"
    
    
    '''                                                                                // multiline string (preservers all characters)  
    <strong>string</strong>                                                                               // also used as multiline comment (because string characters are not parsed)   
      <strong>string</strong>
    '''
    </pre>
<hr>
<!-------------------------------------------------------------------------------------------->
<h2 class="header"> escape notation <mark>\</mark> </h2>
    <p> - in strings we can used the <mark>\</mark> escape notation to escape the following character or use any escape characters </p>
<details class="example">
<summary> DEMO </summary>
    <pre>
    'this is a \'test\''                                                               // the <mark>'</mark> chacters in the string are escaped (printed as <mark>this is a 'test'</mark>)  
    
// referencing characters from latin-1 table ------------------------------------------
    '\x21'                                                                             // -> '!'        // references the <mark>!</mark> character from the latin-1 table as hexadecimal notation    
    '\41'                                                                              // -> '!'        // references the <mark>!</mark> character from the latin-1 table as octal notation    
    
    
// referencing characters from UTF-16 unicode table -----------------------------------
    '\u0021'                                                                           // -> '!'        // references the <mark>!</mark> character from the UTF-16 unicode table as hexadecimal notation    
    chr(33)                                                                            // -> '!'        // references the <mark>!</mark> character from the UTF-16 unicode table as decimal notation    
    ord('!')                                                                           // -> 33         // returns the passed character's decimal notation from the UTF-16 unicode table   
    
    '\u1fa7'                                                                           // -> '·æß'
    chr(8103)                                                                          // -> '·æß'
    ord('·æß')                                                                           // -> 8103
    
    
// UTF-16 2 byte character reference limitation ---------------------------------------
    // -! the üíî character is referenced as <mark>d83ddc94</mark> hexadecimal or <mark>3627932820</mark> decimal in the unicode table (encoded in 4 bytes), so the below tools cannot reference it because they are limited to reference only 2 byte characters   
    '/ud83ddc94'                                                                       // -> '/ud83ddc94'
    chr(3627932820)                                                                    // -! raises an OverflowError  
    </pre>
</details>
<hr>
<!-------------------------------------------------------------------------------------------->
<h2 class="header"> The <mark>in</mark> keywords, <mark>+</mark> operator and range slicing <mark>[:]</mark> </h2>
<details class="example">
<summary> DEMO </summary>
    <pre>
// in operator ------------------------------------------------------------------------
    text = 'Kicsi kutya tarka'
    
    'cs' in text                                                                       // -> True
    'x' not in text                                                                    // -> True
    
// + (operator) -----------------------------------------------------------------------
    size = 'Kicsi '
    animal = 'kutya '
    adjective = 'tarka'
    
    size + animal + adjective                                                          // -> Kicsi kutya tarka    // concateneates strings togehter 
    
    size                                                                               // -> 'Kicsi '             // does not modify originals 
    animal                                                                             // -> 'kutya '
    adjective                                                                          // -> 'tarka'
    
// indexing and range slicing ---------------------------------------------------------
    string = 'this is a test string'
    
    string[0]                                                                          // -> 't'                  // returns the indexed the letter   
    
    string[-1]                                                                         // -> 'g'                  // element order is counted (not indexed) from the back when using negative indexing   
    string[-2]                                                                         // -> 'n'
    
    string[5:7]                                                                        // -> 'is'                 // returns the indexed range 
    string[:4]                                                                         // -> 'this'
    string[10:]                                                                        // -> 'test string'
    
    string[-11:-7]                                                                     // -> 'test'               // indexing from the end 
    string[-6:]                                                                        // -> 'string'
    string[:-7]                                                                        // -> 'this is a test'
    </pre>
</details>
<hr>
<!-------------------------------------------------------------------------------------------->
<h2 class="header"> The <mark>char()</mark> / <mark>ord()</mark> methods </h2>
<details class="example">
<summary> DEMO </summary>
    <pre>
    'this is a \'test\''                                                               // the <mark>'</mark> chacters in the string are escaped (printed as <mark>this is a 'test'</mark>)  
    
// referencing characters from latin-1 table ------------------------------------------
    '\x21'                                                                             // -> '!'        // references the <mark>!</mark> character from the latin-1 table as hexadecimal notation    
    '\41'                                                                              // -> '!'        // references the <mark>!</mark> character from the latin-1 table as octal notation    
    
    
// referencing characters from UTF-16 unicode table -----------------------------------
    '\u0021'                                                                           // -> '!'        // references the <mark>!</mark> character from the UTF-16 unicode table as hexadecimal notation    
    chr(33)                                                                            // -> '!'        // references the <mark>!</mark> character from the UTF-16 unicode table as decimal notation    
    ord('!')                                                                           // -> 33         // returns the passed character's decimal notation from the UTF-16 unicode table   
    
    '\u1fa7'                                                                           // -> '·æß'
    chr(8103)                                                                          // -> '·æß'
    ord('·æß')                                                                           // -> 8103
    
    
// UTF-16 2 byte character reference limitation ---------------------------------------
    // -! the üíî character is referenced as <mark>d83ddc94</mark> hexadecimal or <mark>3627932820</mark> decimal in the unicode table (encoded in 4 bytes), so the below tools cannot reference it because they are limited to reference only 2 byte characters   
    '/ud83ddc94'                                                                       // -> '/ud83ddc94'
    chr(3627932820)                                                                    // -! raises an OverflowError  
    </pre>
</details>
<hr>
<!-------------------------------------------------------------------------------------------->
<h2 class="header"> The <mark>upper()</mark> / <mark>lower()</mark> / <mark>casefold()</mark> / <mark>capitalize()</mark> / <mark>swapcase()</mark>/ <mark>islower()</mark> / <mark>isupper()</mark> methods </h2>
<details class="example">
<summary> DEMO </summary>
    <pre>
// upper() / lower() / casefold() / capitalize() / swapcase() -------------------------
    text = 'test ”™ tEsT'
    
    text.upper()                                                                       // -> 'TEST ”™ TEST'
    text.lower()                                                                       // -> 'test ”´ test'
    text.casefold()                                                                    // -> 'test ”´ test'      // does the same as <mark>lower()</mark>, it's more effective when lowering unicode letters, however I don't see any difference here    
    
    text.capitalize()                                                                  // -> 'Test ”´ test'      // upper case the very first letter only  
    text.swapcase()                                                                    // -> 'TEST ”´ TeSt'      // swap letter cases in the string  
    
    text                                                                               // -> 'test ”™ tEsT'      // none of the above methods modify the original string   
    
    
// islower() / isupper() --------------------------------------------------------------
    'test'.islower()                                                                   // -> True
    'TEST'.isupper()                                                                   // -> True
    </pre>
</details>
<hr>
<!-------------------------------------------------------------------------------------------->
<h2 class="header"> The <mark>strip()</mark> / <mark>lstrip()</mark> / <mark>rstrip()</mark> / <mark>center()</mark> / <mark>ljust()</mark> / <mark>rjust()</mark> / <mark>zfill()</mark> methods </h2>
<details class="example">
<summary> DEMO </summary>
    <pre>
    text = '  test  '
    
// strip() / lstrip() / rstrip() ------------------------------------------------------
    
    text.strip()                                                                       // -> '  test  '           // removes white spaces from both ends 
    text.lstrip()                                                                      // -> 'test  '             // removes white spaces on the left   
    text.rstrip()                                                                      // -> '  test'             // removes white spaces on the right    
    
    text                                                                               // -> '  test  '           // none of the above methods modify the original string    
    
    
// center() / ljust() / rjust() / zfill() ---------------------------------------------
    text.center(8, '-')                                                                // -> '--test--'           // centers the string by filling the specified character on both sides   
    text.center(7, '-')                                                                // -> '--test-'
    text.center(3, '-')                                                                // -> 'test'               // not modified short length specified    
    
    text.ljust(6, '-')                                                                 // -> 'test--'             // fills the specified character on the rigth untill the specified length reached    
    text.ljust(3, '-')                                                                 // -> 'test'               // not modified short length specified    
    
    text.rjust(6, '-')                                                                 // -> '--test'             // fills the specified character on the left untill the specified length reached    
    text.rjust(3, '-')                                                                 // -> 'test'               // not modified short length specified    
    
    text.zfill(6)                                                                      // -> '00test'             // fills the <mark>0</mark> character on the left untill the specified length reached    
    text.zfill(3)                                                                      // -> 'test'               // not modified short length specified    
    
    text                                                                               // -> '  test  '           // none of the above methods modify the original string     
    </pre>
</details>
<hr>
<!-------------------------------------------------------------------------------------------->
<h2 class="header"> The <mark>startswith()</mark> / <mark>endswith()</mark> / <mark>isalnum()</mark> / <mark>isalpha()</mark> / <mark>isdecimal()</mark> / <mark>isdigit()</mark> / <mark>isnumeric()</mark> / <mark>isidentifier()</mark> / <mark>isprintable()</mark> / <mark>istitle()</mark> / <mark>isspace()</mark> methods </h2>
<details class="example">
<summary> DEMO </summary>
    <pre>
// startswith() / endswith() ----------------------------------------------------------
    text = 'test text'
    
    text.startswith('te')                                                              // -> True
    text.startswith(' t', 4, 7)                                                        // -> True         // between the specified range    
    
    text.endswith('xt')                                                                // -> True
    text.endswith('st', 0, 4)                                                          // -> True         // between the specified range    
    
    
// isalnum() / isalpha() --------------------------------------------------------------
    '√Årp√°d01¬≤¬æ'.isalnum()                                                              // -> True         // string contains alphanumeric characters (alphabetical letters (accent letters included) and numerical values)
    'P√°ll √Årp√°d'.isalnum()                                                             // -> False        // the space is not part of alphanumerics   
    
    '√Årp√°d'.isalpha()                                                                  // -> True         // string contains alphabetical letters only (accent letters included)   
    'P√°ll √Årp√°d'.isalnum()                                                             // -> False        // the space is not part of alphanumerics    
    
    
// isdecimal() / isdigit() / isnumeric() ----------------------------------------------
    '1548'.isdecimal()                                                                 // -> True         // string contains only decimal characters    
    '1548¬≤'.isdecimal()                                                                // -> False        // <mark>¬≤</mark> is not decimal character   
    
    '1548¬≤'.isdigit()                                                                  // -> True         // string containrs only digits 
    '1548¬æ'.isdigit()                                                                  // -> False        // <mark>¬æ</mark> is not digit characgter 
    
    '1548¬≤¬æ'.isnumeric()                                                               // -> True         // string contains only numberical characters (any character that contains numbers)    
    '1548!'.isnumeric()                                                                // -> False        // <mark>!</mark> is not a numeric character    
    
    
// isidentifier() / isprintable() / istitle() / isspace() -----------------------------
    '_varName1'.isidentifier()                                                         // -> True         // valid variable name   
    '1_varName'.isidentifier()                                                         // -> False   
    
    'my name is √Årp√°d'.isprintable()                                                   // -> True         // all chacters are printable  
    'my name is √Årp√°d\n'.isprintable()                                                 // -> False        // <mark>\n</mark> is not printable   
    
    ''The Game Player'.istitle()'.istitle()                                            // -> True         // all words starts with a capital letter  
    'The game player'.istitle()                                                        // -> False
    
    '   '.isspace()                                                                    // -> True         // all characters are white spaces   
    ''.isspace()                                                                       // -> False   
    </pre>
</details>
<hr>
<!-------------------------------------------------------------------------------------------->
<h2 class="header"> The <mark>count()</mark> / <mark>find()</mark> / <mark>rfind()</mark> / <mark>index()</mark> / <mark>rindex()</mark> methods </h2>
<details class="example">
<summary> DEMO </summary>
    <pre>
// count() ----------------------------------------------------------------------------
    'kacsa karika'.count('ka')                                                         // -> 3          // the <mark>'ka'</mark> is found 3 times in the text   
    
    
// find() / index() / rfind() / rindex() ----------------------------------------------
    'kacsa karika'.find('ka', 3, 9)                                                    // -> 5          // the <mark>'ka'</mark> is found at index 5 (between the specified range)  
    'kacsa karika'.index('ka', 3, 9)                                                   // -> 5
    
    'kacsa karika'.find('x')                                                           // -> -1         // value not found in the text   
    'kacsa karika'.index('x')                                                          // -! raises a ValueError because the searched value is not found    
    
    'kacsa karika'.rfind('ka')                                                         // -> 9          // the <mark>'ka'</mark> is found at index 9 (searches end-to-start)  
    'kacsa karika'.rindex('ka')                                                        // -> 9
    
    'kacsa karika'.rfind('x')                                                          // -> -1         // value not found in the text    
    'kacsa karika'.rindex('x')                                                         // -! raises a ValueError because the searched value is not found    
    </pre>
</details>
<hr>
<!-------------------------------------------------------------------------------------------->
<h2 class="header"> The <mark>join()</mark> / <mark>split()</mark> /  <mark>splitlines()</mark> / <mark>rsplit()</mark> / <mark>partition()</mark> / <mark>rpartition()</mark>  methods </h2>
<details class="example">
<summary> DEMO </summary>
    <pre>
// join() -----------------------------------------------------------------------------
    separator = ' - '
    
    separator.join(['John', 'Steve', 'Zoran', 'Stewe'])                                // -> 'John - Steve - Zoran - Stewe '            // joins the list memebers togehter by using the original string as separator between them and returns the result    
    
    separator                                                                          // -> ' - '                                      // original string not modified   
    
    
// split() / rsplit() -----------------------------------------------------------------
    names = 'John, Steve, Zoran, Stewe'
    
    names.split(', ')                                                                  // -> ['John', 'Steve', 'Zoran', 'Stewe']        // split the string at <makr>' '</makr> character and returns the split values in a list    
    names.split(', ', 2)                                                               // -> ['John', 'Steve', 'Zoran, Stewe']          // split limited for 2 encounter of the split value, the rest is returned as it is   
    
    names.rsplit(', ')                                                                 // -> ['John', 'Steve', 'Zoran', 'Stewe']        // the right split starts spliting parts end-to-start but, there's no difference when no split limit is specified    
    names.rsplit(', ', 2)                                                              // -> ['John, Steve', 'Zoran', 'Stewe']          // right split limited for 2 encounter of the split value, the rest is returned as it is    
    
    names                                                                              // -> 'John, Steve, Zoran, Stewe'                // none of the above methods modify the original string     
    
    
// splitlintes() ----------------------------------------------------------------------
    names = 'John\nSteve\nZoran\rStewe'
    
    names.splitlines()                                                                 // -> ['John', 'Steve', 'Zoran', 'Stewe']        // splits the string at <mark>\n</mark> and <mark>\r</mark> characters   
    names.splitlines(True)                                                             // -> ['John\n', 'Steve\n', 'Zoran\r', 'Stewe']  // preservers the new line characters   
    
    names                                                                              // -> 'John\nSteve\nZoran\rStewe'                // does not modify the original string     
    
    
// partition() / rpartition() ---------------------------------------------------------
    names = 'John Steve Zoran Steve Bob'
    
    names.partition('Steve')                                                           // -> ('John ', 'Steve', ' Zoran Steve Bob')     // partition the string into 3 parts at the first match  
    names.rpartition('Steve')                                                          // -> ('John Steve Zoran ', 'Steve', ' Bob')     // partition the string into 3 parts at the last match  
    
    names                                                                              // -> 'John Steve Zoran Steve Bob'               // does not modify the original string     
    </pre>
</details>
<hr>
<!-------------------------------------------------------------------------------------------->
<h2 class="header"> The <mark>replace()</mark> / <mark>format()</mark> / <mark>format_map()</mark> / <mark>translate()</mark> / <mark>maketrans()</mark> methods </h2>
<details class="example">
<summary> DEMO </summary>
    <pre>
// replace() --------------------------------------------------------------------------
    names = 'John Steve Zoran Steve Bob Stewe'
    
    names.replace(' ', ' - ')                                                          // -> 'John - Steve - Zoran - Steve - Bob - Stewe' // replaces all <mark>' '</mark> characters by <mark>' - '</mark> 
    
    names                                                                              // -> 'John Steve Zoran Steve Bob Stewe'           // does not modify the original string  
    
    
// format() / format_map() ------------------------------------------------------------
    'My name is {} {}'.format('P√°ll', '√Årp√°d')                                         // -> 'My name is P√°ll √Årp√°d'                      // arguments are referenced in order 
    'My name is {1} {0}'.format('√Årp√°d', 'P√°ll')                                       // -> 'My name is P√°ll √Årp√°d'                      // index place holders reference arguments   
    'My name is {forename} {name}'.format(name='√Årp√°d', forename='P√°ll')               // -> 'My name is P√°ll √Årp√°d'                      // keyword arguments replace placeholders in the string 
    
    'My name is {forename} {name}'.format_map({"name":"√Årp√°d", "forename":"P√°ll"})     // -> 'My name is P√°ll √Årp√°d'                      // the passed dictionary keys reference placeholders in the string    
    
    
// translate() / maketrans() ----------------------------------------------------------
    text = "Hello World!"
    
    mappingTable = text.maketrans('W', 'L')                                            // creates and returns a mapping table (argument that <mark>translate()</mark> accepts)   
    mappingTable                                                                       // -> {87:76}    
    text.translate(mappingTable)                                                       // -> 'Hello Lord!'    
    
    mappingTable = text.maketrans('lo', '|@', '!')                                     // all <mark>'l'</mark> characters are changed to <mark>'|'</mark> and <mark>'o'</mark> -> <mark>'@'</mark>, all <mark>'!'</mark> characters are removed 
    mappingTable                                                                       // -> {108: 124, 111: 64, 33: None}     
    text.translate(mappingTable)                                                       // -> 'He||@ W@r|d'    
    
    mappingTable = text.maketrans({'W':'L', 'o':'ﬂã'})
    mappingTable                                                                       // -> {87:'L', 111:'ﬂã'}   
    text.translate(mappingTable)                                                       // -> // -> 'Hellﬂã Lﬂãrd!'    
    
    
    text.translate({87:76})                                                            // -> 'Hello Lord!'                                // 'W' = Ascii decimal 87 / "L" = Acsii decimal 76 ("W" is replaced by "L")   
                                                                                       // we can use it directly as well (but it's uncommon)    
    
    text                                                                               // ->  'Hello World!'                              // none of the above methods modify the original string   
    </pre>
</details>
<hr>
<!-------------------------------------------------------------------------------------------->
<h2 class="header"> The <mark>encode()</mark> method </h2>
<details class="example">
<summary> DEMO </summary>
    <pre>
    text = 'abc_‚ô•'
    
    text.encode()                                                                      // -> b'abc_\xe2\x99\xa5'                          // encodes the string in UTF-8 (default) and retrns the result in a bytes object    
    text.encode('utf-16')                                                              // -> b'\xff\xfea\x00b\x00c\x00_\x00e&'
    text.encode('latin-1', 'replace')                                                  // -> b'abc_?'                                     // unknown characters are replaced by <mark>?</mark>    
    text.encode('ascii', 'backslashreplace')                                           // -> b'abc_\\u2665'                               // unknown characters are replaced by <mark>\</mark>   
    
    text                                                                               // -> 'abc_‚ô•'                                      // does not modify the original string    
    </pre>
</details>
    
    
    <br><br>
</body>
</html>
