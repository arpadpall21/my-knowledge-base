<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title> Classes </title>
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css"
    integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <link rel="stylesheet" href="../../../Assets/stylesPages.css">
  <script src="../../../Assets/scriptPages.js"></script>
</head>

<body>
  <h1> Classes </h1>
  <p> Updated ( 2022-03-18 )</p>
  <p class="sitenav"> <a href="../../../index.html">MySite > </a>
    <a href="../../index.html">Python > </a>
    <a href="../index.html">Objects > </a> Classes
  </p>
  <table class="table">
    <caption>
      <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
    </caption>
    <tr>
      <th style="width:30%;"> Attribute / Method </th>
      <th> Description </th>
    </tr>
    <tr>
      <td>
        <strong>class</strong>.__bases__
      </td>
      <td>
        - returns the direct parent classes of this class in a tuple (left-to-right order)
      </td>
    </tr>
    <tr>
      <td>
        <strong>class</strong>.__mro__
      </td>
      <td>
        - returns all parent classes of this class in a tupe, in inheritance lookup order (method resolution order)
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        isinstance(<strong>val:any</strong>, <strong>class</strong>)
      </td>
      <td>
        - returns <mark>True</mark> if <strong>val</strong> appears anywhere in the inheritance chain of
        <strong>class</strong>(es), otherwise returns <mark>False</mark>
      </td>
    </tr>
    <tr>
      <td>
        isinstance(<strong>val:any</strong>, (<strong>class</strong><i>, ...</i>))
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        issubclass(<strong>class_A</strong>, <strong>class_B</strong>)
      </td>
      <td>
        - returns <mark>True</mark> if <strong>class_A</strong> is direct subclass of <strong>class_B</strong><i>,
          ...</i>, otherwise returns <mark>False</mark>
      </td>
    </tr>
    <tr>
      <td>
        issubclass(<strong>class_A</strong>, (<strong>class_B</strong><i>, ...</i>))
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        type(<strong>val:any</strong>)
      </td>
      <td>
        - returns the <strong>val</strong>'s direct parent class
      </td>
    </tr>
    <tr>
      <td>
        <strong>val</strong>.__class__
      </td>
      <td>
        - returns the <strong>val</strong>'s direct parent class
      </td>
    </tr>
  </table>
  <br>
   <h2 class="headerSection"> Description and Demonstration </h2>
  <h2 class="headerSection"> Useful Links : </h2>

  <h2 class="headerSection"> Remember This : </h2>
  <p> - private attributes and methods are NOT PRIVATE, they are just well hidden, we can access them as
    <mark>_<strong>class</strong>__<strong>attr</strong></mark> </p>
  <p> - object instances derived directly from the <mark>object</mark> class cannot have any attributes </p>
  <h2 class="headerSection"> Description and Demonstration : </h2>
  <p> - Python is a class-based programming language where classes can have multiple base classes </p>
  <p> - the <mark>object</mark> class sits on the top of the inheritance chain <u>(instances directly derived from the
      <mark>object</mark> class cannot have attributes)</u> </p>
  <!---------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="header"> Multiple Inheritance <mark>__mro__</mark> / <mark>__bases__</mark> </h2>
  <p> - Python supports multiple inheritance (a class can have multiple base classes) </p>
  <p> - Python uses depth-first left-to-right algorithm when looks up in the class inheritance chain </p>
  <pre>
       G        // class lookup    A -> B -> C -> D -> E -> F -> G -> H -> object
       |        // class A has 3 base classes (B, D, H)
  C  E F        // B, D, H classes are sibling classes to each other 
  |  |/        
  B  D  H
    \|/
     A
    </pre>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    class G:                                                                           // the above class inheritance graph 
        pass
        
    class C:
        pass
    
    class E:
        pass
    
    class F(G):
        pass
    
    class B(C):
        pass
    
    class D(E, F):
        pass
    
    class H:
        pass
    
    class A(B, D, H):
        pass
    
                                                                                       // returns the class lookup path 
    A.__mro__                                                                          // -> (&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.E'&gt;, &lt;class '__main__.F'&gt;, &lt;class '__main__.G'&gt;, &lt;class '__main__.H'&gt;, &lt;class 'object'&gt;)
    C.__mro__                                                                          // -> (&lt;class '__main__.C'&gt;, &lt;class 'object'&gt;)
    D.__mro__                                                                          // -&gt; (&lt;class '__main__.D'&gt;, &lt;class '__main__.E'&gt;, &lt;class '__main__.F'&gt;, &lt;class '__main__.G'&gt;, &lt;class 'object'&gt;)
    
                                                                                       // returns the direct parent classes of this class   
    A.__bases__                                                                        // -> (&lt;class '__main__.B'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.H'&gt;)
    D.__bases__                                                                        // -> (&lt;class '__main__.E'&gt;, &lt;class '__main__.F'&gt;)
    G.__bases__                                                                        // -> (&lt;class 'object'&gt;)
    </pre>
  </details>
  <!---------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="header"> Classes <mark>class</mark> </h2>
  <pre class="syntax">
    import functools
    
    
    class <strong>ClassId_1</strong>:
        <i>docString:str</i>                                                                  // document string (docstring) is readable by <mark><strong>ClassId_1</strong>.__doc__</mark> (used to document the class)
        
        def __init__(self<i>, arg, ...</i>):                                                  // initializes instance attributes and methods 
            self                                                                       // references the instance that will be created (always the 1st argument) 
        
        def __call__(self<i>, arg, ...</i>):                                                  // makes the instance callable (ex: <mark><strong>obj</strong>()</mark>) 
        
        
// public methods and attributes ------------------------------------------------------
        def <strong>methodId</strong>(self, <i>arg, ...</i>):                                                  // owned by this class and accessible by classes and instances on the prototype chain    
            self                                                                       // references the instance that will be created (always the 1st argument) 

        <strong>attrId</strong><i> = val</i>                                                                   // owned by this class and accessible by classes and instances on the prototype chain    
                                                                                          // -! if it holds a mutable data, members who inherit it can modify its value 
    
// class methods ------------------------------------------------------------------
        <em>@classmethod</em>
        def <strong>methodId</strong>(cls, <i>arg, ...</i>):                                                   // (method called on the class directly) owned by this class and accessible by classes and instances on the prototype chain  
            cls                                                                        // references the class in the inheritance chain that calls this method  

        <em>@staticmethod</em>
        def <strong>methodId</strong>(<i>arg, ...</i>):                                                        // same as <mark>@classmethod</mark> but does not get the class as its 1st argument  
    
    
// protected methods and attributes ---------------------------------------------------
        def _<strong>methodId</strong>(self):                                                           // <mark>_</mark> (single underscore) prefixed attributes|methods signify 'protected' method|attribute (used within this class an any of the subclasses) 
        _<strong>attrId</strong><i> = val</i>                                                           // -! this is just a practice these are available publicly   
    
    
// private methods and attributes -----------------------------------------------------
        def __<strong>methodId</strong>(self, <i>arg, ...</i>):                                                // inteded to be used privately, but they are <u>NOT PRIVATE, just well hidden</u> 
        __<strong>attrId</strong><i> = val</i>                                                                 // from outside this class we can access as <mark style="padding:2px;">_<strong>ClassId_1</strong>__<strong>methodId</strong></mark> (ex: <mark style="padding:2px;">TestClass._TestClass__privAttr</mark>) / inside its class accessed as <mark style="padding:2px">self.__<strong>methodId</strong></mark>  
                                                                                       // owned by this class and accessible by classes and instances on the prototype chain 
    
    
// attribute getter / setter / deleter -------------------------------------------------
        <lit>@property</lit>                                                          // attribute getter
        def <reqval>attr_A</reqval>(self):
            return <reqval>attrVal</reqval>
        
        @<reqval>attr_A</reqval>.setter                                               // attribute setter
        def x(self, value):
            // logic to set attirbute <mark>value</mark>
        
        @<reqval>attr_A</reqval>.deleter                                              // attribute deleter
        def x(self):
            // logic to delete attirbute 
    
    
        @functools.<lit id="functools">cached_property</lit>                                        // same as <mark>@property</mark> but caches set value<u>s</u>
        def <reqval>cached_attr</reqval>(self):                                     // doesn't need any setter or deleter methods
            return <reqval>attrVal</reqval>                                         // -! multiple values set are cached <u>so it's not threadsafe! (delete only deletes the most recently set value)</u>
    
    
// singledispatchmethod -------------------------------------------------
        @functools.<lit>singledispatchmethod</lit>                                  // allows different method implementation based on the 1st argument's type
        def <reqval>methodId</reqval>(self, <reqval>arg</reqval>):                                   // default definition we raise a NotImplementedError
            raise NotImplementedError(<i>msg:str</i>)
    
        @<reqval>methodId</reqval>.register                                        // defining a method that will run when the 1st argument is <reqval>pyType</reqval>
        def _(self, <reqval>arg</reqval>: <reqval>pyType</reqval>):
            return <reqval>val</reqval>
        
        <optval>...</optval>
    
    
    
// ------------------------------------------------------------------------------------
// sub-class --------------------------------------------------------------------------
    class <strong>ClassId_2</strong><small>(<i>ClassId_1, ...</i>)</small>:                                                   // multiple base classes can be passed    
        <em>def __init__(self, <i>arg, ...</i>):</em>
            super().__init__(<i>arg, ...</i>)                                                 // this is how we call the super object initialization    
        
        <em>def <strong>methodId</strong>(self):</em>
                                                                                                        
            super().<strong>attr|method</strong>                                                        // <span class="browserSupport" style="color:yellow;" title="Updated: 2022-03-19"> <span><i class="fab fa-python"></i> 3.0 </span></span> references the <u>first-found</u> class attribute|method in the inheritance chain 
                                                                                                        
            super(<strong>ClassId_2</strong>, self).<strong>attr|method</strong>                                         // <span class="browserSupport" style="color:yellow;" title="Updated: 2022-03-19"> <span><i class="fab fa-python"></i> 2.7 </span></span> references the <u>first-found</u> class attribute|method in the inheritance chain 
    </pre>
  <pre class="syntax">
    <strong>class</strong>.<strong>attr = val</strong>                                                                   // set the attributes on the class   
      
    <strong>class</strong>.__doc__                                                                      // returns the class's docstring (<i>docString</i>)     
    
    del <strong>class</strong>.<strong>method|attr</strong>                                                              // deletes the specified class method or attribute   
    
    <strong>class</strong>.<strong>someMethod</strong>(<strong>obj</strong>, <i>arg, ...</i>)                                                    // same as calling <mark><strong>obj</strong>.<strong>someMethod</strong>(<i>arg, ...</i>)</mark>   
    </pre>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    class B():
        def __init__(self, a):
            self.a = a
        
    class A(B):
        def __init__(self, a, b):
            super().__init__(a)                                                        // references the super initializator function with an argument   
            self.b = b
    
    obj = A('a', 'b')                                                                  // creates an object 
    obj.__dict__                                                                       // -> {'a': 'a', 'b': 'b'}
    </pre>
    <hr>
    <!-------------------------------------------------------------------------------------------->
    <h4 class="header"> setting class attributes on existing class </h4>
    <pre>
    class TestClass:
        pass
        
    def method(self):
        return 'method-val'
        
    def privMethod(self):
        return 'priv-method-val'
    
    TestClass.attr = 'attr-val'                                                        // setting attributes on existing classes is allowed   
    TestClass.method = method
    TestClass._TestClass__privAttr = 'priv-attr-val'
    TestClass._TestClass__privMethod = privMethod
    
    obj = TestClass()
    
    obj.attr                                                                           // -> 'attr-val'
    obj.method()                                                                       // -> 'method-val'
    obj._TestClass__privAttr                                                           // -> 'priv-attr-val'
    obj._TestClass__privMethod()                                                       // -> 'priv-method-val'
    
    TestClass.__dict__["newAttr"] = 'new-val'                                          // -! TypeError        // setting class attributes through mappingproxy is not allowed  
    </pre>
    <hr>
    <!-------------------------------------------------------------------------------------------->
    <h4 class="header"> method and attribute inheritance </h4>
    <pre>
    class B():
        attr1 = 'val'                                                                  // attributes owned by this class an present in the inheritance chain 
        attr2 = [1, 2]                                                                   // -! carerul mutable data can be modified by those who inherit it 
        
        def method(self):                                                              // method owned by this class and present in the inheritance chain 
            return 'method-val'
        
    class A(B):
        pass
    
    
    obj = A()
    
    A.attr1                                                                            // -> 'val'            // inherited by all subclasses 
    A.method(obj)                                                                      // -> 'method-val'
    obj.attr1                                                                          // -> 'val'            // inherited by all instance 
    obj.method()                                                                       // -> 'method-val
    
    obj.attr2.append(3)                                                                // -! inherited mutable data can be modified 
    B.attr2                                                                            // -> [1, 2, 3]  
    
    obj.__dict__                                                                       // -> {}
    obj.attr1 = 'new-val'                                                              // object creates its own attribute (does not set the inherited data)   
    obj.__dict__                                                                       // -> {'attr1': 'new-val'}  
    A.attr1                                                                            // -> 'val;            // inheritable data not modified
    </pre>
    <hr>
    <!-------------------------------------------------------------------------------------------->
    <h4 class="header"> <mark>@classmethod</mark> / <mark>@staticmethod</mark> </h4>
    <pre>
    class B:
        @classmethod
        def clsMethod(cls, a):                                                         // called on this or on any sub-classes 
            cls                                                                        // -> class B  | class A   // references the class that calls this method    
            return a
        
        @staticmethod
        def stMethod(a):                                                               // does the same as <mark>@classmethod</mark>, but does not have the class as its 1st argument    
            return a
    
    class A(B):
        pass
    
    
     B.clsMethod('x')                                                                  // -> 'x'
     B.stMethod('x')                                                                   // -> 'x'
    
     A.clsMethod('x')                                                                  // -> 'x'              // inherited from the super class   
    </pre>
    <hr>
    <!-------------------------------------------------------------------------------------------->
    <h4 class="header"> private methods and attributes </h4>
    <pre>
    class B:
        __privateAttr = 'privAttr-val' 
        
        def __privateMethod(self): 
            return 'privMethod-val'
        
        def getPrivates(self):
            self.__privateAttr                                                         // -> 'privAttr-val'     // accessed as normal attributes from inside their class   
            self.__privateMethod()                                                     // -> 'privAttr-val'
    
    class A(B):
        pass
    
    obj = A()
    
    
    B._B__privateAttr                                                                  // accessing private attribute or method ouside their clas   
    A._B__privateAttr       
    obj._B__privateAttr     
    
    B._B__privateAttr = 'new-privAttr-val'                                             // we can set privates like this (as expetect)    
    obj._B__privateAttr                                                                // -> 'new-privAttr-val'   
    
    B.__privateAttr                                                                    // -! AttributeError    // privates are not accessible 'in the normal way'   
    A.__privateAttr                                                                    // -! AttributeError 
    obj.__privateAttr                                                                  // -! AttributeError
    </pre>
    <hr>
    <!-------------------------------------------------------------------------------------------->
    <h4 class="header"> <mark>super()</mark> </h4>
    <pre>
    class C:
        def someMethod(self):                                                          // never reached (there's a <mark>someMethod</mark> method closer to the caller)    
            return 'class-C method'
        
        someAttr = 'class-C attr'
        
    class B:
        def someMethod(self):
            return 'class-B method'
    
    class A(B, C):
        def getSupers(self):
            super().someMethod()                                                       // -> 'class-B method'     // references the first-found super class method 
            super().someAttr                                                           // -> 'class-C attr'       // references the first-found super class attribute    
    
    obj = A()
    obj.getSupers()
    
    A.__mro__                                                                          // -> (&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class 'object'&gt;)   // inheritance chain order  
    </pre>
    <hr>
    <!-------------------------------------------------------------------------------------------->
    <h4 class="header"> <mark>__doc__</mark> / <mark>del</mark> / calling method on the class </h4>
    <pre>
    class A:
        'some class description'
        
        attr = 'someAttrVal'
        
        def method(self, a):
            return a
    
// docstring --------------------------------------------------------------------------
    A.__doc__                                                                          // -> 'some class description'   
    
    
// calling method on the class --------------------------------------------------------
    obj = A()
    
    obj.method('x')                                                                    // -> 'x'
    A.method(obj, 'x')                                                                 // -> 'x'    // does the same as above 
    
// deleteting class attributes and methods --------------------------------------------
    hasattr(A, 'attr')                                                                 // -> True 
    hasattr(A, 'method')                                                               // -> True 
    
    del A.attr                                                                         // deletes the class attribute  
    del A.method                                                                       // deletes the class method   
    
    hasattr(A, 'attr')                                                                 // -> False 
    hasattr(A, 'method')                                                               // -> False 
    </pre>
    <hr>
    <!-------------------------------------------------------------------------------------------->
    <h4 class="header"> Creating callable instances </h4>
    <pre>
    class MyClass:
        def __init__(self, a, b):
            self.a = a
            self.b = b
    
        def __call__(self):
            return 'my object was called!'
    
    
    obj = MyClass(1, 2)
    obj()                    // -> 'my object was called!"
    </pre>
    <hr>
    <!-------------------------------------------------------------------------------------------->
    <h4 class="header"> Attribute getter / setter / deleter (<mark>@property</mark>) </h4>
    <pre>
    class SomeClass:
        def __init__(self):
            self._x = None
    
        @property
        def x(self):
            return self._x
    
        @x.setter
        def x(self, value):
            self._x = value
    
        @x.deleter
        def x(self):
            del self._x
    
    
    some_obj = SomeClass()
    
    some_obj.x                        // -> None
    
    some_obj.x = 'some value'
    some_obj.x                        // -> 'some value'
    
    del some_obj.x
    some_obj.x                        // -> AttributeError
    </pre>
    <hr>
    <!-------------------------------------------------------------------------------------------->
    <h4 class="header"> Cached property (<mark>@cached_property</mark>) </h4>
    <pre>
    import functools
    
    
    class Person:
        def __init__(self, name, surname):
            self.name = name
            self.surname = surname
    
        @property
        def full_name(self):
            return self.name + " " + self.surname
    
        @functools.cached_property                      # cached property
        def full_name_flipped(self):
            return self.surname + " " + self.name
    
    
    peti = Person('Peter', 'Pall')
    
    // @property ------------------
    peti.full_name                        // -> Peter Pall (regular @property decorator)
    peti.full_name = "Peter Bela"         // AttributeError (because no setter attirubte configured)
    del peti.full_name                    // AttributeError (because no deleter attirubte configured)
    
    
    // @cached_property -----------
    peti.full_name_flipped                    // -> Pall Peter (cached attribute is not recomputed )
    peti.full_name_flipped 
    
    peti.full_name_flipped = "Pall Bela"      // cached property don't need setter 
    peti.full_name_flipped                    // -> "Pall Bela"
    
    del peti.full_name_flipped                // -! cached property don't need any deleter however this deletes the latest set (cached) value 
    peti.full_name_flipped                    // -> "Pall Peter" (previously cached value)
    del peti.full_name_flipped                // -! deletes the latest cached value 
    peti.full_name_flipped                    // raises an Attribute Error (all caches are deleted)
    </pre>
    <hr>
    <!-------------------------------------------------------------------------------------------->
    <h4 class="header"> Singledispatchmethod (<mark>@singledispatchmethod</mark>) </h4>
    <pre>
    import functools
    
    class Negator:
        @functools.singledispatchmethod
        def neg(self, arg):
            raise NotImplementedError(f"Cannot negate {arg}, supported types: int | bool")
    
        @neg.register
        def _(self, arg: int):
            return -arg
    
        @neg.register
        def _(self, arg: bool):
            return not arg
    
    
    negator = Negator()
    
    negator.neg('test')                   // -> NotImplementedError
    negator.neg(324)                      // -> -324
    negator.neg(False)                    // -> -True
    </pre>
  </details>
  <!---------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="header"> The <mark>isinstance()</mark> / <mark>issubclass()</mark> / <mark>type()</mark> /
    <mark>__class__</mark> methods and attribute </h2>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    class D:
        pass
        
    class C:
        pass
        
    class B:
        pass
        
    class A(B, C):
        pass
        
    obj = A()
    
// isinstance() -----------------------------------------------------------------------
    isinstance(obj, A)                                                                 // -> True           // object appears anywere on the inheritance chain of class A  
    isinstance(obj, object)                                                            // -> True
    isinstance(obj, D)                                                                 // -> False
    
    isinstance(obj, (A, B, C, D))                                                      // -> Ture           // object appears anywere on the inheritance chain of one of the listed classes 
    
    
// issubclass() -----------------------------------------------------------------------
    isubclass(A, B)                                                                    // -> True           // class A is direct subclass of class B  
    issubclass(A, C)                                                                   // -> True
    issubclass(C, A)                                                                   // -> False
    
    issubclass(D, (A, B, C))                                                           // -> False          // class D is not subclass of any of the listed classes   
    
    
// type() / __class__ -----------------------------------------------------------------
    type(obj)                                                                          // -> class A        // returns the instance's class 
    obj.__class__                                                                      // -> class A
    </pre>
  </details>


  <br><br>
</body>

</html>