<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title> Collections (Arrays) </title>
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css"
    integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <link rel="stylesheet" href="../../Assets/stylesPages.css">
  <script src="../../Assets/scriptPages.js"></script>
</head>

<body>
  <h1> Collections </h1>
  <p> Updated (2022-02-21)</p>
  <nav class="sitenav"> <a href="../../index.html">MySite > </a>
    <a href="../index.html">Python > </a> Collections (Arrays)
  </nav>
  <table class="table">
    <tr>
      <th style="width:20%;"> Collection Type </th>
      <th style="width:20%;"> Ordered </th>
      <th style="width:20%;"> Changable </th>
      <th style="width:20%;"> Allow Duplicate members </th>
      <th style="width:20%;"> Hashable members Only </th>
    </tr>
    <tr>
      <td> List </td>
      <td> yes </td>
      <td> yes </td>
      <td> yes </td>
      <td> no </td>
    </tr>
    <tr>
      <td> Tuple </td>
      <td> yes </td>
      <td> no </td>
      <td> yes </td>
      <td> no </td>
    </tr>
    <tr>
      <td> Set </td>
      <td> no </td>
      <td> no (existing members cannot be changed but we can add/remove members) </td>
      <td> no </td>
      <td> yes </td>
    </tr>
    <tr>
      <td> FrozenSet </td>
      <td> no </td>
      <td> no </td>
      <td> no </td>
      <td> yes </td>
    </tr>
    <tr>
      <td> Dictionary </td>
      <td> from Python v3.7 </td>
      <td> yes </td>
      <td> no </td>
      <td> yes (keys, but not their values) </td>
    </tr>
  </table>
  <br>
  <table class="table">
    <caption>
      Global Function
    </caption>
    <tr>
      <th style="width:30%;"> Function </th>
      <th> Description </th>
    </tr>
    <tr>
      <td>
        sorted(<strong>iterable</strong>, <small class="openable">key=<i>fn</i>
          <div>
            <p> Default: <mark>None</mark> </p>
            <p> - function takes 1 argument which is the current memeber </p>
            <p> - this function basically recompute the current member before sort <u>(can return a tuple with multiple values for group sort)</u> </p>
    </pre>
          </div>
        </small>, <small class="openable">reverse=<i>bol</i>
          <div>
            <p> Default: <mark>False</mark> </p>
            <p> - sorts the list in descending order </p>
          </div>
        </small>)
      </td>
      <td>
        - sorts the passed <strong>iterable</strong>'s items and returns the result in a new list (does not modify the passed <strong>iterable</strong>) <br>
        - cannot sort iterables containing mixed data types, (ex: when the list contains stirngs and numbers = raises an error) <br>
        - strings are sorted according to character unicode points
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        all(<strong>iterable</strong>)
      </td>
      <td>
        - returns <mark>True</mark> if all <strong>iterable</strong> members are truthy, returns <mark>False</mark> otherwise
      </td>
    </tr>
    <tr>
      <td>
        filter(<strong>fn</strong>, <strong>iterable</strong>)
      </td>
      <td>
        - returns an <strong>iterator</strong> object containing the items for which the passed <strong>fn</strong> returned <mark>True</mark>
      </td>
    </tr>
    <tr id="map">
        <td>
            map(<strong>fn</strong>, <strong>iterableArg1</strong>, <i>iterableArg2, ...</i>)
        </td>
        <td>
            - runs the passed function for each item in the iterable(s)<br>
            - returns the result in a <strong>genObj</strong> (generator object)
        </td>
    </tr>
  </table>
  <br>
  <table class="table">
    <caption>
      List
    </caption>
    <tr>
      <th style="width:30%;"> Methods </th>
      <th> Description </th>
    </tr>
    <tr>
      <td>
        <strong>list</strong>.append(<strong>val:any</strong>)
      </td>
      <td>
        - appends the specified <strong>item</strong> at the end of the original <strong>list</strong> (returns
        <mark>None</mark>)
      </td>
    </tr>
    <tr>
      <td>
        <strong>list</strong>.extend(<strong>iterable</strong>)
      </td>
      <td>
        - appends <strong>iterable</strong>'s items at the end of the original <strong>list</strong>
      </td>
    </tr>
    <tr>
      <td>
        <strong>list</strong>.insert(<strong>idx(inc):int</strong>, <strong>val:any</strong>)
      </td>
      <td>
        - inserts the <strong>item</strong> at the specified index position in the original <strong>list</strong>
        (stretches the list size +1)
      </td>
    </tr>
    <tr>
      <td>
        <strong>list</strong>.copy()
      </td>
      <td>
        - creates and returns a new list (creates a completely new object)
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>list</strong>.index(<strong>val:any</strong>, <i>stIdx(inc):int</i>, <i>endIdx(exc):int</i>)
      </td>
      <td>
        - searches for the <strong>val</strong> in the list and returns the first found item's index in the list,
        <u>raises a <mark>ValueError</mark> if the item is not found</u> <br>
        - optionally we can specify a search index range (<i>stIdx(inc) - endIdx(exc)</i>)
      </td>
    </tr>
    <tr>
      <td>
        <strong>list</strong>.count(<strong>val:any</strong>)
      </td>
      <td>
        - returns how many times the <strong>val</strong> appears in the list
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>list</strong>.pop(<i>idx:int</i>)
      </td>
      <td>
        - removes and returns the last (or the indexed) list item from the list (does not leave a 'hole' = shrinks the
        list)
      </td>
    </tr>
    <tr>
      <td>
        <strong>list</strong>.remove(<strong>val:any</strong>)
      </td>
      <td>
        - removes the first found <strong>val</strong> from the list, <u>raises a <mark>ValueError</mark> if the item is
          not found</u> (does not leave a 'hole' = shrinks the list) (returns <mark>None</mark>)
      </td>
    </tr>
    <tr>
      <td>
        <strong>list</strong>.clear()
      </td>
      <td>
        - completely empties the list (returns <mark>None</mark>)
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>list</strong>.sort(<small class="openable">key=<i>fn</i>
          <div>
            <p> Default: <mark>None</mark> </p>
            <p> - function takes 1 argument and must return a number </p>
            <p> - the returned number is bound to the checked item, then the sort order is defined according to the
              bound numbers order </p>
            <p> ex: </p>
            <pre>
    someList = ['xxxx', 'x', 'xx']
    someList.sort(key=len)      // the len global function returns the length for each element 
                                // len('xxxx') -> 4  |  len('x') -> 1  |  len('xx') -> 2
                                // the sort order is defined by the returned numbers -> 1 | 2 | 4
    
    someList                    // -> ['x', 'xx', 'xxxx']
    </pre>
          </div>
        </small>, <small class="openable">reverse=<i>bol</i>
          <div>
            <p> Default: <mark>False</mark> </p>
            <p> - sorts the list in descending order </p>
          </div>
        </small>)
      </td>
      <td>
        - sort list items in place in ascending order (returns <mark>None</mark>) <br>
        - cannot sort list containing mixed data types, (ex: when the list contains stirngs and numbers = raises an
        error) <br>
        - strings are sorted based on ASCII translation order <br>
      </td>
    </tr>
    <tr>
      <td>
        <strong>list</strong>.reverse()
      </td>
      <td>
        - simply reverses the list order in place (returns <mark>None</mark>)
      </td>
    </tr>
  </table>
  <br>
  <table class="table">
    <caption>
      Tuple
    </caption>
    <tr>
      <th style="width:30%;"> Methods </th>
      <th> Description </th>
    </tr>
    <tr>
      <td>
        <strong>tuple</strong>.count(<strong>val:any</strong>)
      </td>
      <td>
        - returns how many times the <strong>val</strong> appears in the tuple
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>tuple</strong>.index(<strong>val:any</strong>, <i>stIdx(inc):int</i>, <i>endIdx(exc):int</i>)
      </td>
      <td>
        - searches for the <strong>val</strong> in the tuple and returns the first found item's index in the tuple,
        <u>raises a <mark>ValueError</mark> if the item is not found</u> <br>
        - optionally we can specify a search index range (<i>stIdx(inc) - endIdx(exc)</i>)
      </td>
    </tr>
  </table>
  <br>
  <table class="table">
    <caption>
      Set / Frozenset
    </caption>
    <tr>
      <th style="width:30%;"> Methods </th>
      <th> Description </th>
    </tr>
    <tr>
      <td>
        <strong>set</strong>.add(<strong>val:any</strong>)
      </td>
      <td>
        - adds a new value to the set
      </td>
    </tr>
    <tr>
      <td>
        <strong>set</strong>.update(<strong>iterable</strong>)
      </td>
      <td>
        - adds the <strong>iterable</strong>'s items to the set
      </td>
    </tr>
    <tr>
      <td>
        <strong>set|frozenset</strong>.copy(<strong>iterable</strong>)
      </td>
      <td>
        - creates and returns a new set|frozenset (creates a completely new object)
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>set</strong>.pop()
      </td>
      <td>
        - removes and returns an arbitary member from the set (we never know which one)
      </td>
    </tr>
    <tr>
      <td>
        <strong>set</strong>.remove(<strong>val:any</strong>)
      </td>
      <td>
        - removes the specified member (<strong>val</strong>) from the set (returns <mark>None</mark>), <u>raises a
          ValueError if the item does not exist in the set</u>
      </td>
    </tr>
    <tr>
      <td>
        <strong>set</strong>.discard(<strong>val:any</strong>)
      </td>
      <td>
        - removes the specified member (<strong>val</strong>) from the set (returns <mark>None</mark>), <u>does nothing
          if the item does not exist in the set</u>
      </td>
    </tr>
    <tr>
      <td>
        <strong>set</strong>.clear()
      </td>
      <td>
        - completely empties the set (returns <mark>None</mark>)
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td colspan="2">
        Math Methods
      </td>
    </tr>
    <tr>
      <td>
        <strong>set|frozenset</strong>.union(<strong>list|tuple|set|frozenset|dict</strong>)
      </td>
      <td>
        - unifies all members from both sides in a new <strong>set|frozenset</strong> and returns it (does not modify
        original objects)
      </td>
    </tr>
    <tr>
      <td>
        <strong>set1|frozenset1</strong> | <strong>set2|frozenset2</strong>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>set|frozenset</strong>.intersection(<strong>list|tuple|set|frozenset|dict</strong>)
      </td>
      <td>
        - only members that are present in both sides are returned in a new <strong>set|frozenset</strong> (does not
        modify original objects)
      </td>
    </tr>
    </tr>
    <tr>
      <td>
        <strong>set1|frozenset1</strong> & <strong>set2|frozenset2</strong>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <strong>set</strong>.intersection_update(<strong>list|tuple|set|frozenset|dict</strong>)
      </td>
      <td>
        - only members that are present in both sides are collected and returned in the original <strong>set</strong>
        (modifies the original <strong>set</strong>) (returns <mark>None</mark>)
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>set|frozenset</strong>.difference(<strong>list|tuple|set|frozenset|dict</strong>)
      </td>
      <td>
        - members that are present only in left side are returned in a new <strong>set|frozenset</strong> (does not
        modify original objects)
      </td>
    </tr>
    </tr>
    <tr>
      <td>
        <strong>set1|frozenset1</strong> - <strong>set2|frozenset2</strong>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <strong>set</strong>.difference_update(<strong>list|tuple|set|frozenset|dict</strong>)
      </td>
      <td>
        - members that are present only in left side are collected and returned in the original <strong>set</strong>
        (modifies the original <strong>set</strong>) (returns <mark>None</mark>)
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>set|frozenset</strong>.symmetric_difference(<strong>list|tuple|set|frozenset|dict</strong>)
      </td>
      <td>
        - members that are not present in both sides are returned in a new <strong>set|frozenset</strong> (does not
        modify original objects)
      </td>
    </tr>
    </tr>
    <tr>
      <td>
        <strong>set1|frozenset1</strong> ^ <strong>set2|frozenset2</strong>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <strong>set</strong>.symmetric_difference_update(<strong>list|tuple|set|frozenset|dict</strong>)
      </td>
      <td>
        - members that are not present in both sides are collected and returned in the original <strong>set</strong>
        (modifies the original <strong>set</strong>) (returns <mark>None</mark>)
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>set|frozenset</strong>.isdisjoint(<strong>list|tuple|set|frozenset</strong>)
      </td>
      <td>
        - returns <mark>True</mark> if left and right side have no common members, returns <mark>False</mark> if the
        sides have any common members
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>set|frozenset</strong>.issubset(<strong>list|tuple|set|frozenset</strong>)
      </td>
      <td>
        - returns <mark>True</mark> if all left side members are present in the right side, returns <mark>False</mark>
        if not all left side members are present in the right side <br>
        - the <mark>&lt;</mark> operator also returns <mark>False</mark> if the sides have the same members (ex:
        <mark>{1} &lt; {1}</mark> returns <mark>False</mark>)
      </td>
    </tr>
    </tr>
    <tr>
      <td>
        <strong>set1|frozenset1</strong> &lt;= <strong>set2|frozenset2</strong>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <strong>set1|frozenset1</strong> &lt; <strong>set2|frozenset2</strong>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>set|frozenset</strong>.issuperset(<strong>list|tuple|set|frozenset</strong>)
      </td>
      <td>
        - returns <mark>True</mark> if all right side members are present in the left side, returns <mark>False</mark>
        if not all right side members are present in the left side <br>
        - the <mark>&gt;</mark> operator also returns <mark>False</mark> if the sides have the same members (ex:
        <mark>{1} &gt; {1}</mark> returns <mark>False</mark>)
      </td>
    </tr>
    </tr>
    <tr>
      <td>
        <strong>set1|frozenset1</strong> &gt;= <strong>set2|frozenset2</strong>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <td>
        <strong>set1|frozenset1</strong> &gt; <strong>set2|frozenset2</strong>
      </td>
      <td>
      </td>
    </tr>
  </table>
  <br>
  <table class="table">
    <caption>
      Dictionary
    </caption>
    <tr>
      <th style="width:30%;"> Methods </th>
      <th> Description </th>
    </tr>
    <tr>
      <td>
        <em>dict</em>.fromkeys(<strong>iterable</strong>, <strong>val:any</strong>)
      </td>
      <td>
        - creates and returns a new dictionary where the <strong>iteralbe</strong>'s members will be the keys and the
        2nd argument (<strong>val</strong>) will be the value for each key
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <reqval>dict_1</reqval> | <reqval>dict_2</reqval>
      </td>
      <td>
        - merges dictionaries together (<reqval>dict_2</reqval> overrides <reqval>dict_1</reqval> key/value pairs) <br>
        - returns a new merged <reqval>dict</reqval> 
        <span id="browserSupport">
          <span><i class="fab fa-python"></i> 3.9 </span>
        </span>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>dict</strong>.get(<strong>key</strong>, <i>defVal:any</i>)
      </td>
      <td>
        - if <strong>key</strong> exist returns the key's value <br>
        - if <strong>key</strong> does not exist returns the default value (<i>defVal</i>, <mark>None</mark> by default)
      </td>
    </tr>
    <tr>
      <td>
        <strong>dict</strong>.setdefault(<strong>key:hashable</strong>, <i class="openable">val:any<div>
            <p> Default: <mark>None</mark> </p>
          </div></i>)
      </td>
      <td>
        - if the <strong>key</strong> does not exist in the dictionary -> sets the <strong>key/val</strong> pair to the
        dictionary (returns <i>val</i>) <br>
        - if the <strong>key</strong> exist in the dictionary -> does nothing (returns the value the
        <strong>key</strong> currently holds in the dictionary)
      </td>
    </tr>
    <tr>
      <td>
        <strong>dict</strong>.update(<strong class="openable">dict|iterableKeyVal<div>
            <p> a dictionary or an iterable with key/value structure (ex: <mark>[['key1', 1], ['key2', 2]]</mark>) </p>
          </div></strong>)
      </td>
      <td>
        - adds or updates key/value members according to the passed <strong>dict|iterableKeyVal</strong> 
      </td>
    </tr>
    <tr>
      <td>
        <strong>dict</strong>.copy()
      </td>
      <td>
        - creates and returns a new dictionary (creates a completely new object)
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>dict</strong>.keys()
      </td>
      <td>
        - returns an <strong>genObj</strong> which provides the dictionary's keys<br>
        - provides a direct view to the dictionary's items <u>(can get, but cannot mutate items)</u>
      </td>
    </tr>
    <tr>
      <td>
        <strong>dict</strong>.values()
      </td>
      <td>
        - returns an <strong>genObj</strong> which provides the dictionary's values<br>
        - provides a direct view to the dictionary's items <u>(can get, but cannot mutate items)</u>
      </td>
    </tr>
    <tr>
      <td>
        <strong>dict</strong>.items()
      </td>
      <td>
        - returns an <strong>genObj</strong> which provides the dictionary's key/value pairs in tuples (<mark>(<strong>key</strong>, <strong>val</strong>)</mark>)<br>
        - provides a direct view to the dictionary's items <u>(can get, but cannot mutate items)</u>
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>dict</strong>.pop(<strong>key</strong>, <i>defVal:any</i>)
      </td>
      <td>
        - removes the specified key from the dictionary and returns the value of the removed key <br>
        - if the dictionary does not have the specified key -> returns <i>defVal</i> (default value) <br>
        - if the dictionary does not have the specified key and this method has not <i>defVal</i> (default value)
        specified <u>raises a KeyError</u>
      </td>
    </tr>
    <tr>
      <td>
        <strong>dict</strong>.popitem()
      </td>
      <td>
        - removes and returns in a tuple the last key/value pair from the dictionary <u>(raises a KeyError if the
          dictionary is empty)</u> <br>
        - before v3.7 this method returns a random member
      </td>
    </tr>
    <tr>
      <td>
        <strong>dict</strong>.clear()
      </td>
      <td>
        - completely empties the dictionary (returns <mark>None</mark>)
      </td>
    </tr>
  </table>
  <br>
  <details class="example" id="notes">
    <summary> Notes :</summary>
    <!-- <p> - paragraph removes the 'empty' message from the detail TAG -->
  </details>
  <h2 style="color:green;"><u> Useful Links : </u></h2>
  <p><a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" target="_blank">list()
      (docs.python.org)</a></p>
  <p><a href="https://docs.python.org/3/library/stdtypes.html#set" target="_blank">set() and frozenset()
      (docs.python.org)</a></p>
  <p><a href="https://docs.python.org/3/library/stdtypes.html#dict" target="_blank">dict() (docs.python.org) </a></p>
  <h2 style="color:green;"><u> Remember This : </u></h2>

  <h2 style="color:green;"><u> Description and Demonstration : </u></h2>
  <p> - all Python Collection types are <u>iterable</u> </p>
  <h2 class="header"> Accessing and Slicing Collection (Iterable) Members </h2>
  <p><u> - slicing creates a <u>shallow copy</u> </u></p>
  <pre class="syntax">
// dictionary --------------------------------------------------------------
    <strong>dict</strong>[<strong>key</strong>]                                                                          // returns the dictionary key value <u>(raises a KeyError if the key does not exist)</u>
    <strong>dict</strong>.get(<strong>key</strong>)                                                                      // returns the dictionary key value (returns <mark>None</mark> if the key does not exist)   
    
    import itertools                                <span id="browserSupport" style="color:yellow;"> <span><i class="fab fa-python"></i> 3.0 </span></span>
    dict(itertools.islice(<strong>dict</strong>.items(), <strong class="openable">stIdx(inc), endIdx(exc)<div>
    <pre>
    my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5}
    
    dict(itertools.islice(my_dict.items(), 1, 4))       {'two': 2, 'three': 3, 'four': 4}
    dict(itertools.islice(my_dict.items(), 2))          {'one': 1, 'two': 2}
    dict(itertools.islice(my_dict.items(), 2, None))    {'three': 3, 'four': 4, 'five': 5}
    </pre>
    </div></strong>))                     // returns a new dictionary of the specified range
    
    
// iterable (this syntax will work on every <strong>itarable</strong>) having solo members -
    <strong>iterable</strong>[<strong>idx</strong>]                                                                      // returns the item at the specified index 
    <strong>iterable</strong>[-<strong>idx</strong>]                                                                     // negative indexes are counted from end to start (<mark>-1</mark> = last member)    
    
    <strong>iterable</strong>[<i>stIdx(inc)</i>:<i>endIdx(exc)</i><small>:</small><i class="openable">step:int<div>
        <p> - takes every nth element from the sliced part </p>
    </div></i>]                                         // returns the specified range in a new <strong>iterable</strong> (omitting <i>idx</i> = from the start|to the end)   
    <strong>iterable</strong>[<i>-endIdx(exc)</i>:<i>-stIdx(inc)</i><small>:</small><i class="openable">-step:int<div>
        <p> - takes every nth element from the sliced part </p>
        <p> - using <mark>[::-1]</mark> reverses the list (awesome) </p>
    </div></i>]                                      // negative indexes are counted from end to start (<mark>-1</mark> = last member)    
    
    <strong>set</strong>                                                                                <span style="color:orange;">// sets are iterable (we can iterate over with <mark>for</mark> loop)</span>, but not indexed -> <mark><strong>set[<strong>idx</strong>]</strong></mark> <mark><strong>set[<strong>idx</strong>:<strong>idx</strong>]</strong></mark> throws an error    
    </pre>
  <details class="example">
    <summary> DEMO </summary>
    <h4 class="header"> Dictionary </h4>
    <pre>
    import itertools
    
    
    myDict = {'key1':1, 'key2':2, 'key3':3}
    
    myDict['key3']                                                                     // -> 3
    myDict['key4']                                                                     // -! raises a KeyError because the 'key4' does not exist in the dictionary  
    
    myDict.get('key3')                                                                 // -> 3
    myDict.get('key4')                                                                 // -> None  
    
    
// slice dictionary technique ---------------------------------------------------------
    my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5}
    
    dict(itertools.islice(my_dict.items(), 1, 4))                                       // -> {'two': 2, 'three': 3, 'four': 4}
    dict(itertools.islice(my_dict.items(), 2))                                          // -> {'one': 1, 'two': 2}
    dict(itertools.islice(my_dict.items(), 2, None))                                    // -> {'three': 3, 'four': 4, 'five': 5}    
    </pre>
    <h4 class="header"> Iterables with solo members </h4>
    <pre>
// set --------------------------------------------------------------------------------
    mySet = {1, 2, 3}
    
    for i in mySet:
        i                                                                              // -> 1  |  2  |  3
    
    mySet[0]                                                                           // -! raises a TypeError because sets are not indexed   
    
    
// iterables --------------------------------------------------------------------------
    myList = [1, 2, 3, 4, 5]
    myTuple = (1, 2, 3, 4, 5)
    
    newList = myList[:]                                                                 // slicing creates a new object    
    newList[0] = 'replaced'
    myList                                                                              // -> [1, 2, 3, 4, 5]       // original not modified    
    newList                                                                             // -> ['replaced', 2, 3, 4, 5]
    
    myList[1]                                                                           // -> 2           // returns the indexed member    
    myTuple[1]                                                                          // -> 2
    
    myList[-1]                                                                          // -> 5           // element order is counted (not indexed) from the back when using negative indexing 
    myTuple[-2]                                                                         // -> 4
    
    myList[1: 4]                                                                        // -> [2, 3, 4]   // returns the indexed range in a new list|tuple 
    myTuple[1: 4]                                                                       // -> (2, 3, 4)
    
    myList[:2]                                                                          // -> [1, 2]      // range is start to 2nd index excluded   
    myTuple[2:]                                                                         // -> (3, 4, 5)   // range is 2nd index included to the end  
    
    myList[-3:-1]                                                                       // -> [3, 4]      // indexing from the end   
    myTuple[-3:-1]                                                                      // -> (3, 4)
    
    myList[:-2]                                                                         // -> [1, 2, 3]   // from start to end index 2 (excluded)    
    myTuple[-2:]                                                                        // -> (4, 5)      // from end index 2 (indcluded) to the end   
    
  // step ------------------------------------------------------------
    l = [1, 4, 2, 11, 0, 7]
    l[::2]                                                                              // -> [1, 2, 0]   // takes every 2nd element 
    l[:3:2]                                                                             // -> [1, 2]      // slices from <mark>0</mark> to <mark>3</mark> index and takes every 2nd element from the sliced part 
    
    l[::-1]                                                                             // -> [1, 4, 2, 11, 0, 7] // reverses the list   
    l[::-2]                                                                             // -> [7, 11, 4]  // negative slice means slicing from end to start    
    
    l[-1:-4:-1]                                                                         // -> [7, 0, 11]  // -! if the step is negative all slicing must be indexed with negative indexes    
    l[-1:-4:-2]                                                                         // -> [7, 0]
    </pre>
  </details>
  <hr>
  <!-------------------------------------------------------------------------------------------->
  <h2 class="header"> Unpacking </h2>
  <p> - we can assign collection members to variables with unpacking </p>
  <pre class="syntax">
    <strong>var</strong><i>, ...</i><small class="openable">[, *<i>rest</i><div>
        <p> - additional values are collected in <i>var</i> list </p>
    </div>]</small> = <strong>collection</strong>                                                    // members are assigned to variables in the sequence (for <strong>dict</strong> keys are unpacked)
    </pre>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    a, b, *rest = [1, 2, 3, 4]
    a                                                                                  // -> 1
    b                                                                                  // -> 2
    rest                                                                               // -> [3, 4]
    
    a, b, *rest = (1, 2, 3, 4)
    a                                                                                  // -> 1
    b                                                                                  // -> 2
    rest                                                                               // -> [3, 4]
    
    a, b, *rest = {1, 2, 3, 4}                                                         // -! sets can be unpacked but the order is random   
    a                                                                                  // -> 3
    b                                                                                  // -> 1
    rest                                                                               // -> [2, 4]
    
    a, b, *rest = {'p1':1, 'p2':2, 'p3':3, 'p4':4}                                     // unpacks only keys  
    a                                                                                  // -> 'p1'
    b                                                                                  // -> 'p2'
    rest                                                                               // -> ['p3', 'p4']
    </pre>
  </details>
  <hr>
  <!-------------------------------------------------------------------------------------------->
  <h2 class="header"> The <mark>sorted()</mark> / <mark>all()</mark> / <mark>map()</mark> global functions </h2>
  <details class="example">
  <summary> DEMO </summary>
    <pre>
// sorted() ---------------------------------------------------------------------------
    myList1 = [111, 1, 3, 15, 1.1]
    sorted(myList1)                                                                    // -> [1, 1.1, 3, 15, 111]    
    myList1                                                                            // -> [111, 1, 3, 15, 1.1]                 // original not modified 
    
    myTuple = ['kcp', 'AB', 'ab', 'kac', 'KCP']
    sorted(myTuple)                                                                    // -> ['AB', 'KCP', 'ab', 'kac', 'kcp']    // sort strings in unocide point order
    
    myString = 'developer'
    sorted(myString)                                                                   // -> ['d', 'e', 'e', 'e', 'l', 'o', 'p', 'r', 'v']    
    
    myList2 = ['kcp', 111, 1, 'AB', 3, 15, 'ab', 'kac', 'KCP']
    sorted(myList2)                                                                    // -! raises a TypeError because the sort does not support sort between strings and numbers    
    
    
    myList3 = [[11, 22], [3, 4], [1, 2]]
    sorted(myList3)                                                                    // -> [[1, 2], [3, 4], [11, 22]]
    
    myList4 = [{'p33':33}, {"p1":1, "p3":3}]
    sorted(myList4)                                                                    // -! raises a TypeError because the sort does not support sort between dictionaries     
    
    data = [(1, 'one'), (3, 'three'), (2, 'two')]                                     // the <mark>key</mark> lambda function returns which data should be used for sorting
    sorted(data, key=lambda x: x[0])                                                  // -> [(1, 'one'), (3, 'three'), (2, 'two')]
    
    data = [(1, 'banana'), (3, 'apple'), (2, 'banana'), (1, 'apple'), (2, 'apple')]   // the <mark>key</mark> lambda function can return a tuple for group sort 
    sorted(data, key=lambda x: (x[0], x[1]))                                          // -> [(1, 'apple'), (1, 'banana'), (2, 'apple'), (2, 'banana'), (3, 'apple')]
    
    
// all() ------------------------------------------------------------------------------
    some_list = ['a', 1, True]
    some_set = ('a', 0, True)
    
    all(some_list)                                                                     // -> True
    all(some_set)                                                                      // -> False 
    
    
// filter() ---------------------------------------------------------------------------
    number = [1, 2, 3, 4]
    
    bigger_than_2 = filter(lambda x: x > 2, number)
    
    for i in bigger_than_2:
        i                     // -> 3, 4
    </pre>
    <h4 class="header"> <mark>map()</mark> </h4>
    <pre>
    def test(a, b):
        return a + b
    
    for i in map(test, [1, 32, -145], [1, 8, 145]):
        print( i )                            // -> 2  |  40  |  0
    
    for i in map(test, ('a', 'b', 'c'), ('x', 'y', 'z')):
        print( i )                            // -> "ax"  |  "by"  |  "cz"
    </pre>
  </details>
  <hr>
  <!-------------------------------------------------------------------------------------------->
  <h2 class="headerExtra"> Lists </h2>
  <p> - a lists is an indexed collection data type which is ordered, changable and allow duplicate members </p>
  <pre class="syntax">
    [<strong>val:any</strong>, <i>...</i>]              // creating a list
    list(<strong>iterable</strong>)
    
    
    <strong>val:any</strong> <small>not</small> in <strong>list</strong>         // returns <mark>True</mark> if <strong>val</strong> is (<small>not</small>) part of <strong>list</strong> otherwise returns <mark>False</mark>    
    <strong>list</strong> + <strong>list</strong>                 // joins the two lists together and retuns the result as a new list (does not modify the original lists)
    
    del <strong>list</strong>[<strong>idx</strong>]               // deletes the indexed list member (does not leave a 'hole' = shrinks the list)
  </pre>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    myList = [1, 'egy', 1.1]
    yourList = [2, 'ketto', 2.2]
    
    'egy' in myList                                                                    // -> True                                 // member exist   
    'ketto' in myList                                                                  // -> False                                // member does not exist    
    
// + (operator) -----------------------------------------------------------------------
    myList + yourList                                                                  // -> [1, 'egy', 1.1, 2, 'ketto', 2.2]     // a new list is returned   
    
    myList                                                                             // the + operator does not modify the original list   
    yourList 
    
// del --------------------------------------------------------------------------------
    del myList[2]                                                                      // deletes the 2 indexed member from the list 
    
    myList                                                                             // -> [1, 'egy']                           // member completely removed    
    len(myList)                                                                        // -> 2   
    </pre>
  </details>
  <hr>
  <!-------------------------------------------------------------------------------------------->
  <h2 class="header"> The <mark>append()</mark> / <mark>extend()</mark> / <mark>insert()</mark> / <mark>copy()</mark>
    methods </h2>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    myList = [1, 'egy', 1.1]
    
// append() ---------------------------------------------------------------------------
    myList.append(2)                                                                   // appends the 2 value at the end of the list 
    myList                                                                             // -> [1, 'egy', 1.1, 2 ]
    
// extend() ---------------------------------------------------------------------------
    myList.extend(('ketto', 2.2))                                                      // appends the passed list's element at the end of the original list     
    myList                                                                             // -> [1, 'egy', 1.1, 'ketto', 2.2]
    
// insert() ---------------------------------------------------------------------------
    myList.insert(0, 'one')                                                            // inserts the value 'one' at 0 index (stretches the list to make space)    
    myList                                                                             // -> ['one', 1, 'egy', 1.1]
    
// copy() -----------------------------------------------------------------------------
    newList = myList.copy()                                                            // creates a new object, copy of the original list    
    
    myList.clear()
    myList                                                                             // -> []
    newList                                                                            // -> [1, 'egy', 1.1]
    </pre>
  </details>
  <hr>
  <!-------------------------------------------------------------------------------------------->
  <h2 class="header"> The <mark>index()</mark> / <mark>count()</mark> methods </h2>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    myList = [1, 'egy', 1.1, 2, 'ketto', 2.2, 1.1]
    
// count() ----------------------------------------------------------------------------
    myList.count('egy')                                                                // -> 1            // returns how many times the specified item appears in the list    
    myList.count(1.1)                                                                  // -> 2
    myList.count('harom')                                                              // -> 0
    
// index() ----------------------------------------------------------------------------
    myList.index('egy')                                                                // -> 1            // returns the first found item's index in the list   
    myList.index(1.1, 1, 3)                                                            // -> 2            // search range specified (from index 1 (included) to index 3 (excluded))    
    
    myList.index('ketto', 1, 3)                                                        // -! ValueError raised (because searched item is out of the specified srearch range)    
    </pre>
  </details>
  <hr>
  <!-------------------------------------------------------------------------------------------->
  <h2 class="header"> The <mark>pop()</mark> / <mark>remove()</mark> / <mark>clear()</mark> methods </h2>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    myList = [1, 'egy', 1.1, 2, 'ketto', 2.2, 1.1]
    
// pop() ------------------------------------------------------------------------------
    myList.pop()                                                                       // -> 1.1              // removes and returns the last list item   
    myList                                                                             // -> [1, 'egy', 1.1, 2, 'ketto', 2.2]
    
    myList.pop(1)                                                                      // -> 'egy'            // removes and returns the 1 indexed list item   
    myList                                                                             // -> [1, 1.1, 2, 'ketto', 2.2]
    
// remove() ---------------------------------------------------------------------------
    myList = [1, 'egy', 1.1, 2, 'ketto', 2.2, 1.1]
    
    myList.remove(1.1)                                                                 // removes the first found 1.1 from the list 
    myList                                                                             // -> [1, 'egy', 2, 'ketto', 2.2, 1.1]
    
    myList.remove('harom')                                                             // -! ValueError raised (no 'harom' item found in the list)     
    
// clear() ----------------------------------------------------------------------------
    myList.clear()                                                                     // completely clears the list 
    myList                                                                             // -> []
    </pre>
  </details>
  <hr>
  <!-------------------------------------------------------------------------------------------->
  <h2 class="header"> The <mark>sort()</mark> / <mark>reverse()</mark> methods </h2>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
// sort() -----------------------------------------------------------------------------
    myList1 = [111, 1, 3, 15, 1.1]
    myList1.sort()                                                                     // sort numbers in ascending order  
    myList1                                                                            // -> [1, 1.1, 3, 15, 111]
    
    myList2 = ['kcp', 'AB', 'ab', 'kac', 'KCP']
    print( myList2.sort()                                                              // sort strings in ASCII transition order   
    myList2                                                                            // -> ['AB', 'KCP', 'ab', 'kac', 'kcp']    
    
    myList3 = ['kcp', 111, 1, 'AB', 3, 15, 'ab', 'kac', 'KCP']
    print( myList3.sort()                                                              // -! raises a TypeError because the sort does not support sort between strings and numbers    
    
    myList4 = [[11, 22], [3, 4], [1, 2]]
    myList4.sort()
    myList4                                                                            // -> [[1, 2], [3, 4], [11, 22]]
    
    myList5 = [{'p33':33}, {"p1":1, "p3":3}]
    myList5.sort()                                                                     // -! raises a TypeError because the sort does not support sort between dictionaries    
    
    myList6 = ['Lorem', 'ipsum', 'dolor', 'sit', 'amet', 'consectetur', 'adipiscing']
    myList6.sort(key=len)                                                              // items are sorted by length (the <mark>len</mark> function returns the length for each string)    
    myList6                                                                            // -> ['sit', 'amet', 'Lorem', 'ipsum', 'dolor', 'adipiscing', 'consectetur']    
    
    myList7 = [4, 145, 844, 2, 12, 10, -4]
    def sort10(nr):                                                                    // custom sort function, sort numbers lower than 10 left, larger than 10 right   
        if nr &lt; 10:
            return -1
        elif nr > 10:
            return 1
        else:
            return 0
    
    myList7.sort(key=sort10)
    myList7                                                                            // -> [4, 2, -4, 10, 145, 844, 12]    
    
    myList8 = [4, 145, 844, 2, 12, 10, -4] 
    myList8.sort(reverse=True)                                                         // sorts the list in descending order     
    myList8                                                                            // -> [844, 145, 12, 10, 4, 2, -4]    
    
// reverse() --------------------------------------------------------------------------
    myList1 = ['kcp', 111, 1, 'AB', 3, 15, 'ab', 'kac', 'KCP']
    myList1.reverse()                                                                  // simply reverses the list order in place   
    myList1                                                                            // -> ['KCP', 'kac', 'ab', 15, 3, 'AB', 1, 111, 'kcp']
    </pre>
  </details>
  <hr>
  <!-------------------------------------------------------------------------------------------->
  <h2 class="headerExtra"> Tuples and Named Tuples </h2>
  <p> - a tuple is an indexed collection data type is ordered, not changable and allow duplicate members </p>
  <p> - named tuple members are referenced by keys, they can be accessed as object attributes (and also indexed just like normal tuple members) <span id="browserSupport">
      <span><i class="fab fa-python"></i> 2.6 </span>
      <span><i class="fab fa-python"></i> 3.0 </span>
    </span></p>
    <pre class="syntax">
    from collections import namedtuple
    
    
    (<strong>val:any</strong>, <i>...</i>)                          // creates a tuple
    <strong>val:any</strong>, <i>...</i>
    tuple(<strong>iterable</strong>)
    
    <strong>ClassNamedTuple</strong> = namedtuple(<strong>ClassName:str</strong>, [<strong>attr:str</strong><i>, ...</i>], <small>defaults=[<i>val:any</i><i>, ...</i>]</small>])   // creates and returns a named tuple class (<a href="../Built-in Libraries/dataclass/index.html#make_dataclass" target="_blank">same method as <mark>dataclasses.make_dataclass()</mark> syntax</a>)
    <strong>namedTuple</strong> = <strong>ClassNamedTuple</strong>(<strong>attr</strong>=<strong>val:any</strong><i>, ...</i>)                                          // creates a named tuple   
    
    
    <strong>val:any</strong> <small>not</small> in <strong>tuple|namedTuple</strong>         // returns <mark>True</mark> if <strong>val</strong> is (<small>not</small>) part of <strong>tuple|namedtuple</strong>, otherwise returns <mark>False</mark>    
    <strong>tuple|namedtuple</strong> + <strong>tuple|namedtuple</strong>     // joins the two tuples together and retuns a new tuple as the result   
                                              <span style="color:orange;">// -! we can join named tuples as well, but the result will be a normal <strong>tuple</strong></span>
    
    <strong>namedTuple</strong>.<strong>attr_1</strong>                       // named tuple attributes accessible as object attirbutes, <u>but they cannot be set!</u>    
    </pre>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    myTuple = 1, 'str', 4-4j                                                           // comma separated values are returned in a new tuple   
    myTuple                                                                            // -> (1, 'str', 4-4j)
    
    myTuple2 = 'one',                                                                  // -! this also returns a new tuple (note the comma)
    myTuple2                                                                           // -> ('egy')
    
    myTuple2 = ([1, 2, 3], 2)
    del myTuple2[0][1]                                                                 // tuples are unchangable but they can hold mutable data 
    myTuple2                                                                           // -> ([1, 2], 3)
    
    
// joining tuples ------------------------------------------
    myTuple1 = ('egy', 'ketto', 'harom')
    myTuple2 = ('negy', 'ot', 'hat')
    
    myTuple1 + myTuple2                                                                // -> ('egy', 'ketto', 'harom', 'negy', 'ot', 'hat')     // returns the joined tuple  
    
    myTuple1                                                                           // -> ('egy', 'ketto', 'harom')                          // does not modify the original tuple  
    
    
// <mark>in</mark> operation --------------------------------------------
    myTuple = ('egy', 'ketto', 'harom')
    'egy' in myTuple                                                                   // -> True
    'negy' in myTuple                                                                  // -> False
    </pre>
  <h4 class="header"> Named Tuple </h2>
    <pre>
    from collections import namedtuple
    
    
    MyNamedTupleClass = namedtuple('MyNamedTuple', ['x', 'y', 'z'])
    my_named_tuple_instance = MyNamedTupleClass(1, 2, 3)
    
    my_named_tuple_instance[1]                            // -> 2
    my_named_tuple_instance.y                             // -> 2   // can be accessed by name (like object attributes)
    
    type(my_named_tuple_instance) == MyNamedTupleClass    // -> True
    
// joining named tuples ------------------------------------
    my_named_tuple_instance2 = MyNamedTupleClass(4, 5, 6)
    tuple_result = my_named_tuple_instance + my_named_tuple_instance2   // -! named tuples can be joined but the result is a normal tuple
    type(tuple_result) == tuple                           // -> True
    
    
// default values ------------------------------------------
    NamedTupleClass = namedtuple('NamedTupleClass', ['x', 'y', 'z'], defaults=[1, 2, 3])
    my_named_tuple_instance = NamedTupleClass()
    
    my_named_tuple_instance.x                             // -> 1
    my_named_tuple_instance.y                             // -> 2    
    </pre>
  </details>
  <hr>
  <!-------------------------------------------------------------------------------------------->
  <h2 class="header"> The <mark>index()</mark> / <mark>count()</mark> methods </h2>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    myTuple = (1, 'egy', 1.1, 2, 'ketto', 2.2, 1.1)
    
// count() ----------------------------------------------------------------------------
    myTuple.count('egy')                                                               // -> 1            // returns how many times the specified item appears in the tuple     
    myTuple.count(1.1)                                                                 // -> 2
    myTuple.count('negy')                                                              // -> 0
    
// index() ----------------------------------------------------------------------------
    myTuple.index('egy')                                                               // -> 1            // returns the first found item's index in the tuple      
    myTuple.index(1.1, 1, 3)                                                           // -> 2            // search range specified (from index 1 (included) to index 3 (excluded))    
    
    myTuple.index('ketto', 1, 3)                                                       // -! ValueError raised (because searched item is out of the specified srearch range)    
    </pre>
  </details>
  <hr>
  <!-------------------------------------------------------------------------------------------->
  <h2 class="headerExtra"> Sets / Frozensets </h2>
  <p> - Sets are unordered where members are unchangable, but we can add|remove them, no duplicate members are allowed (great for duplicate filtering) </p>
  <p> - Sets are not really used to store data, but for removing duplicate members from other collections or for math operations like union and intersection </p>
  <p> - a Frozenset is the same as a Set but it is immutable (once created it's unchangable) </p>
  <pre class="syntax">
    {<strong>val:any</strong>, <i>...</i>}                  // creates a set
    set(<strong>iterable</strong>)
    
    frozenset(<strong>iterable</strong>)             // creates a new frozenset
    
    
    <strong>val:any</strong> <small>not</small> in <strong>set|frozenset</strong>    // returns <mark>True</mark> if <strong>val</strong> is (<small>not</small>) part of <strong>tuple</strong>, otherwise returns <mark>False</mark>
  </pre>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    set1 = {3, 1, 76, 2} 
    set2 = set([1, 2, 3, 76])
    frozenset1 = frozenset([1, 3, 55])
    
    set1[0]                                                                            // -! raises a TypeError (sets are unordered so it would be pointless to access members sequentially)
    frozenset1[0]                                                                      // -! raises a TypeError (frozensets are unordered so it would be pointless to access members sequentially)   
    
    for i in set1:
        i                                                                              // -> 1 | 2 | 3 | 76   // we can loop through members but they are unordered   
    for i in frozenset1:
        i                                                                              // -> 3 | 1 | 55
    </pre>
  <h4 class="header"> The <mark>in</mark> keywords </h4>
    <pre>
    mySet = {'egy', 'ketto', 'harom'}
    'egy' in mySet                                                                     // -> True
    'negy' in mySet                                                                    // -> False
    </pre>
  </details>
  <hr>
  <!-------------------------------------------------------------------------------------------->
  <h2 class="header"> The <mark>add()</mark> / <mark>update()</mark> / <mark>copy()</mark> methods </h2>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
  set1 = {3, 1, 76, 2}
  frozenset1 = frozenset([2, 22, 222])
    
// add() ------------------------------------------------------------------------------
    set1.add(33)                                                                       // adds a new member to the set 
    set1                                                                               // -> {1, 2, 3, 33, 76}
  
// update() ---------------------------------------------------------------------------
    set1.set1.update([11, 111])                                                        // adds the passed iterable's items to the set    
    set1                                                                               // -> {1, 2, 3, 11, 76, 111}   
  
// copy() -----------------------------------------------------------------------------
    set2 = set1.copy()                                                                 // creates a new object, copy of the original set   
    forzenset2 = frozenset1.copy()                                                     // creates a new object, copy of the original frozenset  
    </pre>
  </details>
  <hr>
  <!-------------------------------------------------------------------------------------------->
  <h2 class="header"> The <mark>pop()</mark> / <mark>remove()</mark> / <mark>discard()</mark> / <mark>clear()</mark>
    methods </h2>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    set1 = {3, 1, 76, 2}
    
// pop() ------------------------------------------------------------------------------
    set1.pop()                                                                         // -> 1            // removes an arbitary member and returns it 
    set1                                                                               // -> {2, 3, 76}   
    
// remove() / discard() ---------------------------------------------------------------
    set1.discard(1)                                                                    // -> None         // removes 1 from the set  
    set1.discard(1)                                                                    // -> None         // does nothing if the member is already removed   
    
    set1.remove(3)                                                                     // -> None         // removes 3 from the set 
    set1.remove(3)                                                                     // -! raises a KeyError (element does not exist in the set)    
    
// clear() ----------------------------------------------------------------------------
    set1.clear()                                                                       // completely clears the set 
    set1                                                                               // -> {}
    </pre>
  </details>
  <hr>
  <!-------------------------------------------------------------------------------------------->
  <h2 class="header"> Math Methods and Operators <mark>union()</mark> / <mark>|</mark> / <mark>intersection()</mark> /
    <mark>&</mark> / <mark>intersection_update()</mark> / <mark>difference()</mark> / <mark>-</mark> /
    <mark>difference_update()</mark> / <mark>symmetric_difference()</mark> / <mark>^</mark> /
    <mark>symmetric_difference_update()</mark> / <mark>isdisjoint()</mark> / <mark>issubset()</mark> /
    <mark>&lt;=</mark> / <mark>&lt;</mark> / <mark>issuperset()</mark> / <mark>>=</mark> / <mark>></mark> </h2>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
// union() / | ------------------------------------------------------------------------
    set1 = {1, 2}
    list1 = [5, 2]
    frozenset1 = frozenset((5, 2))
    
    set1.union(list1)                                                                  // -> {1, 2, 5}              // all members from boths sides are returned in a new set (set filters duplicate members)    
    set1 | frozenset1                                                                  // -> {1, 2, 5}              // the <mark>|</mark> operator does the same as above   // -! only between sets    
    frozenset1 | set1                                                                  // -> frozenset({1, 2, 5})    
    
    set1                                                                               // -> {1, 2}                 // does not modify originals 
    list1                                                                              // -> [5, 2]
    frozenset1                                                                         // -> frozenset({2, 5})
    
    
// intersection() / & / intersection_update() -----------------------------------------
    set1 = {1, 2}
    list1 = [5, 2]
    frozenset1 = frozenset((5, 2))
    
    set1.intersection(list1)                                                           // -> {2}                    // members that are present in both sides are returned in a new set   
    set1 & frozenset1                                                                  // -> {2}                    // the <mark>&</mark> operator does the same as above   // -! only between sets    
    frozenset1 & set1                                                                  // -> frozenset({2, 5})
    
    set1                                                                               // -> {1, 2}                 // does not modify originals   
    list1                                                                              // -> [5, 2]    
    frozenset1                                                                         // -> frozenset({5, 2})
    
  // ---------------------------------------------
    set1.intersection_update(list1)                                                    // -> None                   // does the same as <mark>intersection()</mark> but the result in collected in the original set  
    
    set1                                                                               // -> {2}                    // modifies the original set   
    myList1                                                                            // -> [5, 2]
    
    
// difference() / - / difference_update() ---------------------------------------------
    set1 = {1, 2}
    list1 = [5, 2]
    frozenset1 = frozenset((5, 2))
    
    set1.difference(list1)                                                             // -> {1}                    // members in <mark>set1</mark> that are NOT present <mark>list1</mark> are returned in a new set   
    set1 - frozenset1                                                                  // -> {1}                    // the <mark>-</mark> operator does the same as above   // -! only between sets    
    frozenset1 - set1                                                                  // -> frozenset({5})
    
    set1                                                                               // -> {1, 2}                 // does not modify originals   
    list1                                                                              // -> [5, 2]    
    frozenset1                                                                         // -> frozenset({5, 2})    
    
  // ---------------------------------------------
    set1.difference_update(list1)                                                      // -> None                   // does the same as <mark>difference()</mark> but the result in collected in the original set  
    
    set1                                                                               // -> {1}                    // modifies the original set   
    myList1                                                                            // -> [5, 2]
    
    
// symmetric_difference() / ^ / symmetric_difference_update() -------------------------
    set1 = {1, 2}
    list1 = [5, 2]
    frozenset1 = frozenset((5, 2))
    
    set1.symmetric_difference(list1)                                                   // -> {1, 5}                 // members that are not presnet in both sides are returned in a new set   
    set1 ^ frozenset1                                                                  // -> {1, 5}                 // the <mark>^</mark> operator does the same as above   // -! only between sets    
    frozenset1 ^ set1                                                                  // -> frozenset({1, 5})
    
    set1                                                                               // -> {1, 2}                 // does not modify originals   
    list1                                                                              // -> [5, 2]    
    frozenset1                                                                         // -> frozenset({5, 2})    
    
  // ---------------------------------------------
    set1.symmetric_difference_update(list1)                                            // -> None                   // does the same as <mark>symmetric_difference()</mark> but the result in collected in the original set  
    
    set1                                                                               // -> {1, 5}                 // modifies the original set   
    myList1                                                                            // -> [5, 2]
    
    
// isdisjoint() -----------------------------------------------------------------------
    {1, 2}.isdisjoint([3, 4])                                                          // -> True                   // left and right side have no common members    
    {1, 2}.isdisjoint((1, 3))                                                          // -> False                  // left and right side have common members    
    
    
// issubset() / &lt;= / &lt; ----------------------------------------------------------------
    {1, 2}.issubset([1, 2, 3])                                                         // -> True                   // all left side members are present in the right side   
    set1.issubset(tuple1)                                                              // -> False                  // not all left side members are present in the right side   
    
    {1, 2} &lt;= {1, 2}                                                                   // -> True                   // the <mark>&lt;=</mark> operator does the same as above  // -! only between sets     
    
    {1, 2} &lt; {1, 2, 3}                                                                 // -> True                   // the <mark>&lt;</mark> operator does the same as <mark>&lt;=</mark> but the operands cannot be equal   
    {1, 2} &lt; {1, 2}                                                                    // -> False
    
    
// issuperset() / &gt;= / &gt; --------------------------------------------------------------
    {1, 2, 3}.issuperset([1, 2])                                                       // -> True                   // all rigth side members are present in the left side   
    {1, 2, 3}.issuperset((1, 4))                                                       // -> False                  // not all right side members are present in the left side   
    
    {1, 2, 3} &gt;= {1, 2}                                                                // -> True                   // the <mark>&gt;=</mark> operator does the same as above  // -! only between sets     
    
    {1, 2, 3} &gt; {1, 2}                                                                 // -> True                   // the <mark>&gt;</mark> operator does the same as <mark>&gt;=</mark> but the operands cannot be equal   
    {1, 2, 3} &gt; {1, 2, 3}                                                              // -> False
    </pre>
  </details>
  <hr>
  <!-------------------------------------------------------------------------------------------->
  <h2 class="headerExtra"> Dictionaries </h2>
  <p> - a dictionary is a key/value data type which is ordered (after v3.7), changable and does not allow duplicate keys
  </p>
  <p> - Python dictionaries are associative arrays (keys are hashed under the hood for faster accessing), so dictionary
    keys can be any hashable data types (primitives and tuples holding only primitives) </p>
    <pre class="syntax">
    {<strong>key:hashable</strong>: <strong>val:any</strong>, <i>...</i>}     // creates and returns a new dictionary    
    dict(<strong class="openable">iterableKeyVal<div>
            <p> - an iterable with key/value pairs (ex: <mark>[['ke1', 1], ['key2', 2]]</mark>) </p>
          </div></strong>)
    
    
    <strong>val:any</strong> <small>not</small> in <strong>dict</strong>              // returns <mark>True</mark> if <strong>val</strong> is (<small>not</small>) part of dictionary, otherwise returns <mark>False</mark>
    del <strong>dict</strong>[<strong>key</strong>]                    // deletes the <strong>key</strong> with its value from the dictionary
    </pre>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    dict1 = {
        'str':'string,',                                                               // primitives ara hashable 
        1:1, 
        1.1:1.1,
        1-1j:1-1j, 
        True: True,
        None: None,
        (1, False): ('some tuple value'),                                              // a tuple can be used as dictionary keys if it holds only hashable types    
        ([1]): 'someVal',                                                              // -! raises a TypeError (tuple cannot hold any unchangable type)
        [1]: 'someVale'                                                                // -! raises a TypeError (list unchangable type)    
    }
    
    dict1['str']
    dict1[(1, False)]
    </pre>
  <h4 class="header"> The <mark>in</mark> / <mark>del</mark> keywords </h4>
    <pre>
    myDict = {'egy':1, 'ketto':2}
    
    'egy' in myDict                                                                    // -> True                                 // member exist 
    'harom' not in myDict                                                              // -> True                                 // member does not exist 
    
// del --------------------------------------------------------------------------------
    del myDict['ketto']                                                                // deletes the 'ketto' key with its value form the dictionary     
    
    myDict                                                                             // -> {'egy':1}
    </pre>
  </details>
  <hr>
  <!-------------------------------------------------------------------------------------------->
  <h2 class="header"> The <mark>fromkeys()</mark> class method </h2>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    myDict = dict.fromkeys(['key1', 'key2', 'key3'], 'someVal')                        // creates and returns a new dictionary where the iterable's members will be the keys and the 2nd argument will be the value for each key    
    
    myDict                                                                             // -> {'key1': 'someVal', 'key2': 'someVal', 'key3': 'someVal'}
    </pre>
  </details>
  <hr>
  <!-------------------------------------------------------------------------------------------->
  <h2 class="header"> The <mark>get()</mark> / <mark>setdefault()</mark> / <mark>update()</mark> / <mark>copy()</mark> methods and the <mark>|</mark> merge operator </h2>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    myDict = {'key1':1, 'key2':2}
    
// get() ------------------------------------------------------------------------------
    myDict.get('key1')                                                                 // -> 1              // key exist   
    myDict.get('key3')                                                                 // -> None           // key does not exist, default value returned instead   
    myDict.get('key3', 3)                                                              // -> 3
    
// sedefault() ------------------------------------------------------------------------
    myDict.setdefault('key3', 3)                                                       // -> 3              // sets a new key and value pair to the dictionary    
    myDict                                                                             // -> {'key1': 1, 'key2': 2, 'key3': 3}    
    
    myDict.setdefault('key1', 11)                                                      // -> 1              // does nothing because the 'key1' key exist in the dictionary (returns the value of the current key)    
    myDict                                                                             // -> {'key1': 1, 'key2': 2, 'key3': 3}   
    
// update() ---------------------------------------------------------------------------
    myDict.update({'key3':3, 'key4':4})                                                // adds the passed dictionary members to the dictionary    
    myDict                                                                             // -> 'key1': 1, 'key2': 2, 'key3': 3, 'key4': 4}   
    
    myDict.update([['key5', 5], ['key6', 6]])                                          // iterable with key/val pair structure also can be used   
    myDict                                                                             // -> {'key1': 1, 'key2': 2, 'key3': 3, 'key4': 4, 'key5': 5, 'key6': 6}   
    
// copy() -----------------------------------------------------------------------------
    myDict2 = myDict.copy()                                                            // creates and returns a new dictionary, copy of the original    
    
    del myDict['key2']
    myDict                                                                             // -> {'key1':1}
    myDict2                                                                            // -> {'key1':1, 'key2':2}         // different object
    
// | (merging dictionaries) -----------------------------------------------------------
    x = {"key1": 1, "key2": 2}
    y = {"key2": 22, "key3": 33}
    
    x | y                                                              // -> {'key1': 1, 'key2': 22, 'key3': 33}
    </pre>
  </details>
  <hr>
  <!-------------------------------------------------------------------------------------------->
  <h2 class="header"> The <mark>keys()</mark> / <mark>values()</mark> / <mark>items()</mark> methods </h2>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    myDict = {'key1':1, 'key2':2, 'key3':3}
    
    viewKeys = myDict.keys()          
    viewValues = myDict.values()      
    viewItems = myDict.items()        
    
    print( viewKeys )                                                                  // -> dict_keys(['key1', 'key2', 'key3'])
    print( viewValues )                                                                // -> dict_values([1, 2, 3])
    print( viewItems )                                                                 // -> dict_items([('key1', 1), ('key2', 2), ('key3', 3)])
    
    del myDict['key2'] 
    
    // any changes are reflected in the view object (other than this I don't see any use of these methods)
    viewKeys                                                                           // -> dict_keys(['key1', 'key3'])
    viewValues                                                                         // -> dict_values([1, 3])
    viewItems                                                                          // -> dict_items([('key1', 1), ('key3', 3)])
    
// access view object members ---------------------------------------------------------
    for i in viewItems:                                                                // view objects are iterable    
        i                                                                              // -> ('key1', 1)  |  ('key3', 3)
    
    viewItems[0]                                                                       // -! raises a TypeError (view objects are not indexed)    
    </pre>
  </details>
  <hr>
  <!-------------------------------------------------------------------------------------------->
  <h2 class="header"> The <mark>pop()</mark> / <mark>popitem()</mark> / <mark>clear()</mark> methods </h2>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    myDict = {'key1':1, 'key2':2, 'key3':3}

// pop() ------------------------------------------------------------------------------
    myDict.pop('key2', 'def')                                                          // -> 2              // returns the removed key's value   
    myDict.pop('key2', 'def')                                                          // -> 'def'          // returns the default value because the key does not exist in the dictionary    
    myDict.pop('key2')                                                                 // -! raises a KeyError because the key does not exist in the dictionary and the pop() has no default value   
    
    myDict                                                                             // -> {'key1':1, 'key3':3}
    
// popitem() --------------------------------------------------------------------------
    myDict = {'key1':1, 'key2':2, 'key3':3}
    
    myDict.popitem()                                                                   // -> ('key3', 3)    // removes and returns the last key/value pair from the dictionary   
    
    myDict.clear()
    myDict.popitem()                                                                   // -! raises a KeyError because the dictionary is empty 
    
// clear() ----------------------------------------------------------------------------
    myDict.clear()                                                                     // -> None           // empties the dictionary 
    
    myDict                                                                             // -> {}
    </pre>
  </details>


  <br><br>
</body>

</html>