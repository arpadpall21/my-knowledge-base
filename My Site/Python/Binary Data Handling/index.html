<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title> Binary Data Handling </title> 
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous"> 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../Assets/stylesPages.css"> 
    <script src="../../Assets/scriptPages.js"></script>
</head>
<body>
<h1> Binary Data Handling </h1>
    <p> Updated ( 2022-06-02 )</p>
    <p class="sitenav"> <a href="../../index.html">MySite></a>
        <a href="../index.html">Python></a> Binary Data Handling
    </p>
<table class="table">
<caption>
    <mark>bytes</mark> & <mark>bytearray</mark>
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Method / Property </th>
        <th> Description </th>
    </tr>
    <tr class="05.01">
        <td> 
            <em>bytes|bytearray</em>(<strong>src:str</strong>, <strong>encode:str</strong>, <i>errMsg:str</i>)
        </td>
        <td> 
            - creates a <strong>bytes|bytearray</strong> from the passed string 
        </td>
    </tr>
        <tr class="05.02"><td></td><td></td></tr>
    <tr class="05.03">
        <td> 
            <em>bytes|bytearray</em>(<i>len:int</i>)
        </td>
        <td> 
            - creates a 0 byte filled <strong>bytes|bytearray</strong> with the specified length 
        </td>
    </tr>
        <tr class="05.04"><td></td><td></td></tr>
    <tr class="05.05">
        <td> 
            <em>bytes|bytearray</em>(<strong>[int(0-255), ...]</strong>)
        </td>
        <td> 
            - creates a new <strong>bytes|bytearray</strong> from the passed iterables integer members <br>
            - members are <mark>0-255</mark> integers which are interpreted as bytes
        </td>
    </tr>
        <tr class="05.06"><td></td><td></td></tr>
    <tr class="05.07">
        <td> 
            <em>bytes|bytearray</em>(<strong>bytes|bytearray</strong>)
        </td>
        <td> 
            - creates a  <strong>bytes|bytearray</strong> copy
        </td>
    </tr>
        <tr class="05.08"><td></td><td></td></tr>
    <tr class="06.01">
        <td> 
            <em>bytes|bytearray</em>.fromhex(<strong>strHexSeq</strong>)
        </td>
        <td> 
            - creates a <strong>bytes|bytearray</strong> from the passed string containing hex sequences (ex: <mark>bytes.fromhex('4b757461')</mark> => <mark>b'Kutya'</mark>)
        </td>
    </tr>
    <tr class="06.02">
        <td> 
            <strong>bytes|bytearray</strong>.hex(<i class="openable">sep:str<div>
                <p> - separator character between bytes </p>
            </div></i>, <i class="openable">bytesPerSep<div>
                <p> - number of bytes between separator characters (Default: <mark>1</mark>) </p>
            </div></i>)
        </td>
        <td> 
            - returns the ASCII hex values per byte in a sting (ex: <mark>b'Kutya'</mark> => <mark>'4b75747961'</mark>)
        </td>
    </tr>
    <tr class="07.01">
        <td> 
            <strong>bytes|bytearray</strong>.decode(<small class="openable">encoding=<i>encode:str</i><div>
                <p> Default: <mark>'utf-8'</mark> </p>
            </div></small>, <small class="openable">errors=<i>'strict'</i><div>
                <p> Default: <mark>'strict'</mark> - raises a <strong>UnicodeError</strong> </p>
                <p> - other options <mark>'strict'</mark> <strong>'replace'</strong> </p>
            </div></small>)
        </td>
        <td>
            - decodes the <strong>bytes|bytearray</strong> according to the decode fromat and returns the result in a string
        </td>
    </tr>
    <tr class="10.01">
        <td colspan="2"> 
            Methods 
        </td>
    </tr>
    <tr class="25.01">
        <td> 
            <strong>bytes|bytearray</strong>.capitalize()
        </td>
        <td> 
            - converts the first letter into ASCII equivalent upper case and returns the result in a new <strong>bytes|bytearray</strong> (does not modify the original)
        </td>
    </tr>
    <tr class="35.01">
        <td> 
            <strong>bytes|bytearray</strong>.center(<strong>length:int</strong>, <i>char:bytes|bytearray</i>)
        </td>
        <td> 
            - centers the content by filling ASCII spaces (or <i>char</i>) on both sides on the <strong>bytes|bytearray</strong> and returns the result in a new <strong>bytes|bytearray</strong> (does not modify the original)
        </td>
    </tr>
    <tr class="40.02">
        <td> 
            <strong>bytes|bytearray</strong>.endswith(<strong>srch:bytes|bytearray</strong>, <i>stIdx(inc)</i>, <i>endIdx(exc)</i>)
        </td>
        <td> 
            - returns <mark>True</mark> if the <strong>bytes|bytearray</strong> (or the range) ends with <strong>srch</strong>, <mark>False</mark> otherwise  
        </td>
    </tr>
    <tr class="50.01">
        <td> 
            <strong>bytes|bytearray</strong>.count(<strong>srch:bytes|bytearray</strong>)
        </td>
        <td> 
            - returns how many times <strong>srch</strong> is found in the <strong>bytes|bytearray</strong>
        </td>
    </tr>
    <tr class="55.01">
        <td> 
            <strong>bytes|bytearray</strong>.find(<strong>srch:bytes|bytearray</strong>, <i>stIdx(inc)</i>, <i>endIdx(exc)</i>)
        </td>
        <td> 
            - returns the first found index where <strong>srch</strong> is found in the <strong>bytes|bytearray</strong> (optional search range can be specified) <br>
            - returns <mark>-1</mark> if <strong>srch</strong> is not found  
        </td>
    </tr>
    <tr class="55.02">
        <td> 
            <strong>bytes|bytearray</strong>.index(<strong>srch:bytes|bytearray</strong>, <i>stIdx(inc)</i>, <i>endIdx(exc)</i>)
        </td>
        <td> 
            - returns the first found index where <strong>srch</strong> is found in the <strong>bytes|bytearray</strong> (optional search range can be specified) <br>
            - raises a <mark>ValueError</mark> if <strong>srch</strong> is not found  
        </td>
    </tr>
    <tr class="45.01">
        <td> 
            <strong>bytes|bytearray</strong>.isalnum()
        </td>
        <td> 
            - returns <mark>True</mark> if the <strong>bytes|bytearray</strong> contains only ASCII alphanumerical characters (alphabetical letters) and any numerical characters), <mark>False</mark> otherwise
        </td>
    </tr>
    <tr class="45.02">
        <td> 
            <strong>bytes|bytearray</strong>.isalpha()
        </td>
        <td> 
            - returns <mark>True</mark> if the <strong>bytes|bytearray</strong> contains only ASCII alphabetical letters, <mark>False</mark> otherwise   
        </td>
    </tr>
    <tr class="45.04">
        <td> 
            <strong>bytes|bytearray</strong>.isdigit()
        </td>
        <td> 
            - returns <mark>True</mark> if the <strong>bytes|bytearray</strong> contains only ASCII digit characters, <mark>False</mark> otherwise   
        </td>
    </tr>
    <tr class="27.01">
        <td> 
            <strong>bytes|bytearray</strong>.islower()
        </td>
        <td> 
            - returns <mark>True</mark> if the <strong>bytes|bytearray</strong> contains only ASCII lower case characters, <mark>False</mark> otherwise   
        </td>
    </tr>
    <tr class="45.09">
        <td> 
            <strong>bytes|bytearray</strong>.isspace()
        </td>
        <td> 
            - returns <mark>True</mark> if the <strong>bytes|bytearray</strong> contains only ASCII space characters, <mark>False</mark> otherwise   
        </td>
    </tr>
    <tr class="45.08">
        <td> 
            <strong>bytes|bytearray</strong>.istitle()
        </td>
        <td> 
            - returns <mark>True</mark> if the <strong>bytes|bytearray</strong> contains ASCII words that all starts with an ASCII capital letter, <mark>False</mark> otherwise   
        </td>
    </tr>
    <tr class="27.02">
        <td> 
            <strong>bytes|bytearray</strong>.isupper()
        </td>
        <td> 
            - returns <mark>True</mark> if all letters are ASCII upper cases in the <strong>bytes|bytearray</strong>, <mark>False</mark> otherwise   
        </td>
    </tr>
    <tr class="60.01">
        <td> 
            <strong>bytes|bytearray</strong>.join(<strong>iterable</strong>)
        </td>
        <td> 
            - joins the <strong>iterable</strong> members together by using the original <strong>bytes|bytearray</strong> as separator between them, returns the result in a new <strong>bytes|bytearray</strong> (does not modify the original string) <br>
            - all <strong>iterable</strong> members must be bytes-like
        </td>
    </tr>
    <tr class="35.02">
        <td> 
            <strong>bytes|bytearray</strong>.ljust(<strong>length:int</strong>, <i>char:bytes|bytearray</i>)
        </td>
        <td> 
            - left adjust the <strong>bytes|bytearray</strong> by filling ASCII spaces (or <i>char</i>) <u>on the right side (not left side)</u> on the <strong>bytes|bytearray</strong>, returns the result in a new <strong>bytes|bytearray</strong> (does not modify the original)
        </td>
    </tr>
    <tr class="20.03">
        <td> 
            <strong>bytes|bytearray</strong>.lower()
        </td>
        <td> 
            - converts the <strong>bytes|bytearray</strong> into ASCII lower case letters and returns the result in a new <strong>bytes|bytearray</strong> (does not modify the original)
        </td>
    </tr>
    <tr class="30.02">
        <td> 
            <strong>bytes|bytearray</strong>.lstrip(<i>srch:bytes|bytearray<i>)
        </td>
        <td> 
            - removes ASCII spaces (or <i>srch</i>) sequences on the left side on the <strong>bytes|bytearray</strong> and returns the result in a new <strong>bytes|bytearray</strong> (does not modify the orignal)
        </td>
    </tr>
    <tr class="70.01">
        <td> 
            <strong>bytes|bytearray</strong>.partition(<strong>srch:bytes|bytearray</strong>)
        </td>
        <td> 
            - partition the <strong>bytes|bytearray</strong> into 3 parts at the first found <strong>srch</strong> and returns the result in a uple (does not modify the original) <br>
            - partitions = 1) part before <strong>srch</strong> / 2) the <strong>srch</strong> / 3) part after <strong>srch</strong>  
        </td>
    </tr>
    <tr class="30.03">
        <td> 
            <strong>bytes|bytearray</strong>.removeprefix(<strong>srch:bytes:bytearray</strong>)
        </td>
        <td> 
            - removes <strong>srch</strong> on the right side on the <strong>bytes|bytearray</strong> and returns the result in a new  <strong>bytes|bytearray</strong> (does not modify the orignal) <br>
            - if there's nothing to remove the <strong>bytes|bytearray</strong> returned unchanged
            <span id="browserSupport" title="Updated : 2022-07-11">
                <span><i class="fab fa-python"></i> 3.9 </span>
            </span>
        </td>
    </tr>
    <tr class="30.05">
        <td> 
            <strong>bytes|bytearray</strong>.removesuffix(<strong>srch:bytes:bytearray</strong>)
        </td>
        <td> 
            - removes <strong>srch</strong> on the left side on the <strong>bytes|bytearray</strong> and returns the result in a new <strong>bytes|bytearray</strong> (does not modify the orignal) <br>
            - if there's nothing to remove the <strong>bytes|bytearray</strong> returned unchanged
            <span id="browserSupport" title="Updated : 2022-07-11">
                <span><i class="fab fa-python"></i> 3.9 </span>
            </span>
        </td>
    </tr>
    <tr class="75.01">
        <td> 
            <strong>bytes|bytearray</strong>.replace(<strong>srch:<strong>bytes|bytearray</strong></strong>, <strong>new:<strong>bytes|bytearray</strong></strong>)
        </td>
        <td> 
            - replaces all <strong>srch</strong> by <strong>new</strong> and returns the result in a new <strong>bytes|bytearray</strong> (does not modify the original string)
        </td>
    </tr>
    <tr class="55.03">
        <td> 
            <strong>bytes|bytearray</strong>.rfind(<strong>srch:bytes|bytearray</strong>, <i>stIdx(inc)</i>, <i>endIdx(exc)</i>)
        </td>
        <td> 
            - returns the index where <strong>srch</strong> is found in the <strong>bytes|bytearray</strong>, searches end-to-start (optional search range can be specified) <br>
            - returns <mark>-1</mark> if <strong>srch</strong> is not found  
        </td>
    </tr>
    <tr class="55.04">
        <td> 
            <strong>bytes|bytearray</strong>.rindex(<strong>srch:bytes|bytearray</strong>, <i>stIdx(inc)</i>, <i>endIdx(exc)</i>)
        </td>
        <td> 
            - returns the index where <strong>srch</strong> is found in the <strong>bytes|bytearray</strong>, searches end-to-start (optional search range can be specified) <br>
            - raises a <mark>ValueError</mark> if <strong>srch</strong> is not found  
        </td>
    </tr>
    <tr class="35.03">
        <td> 
            <strong>bytes|bytearray</strong>.rjust(<strong>length:int</strong>, <i>char:bytes|bytearray</i>)
        </td>
        <td> 
            - right adjust the <strong>bytes|bytearray</strong> by filling ASCII spaces (or <i>char</i>) <u>on the left side (not right side)</u> on the <strong>bytes|bytearray</strong>, returns the result in a new <strong>bytes|bytearray</strong> (does not modify the original)
        </td>
    </tr>
    <tr class="70.02">
        <td> 
            <strong>bytes|bytearray</strong>.rpartition(<strong>srch:bytes|bytearray</strong>)
        </td>
        <td> 
            - partition the <strong>bytes|bytearray</strong> into 3 parts at the last found <strong>srch</strong> and returns the result in a tuple (does not modify the original) <br>
            - partitions = 1) part before <strong>srch</strong> / 2) the <strong>srch</strong> / 3) part after <strong>srch</strong>  
        </td>
    </tr>
    <tr class="65.02">
        <td> 
            <strong>bytes|bytearray</strong>.rsplit(<strong>srch:bytes|bytearray</strong>, <i class="openable">limit:int<div>
                <p> - split limit </p>
            </div></i>)
        </td>
        <td>
            - end-to-start splits the <strong>bytes|bytearray</strong> at <strong>srch:str</strong> and returns the splitted parts in a new list (does not modify the original) (<strong>srch</strong> is removed from the sliptted parts)
        </td>
    </tr>
    <tr class="30.04">
        <td> 
            <strong>bytes|bytearray</strong>.rstrip(<i>srch:bytes</i>)
        </td>
        <td> 
            - removes ASCII spaces (or <i>srch</i>) sequences on the right side on the <strong>bytes|bytearray</strong> and returns the result in a new <strong>bytes|bytearray</strong> (does not modify the orignal)
        </td>
    </tr>
    <tr class="40.01">
        <td> 
            <strong>bytes|bytearray</strong>.startswith(<strong>src:bytes|bytearray</strong>, <i>stIdx(inc)</i>, <i>endIdx(exc)</i>)
        </td>
        <td> 
            - returns <mark>True</mark> if the <strong>bytes|bytearray</strong> (or the range) starts with <strong>srch</strong>, <mark>False</mark> otherwise  
        </td>
    </tr>
    <tr class="30.01">
        <td> 
            <strong>bytes|bytearray</strong>.strip(<i>srch:bytes</i>)
        </td>
        <td> 
            - removes ASCII spaces (or <i>srch</i> sequences) on both side on the <strong>bytes|bytearray</strong> and returns the result in a new (or <i>srch</i> sequences) (does not modify the original)
        </td>
    </tr>
    <tr class="65.01">
        <td> 
            <strong>bytes|bytearray</strong>.split(<strong>srch:bytes|bytearray</strong>, <i class="openable">limit:int<div>
                <p> - split limit </p>
            </div></i>)
        </td>
        <td> 
            - splits the <strong>bytes|bytearray</strong> at <strong>srch</strong> and returns the splitted parts in a new list (does not modify the original) (<strong>srch</strong> is removed from the sliptted parts)
        </td>
    </tr>
    <tr class="65.03">
        <td> 
            <strong>bytes|bytearray</strong>.splitlines(<i class="openable">preserve\n\r:bol<div>
                <p> - preservers the <mark>\r</mark>, <mark>\n</mark> characters on the splitted parts (Default: <mark>False</mark>) </p>
            </div></i>)
        </td>
        <td> 
            - splits the <strong>bytes|bytearray</strong> at ASCII new line characters (<mark>\n</mark>, <mark>\r</mark>) and returns the splitted parts in a new list (does not modify the original) (by default new line characters are removed from the sliptted parts)
        </td>
    </tr>
    <tr class="20.05">
        <td> 
            <strong>bytes|bytearray</strong>.swapcase()
        </td>
        <td> 
            - swaps ASCII letter cases, lower to upper and vice versa (returns the resutl in a new <strong>bytes|bytearray</strong>)
        </td>
    </tr>
    <tr class="20.02">
        <td> 
            <strong>bytes|bytearray</strong>.upper()
        </td>
        <td> 
            - converts the <strong>bytes|bytearray</strong> into ASCII upper case letters and returns the result in a new <strong>bytes|bytearray</strong> (does not modify the original)
        </td>
    </tr>
    <tr class="35.04">
        <td> 
            <strong>bytes|bytearray</strong>.zfill(<strong>len:int</strong>)
        </td>
        <td> 
            - fills <mark>b'0'</mark> characters on the left side on the <strong>bytes|bytearray</strong> untill the specified length is reached, returns the result in a new <strong>bytes|bytearray</strong> (does not modify the original)
        </td>
    </tr>
</table>
    <br>
<table class="table">
<caption>
    <mark>memoryview</mark>
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Method / Property </th>
        <th> Description </th>
    </tr>
    <tr class="05.01">
        <td> 
            <em>memoryview</em>(<strong>bytes|bytearray</strong>)
        </td>
        <td> 
            - creates a <strong>memView</strong> of the passed buffer protocol supported types
        </td>
    </tr>
    <tr class="10.01">
        <td colspan="2"> 
            Methods 
        </td>
    </tr>
    <tr class="20.02">
        <td> 
            <strong>memView</strong>.hex(<i class="openable">sep:str<div>
                <p> - separator character between bytes </p>
            </div></i>, <i class="openable">bytesPerSep<div>
                <p> - number of bytes between separator characters (Default: <mark>1</mark>) </p>
            </div></i>)
        </td>
        <td> 
            - returns the ASCII hex values per byte in a sting (ex: <mark>b'Kutya'</mark> => <mark>'4b75747961'</mark>)
    </tr>
    <tr class="25.02">
        <td> 
            <strong>memView</strong>.itemsize
        </td>
        <td> 
            - returns the size in bytes of each element of the <strong>memView</strong> (ex: arrays may have items larger than 1 byte)
        </td>
    </tr>
    <tr class="25.01">
        <td> 
            <strong>memView</strong>.obj
        </td>
        <td> 
            - returns the original object which the <strong>memView</strong> views
            <span id="browserSupport" title="Updated : 2022-07-12">
                <span><i class="fab fa-python"></i> 3.3 </span>
            </span>
        </td>
    </tr>
    <tr class="10.01">
        <td> 
            <strong>memView</strong>.release()
        </td>
        <td> 
            - releases the underlying buffer (free up the resource) (same as exiting the <mark>with</mark> block) <br>
            - after this the <strong>memView</strong> is not usable anymore (the buffer is closed through which we see the underlying memory)
            <span id="browserSupport" title="Updated : 2022-07-12">
                <span><i class="fab fa-python"></i> 3.2 </span>
            </span>
        </td>
    </tr>
    <tr class="20.01">
        <td> 
            <strong>memView</strong>.tobytes()
        </td>
        <td> 
            - returns a new <strong>bytes</strong> of the data viewed by the <strong>memView</strong>
        </td>
    </tr>
    <tr class="20.03">
        <td> 
            <strong>memView</strong>.tolist()
        </td>
        <td> 
            - returns a list of <strong>memeView</strong> where members are the decimal ASCII representation of the underlying byte
        </td>
    </tr>
    <tr class="15.01">
        <td> 
            <strong>memView</strong>.toreadonly()
        </td>
        <td> 
            - returns a read-only <strong>memeView</strong> (not a copy, we 'see' the same underlying memory just a read-only version of it)
            <span id="browserSupport" title="Updated : 2022-07-12">
                <span><i class="fab fa-python"></i> 3.8 </span>
            </span>
        </td>
    </tr>
    <tr class="15.02">
        <td> 
            <strong>memView</strong>.readonly
        </td>
        <td> 
            - returns <mark>True</mark> if the <strong>memView</strong> is read-only, <mark>False</mark> otherwise 
        </td>
    </tr>
</table>
    <br>
<h2 class="headerSection"> Useful Links : </h2>
    <p><a href="https://docs.python.org/3/library/stdtypes.html#binary-sequence-types-bytes-bytearray-memoryview" target="_blank">Binary Sequence Types</a></p>
<h2 class="headerSection"> Remember This : </h2>
    
<h2 class="headerSection"> Description and Demonstration : </h2>
<h2 class="header"> Bytes and Bytearray </h2>
    <p> - <mark class="mark">bytes</mark> & <mark class="mark">bytearray</mark> types in Python are iterable objects containing byte sequences </p>
    <p> - <mark class="mark">bytes</mark> type is immutable VS the <mark class="mark">bytearray</mark> type is mutable (that's the only difference) </p>
    <p> - both <mark class="mark">bytes</mark> and <mark class="mark">bytearray</mark> supports the buffer protocol (direct memory access) </p>
    <pre class="syntax">
    b'<strong>asciiChars|hexSeq</strong>'                                                               // <strong>bytes</strong> literal accepts ascii characters or hex notation sequences 
    b"<strong>asciiChars|hexSeq</strong>"

    <strong>bytes|bytearray</strong>[<strong>idx</strong>]                                                               // returns the decimal ascii value of the indexed byte
    <strong>bytes|bytearray</strong>[<strong>stIdx(inc)</strong>:<strong>endIdx(exc)</strong>]                                            // returns the sliced part in a new <strong>bytes|bytearray</strong>
    </pre>
<details class="example">
<summary> DEMO </summary>
    <pre>
    b'test'                                                                            // -> b'test'            // ascii characters
    b'\x74\x65\x73\x74'                                                                // -> b'test'            // hex sequnece 
    
    b'รก'                                                                               // -! SyntaxError (only ascii characters allowed)
    
    
// slicing operations -----------------------------------------------------------------
    myBytes[0]                                                                         // -> 116                // decimal ascii value of 't'
    myByteArray[0]                                                                     // -> 116
    
    myBytes[0:1]                                                                       // -> b't'               // creates a new bytes from the specified slice range
    myByteArray[0:1]                                                                   // -> bytearray(b't')    // creates a new bytearray from the specified slice range
    </pre>
</details>
<hr>
<!----------------------------------------------------------------------------------------------------->
<h2 class="header"> Memoryview </h2>
    <p> - the <mark class="mark">memoryview</mark> type in Python gives direct access to the underlying memory (without copying) (memoryview => view the memory) </p>
    <p> - we can create memory view on object supporting the buffer protocol (<mark class="mark">bytes</mark> and <mark class="mark">bytearray</mark>) </p>
    <p> - the <mark class="mark">memoryview</mark> supports context management, (can be opened by the <mark>with</mark> statement and free up the underlying buffer when the program exits the <mark>with</mark> block) </p>
    <p> - the main reason to use memoryview is speed (we have direct access to the underlying memory) </p>
    <pre class="syntax">
    <strong>memView</strong>[<strong>idx</strong>]                                                                       // returns the decimal ascii value of the indexed byte
    <strong>memView</strong>[<strong>stIdx(inc)</strong>:<strong>endIdx(exc)</strong>]                                                    // returns the sliced part in a new <strong>memView</strong>
    </pre>
<details class="example">
<summary> DEMO </summary>
    <pre>
    b = b'test'
    ba = bytearray('test', 'ascii')
    
    memv1 = memoryview(b)                                                              // creating memoryview 
    memv2 = memoryview(ba)
    
    memv1[0]                                                                           // -> 116                   // byte decimal ascii value
    memv1[0]                                                                           // -> 116
    
    memv1[0:1]                                                                         // -> memoryview object     // -! this is not a copy we 'see' the same underlying memory here 
    memv1[0:1]                                                                         // -> memoryview object 
    
    memv1[0] = 84                                                                      // -! raises an Error (original bytes object is not mutable => not writable)
    memv2[0] = 84                                                                      // we directly modify the underlying byte here 
    
    b                                                                                  // -> b'test'
    ba                                                                                 // -> bytearray('Test')     // original data modified 
    
    
// copy never created -----------------------------------------------------------------
    ba = bytearray('test', 'ascii')
    
    orgMemv = memoryview(ba)
    
    v1 = orgMemv[0:4]
    v2 = v1[0:4]                                                                       // never creates a copy (we see the same underlying memory)
    v3 = v2[0:4]
    v4 = v3[0:4]
    
    v4[0] = 84                                                                         // modify byte 
    
    ba                                                                                 // -> bytearray('Test')      // original data modified  
    </pre>
    <p> - context management support </p>
    <pre>
    with memoryview(b'test') as m:
        m[0]                                                                           // -> 116
    
    m[0]                                                                               // -! ValueError     // context exited so the memoryview buffer is closed (the memoryview object is not usable anymore)   
    </pre>
</details>
    
    <br><br>
</body>
</html>
