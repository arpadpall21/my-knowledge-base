<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title> asyncaio </title>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../../Assets/stylesPages.css">
    <script src="../../../Assets//scriptPages.js"></script>
  </head>

  <body>
    <h1> asyncaio </h1>
    <p> Updated ( 2022-10-19 )</p>
    <nav class="sitenav">
      <a href="../../../index.html">MySite > </a>
      <a href="../../index.html">Python > </a>
      <a href="../index.html">Standard Libraries > </a> asyncio
    </nav>
    <table class="table">
      <caption>
        <span class="browserSupport" title="updated : 2022-10-51">
          <span><i class="fab fa-python"></i> <mark>asyncio</mark> 3.4 </span>
        </span>
        <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
      </caption>
      <tr>
        <th style="width:30%;"> Method / Property </th>
        <th> Description </th>
      </tr>
      <tr class="05.01">
        <td>
          <em>asyncio</em>.run(<strong>coro()</strong><small>, debug=<i>bool</i></small>)
        </td>
        <td>
          - high level event loop API management funciton (takes care of low level management of the asyncio event loop, finalizing asynchronous generators, and closing the threadpool)<br>
          - used as main entry point to the event loop (only one allowed)
        </td>
      </tr>
      <tr class="07.01">
        <td>
          <em>asyncio</em>.gather(<strong>awaitable</strong><i>, ...</i>, <small>return_exception=<i>bool</i></small>)
        </td>
        <td>
          - coroutine start executing all <strong>awaitable</strong>s concurently and awaits their result<br>
          - the awaited result is a list of the <strong>awaitable</strong> result<br>
          - <small>return_exception=False</small> -> first exception immediately propagated to this corutine (Default)<br>
          - <small>return_exception=True</small> -> exceptions are threated as successful result
        </td>
      </tr>
      <tr class="08.01">
        <td>
          <em>asyncio</em>.sleep(<strong>delaySec:int</strong>, <small>result=<i>str</i></small>)
        </td>
        <td>
          - awaiting this coroutine suspends the execution for <strong>delay</strong> (execution is passed to somewhere else) <br>
          - awaiting returns <small>result</small> <br>
          - in long function we can use <mark>await asyncio.sleep(0)</mark> to momentarily pass the execution to somewhere else (to optimize resources)
          <span class="browserSupport" title="updated : 2022-10-18">
            <span><i class="fab fa-python"></i> 3.7 </span>
          </span>
        </td>
      </tr>
      <tr class="10.01">
        <td>
          <em>asyncio</em>.shield(<strong>awaitable</strong>)
        </td>
        <td>
          - awaiting this corutine protects the <strong>awaitable</strong> from being cancelled (calling <mark>cancel()</mark> on the <strong>awaitable</strong> will be ignored)
        </td>
      </tr>
      <tr class="15.01">
        <td>
          <em>asyncio</em>.wait_for(<strong>awaitable</strong>, <strong>delaySec:float|int</strong>)
        </td>
        <td>
          - coroutine limits the execution time for the <strong>awaitable</strong><br>
          - if the <strong>awaitable</strong> takes longer than <strong>delay</strong> it is cancelled and raises an <mark>asyncio.exceptions.TimeoutError</mark><br>
          - awaiting returns the <strong>awaitable</strong>'s result on success
        </td>
      </tr>
      <tr class="15.02">
        <td>
          <em>asyncio</em>.wait([<strong>task</strong><i>, ...</i>], <small>timeout=<i>float</i></small>, <small class="openable">return_when=<i>str</i>
            <div>
              <p> <mark>ALL_COMPLETED</mark> - return when all futures are finished (Default) </p>
              <p> <mark>FIRST_COMPLETED</mark> - return the first future is finished </p>
              <p> <mark>FIRST_EXCEPTION</mark> - return the first future raises an exception </p>
            </div>
          </small>)
        </td>
        <td>
          - awaiting this coroutine will wait untill all <strong>task</strong>s are finished (or untill <small>timeout</small> by Default)<br>
          - the awaited result is a tuple (index <mark>0</mark> -> a set of finished futures) (index <mark>1</mark> -> a set of unfinished futures)
        </td>
      </tr>
      <tr class="20.01">
        <td>
          <em>asyncio</em>.as_completed([<strong>task</strong><i>, ...</i>], <small>timeout=<i>float</i></small>)
        </td>
        <td>
          - returns a <strong>genObj</strong> which yields <strong>tasks</strong> as soon as they finished (when we start iterating the <strong>genObj</strong>) (does not block, this is not a coroutine)
        </td>
      </tr>
      <tr class="25.01">
        <td>
          <em>asyncio</em>.to_thread(<strong>fn</strong>, <i>arg1, ...</i>)
        </td>
        <td>
          - runs the passed <strong>fn</strong> in a separate thread <br>
          - returns a coroutine which awaited result is the returned value of <strong>fn</strong>
          <span class="browserSupport" title="updated : 2022-10-19">
            <span><i class="fab fa-python"></i> 3.9 </span>
          </span>
        </td>
      </tr>
      <tr class="30.01">
        <td>
          <em>asyncio</em>.iscoroutinefunction(<strong>fn</strong>)
        </td>
        <td>
          - returns <mark>True</mark> if the passed <strong>fn</strong> is a coroutine funciton (async function), <mark>False</mark> otherwise
        </td>
      </tr>
      <tr class="30.02">
        <td>
          <em>asyncio</em>.iscoroutine(<strong>obj</strong>)
        </td>
        <td>
          - returns <mark>True</mark> if the passed <strong>obj</strong> is a coroutine object, <mark>False</mark> otherwise
        </td>
      </tr>
      <tr class="30.03">
        <td>
          <em>asyncio</em>.isfuture(<strong>obj</strong>)
        </td>
        <td>
          - returns <mark>True</mark> if the passed <strong>obj</strong> is a <strong>task</strong> or <strong>future</strong>, <mark>False</mark> otherwise
        </td>
      </tr>
      <tr class="35.01">
        <td colspan="2"> Tasks </td>
      </tr>
      <tr class="40.01">
        <td>
          <em>asyncio</em>.create_task(<strong>coro()</strong>, <small>name=<i>str</i></small>)
        </td>
        <td>
          - creates and returns a <strong>task</strong> (starts executing <strong>coro()</strong> in the background) <br>
          - the returned <strong>task</strong> can be awaited later on for the <strong>coro</strong> result
          <span class="browserSupport" title="updated : 2022-10-19">
            <span><i class="fab fa-python"></i> before 3.7 <mark>asyncio.encure_future()</mark> </span>
            <span><i class="fab fa-python"></i> 3.8 <small>name</small> </span>
          </span>
        </td>
      </tr>
      <tr class="40.02">
        <td>
          <em>asyncio</em>.Task(<strong>coro()</strong>, <small>loop=<i>evLoop</i></small>, <small>name=<i>str</i></small>)
        </td>
        <td>
          - creates and returns a <strong>task</strong> (the passed <strong>coro</strong> starts running in the background) <u>(not recommended use <mark>asyncio.create_task()</mark> instead)</u>
        </td>
      </tr>
      <tr class="45.01">
        <td>
          <strong>task</strong>.cancel(<small>msg=<i>str</i></small>)
        </td>
        <td>
          - cancells the <strong>task</strong> execution, passes a <mark>CancelledError</mark> in the warped <strong>coro</strong>
        </td>
      </tr>
      <tr class="45.02">
        <td>
          <strong>task</strong>.cancelled()
        </td>
        <td>
          - returns <mark>True</mark> if the task is cancelled, <mark>False</mark> otherwise
        </td>
      </tr>
      <tr class="50.01">
        <td>
          <strong>task</strong>.result()
        </td>
        <td>
          - returns the result of the <u>already awaited</u> <strong>task</strong> (error raised if the task is not awaited)
        </td>
      </tr>
      <tr class="50.02">
        <td>
          <strong>task</strong>.exception()
        </td>
        <td>
          - returns the exception message of the <u>already awaited</u> <strong>task</strong>, return <mark>None</mark> if the <strong>task</strong> did not raised any exception
        </td>
      </tr>
      <tr class="55.01">
        <td>
          <strong>task</strong>.add_done_callback(<strong>fn</strong>)
        </td>
        <td>
          - adds a callback which is called when the <strong>task</strong> finshes<br>
          - the callback (<strong>fn</strong>) receives this <strong>task</strong> as its 1st argument
        </td>
      </tr>
      <tr class="55.02">
        <td>
          <strong>task</strong>.remove_done_callback(<strong>fn</strong>)
        </td>
        <td>
          - removes a previously added callback (<strong>fn</strong>) reference
        </td>
      </tr>
      <tr class="60.01">
        <td>
          <strong>task</strong>.get_name()
        </td>
        <td>
          - returns the name of the <strong>task</strong>
        </td>
      </tr>
      <tr class="60.02">
        <td>
          <strong>task</strong>.set_name()
        </td>
        <td>
          - sets the name of the <strong>task</strong>
        </td>
      </tr>
    </table>
    <br>
    <table class="table">
      <caption>
        Subprocess
        <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
      </caption>
      <tr>
        <th style="width:30%;"> Method / Property </th>
        <th> Description </th>
      </tr>
      <tr class="05.01">
        <td>
          <em>asyncio</em>.create_subprocess_shell(<strong>shellCmd</strong>, <small class="openable">stdin=<i>pipe</i>
            <div>
              <p> <mark>None</mark> - no stdin </p>
              <p> <mark>asyncio.subprocess.PIPE</mark> - stdin open (we can pass data through the <mark>communicate()</mark> method to this process) </p>
            </div>
          </small>, <small class="openable">stdout=<i>pipe</i>
            <div>
              <p> <mark>None</mark> - stdout linked to the parent process </p>
              <p> <mark>asyncio.subprocess.PIPE</mark> - stdout open (can read data through the <mark>communicate()</mark> method from this process) </p>
            </div>
          </small>, <small class="openable">stdout=<i>pipe</i>
            <div>
              <p> <mark>None</mark> - stderr linked to the parent process </p>
              <p> <mark>asyncio.subprocess.PIPE</mark> - stdout open (can read data through the <mark>communicate()</mark> method from this process) </p>
            </div>
          </small>, <small class="openable">limit=<i>int</i>
            <div>
              <p> - sets the buffer limit for <mark>StreamReader</mark> wrappers (<mark>strout</mark>, <mark>sterr</mark>)
              </div>
            </small>)
          </td>
          <td>
            - executes the <strong>shellCmd</strong> in <mark>sh</mark> shell, returns a <strong>subProcess</strong> object <br>
            - if any <small>stdin|stdout|stderr</small> is <mark>None</mark> (Default) that channel is linked to the parent process <br>
            - if any <small>stdin|stdout|stderr</small> is <mark>asyncio.subprocess.PIPE</mark> that channel is opened as a stream reader|writer (communication possible through <mark><strong>subProcess</strong>.communicate</mark>) <br>
            - <u>awaiting this coroutine does not wait the subprocess to finish (only awaits the supbrocess to spawn)</u>
          </td>
        </tr>
        <tr class="05.02">
          <td>
            <em>asyncio</em>.create_subprocess_exec(<strong>executable</strong>, <i>[execArg, ...]</i>, <small class="openable">stdin=<i>pipe</i>
              <div>
                <p> <mark>None</mark> - no stdin </p>
                <p> <mark>asyncio.subprocess.PIPE</mark> - stdin open (we can pass data through the <mark>communicate()</mark> method to this process) </p>
              </div>
            </small>, <small class="openable">stdout=<i>pipe</i>
              <div>
                <p> <mark>None</mark> - stdout linked to the parent process </p>
                <p> <mark>asyncio.subprocess.PIPE</mark> - stdout open (can read data through the <mark>communicate()</mark> method from this process) </p>
              </div>
            </small>, <small class="openable">stdout=<i>pipe</i>
              <div>
                <p> <mark>None</mark> - stderr linked to the parent process </p>
                <p> <mark>asyncio.subprocess.PIPE</mark> - stdout open (can read data through the <mark>communicate()</mark> method from this process) </p>
              </div>
            </small>, <small class="openable">limit=<i>int</i>
              <div>
                <p> - sets the buffer limit for <mark>StreamReader</mark> wrappers (<mark>strout</mark>, <mark>sterr</mark>)
                </div>
              </small>)
            </td>
            <td>
              - runs the <strong>executable</strong>, returns a <strong>subProcess</strong> object <br>
              - if any <small>stdin|stdout|stderr</small> is <mark>None</mark> (Default) that channel is linked to the parent process <br>
              - if any <small>stdin|stdout|stderr</small> is <mark>asyncio.subprocess.PIPE</mark> that channel is opened as a stream reader|writer (communication possible through <mark><strong>subProcess</strong>.communicate</mark>) <br>
              - <u>awaiting this coroutine does not wait the subprocess to finish (only awaits the supbrocess to spawn)</u>
            </td>
          </tr>
          <tr class="10.01">
            <td>
              <strong>subProcess</strong>.wait()
            </td>
            <td>
              - awaiting this coroutine will block untill the <strong>subProcess</strong> is terminated
            </td>
          </tr>

          <tr class="15.01">
            <td>
              <strong>subProcess</strong>.communicate(<small>input=<i>str</i></small>)
            </td>
            <td>
              - awaiting this coroutine will send an <small>input</small> to the <strong>subProcess</strong> (if <strong>supProcess</strong> was spawned with <small>stdin</small> <mark><mark>asyncio.subprocess.PIPE</mark></mark>)<br>
              - will return <mark>(<strong>stdout</strong> <strong>sterr</strong>)</mark> which are writable streams (if <strong>supProcess</strong> was spawned with <small>stdout</small> <small>stderr</small> <mark><mark>asyncio.subprocess.PIPE</mark></mark>)
            </td>
          </tr>
          <tr class="20.01">
            <td>
              <strong>subProcess</strong>.send_signal(<strong class="openable">signal<div>
                  <p> - ex: <mark>signal.SIGTERM</mark> </p>
                </div></strong>)
            </td>
            <td>
              - sends the specified <strong>signal</strong> to the subprocess
            </td>
          </tr>
          <tr class="20.02">
            <td>
              <strong>subProcess</strong>.terminate()
            </td>
            <td>
              - sends <mark>signal.SIGTERM</mark> on POSIX, calls <mark>TerminateProcess()</mark> on Windows on the process
            </td>
          </tr>
          <tr class="20.03">
            <td>
              <strong>subProcess</strong>.kill()
            </td>
            <td>
              - sends <mark>signal.SIGKILL</mark> on POSIX, calls <mark>TerminateProcess()</mark> on Windows on the process
            </td>
          </tr>
          <tr class="25.01">
            <td>
              <strong>subProcess</strong>.stdin
            </td>
            <td>
              - stdin of the process (writable stream if the process stdin was started with <mark>asyncio.subprocess.PIPE</mark>), <mark>None</mark> otherwise
            </td>
          </tr>
          <tr class="25.02">
            <td>
              <strong>subProcess</strong>.stdout
            </td>
            <td>
              - stdout of the process (writable stream if the process stdout was started with <mark>asyncio.subprocess.PIPE</mark>), <mark>None</mark> otherwise
            </td>
          </tr>
          <tr class="25.03">
            <td>
              <strong>subProcess</strong>.stderr
            </td>
            <td>
              - stderr of the process (writable stream if the process stderr was started with <mark>asyncio.subprocess.PIPE</mark>), <mark>None</mark> otherwise
            </td>
          </tr>
          <tr class="30.01">
            <td>
              <strong>subProcess</strong>.pid
            </td>
            <td>
              - returns the pid of the subprocess
            </td>
          </tr>
          <tr class="30.02">
            <td>
              <strong>subProcess</strong>.returncode
            </td>
            <td>
              - return the process' exit code when it exits, <mark>None</mark> if the process is still running
            </td>
          </tr>

          <tr class="35.01">
            <td>
              <em>asyncio</em>.subprocess.PIPE
            </td>
            <td>
              - can be used as <strong>stdin|stdout|stderr</strong> arguments in <mark>create_subprocess_shell()</mark> or <mark>create_subprocess_exec()</mark> to open writable|readable streams to the subprocess
            </td>
          </tr>
          <tr class="35.02">
            <td>
              <em>asyncio</em>.subprocess.STDOUT
            </td>
            <td>
              - can be used as <strong>stdinstderr</strong> argument in <mark>create_subprocess_shell()</mark> or <mark>create_subprocess_exec()</mark> in order to redirect the subprocess' stderr to stdout
            </td>
          </tr>
          <tr class="35.03">
            <td>
              <em>asyncio</em>.subprocess.STDOUT
            </td>
            <td>
              - can be used as <strong>stdin|stdout|stderr</strong> arguments in <mark>create_subprocess_shell()</mark> or <mark>create_subprocess_exec()</mark> redirect streams to <mark>os.devnull</mark>
            </td>
          </tr>
        </table>
        <br>
        <h2 class="headerSection"> Description and Demonstration </h2>
        <h2 class="headerSection"> Useful Links : </h2>
        <p><a href="https://docs.python.org/3/library/asyncio.html" target="_blank">asyncio (docs.python.org)</a></p>
        <p><a href="https://realpython.com/async-io-python/" target="_blank">async io (realpython.com)</a></p>
        <h2 class="headerSection"> Remember This : </h2>

        <h2 class="headerSection"> Description and Demonstration : </h2>
        <p> - asyncio allows us to run asynchronous code (single-threated, single-process design allowing tasks to run concurrently, gives the look and feel of concurrency) </p>
        <p> - asyncio is a light weight threading approach (mostly designed or non-blocking IO operations, as its name says asyncio) </p>
        <p> - python supports 3 awaitable object types: <mark class="mark">coroutines</mark>, <mark class="mark">tasks</mark>, <mark class="mark">futures</mark> </p>
        <p style="text-indent: 20px;"> - <mark class="mark">coroutine</mark> </p>
        <p style="text-indent: 40px;"> - async function or awaitable object </p>
        <p style="text-indent: 40px;"> - it's a generator under the hood (run/pause interface) </p>
        <p style="text-indent: 20px;"> - <mark class="mark">task</mark> </p>
        <p style="text-indent: 40px;"> - coroutine wrapper which <u>immediately starts running</u> its coroutine in the background when created, the returned task can be awaited for the result later on) </p>
        <p style="text-indent: 20px;"> - <mark class="mark">future</mark> </p>
        <p style="text-indent: 40px;"> - low-level awaitable object </p>
        <p> - python awaitables can have the following states: </p>
        <p style="text-indent: 40px;"> - <mark class="mark">Pending</mark> awaiting execution </p>
        <p style="text-indent: 40px;"> - <mark class="mark">Running</mark> execution started </p>
        <p style="text-indent: 40px;"> - <mark class="mark">Cancelled</mark> execution cancelled </p>
        <p style="text-indent: 40px;"> - <mark class="mark">Completed (Done/Resolved)</mark> execution successfully completed </p>
        <p> - if an exeption is raised in a corutine that starts to raise on the stack (like in normal functions) </p>
        <p> - supported features by <mark>ayncio</mark> module: </p>
        <p style="text-indent: 20px;"> - high level network connection tools <a href="https://docs.python.org/3/library/asyncio-stream.html" target="_blank">[link]</a></p>
        <p style="text-indent: 20px;"> - same race condition control tools as <mark>threading</mark> does <a href="https://docs.python.org/3/library/asyncio-sync.html" target="_blank">[link]</a> <a href="file:///home/apall/Documents/Pall/CodePlus/My%20Site/Python/Built-in%20Modules/threading/index.html#raceControl" target="_blank">[link]</a> </p>
        <p style="text-indent: 20px;"> - supports the same queue API as the <mark>queue</mark> does, however asyncio queues are not thread-safe and does not support any <mark>timeout</mark> arguments <a href="https://docs.python.org/3/library/asyncio-queue.html" target="_blank">[link]</a> <a href="file:///home/apall/Documents/Pall/CodePlus/My%20Site/Python/Built-in%20Modules/queue/index.html" target="_blank">[link]</a> </p>
        <p style="text-indent: 20px;"> - the build-in event-loop is abstracted behind the <mark>run()</mark> method, however <mark>asyncio</mark> also supports low-level event loop management tools <a href="https://docs.python.org/3/library/asyncio-eventloop.html" target="_blank">[link]</a> </p>
        <pre class="syntax">
    async def <strong>fnName</strong>():                 // creates and returns a <strong>coroutine</strong>
        <i>functionBody ...</i>
        await <strong>awaitable</strong>                 // awaits the <strong>coroutine</strong>'s result (only inside async function)    
        
        <i>raising exception</i>               // exceptions start raising on the stack (like in normal functions)
    
    
// looping over async resources ---------------------------------------
    async def <strong>genFn()</strong>:                  // asynchronous generator     <span id="browserSupport" style="color:yellow;" title="Updated: 2022-03-12"> <span><i class="fab fa-python"></i> 3.6 </span></span>
        <i>// awaiting resources</i>
        yield <strong>val</strong> 
        <i>...</i>
    
    async for <strong>item</strong> in <strong>genFn()</strong>           // sequential iteration over async source    
        <strong>item</strong>
    
    [<strong>item</strong> async for <strong>item</strong> in <strong>genFn()</strong>]    // async of comprehension    
    </pre>
        <details class="example">
          <summary> Example : </summary>
          <pre>
    import asyncio
    
    async def sayHi(name, delay, throw=False):       # coroutine
        await asyncio.sleep(delay)
        
        if throw:
            raise Exception('some exception')
        
        return f"{name} result"
    
    async def main():
        result = await asyncio.gather(sayHi('one', 1), sayHi('two', 1.5))     # starts both coroutines and awaits their results
        print( result )                  // -> ['one result', 'two result']
    
// ----------------------------------------------------------------    
        result2 = await asyncio.gather(
            sayHi('one', 3), 
            sayHi('two', 3.5), 
            sayHi('three', 2, True),
            return_exceptions=True)      # this corutine won't raise the propagated exception by any of the listed coroutines 
    
        print( result2 )                 // -> ['one result', 'two result', Exception('some exception')]    # execption returned in the list 
    
        # this corutine propagates the exception that raised by any of the listed coroutines
        result3 = await asyncio.gather(sayHi('one', 3), sayHi('two', 3.5), sayHi('three', 2, True))      // -> Exception: some exception    # exception raised by the corutine is propagated to this corutine
    
    asyncio.run(main())
    </pre>
          <h4 class="header"> Exceptions </h4>
          <pre>
    import asyncio
    
    
    async def coro():
        raise Exception('Some Error')           # exeption is raised on top (unelss handled)
    
    
    async def main():
        await coro()
    
    
    asyncio.run(main(), debug=True)
    </pre>
          <h4 class="header"> task </h4>
          <pre>
    import asyncio
    
    async def sayHi(name, delay):       # corutine
        await asyncio.sleep(delay)
        print( "Hello World!" )
        return f"{name} result"
    
    async def main():
        task1 = asyncio.create_task(sayHi('one', 1))          # once tasks are created immediately starts executing its corutine in the background   
        task2 = asyncio.create_task(sayHi('two', 1.5))
        
        print( await task1 )            // -> "one result"    # awaiting task results 
        print( await task2 )            // -> "two result"
    
    asyncio.run(main())
    
    
// -------------------------------------------------------------------------
    import asyncio
    
    async def someCoro(name, delay):
        await asyncio.sleep(delay)
        return f'coro {name} result'
    
    async def main():
        task1 = asyncio.Task(someCoro('one', 1.3))            # creating tasks like this is not recommended    
    
        print( await task1 )          // -> "coro one result"
    
    asyncio.run(main())
    </pre>
          <h4 class="header"> task name </h4>
          <pre>
    import asyncio
    
    async def someCoro(name, delay):
        await asyncio.sleep(delay)
        return f"{name} corutine result"
    
    async def main():
        task = asyncio.create_task(someCoro("one" ,1.3), name='myCoro')
    
        print( task.get_coro() )          // -> someCoro corutine object 
    
        print( task.get_name() )          // -> "myCoro"
        task.set_name('newCoroName')
        print( task.get_name() )          // -> "newCoroName"
    
    asyncio.run(main())
    </pre>
          <h4 class="header"> looping over async source </h4>
          <pre>
    import asyncio
    
    async def listGen():
        await asyncio.sleep(1)                # waiting for some source
        yield 1
        await asyncio.sleep(1)
        yield 2
        await asyncio.sleep(1)
        yield 3
    
    async def main():
        async for i in listGen():             # will not block the event loop
            print( i )                        // -> 1  |  2  |  3
    
        print( [i async for i in gen()] )     // -> [1, 2, 3]       # aysnc of comprehension 
    
    asyncio.run(main())
    </pre>
          <h4 class="header"> shielding task from cancellation <mark>asyncio.sheild()</mark> </h4>
          <pre>
    import asyncio
    
    async def sayHi():
        await asyncio.sleep(5)
        return 'some result'
    
    async def main():
        task1 = asyncio.create_task(sayHi())
        await asyncio.shield(task1)                 # shiled the task from cancellation
        
        task1.cancel()                              # ignored because the task in shielded
        
        print( await task1 )                        # // -> 'some result'
    
    asyncio.run(main())
    </pre>
          <h4 class="header"> <mark>wait_for()</mark>
            <h4>
              <pre>
    import asyncio
    
    async def sayHi():
        await asyncio.sleep(1)
        return 'some result'
    
    async def main():
        print( await asyncio.wait_for(sayHi(), timeout=2))        // -> "some result"
        print( await asyncio.wait_for(sayHi(), timeout=.1))       // -> asyncio.exceptions.TimeoutError
    
    asyncio.run(main())
    </pre>
              <h4 class="header"> awaiting multiple tasks <mark>asyncio.wait()</mark> </h4>
              <pre>
    import asyncio
    
    async def sayHi(name, delay):
        await asyncio.sleep(delay)
        return f"{name} result"
    
    async def main():
        task1 = asyncio.create_task(sayHi('one', 1))
        task2 = asyncio.create_task(sayHi('two', 2))
        task3 = asyncio.create_task(sayHi('three', 3))
        result = await asyncio.wait([task1, task2, task3])
    
        for i in result[0]:               # finished tasks
            print( await i )              // -> "two result"  |  "one result"  |  "three result"
    
    asyncio.run(main())
    </pre>
              <h4 class="header"> <mark>as_completed()</mark> </h4>
              <pre>
    import asyncio
    
    async def sayHi(name, delay):
        await asyncio.sleep(delay)
        return f"{name} result"
    
    async def main():
        task1 = asyncio.create_task(sayHi('one', 1))
        task2 = asyncio.create_task(sayHi('two', 2))
        task3 = asyncio.create_task(sayHi('three', 3))
        result = asyncio.as_completed([task1, task2, task3])
    
        for i in result:              # genObj yields the result as soon as they finished
            print( await i )          # // -> "one result"  |  "two result"  |  "three result"
    
    asyncio.run(main())
    </pre>
              <h4 class="header"> <mark>to_thread()</mark> </h4>
              <pre>
    import asyncio
    import time
    
    def blockingIo(name, delay):
        print( f'blocking io {name} start' )
        time.sleep(delay)
        print( f'blocking io {name} end!' )
    
        return 'blocking io result'
    
    async def main():
        print( await asyncio.to_thread(blockingIo, 'one', 1.2) )        // -> "blocking io result"
    
    asyncio.run(main())
    </pre>
              <h4 class="header"> <mark>add_done_callback()</mark> </h4>
              <pre>
    import asyncio
    
    async def someCoro(name, delay):
        await asyncio.sleep(delay)
        return f"{name} corutine result"
    
    def cb(task):
        print( task.result() )                          // -> "one corutine result"
    
    async def main():
        task = asyncio.Task(someCoro("one" ,1.3))
    
        task.add_done_callback(cb)
        # task.remove_done_callback(cb)                 # would remove cb
        
        await asyncio.sleep(3)                          # time to let the task finish
    
    asyncio.run(main())
    </pre>
              <h4 class="header"> type checking </h4>
              <pre>
    import asyncio
    
    async def test():
        return "OK"
    
    async def main():
        coro = test()
        task = asyncio.create_task(test())
        future = asyncio.Future()
        
        print( asyncio.iscoroutinefunction(test) )   // -> True
        print( asyncio.iscoroutine(coro) )           // -> True
        
        print( asyncio.isfuture(test) )              // -> False
        print( asyncio.isfuture(coro) )              // -> False
        print( asyncio.isfuture(task) )              // -> True
        print( asyncio.isfuture(future) )            // -> True
    
    asyncio.run(main())
    </pre>
            </details>
            <hr>
            <!----------------------------------------------------------------------------------------------->
            <h2 class="header"> Subprocesses </h2>
            <p> - <mark>asyncio</mark> provides tools for aysnchronously running subprocesses </p>
            <details class="example">
              <summary> Example : </summary>
              <pre>
    import asyncio
    
    async def main():
        await asyncio.create_subprocess_shell("ps")      # executes the command in shell, stdout and stderr are     linked to the parent process    
    
    asyncio.run(main())
    
    
// ----------------------------------------------------------------------------------
    import asyncio
    
    async def main():
        await asyncio.create_subprocess_exec('/usr/local/bin/python', 'test2.py')     # python executable
        
    asyncio.run(main())
    </pre>
              <p> - communication with the subprocess </p>
              <pre>
    import asyncio
    
    async def main():
        process = await asyncio.create_subprocess_shell('echo test',
            stdin=asyncio.subprocess.PIPE,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.STDOUT,     # stderr redirected to stdout
            limit=1
        )
    
        stdout, stderr = await process.communicate(input=b'some in data')     # data sent to proces in stdin
    
        print( stdout )                 // -> b'test\n'
    
        print( process.stdin )          // -> StreamWrite     # becasue of stdin=asyncio.subprocess.PIPE
    
        print( process.pid )            // -> 282       # process id 
        print( process.returncode )     // -> 0 
    
    asyncio.run(main())
    </pre>
              <p> - waiting for the process to finish </p>
              <pre>
    import asyncio
    
    async def main():
        process = await asyncio.create_subprocess_shell('sleep 3 ; echo "end" ')      # does not await the running code in the subprocess
        
        await process.wait()        # awaits the subprocess to finish
        
    asyncio.run(main())
    </pre>
            </details>

            <br><br>
          </body>

        </html>