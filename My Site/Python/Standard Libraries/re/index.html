<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title> re </title>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../../Assets/stylesPages.css">
    <script src="../../../Assets/scriptPages.js"></script>
  </head>

  <body>
    <h1> re </h1>
    <p> Updated ( 2022-06-15 )</p>
    <nav class="sitenav">
      <a href="../../../index.html">MySite > </a>
      <a href="../../index.html">Python > </a>
      <a href="../index.html">Standard Libraries > </a> re
    </nav>
    <table class="table">
      <caption>
        Regular Expressions
        <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
      </caption>
      <tr>
        <th style="width:30%;"> Pattern </th>
        <th> Description </th>
      </tr>
      <tr class="05.01">
        <td colspan="2">
          flags
        </td>
      </tr>
      <tr class="05.02">
        <td>
          <a href="https://docs.python.org/3/library/re.html#flags" target="_blank">flags</a>
        </td>
        <td>
          - flags link
        </td>
      </tr>
      <tr class="10.01">
        <td colspan="2">
          parentheses and operators
        </td>
      </tr>
      <tr class="10.02">
        <td>
          [<strong>char</strong>...]
        </td>
        <td>
          - any of the enclosed characters
        </td>
      </tr>
      <tr class="10.03">
        <td>
          [(<strong>char</strong>)...]
        </td>
        <td>
          - <strong>char</strong> lose its special meaning (ex: <mark>[(*)]</mark> matchers <mark>*</mark>)
        </td>
      </tr>
      <tr class="10.04">
        <td>
          [<strong>char</strong>-<strong>char</strong>]
        </td>
        <td>
          - character between the specified range (ex: <mark>[a-z]</mark>)
        </td>
      </tr>
      <tr class="10.05">
        <td>
          [^<strong>char</strong>...]
        </td>
        <td>
          - any except the enclosed characters
        </td>
      </tr>
      <tr class="10.06">
        <td>
          [^<strong>char</strong>-<strong>char</strong>]
        </td>
        <td>
          - any except character between the specified range (ex: <mark>[^a-z]</mark>)
        </td>
      </tr>
      <tr class="15.01">
        <td>
          (<strong>pattern</strong>)
        </td>
        <td>
          - regular expression group
        </td>
      </tr>
      <tr class="15.02">
        <td>
          (?#<strong>pattern</strong>)
        </td>
        <td>
          - comment = contents of the parentheses are ignored
        </td>
      </tr>
      <tr class="15.03">
        <td>
          <strong>pattern_A</strong>(?=<strong>pattern_B</strong>)
        </td>
        <td>
          - (positive lookahead) matches <strong>pattern_A</strong> if it's followed by <strong>pattern_B</strong>
        </td>
      </tr>
      <tr class="15.04">
        <td>
          <strong>pattern_A</strong>(?!<strong>pattern_B</strong>)
        </td>
        <td>
          - (negative lookahead) matches <strong>pattern_A</strong> if it it is not followed by <strong>pattern_B</strong>
        </td>
      </tr>
      <tr class="15.05">
        <td>
          (?&lt;=<strong>pattern_A</strong>)<strong>pattern_B</strong>
        </td>
        <td>
          - (positive lookbehind) matches <strong>pattern_B</strong> if it's preceded by <strong>pattern_B</strong>
        </td>
      </tr>
      <tr class="15.06">
        <td>
          (?&lt;!<strong>pattern_A</strong>)<strong>pattern_B</strong>
        </td>
        <td>
          - (negative lookbehind) matches <strong>pattern_B</strong> if it is not preceded by <strong>pattern_B</strong>
        </td>
      </tr>
      <tr class="20.01">
        <td>
          ^<strong>pattern</strong>
        </td>
        <td>
          - start of the string (with <mark>MULTILINE</mark> flag = after all newline character)
        </td>
      </tr>
      <tr class="20.02">
        <td>
          <strong>pattern</strong>$
        </td>
        <td>
          - end of the string (with <mark>MULTILINE</mark> flag = before all newline character)
        </td>
      </tr>
      <tr class="25.01">
        <td>
          <strong>pattern|()</strong>|<strong>pattern|()</strong>
        </td>
        <td>
          - left or right pattern or group (logical OR)
        </td>
      </tr>
      <tr class="30.01">
        <td colspan="2">
          metacharacters
        </td>
      </tr>
      <tr class="30.02">
        <td>
          .
        </td>
        <td>
          - all characters except newline (with <mark>DOTALL</mark> flag = all characters)
        </td>
      </tr>
      <tr class="30.03">
        <td>
          \<strong>char</strong>
        </td>
        <td>
          - escapes the following character (does not escapes <mark>\b</mark> word boundary = the <mark>\b</mark> is still interpreted as backspace character)
        </td>
      </tr>
      <tr class="35.01">
        <td>
          \A<strong>pattern</strong>
        </td>
        <td>
          - matches at the beginning of the string
        </td>
      </tr>
      <tr class="35.02">
        <td>
          <strong>pattern</strong>\Z
        </td>
        <td>
          - matches at the end of the string
        </td>
      </tr>
      <tr class="40.01">
        <td>
          \b<strong>pattern</strong><br>
          <strong>pattern</strong>\b
        </td>
        <td>
          - (word boundary) <strong>pattern</strong> matches at the start|end of each word
        </td>
      </tr>
      <tr class="40.02">
        <td>
          \B<strong>pattern</strong><br>
          <strong>pattern</strong>\B
        </td>
        <td>
          - (in word) <strong>pattern</strong> tested in each word (first|last character excluded)
        </td>
      </tr>
      <tr class="45.01">
        <td>
          \w
        </td>
        <td>
          - matches any word characters (<mark>a-zA-Z0-9_</mark>)
        </td>
      </tr>
      <tr class="45.02">
        <td>
          \W
        </td>
        <td>
          - matches any non word characters (<mark>a-zA-Z0-9_</mark>)
        </td>
      </tr>
      <tr class="45.03">
        <td>
          \d
        </td>
        <td>
          - matches any digit characters (<mark>0-9</mark>)
        </td>
      </tr>
      <tr class="45.04">
        <td>
          \D
        </td>
        <td>
          - matches any non digit characters (<mark>0-9</mark>)
        </td>
      </tr>
      <tr class="45.05">
        <td>
          \s
        </td>
        <td>
          - matches space characters (<mark> </mark> <mark>\f</mark> <mark>\n</mark> <mark>\r</mark> <mark>\t</mark> <mark>\v</mark> <mark>\u</mark>)
        </td>
      </tr>
      <tr class="45.06">
        <td>
          \S
        </td>
        <td>
          - matches non space characters (other than <mark> </mark> <mark>\f</mark> <mark>\n</mark> <mark>\r</mark> <mark>\t</mark> <mark>\v</mark> <mark>\u</mark>)
        </td>
      </tr>
      <tr class="50.01">
        <td colspan="2">
          quantifiers
        </td>
      </tr>
      <tr class="50.02">
        <td>
          <strong>pattern|()</strong>*
        </td>
        <td>
          - 0 or more representation of the preceding pattern or group
        </td>
      </tr>
      <tr class="50.03">
        <td>
          <strong>pattern|()</strong>+
        </td>
        <td>
          - 1 or more representation of the preceding pattern or group
        </td>
      </tr>
      <tr class="50.4">
        <td>
          <strong>pattern|()</strong>?
        </td>
        <td>
          - 0 or 1 representation of the preceding pattern or group
        </td>
      </tr>
      <tr class="55.01">
        <td>
          <strong>pattern|()</strong>{<strong>nr:int</strong>}
        </td>
        <td>
          - exactly <strong>nr</strong> times
        </td>
      </tr>
      <tr class="55.02">
        <td>
          <strong>pattern|()</strong>{<strong>nr:int</strong>,<strong>nr:int</strong>}
        </td>
        <td>
          - between the specified range <strong>nr</strong> to <strong>nr</strong> times <u>(there's now space after the comman)</u>
        </td>
      </tr>
      <tr class="55.03">
        <td>
          <strong>pattern|()</strong>{<strong>nr:int</strong>,}
        </td>
        <td>
          - at least <strong>nr</strong> times
        </td>
      </tr>
      <tr class="60.01">
        <td>
          <strong>pattern|()</strong>.<strong>quantifier</strong>?
        </td>
        <td>
          - (non-greedy match) quantifier matches as few times as possible
        </td>
      </tr>
    </table>
    <br>
    <table class="table">
      <caption>
        Methods
        <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
      </caption>
      <tr>
        <th style="width:30%;"> Method </th>
        <th> Description </th>
      </tr>
      <tr class="05.01">
        <td>
          <em>re</em>.compile(<strong>pattern:str</strong>, <small class="openable">flags=<i>0</i>
            <div>
              <p> - <a href="https://docs.python.org/3/library/re.html#flags" target="_blanc">flag list [link]</a></p>
              <p> <mark>re.I | re.S | re.M</mark> <- to specify multiple flags </p>
            </div>
          </small>)
        </td>
        <td>
          - compiles the passed pattern into a <strong>rePattern</strong> regular expression pattern object
        </td>
      </tr>
      <tr class="10.01">
        <td>
          <strong>rePattern</strong>.pattern
        </td>
        <td>
          - returns the original string from which the <strong>rePattern</strong> was compiled
        </td>
      </tr>
      <tr class="10.02">
        <td>
          <strong>rePattern</strong>.groups
        </td>
        <td>
          - returns how many regExp groups the pattern contains
        </td>
      </tr>
      <tr class="15.01">
        <td>
          <em>re</em>.search(<strong>rePattern:str</strong>, <strong>str</strong>, <small class="openable">flags=<i>0</i>
            <div>
              <p> - <a href="https://docs.python.org/3/library/re.html#flags" target="_blanc">flag list [link]</a></p>
              <p> <mark>re.I | re.S | re.M</mark> <- to specify multiple flags </p>
            </div>
          </small>)<br>
          <strong>rePattern</strong>.search(<strong>str</strong>, <i>stIdx(inc)</i>, <i>endIdx(exc)</i>)
        </td>
        <td>
          - searches for the 1st match in the string, returns a <strong>matchObj</strong> on successful match, return <mark>None</mark> on failed match
        </td>
      </tr>
      <tr class="15.02">
        <td>
          <em>re</em>.match(<strong>rePattern:str</strong>, <strong>str</strong>, <small class="openable">flags=<i>0</i>
            <div>
              <p> - <a href="https://docs.python.org/3/library/re.html#flags" target="_blanc">flag list [link]</a></p>
              <p> <mark>re.I | re.S | re.M</mark> <- to specify multiple flags </p>
            </div>
          </small>)<br>
          <strong>rePattern</strong>.match(<strong>str</strong>, <i>stIdx(inc)</i>, <i>endIdx(exc)</i>)
        </td>
        <td>
          - searches right at the start of the string for a match, returns a <strong>matchObj</strong> on successful match, return <mark>None</mark> on failed match<br>
          - does the same as <mark>re.search()</mark> but only starts the search at <mark>0</mark> index in the string <u>does not searches any further even with the <mark>MULTILINE</mark> flag</u>
        </td>
      </tr>
      <tr class="20.01">
        <td>
          <em>re</em>.fullmatch(<strong>rePattern:str</strong>, <strong>str</strong>, <small class="openable">flags=<i>0</i>
            <div>
              <p> - <a href="https://docs.python.org/3/library/re.html#flags" target="_blanc">flag list [link]</a></p>
              <p> <mark>re.I | re.S | re.M</mark> <- to specify multiple flags </p>
            </div>
          </small>) <br>
          <strong>rePattern</strong>.fullmatch(<strong>str</strong>, <i>stIdx(inc)</i>, <i>endIdx(exc)</i>)
        </td>
        <td>
          - returns a <strong>matchObj</strong> if the regExp pattern matches the whole string, returns <mark>None</mark> otherwise
        </td>
      </tr>
      <tr class="25.01">
        <td>
          <em>re</em>.split(<strong>rePattern:str</strong>, <strong>str</strong>, <small class="openable">maxsplit=<i>0</i>
            <div>
              <p> maximum number of splits (the rest is returned together as last part) </p>
            </div>
          </small>, <small class="openable">flags=<i>0</i>
            <div>
              <p> - <a href="https://docs.python.org/3/library/re.html#flags" target="_blanc">flag list [link]</a></p>
              <p> <mark>re.I | re.S | re.M</mark> <- to specify multiple flags </p>
            </div>
          </small>)<br>
          <strong>rePattern</strong>.split(<strong>str</strong>,<small class="openable">maxsplit=<i>0</i>
            <div>
              <p> maximum number of splits (the rest is returned together as last part) </p>
            </div>
          </small>)
        </td>
        <td>
          - splits the <strong>str</strong> at specified <strong>rePattern</strong> and returns the splited parts in a list (matched <strong>rePattern</strong> part excluded)<br>
          - if <strong>rePattern</strong> contains a regExp group then <strong>rePattern</strong> parts also included in the result
        </td>
      </tr>
      <tr class="30.01">
        <td>
          <em>re</em>.findall(<strong>rePattern:str</strong>, <strong>str</strong>, <small class="openable">flags=<i>0</i>
            <div>
              <p> - <a href="https://docs.python.org/3/library/re.html#flags" target="_blanc">flag list [link]</a></p>
              <p> <mark>re.I | re.S | re.M</mark> <- to specify multiple flags </p>
            </div>
          </small>)<br>
          <strong>rePattern</strong>.findall(<strong>str</strong>, <i>stIdx(inc)</i>, <i>endIdx(exc)</i>)
        </td>
        <td>
          - returns all non overlapping <strong>rePattern:str</strong> matches in a list
        </td>
      </tr>
      <tr class="30.02">
        <td>
          <em>re</em>.finditer(<strong>rePattern:str</strong>, <strong>str</strong>, <small class="openable">flags=<i>0</i>
            <div>
              <p> - <a href="https://docs.python.org/3/library/re.html#flags" target="_blanc">flag list [link]</a></p>
              <p> <mark>re.I | re.S | re.M</mark> <- to specify multiple flags </p>
            </div>
          </small>)<br>
          <strong>rePattern</strong>.finditer(<strong>str</strong>, <i>stIdx(inc)</i>, <i>endIdx(exc)</i>)
        </td>
        <td>
          - returns an iterator object all non overlapping <strong>rePattern:str</strong> matches (each iterator item is a <strong>matchObj</strong>)
        </td>
      </tr>
      <tr class="35.01">
        <td>
          <em>re</em>.sub(<strong>rePattern:str</strong>, <strong>rep:str|fn</strong>, <strong>str</strong>, <small class="openable">count=<i>0</i>
            <div>
              <p> - maximum number of occurences to replace (<mark>0</mark> = replace all) </p>
            </div>
          </small>, <small class="openable">flags=<i>0</i>
            <div>
              <p> - <a href="https://docs.python.org/3/library/re.html#flags" target="_blanc">flag list [link]</a></p>
              <p> <mark>re.I | re.S | re.M</mark> <- to specify multiple flags </p>
            </div>
          </small>)<br>
          <strong>rePattern</strong>.sub(<strong>rep:str</strong>, <strong>str</strong>, <small class="openable">count=<i>0</i>
            <div>
              <p> - maximum number of occurences to replace (<mark>0</mark> = replace all) </p>
            </div>
          </small>)
        </td>
        <td>
          - each <strong>rePattern</strong> matches in the <strong>str</strong> is replaces by <strong>rep</strong> and the result is returned in a new string
        </td>
      </tr>
      <tr class="35.02">
        <td>
          <em>re</em>.subn(<strong>rePattern:str</strong>, <strong>rep:str|fn</strong>, <strong>str</strong>, <small class="openable">count=<i>0</i>
            <div>
              <p> - maximum number of occurences to replace (<mark>0</mark> = replace all) </p>
            </div>
          </small>, <small class="openable">flags=<i>0</i>
            <div>
              <p> - <a href="https://docs.python.org/3/library/re.html#flags" target="_blanc">flag list [link]</a></p>
              <p> <mark>re.I | re.S | re.M</mark> <- to specify multiple flags </p>
            </div>
          </small>)<br>
          <strong>rePattern</strong>.subn(<strong>rep:str</strong>, <strong>str</strong>, <small class="openable">count=<i>0</i>
            <div>
              <p> - maximum number of occurences to replace (<mark>0</mark> = replace all) </p>
            </div>
          </small>)
        </td>
        <td>
          - each <strong>rePattern</strong> matches in the <strong>str</strong> is replaces by <strong>rep</strong> and the result is returned in a tuple <mark>(<strong>newStr</strong>, <strong>numberOfReplacements:int</strong>)</mark>
        </td>
      </tr>
      <tr class="40.01">
        <td>
          <em>re</em>.purge()
        </td>
        <td>
          - clears the regExp cache
        </td>
      </tr>
      <tr class="45.01">
        <td colspan="2">
          The match object
        </td>
      </tr>
      <tr class="45.02">
        <td>
          <strong>matchObj</strong>
        </td>
        <td>
          - always evaluates Truthy, , it has all sorts of methods that are mostly useful for regExp groups <a href="https://docs.python.org/3/library/re.html#match-objects" target="_blanc">[link]</a>
        </td>
      </tr>

    </table>
    <br>
    <h2 class="headerSection"> Description and Demonstration </h2>
    <h2 class="headerSection"> Useful Links : </h2>
    <p><a href="https://docs.python.org/3/library/re.html" target="_blank"> re (docs.python.org) </a></p>
    <p><a href="https://docs.python.org/3/library/re.html#flags" target="_blank"> regular expression flags (docs.python.org)</a></p>
    <h2 class="headerSection"> Remember This : </h2>
    <p> - in regExp pattern the <mark>\b</mark> (backspace) conflict with <mark>\b</mark> (word boundary) metacharacter, so if we want to use the <mark>\b</mark> as word boundary metacharacter we have to unescape it (ex: <mark>'\\b&lt;word&gt;'</mark> or <mark>r'\b&lt;word&gt;'</mark>) </p>
    <h2 class="headerSection"> Description and Demonstration : </h2>
    <p> - the <mark>re</mark> module provides 2 ways to use regula rexpressions: </p>
    <p style="text-indent: 25px;"> 1) precompile a regExp pattern then use methods on it (ex: <mark>pattern = re.compile('test') ; pattern.search('test')</mark>) </p>
    <p style="text-indent: 25px;"> 2) directly using regExp methods (the regExp pattern is compiled every time) (ex: <mark>re.search('test', 'test')</mark>) </p>
    <details class="example">
      <summary> DEMO </summary>
      <p> - regular expression examples </p>
      <pre>
    import re
    
// quantifiers -------------------------------------------------------------------
    re.findall('t+', 'ttttt')                                             // -> ['ttttt']
    re.findall('t+?', 'ttttt')                                            // -> ['t', 't', 't', 't', 't',]       // non-greedy (matches as few times as possible)
    
    re.findall('t{2}', 'ttttt')                                           // -> ['tt', 'tt']                     // exactly 2 times 
    re.findall('t{1,3}', 'ttttt')                                         // -> ['ttt', 'tt']                    // from 1 to 3 times 
    re.findall('t{1,}', 'ttttt')                                          // -> ['ttttt']                        // at least once    
    
    
// metacharacters ----------------------------------------------------------------
    re.findall('\btest', 'test test')                                     // -! the <mark>\b</mark> does not work as word boundary => interpreted as backspace character
    re.findall('\\btest', 'test test')                                    // -> ['test', 'test']      // -! unescape the <mark>\b</mark> to use as word boundary 
    re.findall(r'\btest', 'test test')                                    // -> ['test', 'test']
    
    
// lookahead / lookbehind --------------------------------------------------------
    re.findall('test(?= )', 'test ')                                      // -> ['test']                         // 'test' is followed by ' '
    re.findall('test(?! )', 'test')                                       // -> ['test']                         // 'test' is not followed by ' '

    re.findall('(?&lt;= )test', ' test')                                     // -> ['test']                         // 'test' is preceded by ' '
    re.findall('(?&lt;! )test', 'test')                                      // -> ['test']                         // 'test' is not preceded by ' '
    </pre>
      <p> - the match object </p>
      <pre>
    import re
    
    reg = re.compile('test')
    
    if reg.match('test'):
        print( 'regExp method matched!' )       // printed because <mark>reg.match('test')</mark> returns a Truthy match object 
    
    if reg.match('_test'):
        print( 'regExp method matched!' )       // not printed because <mark>reg.match('_test')</mark> returns <mark>None</mark> 
    </pre>
      <p> - compiled VS compile for match </p>
      <pre>
    import re
    
    reg = re.compile('test')                // precompiled regExp object can be reused    
    reg.match('test')
    reg.match('test')
    
    if re.match('test', 'test'):            // compiles at every test 
    if re.match('test', 'test'):            // compiles at every test 
    </pre>
      <p> - <mark>search()</mark> VS <mark>match()</mark> </p>
      <pre>
    re.search('test', ' test')          // returns a Truthy match object (because the search starts from any index) 
    
    re.match('test', ' test')           // returns None (because the search start from 0 index)
    re.match('test', 'test')            // returns a Truthy match object (match at 0 index)
    </pre>
      <p> - <mark>split()</mark> </p>
      <pre>
    re.split(' ', 'test1 test2 test3 test4')      // -> ['test1', 'test2', 'test3', 'test4']    // parts are returned (split pattern excluded)
    re.split('( )', 'test1 test2 test3 test4')    // -> ['test1', ' ', 'test2', ' ', 'test3', ' ', 'test4']    // parts are returned (split pattern included because regExp group used)
    </pre>
      <p> - <mark>findall()</mark> VS <mark>finditer()</mark> </p>
      <pre>
    import re
    
    re.findall('t', 'test1 test2 test3 test4')                      // -> ['t', 't', 't', 't', 't', 't', 't', 't']  // all matches returned in a list 
    
    for i in re.finditer('t', 'test1 test2 test3 test4'):           // does the same as <mark>findall()</mark> but returns the result in an interator object 
        i                                                           // -> match object for the current match 
    </pre>
      <p> - <mark>sub()</mark> </p>
      <pre>
    re.sub('\W', '-|-', 'test test test')                           // -> 'test-|-test-|-test'      // replaces all regExp <mark>\W</mark> matches in the string by <mark>-|-</mark>    
    
    def replace(pattern):
        return '-|-'
    
    re.sub('\W', replace, 'test test test')                         // -> 'test-|-test-|-test'      // we can pass a function instead of a replace string 
    </pre>
      <p> - regular expression pattern object </p>
      <pre>
    import re
    
    regExp = re.compile('\W')
    
    print( regExp.search('test ') )                     // -> match object    
    print( regExp.match(' test') )                      // -> match object    
    print( regExp.fullmatch(' ') )                      // -> match object    
    
    print( regExp.split('test test') )                  // -> ['test', 'test']
    
    print( regExp.findall('test test test') )           // -> [' ', ' ']
    
    for i in regExp.finditer('test test test'):
        print( i )                                      // -> match object for each match 
    
    print( regExp.sub('-', 'test-test-test') )          // -> 'test-test-test'
    print( regExp.subn('-', 'test-test-test') )         // -> ('test-test-test', 2)
    </pre>
    </details>

    <br><br>
  </body>

</html>