<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title> Modules </title>
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css"
    integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <link rel="stylesheet" href="../../Assets/stylesPages.css">
  <script src="../../Assets/scriptPages.js"></script>
</head>

<body>
  <h1> Modules </h1>
  <p> Updated: ( 2022-03-23 / 2025-03-11 )</p>
  <nav class="sitenav">
    <a href="../../index.html">MySite > </a>
    <a href="../index.html">Python > </a> Modules
  </nav>
  <table class="table">
    <tr>
      <th style="width:30%;"> Attribute / Method </th>
      <th> Description </th>
    </tr>
    <tr>
      <td>
        __name__
      </td>
      <td>
        - returns the module's name (filename) (in main modules this is always <mark>__main__</mark>)
      </td>
    </tr>
    <tr>
      <td>
        __file__
      </td>
      <td>
        - returns the absolute path of this file
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        importlib.reload(<strong>modulePath</strong>)
      </td>
      <td>
        - explicitly imports the specified module (even if the module is already imported) (<mark>importlib</mark> is a standard (built in) module)
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr id="path">
      <td>
        sys.path
      </td>
      <td>
        - settable <strong>list</strong> which contains directory paths where python will search for modules (<mark>sys</mark> is a standard (built in) module)
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        __all__ = [<strong>varName:str</strong>, <i>...</i> ]
      </td>
      <td>
        - lists variables that will be exported when the importing module uses the <mark>from <strong>modulePath</strong> import *</mark> syntax <br>
        - when the importing module uses the <mark>from <strong>modulePath</strong> import <strong>var</strong></mark> or <mark>import <strong>modulePath</strong></mark> syntax this has no effect at all
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td colspan="2"> Import statement </td>
    </tr>
    <tr>
      <td>
        import <strong class="openable">modulePath<div>
            <strong>dir|file</strong>.<i>dir|file</i>.<i>...</i>
            <p> - path resolution start from one of the listed directory path in <mark>sys.path</mark> </p>
          </div></strong><i>, ...</i> <small>[as <i>alias</i>]</small>
      </td>
      <td>
        - imports the specified file or directory in the current module <br>
        - on multiple import only the last imported module can be aliased <br>
        - if <strong>modulePath</strong> is a <mark>.py</mark> file, that file is imported as python module <br>
        - if <strong>modulePath</strong> is a directory, python will search for a <mark>__init__.py</mark> in that
        directory which will be loaded (as <span class="openable">regular package<div>
            <p> basically the <mark>__init__.py</mark> global variables are imported </p>
          </div></span>)
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        from <strong class="openable">modulePath<div>
            <strong>dir|file</strong>.<i>dir|file</i>.<i>...</i>
            <p> - path resolution start from one of the listed directory path in <mark>sys.path</mark> </p>
            <hr>
            <p> .<strong>dir|file</strong>.<i>dir|file</i>.<i>...</i> (<mark>.</mark> => current directory /
              <mark>..</mark> => parnet directory / etc...)
            </p>
            <p> - relative path can be used from modules that are located <u>1 level lower</u> than the entry
              (<mark>__main__</mark>) module </p>
            <p> - relative paths cannot target files|directories that are located <u>higher or at the same level</u> as
              the entry module is located </p>
          </div></strong> import <strong>var <small>[as <i>alias</i>]</small>, <i>...</i>
      </td>
      <td>
        - imports specified variables from the targeted file or directory in the current module<br>
        - if <strong>modulePath</strong> is a <mark>.py</mark> file, that file is imported as python module <br>
        - if <strong>modulePath</strong> is a directory, python will search for a <mark>__init__.py</mark> in that directory which will be loaded (as <span class="openable">regular package<div>
            <p> basically the <mark>__init__.py</mark> global variables are imported </p>
          </div></span>)
      </td>
    </tr>
    <tr>
      <td>
        from <strong class="openable">modulePath<div>
            <strong>dir|file</strong>.<i>dir|file</i>.<i>...</i>
            <p> - path resolution start from one of the listed directory path in <mark>sys.path</mark> </p>
            <hr>
            <p> .<strong>dir|file</strong>.<i>dir|file</i>.<i>...</i> (<mark>.</mark> => current directory /
              <mark>..</mark> => parnet directory / etc...)
            </p>
            <p> - relative path can be used from modules that are located <u>1 level lower</u> than the entry
              (<mark>__main__</mark>) module </p>
            <p> - relative paths cannot target files|directories that are located <u>higher or at the same level</u> as
              the entry module is located </p>
          </div></strong> import *
      </td>
      <td>
        - imports all variables from the targeted file or directory and declares them in the current module's global scope <u>(variables starting with an <mark>_</mark> not imported)</u> <br>
        - <u>on name confclit the imported variable overwrites the local one</u> <br>
        - this syntax is not supported as dynamic import
      </td>
    </tr>
  </table>
  <br>
  <table class="table">
    <caption>
      CLI
    </caption>
    <tr>
      <th style="width:30%;"> Attribute / Method </th>
      <th> Description </th>
    </tr>
    <tr>
      <td>
        <em>export</em> PYTHONDONTWRITEBYTECODE=1
      </td>
      <td>
        - (environment variable) prevent python instances in this shell to create <mark>__pycache__</mark> folder for its modules
      </td>
    </tr>
    <tr>
      <td>
        <em>python</em> -B <strong>pyFile.py</strong>
      </td>
      <td>
        - (flag) prevents this python instance to create <mark>__pycache__</mark> folder for its modules
      </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
      <td>
        <em>export</em> PYTHONPATH=<i>absPath:...</i>
      </td>
      <td>
        - (environment variable) sets module paths that will be prepended (at the beginning) on the <mark>sys.path</mark> for module path resolution
      </td>
    </tr>
  </table>
  <br>
  <details class="example" id="notes">
    <summary> Notes :</summary>
    <!-- <p> - paragraph removes the 'empty' message from the detail TAG -->
  </details>
  <h2 style="color:green;"><u> Useful Links : </u></h2>
  <p> <a href="https://docs.python.org/3/tutorial/modules.html" target="_blank">Python Modules (docs.python.org)</a></p>
  <h2 style="color:green;"><u> Remember This : </u></h2>
  
  <h2 style="color:green;"><u> Description and Demonstration : </u></h2>
  <p> - Python can load <mark>.py</mark> files and directories as modules, the module name will be the file or directory name, except the main module whose name is <mark>__main__</mark> (the very first module that start the program) </p>
  <p> - Python supports dynamic modules loading </p>
  <p> - the imported module's entire global scope is imported along with its variables in the importing module (there are not explicit export or private variables here) </p>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
// main.py (file) ---------------------------------------------------------------------
// ------------------------------------------------------------------------------------
    import module1 
    
    module1.a                                                                          // -> 21                  // the imported module's all global variables are available here   
    module1.b                                                                          // -> 22
    
    def importModule():
        import module2                                                                 // module dynamically imported   
    
        module1.a                                                                      // -> 201                 // the imported module's all global variables are available here   
        module2.y                                                                      // -> 202
    
        // -------------------------------------
        from module2 import x, y                                                      // the <mark>from... import</mark> also works  
        from module2 import *                                                         // -! raises a <mark>SyntaxError</mark> because the <mark>*</mark> is not allowed for relative imports  
    
    importModule()
    
    
// module1.py (file) ------------------------------------------------------------------
// ------------------------------------------------------------------------------------
    a = 21                                                                             // global variables 
    b = 22
    
    
// module2.py (file) ------------------------------------------------------------------
// ------------------------------------------------------------------------------------
    x = 201                                                                            // global variables 
    y = 202 
    </pre>
  </details>
  <!---------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="header"><u> Public / Private module variables </u></h2>
  <!---------------------------------------------------------------------------------------------->
  <p> - in Python modules all variables are public, but there's a naming convertion used to consider variables are
    private (used within this module) </p>
  <pre class="syntax">
    <strong>varname = val</strong>                                                                      // public variable 
    <strong>_varname = val</strong>                                                                     // weak private variable <u>(just naming convertion -> available publicly)</u>    
    <strong>__varname = val</strong>                                                                    // private variable <u>(just naming convertion -> available publicly)</u>    
    </pre>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
    import module1
    
    print( module1.public_var )                                                        // -> 'public'
    print( module1._weak_private_var )                                                 // -> 'weak private'
    print( module1.__private_var )                                                     // -> 'private'
    
    
// <mark>module1.py</mark> (file) ------------------------------------------------------------------
// ------------------------------------------------------------------------------------
    public_var = 'public'                                                              // public variable    
    _weak_private_var = 'weak private'                                                 // considered weak private variable but available publicly    
    __private_var = 'private'                                                          // considered private variable but available publicly    
    </pre>
  </details>
  <hr>
  <h2 class="header"><u> The <mark>__name__</mark> / <mark>__file__</mark> / <mark>__all__</mark> attributes </u></h2>
  <details class="example">
    <summary> DEMO </summary>
    <pre>
// main.py (file) ---------------------------------------------------------------------
// ------------------------------------------------------------------------------------
    import module1 
    import module2 
    
    __name__                                                                           // -> '__main__'          // -! the main module name is always <mark>__main__</mark>
    __file__                                                                           // -> '/workdir/main.py'  // absolute path of this file  
    
    
// module1.py (file) ------------------------------------------------------------------
// ------------------------------------------------------------------------------------
    __name__                                                                           // -> 'module1'
    __file__                                                                           // -> '/workdir/module1.py'
    
    
// module2.py (file) ------------------------------------------------------------------
// ------------------------------------------------------------------------------------
    __name__                                                                           // -> 'module2'
    __file__                                                                           // -> '/workdir/module2.py'
    </pre>
    <p> - <mark>__all__</mark> </p>
    <pre>
// main.py (file) ---------------------------------------------------------------------
// ------------------------------------------------------------------------------------
    from module1 import *                                                              // the <mark>__all__</mark> attribute in the exporting module is valid only for this import syntax 
    
    x                                                                                  // -> 21
    y                                                                                  // -> 22
    x                                                                                  // -! raises a <mark>NameError</mark> because the <mark>x</mark> variable is not imported in this case 
    
    
    from module1 import x, y, z                                                        // other import statements ignore the <mark>__all__</mark> attribute in the exporting module   
    import module1 
    
    x                                                                                  // -> 21
    y                                                                                  // -> 22
    x                                                                                  // -> 23
    
    module1.x                                                                          // -> 21
    module1.y                                                                          // -> 22
    module1.z                                                                          // -> 23
    
    
// module1.py (file) ------------------------------------------------------------------
// ------------------------------------------------------------------------------------
    x = 21
    y = 22
    z = 23
    
    __all__ = ['x', 'y']                                                               // only the <mark>x</mark> and <mark>y</mark> variables are exported when the <mark>from &lt;modulePath&gt; import *</mark> import syntax is used by the importing module   
    </pre>
  </details>
  <!---------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="header"><u> Module caching, <mark>importlib.reload()</mark> / <mark>PYTHONDONTWRITEBYTECODE</mark>
      environment variable / <mark>-B</mark> CLI flag </u></h2>
  <p> - Python caches loaded modules in the <mark>__pycache__</mark> directory where modules are located </p>
  <p> - once the module is loaded never imported again, if we want to explicitly import the module we can use
    <mark>importlib.reload()</mark>
  </p>
  <p> - if we want to prevent the creation of <mark>__pycache__</mark> directories we can use the
    <mark>PYTHONDONTWRITEBYTECODE=1</mark> environment variable or start python with <mark>-B</mark> flag
  </p>
  <pre class="syntax">
    <strong>python_module_directory</strong>
        |- __pycache__                                                                 // directory where modules are cached in the current folder (modules are cached in binary format)    
        |- <strong>module</strong>.py 
        |- <i>..</i>
    </pre>
  <details class="example">
    <summary> DEMO </summary>
    <pre class="cmd">
// PYTHONDONTWRITEBYTECODE ------------------------------------------------------------
    $ export PYTHONDONTWRITEBYTECODE=1                                                 // python starting in this shell won't create <mark>__pycache__</mark> directories for its modules   
    $ python test.py
    
    
//  -B (flag) -------------------------------------------------------------------------
    $ python -B test.py                                                                // this python instance won't create <mark>__pycache__</mark> directories for its modules    
    </pre>
    <p> - <mark>importlib.reload()</mark> </p>
    <pre>
    import pyModules.module1 
    import pyModules.module1                                                           // module won't be imported again 
    import pyModules.module1 
    
    import importlib
    
    importlib.reload(pyModules.module1)                                                // forces the module loader to import the module again  
    </pre>
    <pre class="cmd">
    $ python -B test.py
      Hello from module1
      Hello from module1                                                               // the <mark>importlib.reload()</mark> forces the module loader to import the module again    
    </pre>
  </details>
  <!---------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="header"><u> Module path resolution <mark>sys.path</mark> / <mark>PYTHONPATH</mark> </u></h2>
  <p> - on module import Python first check if the module is a standard (built in) module (like <mark>sys</mark>), then
    searches the <mark>sys.path</mark> list</p>
  <p> - the <mark>sys.path</mark> contains a settabe lists of directory paths where python searches for modules (the
    first found module is imported)</p>
  <p> - directory paths (value) of the <mark>PYTHONPATH</mark> environment variable is automatically added to the
    <mark>sys.path</mark> (at the beginning)
  </p>
  <p> - the <mark>__main__</mark> module directory path is also automatically added to the <mark>sys.path</mark> (always
    the first directory search path) </p>
  <details class="example">
    <summary> DEMO </summary>
    <pre class="cmd">
    $ export PYTHONPATH='/workdir/pyModules:/workdir/pyModules/subModules'             // adds directory paths to the <mark>sys.path</mark>   
    </pre>
    <pre>
    import sys                                                                         // imports the standard <mark>sys</mark> module     // -! the <mark>sys.py</mark> module in the current directory never imported because Python searches standard modules first   
    import pyModules.sys                                                               // however we can import a nested <mark>./pyModules/sys.py</mark> module like this 
    
    sys.path                                                                           // -> ['/workdir', '/workdir/pyModules', '/workdir/pyModules/subModules', ...]
                                                                                       // the current directory path is the 1st item, then the 2 paths of the <mark>PYTHONPATH</mark> environment variable   
    
    sys.path.append('/workdir/pyModules')                                              // adding a new directory to the module search path 
    </pre>
  </details>
  <!---------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="header"><u> Importing modules <mark>import</mark> / <mark>from</mark> </u></h2>
  <p> - in Python we can only import modules at the same directory level or lower levels <u>but never higher</u>
    relative to the directory path (package) in <mark>sys.path</mark> </p>
  <p> - relative import path is allowed but only for navigating 1 level lower than the entry (main) module </p>
  <details class="example">
    <summary> DEMO </summary>
    <p> - this is the directory structure for the below examples </p>
    <pre class="syntax">
    main.py                                                                            &lt;- entry (__main__ module)
    sibling.py
    <span style="color:yellow;">[pyModules]</span>
        |- __inint__.py
        |- module1.py
        <span style="color:yellow;">|- [subModules]</span>
            |- __inint__.py
            |- subModule.py
    </pre>
    <p> - <mark>import</mark> </p>
    <pre>
// <mark>./main.py</mark> (file) -------------------------------------------------------------------
    import sibling                                                                     // imports the <mark>./sibling.py</mark>  
    import pyModules                                                                   // imports the <mark>./pyModules/__init__.py</mark>                  // directory targeted   
    import pyModules.module1 as mod1                                                   // imports the <mark>./pyModules/module1.py</mark>                   // -! this also calls the <mark>./pyModules/__init__.py</mark> but does not import it!   
    import pyModules.subModules as sub                                                 // imports the <mark>./pyModules/subModules/__init__.py</mark>       // -! this also calls the <mark>./pyModules/__init__.py</mark> but does not import it!   
    import pyModules.subModules.subModule as subMod                                    // imports the <mark>./pyModules/subModules/subModule.py</mark>      // -! this also calls the <mark>./pyModules/__init__.py</mark> and <mark>./pyModules/subModules/__init__.py</mark> but does not import them!    
    
                                                                                       // we are basically importing the global scope or the targeted file in an object (name space)
    sibling.sibling                                                                    // -> 'sibling'
    pyModules.initPyModules                                                            // -> 'initPyModules'
    mod1.module1                                                                       // -> 'module1'
    sub.initSubModules                                                                 // -> 'initSubModules'
    subMod.subModule                                                                   // -> 'subModule'
    
    
// <mark>./sibling.py</mark> (file) ----------------------------------------------------------------
    sibling = 'sibling'
    
    
// <mark>./pyModules/__init__.py</mark> (file) -----------------------------------------------------
    import subModules.subModule                                                        // -! raises a <mark>ModuleNotFound</mark> error because the this directory path is not present in <mark>sys.path</mark>    
    from .subModules.submodule import *                                                  <span style="color:darkgray;">// we should use relative path instead </span>
    
    initPyModules = 'initPyModules'
    
    
// <mark>./pyModules/module1.py</mark> (file) ------------------------------------------------------
    module1 = 'module1'    
    
// <mark>./pyModules/subModules/__init__.py</mark> (file) ------------------------------------------
    initSubModules = 'initSubModules'
    
    
// <mark>./pyModules/subModules/subModule.py</mark> (file) -----------------------------------------
    subModule = 'subModule'    
    </pre>
    <p> - <mark>from... import</mark> </p>
    <pre>
// <mark>./main.py</mark> (file) -------------------------------------------------------------------
    sibling = 'localVar'
    from sibling import sibling                                                        // imports a variable from the targeted module 
    sibling                                                                            // -> 'sibling'                     // -! imported variables overwrite local variables on conflict   
    
    initPyModules = 'localVar'
    from pyModules import initPyModules as initPyMod                                   // aliases the imported variable  
    initPyModule                                                                       // -> 'localVar'                    // variable name conflict avoided 
    initPyMod                                                                          // -> 'initPyMOdules'
    
    from pyModules.module1 import module1 as mod1, module2 as mod2                     // multiple variables are imported  
    mod1                                                                               // -> 'module1'
    mod2                                                                               // -> 'module2'
    
    from pyModules.subModules import *                                                 // imports all variables in the current module and dupms them on the global scope of this module (careful about name conflicts)   
    initSubModules1                                                                    // -> 'initSubModules'    
    initSubModules2                                                                    // -> 'initSubModules'    
    
    subModule = 'localVar'
    from pyModules.subModules.subModule import *
    subModule                                                                          // -> 'subModule'                   // -! local variable overwritten   
    
    
// <mark>./sibling.py</mark> (file) ----------------------------------------------------------------
    sibling = 'sibling'
    
    
// <mark>./pyModules/__init__.py</mark> (file) -----------------------------------------------------
    initPyModules = 'initPyModules'
    
// <mark>./pyModules/module1.py</mark> (file) ------------------------------------------------------
    module1 = 'module1'
    module2 = 'module2'
    
// <mark>./pyModules/subModules/__init__.py</mark> (file) ------------------------------------------
    initSubModules1 = 'initSubModules'
    initSubModules2 = 'initSubModules'
    
    
// <mark>./pyModules/subModules/subModule.py</mark> (file) -----------------------------------------
    subModule = 'subModule'    
    </pre>
    <p> - using relative paths <mark>from... import</mark> </p>
    <pre>
// <mark>./main.py</mark> (file) -------------------------------------------------------------------
    from .pyModules import *                                                           // -! raises a <mark>ImportError</mark> error because we cannot use relative imports from the main module   
    from .pyModules.module1 import * 
    
    
// <mark>./sibling.py</mark> (file) ----------------------------------------------------------------
    from .pyModules.module1 import *                                                   // -! raises a <mark>ImportError</mark> because this module (<mark>sibling.py</mark>) is at the same level as the __main__ module therefore relative imports are not allowed    
    
    
// <mark>./pyModules/__init__.py</mark> (file) -----------------------------------------------------
    from .module1 import *                                                             // files or directories can be imported that are located lower than the main module 
    from .subModules.subModule import *
    
    from ..sibling import *                                                            // -! raises a <mark>ImportError</mark> because this targeted module (<mark>sibling.py</mark>) is located at the same level as the __main__ module 
    
    
// <mark>./pyModules/module1.py</mark> (file) ------------------------------------------------------
    
    
// <mark>./pyModules/subModules/__init__.py</mark> (file) ------------------------------------------
    from .subModule import *
    from ..module1 import *                                                            // parent modules can be relatively imported (because they are not at the main module level)
    from ..subModules.subModule import *                                               // even spaghetti like this is allowed 
    
    from ...sibling import *                                                           // -! raises a <mark>ImportError</mark> because this targeted module (<mark>sibling.py</mark>) is located at the same level as the __main__ module 
    
    
// <mark>./pyModules/subModules/subModule.py</mark> (file) -----------------------------------------
    </pre>
  </details>
  <!---------------------------------------------------------------------------------------------->
  <hr>
  <h2 class="header"><u> Namespaced VS Regular (<mark>__init__.py</mark>) packages </u></h2>
  <p> - Namespaced package is basically an ordinary <mark>.py</mark> file which import the necessary dependencies for
    the package </p>
  <p> - Regular package is a directory that contains an <mark>__init__.py</mark> file, this file contains ordinary
    Python code which imports the necessary dependencies for the package </p>
  <p style="text-indent:25px;"> - when the import path targets a directory Python looks for the
    <mark>__inint__.py</mark> file in that directory (that directory contains a regular package)
  </p>
  <details class="example">
    <summary> DEMO </summary>
    <p> - this is the directory structure for the below examples </p>
    <pre class="syntax">
    main.py 
    <span style="color:yellow;">[randomNameGenerator]</span>                                                              &lt;- regular package (directory having <mark>__init__.py</mark> file)   
        |- __inint__.py
        |- randomNameGenerator.py                                                      &lt;- namespaced package  
        <span style="color:yellow;">|- [dependencies]</span>
            |- names.py
            |- randomNumber.py
    </pre>
    <pre>
// <mark>./main.py</mark> (file) -------------------------------------------------------------------
    import randomNameGenerator.randomNameGenerator as nameGenerator1                   // imports namespaced package  
    import randomNameGenerator as nameGenerator2                                       // imports regular package (directory targeted)    
    
    nameGenerator1.generateRandomName()                                                // -> 'Joe'            // returns a random name  
    nameGenerator2.generateRandomName()                                                // -> 'Cecilia'
    
    
// <mark>./randomNameGenerator/__init__.py</mark> (file) -------------------------------------------
    from .dependencies.names import names
    from .dependencies.randomNumber import genRandomNumber
    
    def generateRandomName():
        return names[genRandomNumber(len(names))]
    
    
// <mark>./randomNameGenerator/randomNameGenerator.py</mark> (file) --------------------------------
    from .dependencies.names import names
    from .dependencies.randomNumber import genRandomNumber
    
    def generateRandomName():
        return names[genRandomNumber(len(names))]
    
    
// <mark>./randomNameGenerator/dependencies/names.py</mark> (file) ---------------------------------
    names = ['Janus', 'Joe', 'Stewe', 'Bob', 'Veronica', 'Luisa', 'Celilia', 'Arnold']
    
    
// <mark>./randomNameGenerator/dependencies/randomNumber.py</mark> (file) --------------------------
    import random
    
    def genRandomNumber(len):
        return random.randint(0, len - 1)
    </pre>
  </details>


  <br><br>
</body>

</html>