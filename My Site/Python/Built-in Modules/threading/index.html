<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title> threading </title> 
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous"> 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../../Assets/stylesPages.css">
    <script src="../../../Assets/scriptPages.js"></script>
</head>
<body>
<h1> threading </h1>
    <p> Updated ( 2022-07-12 )</p>
    <p class="sitenav"> <a href="../../../index.html">MySite></a>
        <a href="../../index.html">Python></a>
        <a href="../index.html">Built-in modules></a> threading
    </p>
<table class="table">
<caption>
    threading
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Method </th>
        <th> Description </th>
    </tr>
    <tr class="05.01">
        <td>
            <em>threading</em>.active_count()
        </td>
        <td>
            - returns all thread objects currently alive in a list (including the main thread, daemonic threads and dummy threads)
        </td>
    </tr>
    <tr class="05.02">
        <td>
            <em>threading</em>.enumerate()
        </td>
        <td>
            - returns how many thread ar currently alive (including the main thread, daemonic threads and dummy threads) <br>
            - it's basically the list length of <mark>active_count()</mark>
        </td>
    </tr>
    <tr class="10.01">
        <td>
            <em>threading</em>.current_thread()
        </td>
        <td>
            -  returns the current <strong>thread</strong> object (where it is called)
        </td>
    </tr>
    <tr class="10.02">
        <td>
            <em>threading</em>.main_thread()
        </td>
        <td>
            - returns the main <strong>thread</strong> object
        </td>
    </tr>
    <tr class="15.01">
        <td>
            <em>threading</em>.get_ident()
        </td>
        <td>
            - return the thread identifier (nonzero integer) 
            <span id="browserSupport" title="updated : 2022-07-18">
                <span><i class="fab fa-python"></i> 3.3 </span>
            </span>
        </td>
    </tr>
    <tr class="15.02">
        <td>
            <em>threading</em>.get_native_id()
        </td>
        <td>
            - return the thread identifier (nonzero integer) <u>thread id assigned by the kernel</u>
            <span id="browserSupport" title="updated : 2022-07-18">
                <span><i class="fab fa-python"></i> 3.8 </span>
            </span>
        </td>
    </tr>
    <tr class="20.01">
        <td>
            <em>threading</em>.excephook
        </td>
        <td>
            - we can set a function to it to handle thread thrown exceptions (any thread)
        </td>
    </tr>
    <tr class="40.01">
        <td colspan="2"> thread control </td>
    </tr>
    <tr class="40.02">
        <td> 
            <em>treading</em>.Thread(<small class="openable">group=None<div>
                <p> - not yet implemented argument (v3.10) </p>
            </div></small>, <small class="openable">target=<i>fn</i><div>
                <p> - function executed by the thread (Default: <mark>None</mark>) </p>
            </div></small>, <small>name=<i>str</i></small>, <small class="openable">args=<i>iterable</i><div>
                <p> - arguments passed to the target function (iterable format) </p>
            </div></small>, <small class="openable">kwargs=<i>dict</i><div>
                <p> - arguments passed to the target function (dictionary format) </p>
            </div></small>, <small class="openable">daemon=<i>bol</i><div>
                <p> - thread runs as daemon (separate background process) </p>
                <p> - the main thread won't wait for this thread end because this thread will run in the background </p>
            </div></small>)
        </td>
        <td> 
            - creates and returns a <strong>thread</strong> object which represents activity that is run in a separate thread of control
            <span id="browserSupport" title="updated : 2022-07-18">
                <span><i class="fab fa-python"></i>3.3 <mark>daemon</mark> argument</span>
                <span><i class="fab fa-python"></i>3.3 <mark>target</mark> name used if <mark>name</mark> omitted</span>
            </span>
        </td>
    </tr>
    <tr class="40.03">
        <td>
            <strong>thread</strong>.start()
        </td>
        <td>
            - stats the thread (this call won't block further execution)
        </td>
    </tr>
    <tr class="40.04">
        <td>
            <strong>thread</strong>.join()
        </td>
        <td>
            - waits untill the thread terminates (block further execution)
        </td>
    </tr>
    <tr class="45.01">
        <td>
            <strong>thread</strong>.is_alive()
        </td>
        <td>
            - returns <mark>True</mark> if the thread is running, <mark>False</mark> otherwise
        </td>
    </tr>
    <tr class="50.01">
        <td>
            <strong>thread</strong>.name
        </td>
        <td>
            - returns the name of the thread (returns the <mark>target</mark> name if thread name was not specified)
        </td>
    </tr>
    <tr class="50.02">
        <td>
            <strong>thread</strong>.ident
        </td>
        <td>
            - returns the thread identifier, return <mark>None</mark> if the thread is not yet started
        </td>
    </tr>
    <tr class="50.03">
        <td>
            <strong>thread</strong>.native_id
        </td>
        <td>
            - returns the thread identifier <u>assigned by the OS kernel</u>, return <mark>None</mark> if the thread is not yet started
            <span id="browserSupport" title="updated : 2022-09-14">
                <span><i class="fab fa-python"></i>3.8 </span>
            </span>
        </td>
    </tr>
    <tr class="50.04">
        <td>
            <strong>thread</strong>.daemon
        </td>
        <td>
            - returns <mark>True</mark> if the thread is daemonic, <mark>False</mark> otherwise
        </td>
    </tr>
    <tr class="60.01">
        <td>
            <em>threading</em>.Timer(<strong>delay:float</strong>, <strong>fn</strong>, <small class="openable">args=<i>iterable</i><div>
                <p> - arguments passed to the thread function (iterable format)</p>
            </div></small>, <small class="openable">kwargs=<i>dict</i><div>
                <p> - arguments passed to the thread function (dictionary format) </p>
            </div></small>)
        </td>
        <td>
            - returns a <strong>threadTimer</strong> object which executes the passed function in a thread after the specified delay (once the <mark>start()</mark> is called on it)
        </td>
    </tr>
    <tr class="60.02">
        <td>
            <strong>threadTimer</strong>.cancel()
        </td>
        <td>
            - stops the timer and cancels the thread execution start (works only if the <strong>threadTimer</strong> is still in waiting stage)
        </td>
    </tr>
</table>
    <br>
<table class="table">
<caption>
    Race Condition Control
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Method </th>
        <th> Description </th>
    </tr>
    <tr class="05.01">
        <td colspan="2"> <mark>Lock</mark> simple lock </td>
    </tr>
    <tr class="05.02">
        <td> 
            <em>threading</em>.Lock()
        </td>
        <td> 
            - creates and returns a <strong>simpleLock</strong> <br>
            - can be locked|unlocked only once by any threads <br>
            - supports the context management protocol (<strong>simpleLock</strong> <mark>acquire()</mark> when entering | <mark>release()</mark> when exiting the context)
        </td>
    </tr>
    <tr class="10.01">
        <td> 
            <strong>simpleLock</strong>.acquire(<small class="openable">blocking=<i>bol</i><div>
                <p> - blocks furter execution when the <strong>lock</strong> is already acquired (Default: <mark>True</mark>)
            </div></small>, <small class="openable">timeout=<i>float</i><div>
                <p> - after this delay the lock is unlocked (Default: <mark>-1</mark> = no delay) </p>
            </div></small>)
        </td>
        <td> 
            - acquires (locks) the lock <br>
            - if the <strong>simpleLock</strong> is already locked blocs further executions untill the lock is released 
        </td>
    </tr>
    <tr class="10.02">
        <td> 
            <strong>simpleLock</strong>.release()
        </td>
        <td> 
            - releases (unlocks) the lock
        </td>
    </tr>
    <tr class="15.01">
        <td> 
            <strong>simpleLock</strong>.locked()
        </td>
        <td> 
            - returns <mark>True</mark> if the <strong>simpleLock</strong> is locked, otherwise returns <mark>False</mark>
        </td>
    </tr>
    <tr class="20.01">
        <td colspan="2"> <mark>RLock</mark> reentral lock </td>
    </tr>
    <tr class="20.02">
        <td> 
            <em>threading</em>.RLock()
        </td>
        <td>
            - creates and returns a <strong>reentralLock</strong> <br>
            - thread awaire, the thread that locks it only that thread can unlock it again <br>
            - can be unlocked multiple times within the same thread (must be locked as many times as it was unlocked in order to release the lock) <br>
            - supports the context management protocol (<strong>simpleLock</strong> <mark>acquire()</mark> when entering | <mark>release()</mark> when exiting the context) <br>
            - <u> automatically released when the thread is killed </u>
        </td>
    </tr>
    <tr class="25.01">
        <td> 
            <strong>reentralLock</strong>.acquire(<small class="openable">blocking=<i>bol</i><div>
                <p> - blocks furter execution when the <strong>lock</strong> is already acquired (Default: <mark>True</mark>)
            </div></small>, <small class="openable">timeout=<i>float</i><div>
                <p> - after this delay the lock is unlocked (Default: <mark>-1</mark> = no delay) </p>
            </div></small>)
        </td>
        <td> 
            - acquires (locks) the lock in this thead <br>
            - within the same thread unlock the lock several times <br>
            - if the <strong>reentralLock</strong> is locked by another thread block further execution untill the lock is released by the thred that locked it
        </td>
    </tr>
    <tr class="25.02">
        <td> 
            <strong>reentralLock</strong>.release()
        </td>
        <td> 
            - releases (unlocks) the lock <br>
            - only the thread that locked the <strong>reentralLock</strong> can unlock it again
        </td>
    </tr>
    <tr class="30.01">
        <td colspan="2"> <mark>Condition</mark> object </td>
    </tr>
    <tr class="30.02">
        <td>
            <em>threading</em>.Condition(<small>lock=<i>lock</i></small>)
        </td>
        <td>
            - creates and return a <strong>cond</strong> (condition) object <br>
            - has its internal lock (but we also can pass one) which can be locked serveral times, this makes possible make wait multiple threads (untill <mark>notify</mark> or <mark>notify_all()</mark>) called<br>
            - supports the context management protocol (<mark>acquire()</mark> the lock when entering | <mark>release()</mark> the lock when exiting the context)

        </td>
    </tr>
    <tr class="35.01">
        <td>
            <strong>cond</strong>.acquire()
        </td>
        <td>
            - acquires (locks) the underlying lock 
        </td>
    </tr>
    <tr class="35.02">
        <td>
            <strong>cond</strong>.release()
        </td>
        <td>
            - releases (unlocks) the underlying lock 
        </td>
    </tr>
    <tr class="40.01">
        <td>
            <strong>cond</strong>.wait(<small>timeout=<i>float</i></small>)
        </td>
        <td>
            - blocks further execution untill some other thread calls <mark>notify() release()</mark> on this <strong>cond</strong> object (or untill timeout expires) <br>
            - does not unlock the <strong>cond</strong> lock (<mark>release()</mark> must explicity be called after) <br>
            - <strong>cond</strong> lock must be acquire before this call
        </td>
    </tr>
    <tr class="40.02">
        <td>
            <strong>cond</strong>.notify(<small class="openable">n=<i>int</i><div>
                <p> - how many next waiting threads to release (Default: <mark>1</mark>) </p>
            </div></small>)
        </td>
        <td>
            - notifies the next waiting thread in the queue (releases the next thread in the condition queue that block with <mark>wait()</mark>) <br>
            - <strong>cond</strong> lock must be acquire before this call <br>
            - after this call, the <strong>cond</strong> lock must be released with <mark>release()</mark> in order to unblock waiting threads
        </td>
    </tr>
    <tr class="40.03">
        <td>
            <strong>cond</strong>.notify_all()
        </td>
        <td>
            - releases all waiting threads in the condition queue <br>
            - <strong>cond</strong> lock must be acquire before this call <br>
            - after this call, the <strong>cond</strong> lock must be released with <mark>release()</mark> in order to unblock waiting threads
        </td>
    </tr>
    <tr class="45.01">
        <td>
            <strong>cond</strong>.wait_for(<strong>fn</strong>, <small>timeout=<i>float</i></small>)
        </td>
        <td>
            - blocks futher execution untill <strong>fn</strong> returns <mark>True</mark> (or untill <small>timeout</small> expires)<br>
            - if <strong>fn</strong> returns <mark>False</mark> will block forever (or untill <small>timeout</small> expires)<br>
            - <strong>cond</strong> lock must be acquire before this call
        </td>
    </tr>
    <tr class="50.01">
        <td colspan="2"> <mark>Semaphore</mark> object </td>
    </tr>
    <tr class="50.02">
        <td>
            <em>threading</em>.Semaphore(<small class="openable">value=<i>int</i></small>)
        </td>
        <td>
            - creates and returns a <strong>semaphore</strong> object (default counter <mark>1</mark>) <br>
            - the internal counter is decreased with each <mark>acquire()</mark> and incremented with each <mark>release()</mark> call <br>
            - if the internal counter reaches <mark>0</mark> further call to <mark>acquire()</mark> blocks <u>untill <mark>release()</mark> is called again</u><br>
            - supports the context management protocol (<mark>acquire()</mark> the lock when entering | <mark>release()</mark> the lock when exiting the context)
        </td>
    </tr>
    <tr class="50.03">
        <td>
            <em>threading</em>.BoundedSemaphore(<small class="openable">value=<i>int</i></small>)
        </td>
        <td>
            - same as <mark>Semaphore</mark>, but when the internal counter's upper limit is reached raises a <mark>ValueError</mark> (to fail safe too many lock releases)
        </td>
    </tr>
    <tr class="55.01">
        <td>
            <strong>semaphore|boundedSemaphore</strong>.acquire(<small>block=<i>bol</i></small>, <small>timeout=<i>float</i></small>)
        </td>
        <td> 
            - decrements the internal counter of <strong>semaphore|boundedSemaphore</strong> <br>
            - if the counter is <mark>0</mark>, block futher execution untill the counter is incremented again (or untill <small>timeout</small>)
            <span id="browserSupport" title="updated : 2022-09-18">
                <span><i class="fab fa-python"></i>3.2 <mark>timeout</mark> argument </span>
            </span>
        </td>
    </tr>
    <tr class="55.01">
        <td>
            <strong>semaphore|boundedSemaphore</strong>.release(<small>value=<i>int</i></small>)
        </td>
        <td>
            - increments the internal counter of the <strong>semaphore|boundedSemaphore</strong> by <mark>1</mark> (or by <small>value</small>)
            <span id="browserSupport" title="updated : 2022-09-18">
                <span><i class="fab fa-python"></i>3.9 <mark>value</mark> argument </span>
            </span>
        </td>
    </tr>
    <tr class="60.01">
        <td colspan="2"> <mark>Event</mark> object </td>
    </tr>
    <tr class="60.02">
        <td>
            <em>threading</em>.Event()
        </td>
        <td>
            - creates and returns an <strong>event</strong> object which has an internal boolean flag (initialized with <mark>False</mark>)<br>
            - if the internal flag is set to <mark>False</mark>, the calling <mark>wait()</mark> on the <strong>event</strong> object will block further execution <u>untill the internal flag is set to <mark>True</mark></u> <br>
            - multiple threads can be blocked on <mark>wait()</mark> (and all released with a single <mark>clear()</mark>)
        </td>
    </tr>
    <tr class="65.01">
        <td>
            <strong>event</strong>.set()
        </td>
        <td>
            - sets the internal <strong>event</strong> flag to <mark>True</mark> (this will release all blocking at <mark>wait()</mark>)
        </td>
    </tr>
    <tr class="65.02">
        <td>
            <strong>event</strong>.clear()
        </td>
        <td>
            - sets the internal <strong>event</strong> flag to <mark>False</mark> (this will block all further execution at <mark>wait()</mark>)
        </td>
    </tr>
    <tr class="70.01">
        <td>
            <strong>event</strong>.wait(<small>timeout=<i>float</i></small>)
        </td>
        <td>
            - the internal <strong>event</strong> flag is <mark>False</mark> block further execution <u>utill the flag is set to <mark>True</mark></u> (this can block|unlock multiple threads at the same time)
        </td>
    </tr>
    <tr class="75.01">
        <td>
            <strong>event</strong>.is_set()
        </td>
        <td>
            - returns <mark>True</mark> if the internal <strong>event</strong> flag is set to <mark>True</mark>, <mark>False</mark> otherwise
        </td>
    </tr>
    <tr class="80.01">
        <td colspan="2"> 
            <mark>Barriere</mark> 
        </td>
    </tr>
    <tr class="80.02">
        <td>
            <em>threading</em>.Barriere(<strong>barriere:nr</strong>, <small>action=<i>fn</i></small>, <small>timeout=<i>float</i></small>)
        </td>
        <td>
            - creates and returns a <strong>barriere</strong> object having the number of barrieres specified <br>
            - barrieres will block threads untill <u>all</u> threads reaches the barriere<br>
            - one of the threads will call <small>action</small> (if provided) when passing the barriere
        </td>
    </tr>
    <tr class="85.01">
        <td>
            <strong>barriere</strong>.wait(<small class="openable">timeout=<i>float</i><div>
                <p> - overrides the constructor <mark>Barriere</mark> <strong>timeout</strong> </p>
            </div></small>)
        </td>
        <td>
            - blocks the current thread untill <u>all</u> threads reaching the barrierre <br>
            - when all threads reach the barriere they are released simultaneously <br>
            - returns an <strong>int</strong> index of the barriere
        </td>
    </tr>
    <tr class="90.01">
        <td>
            <strong>barriere</strong>.reset()
        </td>
        <td>
            - resets the <strong>barriere</strong> in default state <br>
            - any threads waiting at the barriere will raise a <mark>BrokenBarrierError</mark>
        </td>
    </tr>
    <tr class="90.02">
        <td>
            <strong>barriere</strong>.abort()
        </td>
        <td>
            - puts the <strong>barriere</strong> into broken state <br>
            - any current or future calls to <mark>wait()</mark> will raise a <mark>BrokenBarrierError</mark>
        </td>
    </tr>
    <tr class="95.01">
        <td>
            <strong>barriere</strong>.parties
        </td>
        <td>
            - returns how many barrieres the <mark>barriere</mark> object contains
        </td>
    </tr>
    <tr class="95.02">
        <td>
            <strong>barriere</strong>.n_waiting
        </td>
        <td>
            - returns how many threads currently waiting at the barriere 
        </td>
    </tr>
    <tr class="95.03">
        <td>
            <strong>barriere</strong>.broken
        </td>
        <td>
            - returns <mark>True</mark> if the <strong>barriere</strong> is broken, <mark>False</mark> otherwise
        </td>
    </tr>
</table>
    <br>
    <details class="example" id="notes">
    <summary> Notes :</summary>
        <!-- <p> - paragraph removes the 'empty' message from the detail TAG -->
    </details>
<h2 style="color:green;"><u> Useful Links : </u></h2>
    <p><a href="https://docs.python.org/3/library/threading.html" target="_blank">Threading (docs.python.org)</a></p>
    <p><a href="https://realpython.com/intro-to-python-threading/" target="_blank">Threading (realpython.com)</a></p>
<h2 style="color:green;"><u> Remember This : </u></h2>
    <p> - error raised in one the thread or process won't affect others (parallel programming) </p>
<h2 style="color:green;"><u> Description and Demonstration : </u></h2>
    <p> - the <mark class="mark">threading</mark> module allows parallel programming in Python (we can run multiple tasks concurrently) </p>
    <p> - the idea behind threading is to run multiple tasks <u>at the same time</u> what need to wait for some kind of external even (like DB query) so they don't block each other (ex: running 3 tasks in parallel  taking 2 seconds each will take a little over 2 seconds to complish because they don't block each other (sequencially this would take 6 seconds)) </p>
    <p> - threading does not help you with performance, use <mark class="mark">multiprocessing</mark> for that </p>
    <p> - by default the main thread waits for all threads (tasks) to end, but tasks can run as daemons (background processes), this way they are independed from the main thread, but also the main thread won't wait from daemon tasks to finish </p>
<details class="example">
<summary> DEMO </summary>
    <pre>
    import threading
    import time
    
    def th(name, delay):                                                      # will run in a separate thread
        print(f'{name} started')
        time.sleep(delay)                                                     # simulates some non cpu intensive task
        print(f'{name} end!')
    
    a = threading.Thread(target=th, args=["Thread-1", 3])
    b = threading.Thread(target=th, args=["Thread-2", 2])
    c = threading.Thread(target=th, args=["Thread-3", 1], daemon=True)        # thread runs as daemon 
    
    a.start()                                                                 # starting threads 
    b.start()
    c.start()
    
    c.join()                                                                  # block further execution untill thread 'c' ends
    </pre>
    <p> - thread exception handler hook </p>
    <pre>
    import threading
    
    def handleException(err):                 # handles thrown exception by thread 
        for e in err:
            print( e )                        // -> Excepiont class  |  'some exception  |  etc...
    
    threading.excepthook = handleException
    
    def th():
        raise Exception('some exception')
    
    th1 = threading.Thread(target=th)
    
    th1.start()
    th1.join()
    </pre>
    <p> - <mark>Time()</mark> </p>
    <pre>
    import threading
    import time
    
    def thread(name):
        print( f'thread {name} started')
        time.sleep(3)                                                         # simulates some non cpu intensive task
        print( f'thread {name} end')
    
    th1 = threading.Timer(2.5, thread, args=[1])                              # delayed thread created
    th2 = threading.Timer(1.2, thread, args=[2])
    
    th1.start()                                                               # starting threads execution
    th2.start()
    </pre>
</details>
<hr>
<!--------------------------------------------------------------------------------->
<h2 class="header" id="raceControl"> Race Condition Control </h2>
    <p> - <mark class="mark">threading</mark> offers the following race condition control tools (<mark class="mark">multiprocessing</mark> use these same tools) : </p>
    <p style="text-indent: 30px;"> - <mark>Lock</mark> (simple lock) </p>
    <p style="text-indent: 60px;"> - can be locked or unlocked, the idea is that several threads use the same lock but only one of them unlock it, other threads wait until the lock unlocks again (ex: connecting to DB with this lock approach makes shure that there's only one query at a time) </p>
    <p style="text-indent:30px;"> - <mark>RLock</mark> (reentral lock, thread awaire lock) </p>
    <p style="text-indent:60px;"> - thread aware, meaning knows which thread acquired (locked) it and <u>only the acquiring thread can unlock it again</u> </p>
    <p style="text-indent:60px;"> - within the same thread can be acquired (unlocked) several times (must be released (locked) as many times as it was arquired (locked) to release the lock) </p>
    <p style="text-indent:30px;"> - <mark>Condition</mark> </p>
    <p style="text-indent:60px;"> - the idea is to make wait 'consumer' threads untill some kind of condition is satisfied in the 'producer' thread </p>
    <p style="text-indent:60px;"> - simple ex: 1) consumer threas acquire the lock then wait untill noticiation 2) producer thread acquires the lock then notifies the next thread in the condition queue (or all waiting threads) then releases its lock 3) consumer thread(s) will unlock the wait call </p>
    <p style="text-indent:30px;"> - <mark>Semaphore</mark> </p>
    <p style="text-indent:60px;"> - it's a simle lock with an internal counter, the counter is decremented with each <mark>acquire()</mark> and incremented with each <mark>release()</mark> call </p>
    <p style="text-indent:60px;"> - if the counter reaches <mark>0</mark> futher calls to <mark>acquire()</mark> block <u>untill <mark>release()</mark> is called again</u> </p>
    <p style="text-indent:30px;"> - <mark>Event</mark> </p>
    <p style="text-indent:60px;"> - has an internal boolean flag, if this flag is set to <mark>False</mark> then threads will be blocked at <mark>wait()</mark> untill this flag is set to <mark>True</mark> (setting the flag to <mark>True</mark> will release all waiting threads) </p>
    <p style="text-indent:30px;"> - <mark>Barriere</mark> </p>
    <p style="text-indent:60px;"> - sereral thread are blocked and waiting at the barriere, when <u>all</u> threads reaches the barriere they are simultaneously released </p>
<details class="example">
<summary> DEMO </summary>
    <p> - <mark>Lock</mark> </p>
    <pre>
    import threading 
    import time
    
    lock = threading.Lock()
    
    def th(name, lock):
        print( f"{name} tread started")
        time.sleep(3)
    
        with lock:                                        # lock acqured when entering context / lock released when exiting context
            pass
        print( f"{name} tread end")
    
    threading.Thread(target=th, args=[1, lock]).start()
    threading.Thread(target=th, args=[2, lock]).start()   # thread 2 will wait untill the lock is released
    </pre>
    <pre>
    import threading
    
    lock = threading.Lock()
    
    lock.acquire()
    
    print( lock.locked() )                                // -> True
    lock.acquire()                                        # program will hang because the lock is closed (this is called deadlock)
    </pre>
    <p> - <mark>RLock</mark> </p>
    <p> - thread-1 acquires the lock and blocks thread-2 and thread-3 untill it releases the lock again </p>
    <pre>
    import threading 
    import time
    
    lock = threading.RLock()
    
    def th(name):
        print( f"{name} tread started")
        
        lock.acquire()
        time.sleep(0.1)       # simulating some work
        
        print( f"{name} tread end")
    
    th1 = threading.Thread(target=th, args=[1])
    th2 = threading.Thread(target=th, args=[2])
    th3 = threading.Thread(target=th, args=[3])
    
    th1.start()
    th2.start()
    th3.start()
    </pre>
    <pre class="cmd">
    1 tread started
    2 tread started
    3 tread started
    1 tread end
    </pre>
    <p> - within the same thread the reentral lock can be unlocked several times </p>
    <pre>
    import threading 
    import time
    
    lock = threading.RLock()
    
    def th(name):
        print( f"{name} tread started")
        
        for i in range(3):
            lock.acquire()        # acquired 3 times 
            time.sleep(0.1)
        
        time.sleep(1)
        for i in range(3):
            lock.release()        # released as many times as it was arquired to unlock the lock  
        
        print( f"{name} tread end")
    
    th1 = threading.Thread(target=th, args=[1])
    th2 = threading.Thread(target=th, args=[2])
    th3 = threading.Thread(target=th, args=[3])
    
    th1.start()
    th2.start()
    th3.start()
    </pre>
    <pre class="cmd">
    1 tread started
    2 tread started
    3 tread started
    1 tread end
    </pre>
    <p> - Condition object </p>
    <pre>
    import threading
    import time
    
    c = threading.Condition()
    
    def consumer(name, c):
        print( f'-- consumter thread {name} start --' )
        c.acquire()           # acquiring lock
        c.wait()              # will block untill the procducer calls notify() and releases its lock
        
        # doint something with the produced data...
        
        c.release()           # releasing lock
        
        print( f'-- consumter thread {name} end ---' )
        
    def producer( c):
        print( f'-- producer thread start --' )
        
        for _ in range(4):
            c.acquire()           # acquiring lock
            
            # producint data ...
            
            c.notify()            # notify one thread AND release the lock! (releases the next waiting thread)    
            c.release()
        
        print( f'-- producer thread end --' )
    
    threading.Thread(target=consumer, args=(1, c)).start()
    threading.Thread(target=consumer, args=(2, c)).start()
    threading.Thread(target=consumer, args=(3, c)).start()
    threading.Thread(target=consumer, args=(4, c)).start()
    
    time.sleep(1)
    threading.Thread(target=producer, args=(c,)).start()
    </pre>
    <p> - Condition object notifying all threads </p>
    <pre>
    import threading
    import time
    
    c = threading.Condition()
    
    def consumer(name, c):
        print( f'-- consumter thread {name} start --' )
        c.acquire()           # acquiring lock
        c.wait()              # will block untill the procducer calls notify() and releases its lock    
        
        # doint something with the produced data...
        
        c.release()           # releasing lock
    
        print( f'-- consumter thread {name} end ---' )
    
    def producer( c):
        print( f'-- producer thread start --' )
        
        c.acquire()           # acquiring lock
        
        # producint data ...
        
        c.notify_all()            # notify all thread AND release the lock!
        c.release()
        
        print( f'-- producer thread end --' )
    
    threading.Thread(target=consumer, args=(1, c)).start()
    threading.Thread(target=consumer, args=(2, c)).start()
    threading.Thread(target=consumer, args=(3, c)).start()
    threading.Thread(target=consumer, args=(4, c)).start()
    
    time.sleep(1)
    threading.Thread(target=producer, args=(c,)).start()
    </pre>
    <p> - condition queue </p>
    <pre>
    import threading
    import time
    
    c = threading.Condition()
    
    def cons(c, name):
        print( f'--- Consumer {name} thread started ---')
        c.acquire()
        c.wait()
        c.release()
        print( f'--- Consumer {name} thread end ---')
    
    def prod(c):
        print( '--- Producer thread started ---')
        c.acquire()
        c.notify()            // release only one waiting thread (which is thread 1 => waiting threads are registered in a queue)    
        c.release()
        print( '--- Producer thread end ---')
    
    cons1 = threading.Thread(target=cons, args=(c, 1))
    cons2 = threading.Thread(target=cons, args=(c, 2))
    p = threading.Thread(target=prod, args=(c, ))
    
    cons1.start()
    time.sleep(2)
    cons2.start()
    
    time.sleep(2)
    p.start()
    </pre>
    <p> - Condition object <mark>wait_for()</mark> </p>
    <pre>
    import threading
    import time
    
    c = threading.Condition()
    
    def delay():
        time.sleep(2)
        return True
    
    c.acquire()
    c.wait_for(delay, timeout=5.5)        # block untill 'delay' function returns True (or until timeout)   
    </pre>
    <p> - Semaphore object </p>
    <pre>
    import threading
    
    s = threading.Semaphore()     # initial semaphore stack = 1
    
    s.acquire()                   # semaphore stack reaches 0 (furhter call will block)
    s.acquire()                   # blocks furhter call untill the semaphore is released (untill <mark>release()</mark> is called)
    
    
// ------------------------------------------------------
    s = threading.BoundedSemaphore(value=2)   # initial semaphore stack = 2
    
    s.acquire()                   # stack => 1
    s.acquire()                   # stack => 0 (further call would block)
    
    s.release()                   # stack => 1
    s.release()                   # stack => 2 (further call will raise a <mark>ValueError</mark>)
    s.release()                   // -> <mark>ValueError</mark> raised 
    </pre>
    <p> - Event object </p>
    <pre>
    import threading
    import time
    
    ev = threading.Event()
    
    def prod(ev):
        print( 'producer thread started...' )
        print( ev.is_set() )                  // -> False 
        
        time.sleep(5)
        ev.set()                              # setting event object's internal flag to True (this relases all waiting threads)    
        print( ev.is_set() )                  // -> True
    
        ev.clear()                            # sets the internal flag to False
        print( ev.is_set() )                  // -> False (locking again)
    
        print( 'producer thread end' )
    
    def cons(ev):
        print( 'consumer thread started...' )
        ev.wait()                             # blocks futher calls untill the internal flag is set to False
    
        print( 'consumer thread end' )
    
    producer = threading.Thread(target=prod, args=(ev, ))
    
    consumer1 = threading.Thread(target=cons, args=(ev, ))
    consumer2 = threading.Thread(target=cons, args=(ev, ))
    consumer3 = threading.Thread(target=cons, args=(ev, ))
    consumer4 = threading.Thread(target=cons, args=(ev, ))
    
    producer.start()
    
    consumer1.start()
    consumer2.start()
    consumer3.start()
    consumer4.start()
    </pre>
    <p> - Barriere </p>
    <pre>
    import threading
    import time
    
    b = threading.Barrier(4)
    
    def th(name, b, delay):
        print( f"{name} thread started ..." )
        time.sleep(delay)
        b.wait()                                        # all threads will be released at the barrier at 5.2 (the     longest thread reaches last the barrier)
        print( f"{name} thread end" )
        
    threading.Thread(target=th, args=(1, b, 2)).start()
    threading.Thread(target=th, args=(2, b, 1.5)).start()
    threading.Thread(target=th, args=(3, b, 5.2)).start()
    threading.Thread(target=th, args=(4, b, 4.9)).start()
    </pre>
</details>
<hr>
<!--------------------------------------------------------------------------------->
<h2 class="header"> Communication between threads </h2>
    <p> - because threads run in the same process data in the main process is available for all threads (no need to use some communication channes like in <mark class="mark">multiprocessing</mark>) </p>
    
    
    <br><br>
</body>
</html>
