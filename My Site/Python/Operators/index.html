<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title> Operators </title>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css"
      integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="../../Assets/scriptPages.js"></script>
    <link rel="stylesheet" href="../../Assets/stylesPages.css">
    <link rel="stylesheet" href="./styles.css">
  </head>

  <body>
    <h1> Operators </h1>
    <p> Updated: ( 2022-05-03 / 2025-03-10 )</p>
    <nav class="sitenav"> <a href="../../index.html">MySite > </a>
      <a href="../index.html">Python > </a> Operator
    </nav>
    <table class="table precedence">
      <tr>
        <th style="width:25%"> Operator </th>
        <th> Description </th>
        <th style="width:5%;"> Precedence </th>
      </tr>
      <tr>
        <td colspan="3">
          Arithmetic Operators
        </td>
      </tr>
      <tr>
        <td>
          <strong>nrType</strong> + <strong>nrType</strong>
        </td>
        <td>
          - addition
        </td>
        <td>
          14
        </td>
      </tr>
      <tr>
        <td>
          <strong>nrType</strong> - <strong>nrType</strong>
        </td>
        <td>
          - subtraction
        </td>
        <td>
          14
        </td>
      </tr>
      <tr>
        <td>
          <strong>nrType</strong> * <strong>nrType</strong>
        </td>
        <td>
          - multiplication
        </td>
        <td>
          15
        </td>
      </tr>
      <tr>
        <td>
          <strong>nrType</strong> / <strong>nrType</strong>
        </td>
        <td>
          - division
        </td>
        <td>
          15
        </td>
      </tr>
      <tr>
        <td>
          <strong>nrType</strong> // <strong>nrType</strong>
        </td>
        <td>
          - floor division the division quotient is floored to the closest integer
        </td>
        <td>
          15
        </td>
      </tr>
      <tr>
        <td>
          <strong>nrType</strong> ** <strong>nrType</strong>
        </td>
        <td>
          - exponentiation
        </td>
        <td>
          17
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td colspan="3">
          Unary Operators
        </td>
      </tr>
      <tr>
        <td>
          +<strong>var</strong>
        </td>
        <td>
          - unary plus, (<strong>var</strong> must contain a number type) returns the value held by the variable (does nothing)
        </td>
        <td>
          16
        </td>
      </tr>
      <tr>
        <td>
          -<strong>var</strong>
        </td>
        <td>
          - unary minus, (<strong>var</strong> must contain a number type) <u>flips the sign</u> of the number type and returns the value held by the variable <br>
          - for <strong>complex</strong> types both real and imaginary signs are flipped
        </td>
        <td>
          16
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td colspan="3">
          Assignement Operators
        </td>
      </tr>
      <tr>
        <td>
          <strong>var</strong> := <strong>exp</strong>
        </td>
        <td>
          - walrus operator (assignement expressions) assigns the <strong>exp</strong> result to <strong>var</strong> <u>can be used within an expression</u>
          <span id="browserSupport" title="updated : 2023-03-14">
            <span><i class="fab fa-python"></i> 3.8 </span>
          </span>
        </td>
        <td>
          3
        </td>
      </tr>
      <tr>
        <td>
          <strong>var</strong> = <strong>val:any</strong>
        </td>
        <td>
          - assigns (binds) <strong>val</strong> to the variable
        </td>
        <td>
          4
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>var</strong> += <strong>nrType</strong>
        </td>
        <td>
          - addition assignement, adds <strong>var</strong> to <strong>nrType</strong> then reassigns the result to <strong>var</strong> (same as <mark><strong>var</strong> = <strong>var</strong> + <strong>nrType</strong></mark>)
        </td>
        <td>
          4
        </td>
      </tr>
      <tr>
        <td>
          <strong>var</strong> -= <strong>nrType</strong>
        </td>
        <td>
          - subtraction assignement, subtracts <strong>nrType</strong> from <strong>var</strong> then reassigns the result to <strong>var</strong> (same as <mark><strong>var</strong> = <strong>var</strong> - <strong>nrType</strong></mark>)
        </td>
        <td>
          4
        </td>
      </tr>
      <tr>
        <td>
          <strong>var</strong> *= <strong>nrType</strong>
        </td>
        <td>
          - multiplication assignement, multiplies <strong>var</strong> by <strong>nrType</strong> then reassigns the result to <strong>var</strong> (same as <mark><strong>var</strong> = <strong>var</strong> * <strong>nrType</strong></mark>)
        </td>
        <td>
          4
        </td>
      </tr>
      <tr>
        <td>
          <strong>var</strong> /= <strong>nrType</strong>
        </td>
        <td>
          - division assignement, divides <strong>var</strong> by <strong>nrType</strong> then reassigns the result to <strong>var</strong> (same as <mark><strong>var</strong> = <strong>var</strong> / <strong>nrType</strong></mark>)
        </td>
        <td>
          4
        </td>
      </tr>
      <tr>
        <td>
          <strong>var</strong> **= <strong>nrType</strong>
        </td>
        <td>
          - exponentiation assignement, takes <strong>var</strong> to the power of <strong>nrType</strong> then reassigns the result to <strong>var</strong> (same as <mark><strong>var</strong> = <strong>var</strong> ** <strong>nrType</strong></mark>)
        </td>
        <td>
          4
        </td>
      </tr>
      <tr>
        <td>
          <strong>var</strong> %= <strong>nrType</strong>
        </td>
        <td>
          - modulo division assignement, modulo divides <strong>var</strong> by <strong>nrType</strong> then reassigns the result to <strong>var</strong> (same as <mark><strong>var</strong> = <strong>var</strong> % <strong>nrType</strong></mark>)
        </td>
        <td>
          4
        </td>
      </tr>
      <tr>
        <td>
          <strong>var</strong> //= <strong>nrType</strong>
        </td>
        <td>
          - floor division assignement, floor divides <strong>var</strong> by <strong>nrType</strong> then reassigns the result to <strong>var</strong> (same as <mark><strong>var</strong> = <strong>var</strong> // <strong>nrType</strong></mark>)
        </td>
        <td>
          4
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>var</strong> &= <strong>int</strong>
        </td>
        <td>
          - bitwise and assignement, performs a bitwise and operation between <strong>var</strong> and <strong>int</strong> then reassigns the result to <strong>var</strong> (same as <mark><strong>var</strong> = <strong>var</strong> & <strong>int</strong></mark>)
        </td>
        <td>
          4
        </td>
      </tr>
      <tr>
        <td>
          <strong>var</strong> |= <strong>int</strong>
        </td>
        <td>
          - bitwise or assignement, performs a bitwise or operation between <strong>var</strong> and <strong>int</strong> then reassigns the result to <strong>var</strong> (same as <mark><strong>var</strong> = <strong>var</strong> | <strong>int</strong></mark>)
        </td>
        <td>
          4
        </td>
      </tr>
      <tr>
        <td>
          <strong>var</strong> ^= <strong>int</strong>
        </td>
        <td>
          - bitwise xor assignement, performs a bitwise xor operation between <strong>var</strong> and <strong>int</strong> then reassigns the result to <strong>var</strong> (same as <mark><strong>var</strong> = <strong>var</strong> ^ <strong>int</strong></mark>)
        </td>
        <td>
          4
        </td>
      </tr>
      <tr>
        <td>
          <strong>var</strong> &lt;&lt;= <strong>int</strong>
        </td>
        <td>
          - bitwise left shift assignement, performs a bitwise left shift operation between <strong>var</strong> and <strong>int</strong> then reassigns the result to <strong>var</strong> (same as <mark><strong>var</strong> = <strong>var</strong> &lt;&lt; <strong>int</strong></mark>)
        </td>
        <td>
          4
        </td>
      </tr>
      <tr>
        <td>
          <strong>var</strong> &gt;&gt;= <strong>int</strong>
        </td>
        <td>
          - bitwise right shift assignement, performs a bitwise right shift operation between <strong>var</strong> and <strong>int</strong> then reassigns the result to <strong>var</strong> (same as <mark><strong>var</strong> = <strong>var</strong> &gt;&gt; <strong>int</strong></mark>)
        </td>
        <td>
          4
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td colspan="3">
          Comparison Operators
        </td>
      </tr>
      <tr>
        <td>
          <strong>val</strong> == <strong>val</strong>
        </td>
        <td>
          - equality comparison, can compare any data types (primitive or complex) <br>
          - cannot compare objects or function definitions (always returns <mark>False</mark>) <br>
          - returns <mark>True</mark> for same variable references (for mutable data)
        </td>
        <td>
          9
        </td>
      </tr>
      <tr>
        <td>
          <strong>val</strong> != <strong>val</strong>
        </td>
        <td>
          - unequality comparison, can compare any data types (primitive or complex) <br>
          - cannot compare objects or function definitions (always returns <mark>True</mark>) <br>
          - returns <mark>True</mark> for unequal variable references (for mutable data)
        </td>
        <td>
          9
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>val1</strong> &lt; <strong>val2</strong>
        </td>
        <td>
          - less than, returns <mark>True</mark> if <span class="openable"><strong>val1</strong> is smaller than <strong>val2</strong>
            <div>
              <p> - strings are compared in alpahbetical order (unicode order) </p>
            </div>
          </span> <br>
          - can compare strings or number types
        </td>
        <td>
          9
        </td>
      </tr>
      <tr>
        <td>
          <strong>val1</strong> &lt;= <strong>val2</strong>
        </td>
        <td>
          - less or equal than, reurns <mark>True</mark> if <span class="openable"><strong>val1</strong> is smaller or equal than <strong>val2</strong>
            <div>
              <p> - strings are compared in alpahbetical order (unicode order) </p>
            </div>
          </span> <br>
          - can compare strings or number types
        </td>
        <td>
          9
        </td>
      </tr>
      <tr>
        <td>
          <strong>val1</strong> &gt; <strong>val2</strong>
        </td>
        <td>
          - greater than, reurns <mark>True</mark> if <span class="openable"><strong>val1</strong> is greater than <strong>val2</strong>
            <div>
              <p> - strings are compared in alpahbetical order (unicode order) </p>
            </div>
          </span> <br>
          - can compare strings or number types
        </td>
        <td>
          9
        </td>
      </tr>
      <tr>
        <td>
          <strong>val1</strong> &gt;= <strong>val2</strong>
        </td>
        <td>
          - greater or equal than, reurns <mark>True</mark> if <span class="openable"><strong>val1</strong> is greater or equal than <strong>val2</strong>
            <div>
              <p> - strings are compared in alpahbetical order (unicode order) </p>
            </div>
          </span> <br>
          - can compare strings or number types
        </td>
        <td>
          9
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td colspan="3">
          Identity Operators
        </td>
      </tr>
      <tr>
        <td>
          <strong>var</strong> is <strong>var</strong>
        </td>
        <td>
          - returns <mark>True</mark> if both variables point to the same data in memory (used to test mutable data) <br>
          - returns <mark>False</mark> if variables (operands) does not point to the same data in memory
        </td>
        <td>
          9
        </td>
      </tr>
      <tr>
        <td>
          <strong>var</strong> is not <strong>var</strong>
        </td>
        <td>
          - returns <mark>True</mark> if variables both operands does point to the same data in memory (used to test mutable data) <br>
          - returns <mark>False</mark> if variables point to the same data in memory
        </td>
        <td>
          9
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td colspan="3">
          Logical Operators
        </td>
      </tr>
      <tr>
        <td>
          <strong>exp1</strong> or <strong>exp2</strong>
        </td>
        <td>
          - logical or, if <strong>exp1</strong> evaluates <mark>False</mark> returns <strong>exp2</strong> <br>
          - if <strong>exp1</strong> evaluates <strong>True</strong> returns <strong>exp1</strong> <u>and never evaluates <strong>exp2</strong> = short circuit logic</u>
        </td>
        <td>
          6
        </td>
      </tr>
      <tr>
        <td>
          <strong>exp1</strong> and <strong>exp2</strong>
        </td>
        <td>
          - logical and, if <strong>exp1</strong> evaluates <mark>True</mark> returns <strong>exp2</strong> <br>
          - if <strong>exp1</strong> evaluates <strong>False</strong> returns <strong>exp1</strong> <u>and never evaluates <strong>exp2</strong> = short circuit logic</u>
        </td>
        <td>
          7
        </td>
      </tr>
      <tr>
        <td>
          not <strong>exp</strong>
        </td>
        <td>
          - logical not, if <strong>exp</strong> evaluates <mark>True</mark>, returns <mark>False</mark> <br>
          - if <strong>exp</strong> evaluates <mark>False</mark>, returns <mark>True</mark> <br>
        </td>
        <td>
          8
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td colspan="3">
          Bitwise Operators
        </td>
      </tr>
      <tr>
        <td>
          <strong>int</strong> | <strong>int</strong>
        </td>
        <td>
          - bitwise or, <strong>int</strong> are converted to binary <u>(Python uses two's complement to convert to negative)</u> <br>
          - in the result sets bits to <mark>1</mark> where any of the operands have <mark>1</mark> bits
        </td>
        <td>
          10
        </td>
      </tr>
      <tr>
        <td>
          <strong>int</strong> ^ <strong>int</strong>
        </td>
        <td>
          - bitwise xor, <strong>int</strong> are converted to binary <u>(Python uses two's complement to convert to negative)</u> <br>
          - in the result sets bits to <mark>1</mark> where any of the operands have <mark>1</mark> <br>
          - sets bits to <mark>0</mark> where both operands have <mark>1</mark> bits
        </td>
        <td>
          11
        </td>
      </tr>
      <tr>
        <td>
          <strong>int</strong> & <strong>int</strong>
        </td>
        <td>
          - bitwise and, <strong>int</strong> are converted to binary <u>(Python uses two's complement to convert to negative)</u> <br>
          - in the result sets bits to <mark>1</mark> where both operands have <mark>1</mark> bits
        </td>
        <td>
          12
        </td>
      </tr>
      <tr>
        <td>
          <strong>int</strong> &lt;&lt; <strong>int</strong>
        </td>
        <td>
          - bitwise left shift, <strong>int</strong> left operand is converted to binary <u>(Python uses two's complement to convert to negative)</u> <br>
          - shifts bits to left by <strong>int</strong> (right operand) (basically adds <mark>0</mark> bits to the right)
        </td>
        <td>
          13
        </td>
      </tr>
      <tr>
        <td>
          <strong>int</strong> &gt;&gt; <strong>int</strong>
        </td>
        <td>
          - bitwise right shift, <strong>int</strong> left operand is converted to binary <u>(Python uses two's complement to convert to negative)</u> <br>
          - shifts bits to right by <strong>int</strong> (right operand) (basically removes bits from the right)
        </td>
        <td>
          13
        </td>
      </tr>
      <tr>
        <td>
          ~<strong>int</strong>
        </td>
        <td>
          - bitwise not, <strong>int</strong> is converted to binary <u>(Python uses two's complement to convert to negative)</u> <br>
          - flips the bits of the operand (<mark>1</mark> to <mark>0</mark>) (<mark>0</mark> to <mark>1</mark>)
        </td>
        <td>
          16
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td colspan="3">
          Other
        </td>
      </tr>
      <tr>
        <td>
          lambda <strong>arg</strong> : <strong>exp</strong>
        </td>
        <td>
          - lambda expression
        </td>
        <td>
          5
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>member</strong> in <strong>list|tuple|set|frozenset|dict</strong>
        </td>
        <td>
          - returns <mark>True</mark> if <strong>member</strong> is present in <strong>list|tuple|set|frozenset|dict</strong>, returns <mark>False</mark> if not present
        </td>
        <td>
          9
        </td>
      </tr>
      <tr>
        <td>
          <strong>member</strong> not in <strong>list|tuple|set|frozenset|dict</strong>
        </td>
        <td>
          - returns <mark>True</mark> if <strong>member</strong> is not present in <strong>list|tuple|set|frozenset|dict</strong>, returns <mark>False</mark> if present
        </td>
        <td>
          9
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>
          await <strong>exp</strong>
        </td>
        <td>
          - await expression
        </td>
        <td>
          18
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>iterable</strong>[<i>idx</i>:<i>idx</i>]
        </td>
        <td>
          - slicing
        </td>
        <td>
          19
        </td>
      </tr>
      <tr>
        <td>
          <strong>iterable</strong>[<strong>idx</strong>]
        </td>
        <td>
          - subscription
        </td>
        <td>
          19
        </td>
      </tr>
      <tr>
        <td>
          <strong>obj</strong>.<strong>attr</strong>
        </td>
        <td>
          - attribute reference
        </td>
        <td>
          19
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>
          <strong>fn</strong>()
        </td>
        <td>
          - function call
        </td>
        <td>
          20
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>
          (<strong>exp</strong>)
        </td>
        <td>
          - expression grouping
        </td>
        <td>
          21
        </td>
      </tr>
    </table>
    <br>
    <details class="example" id="notes">
      <summary> Notes :</summary>
      <!-- <p> - paragraph removes the 'empty' message from the detail TAG -->
    </details>
    <h2 class="headerSection"> Useful Links : </h2>

    <h2 class="headerSection"> Remember This : </h2>
    <p> - Python uses two's complement to represent negative integers in binary, keep that in my for bitwise operations
    </p>
    <h2 class="headerSection"> Description and Demonstration : </h2>
    <h2 class="header"> Operator Precedence </h2>
    <p> - precedence describes in which order operations are performed in a statement (ex: <mark>*</mark> operation has
      higher precedence than <mark>+</mark>) (equal operations are performed left-to-right) </p>
    <pre>
    100 + 50 * 3                                                                       // -> 250        // <mark>*</mark> operations performed before <mark>+</mark> 
    (100 + 50) * 3                                                                     // -> 450        // <mark>()</mark> operator has higher precedence than <mark>*</mark>
    100 + 50 - 3                                                                       // -> 147        // equal operations are performed from left-to-right   
    </pre>
    <!------------------------------------------------------------------------------------>
    <hr>
    <h2 class="header"> Arithmetic Operators <mark>+</mark> / <mark>-</mark> / <mark>*</mark> / <mark>/</mark> /
      <mark>**</mark> / <mark>%</mark> / <mark>//</mark> </h2>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
    21 + 9                                                                             // -> 30
    21 - 11                                                                            // -> 10
    
    21 * 3                                                                             // -> 63
    10 ** 3                                                                            // -> 1000        // exponentiation 
    
    10 / 4                                                                             // -> 2.5
    10 % 4                                                                             // -> 2           // modulo division (reminder is returned)
    10 // 4                                                                            // -> 2           // floating point result is floored to the closest integer
    </pre>
    </details>
    <!------------------------------------------------------------------------------------>
    <hr>
    <h2 class="header"> Unary Operators <mark>+</mark> / <mark>-</mark> </h2>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
    x = 5
    y = -6
    
    -x                                                                                // -> -5        // unary <mark>-</mark> flips the sign of the number and returns the result   
    -y                                                                                // -> 6
    
    +x                                                                                // -> 5         // unary <mark>+</mark> doesn't do anything (just return the value as it is)
    +y                                                                                // -> -6
    
    myComplex = 4-4j
    -myComplex                                                                        // -> -4+4-4j   // for complex numbers both real and imaginary signes are flipped 
    </pre>
    </details>
    <!------------------------------------------------------------------------------------>
    <hr>
    <h2 class="header"> Assignement Operators <mark>=</mark> / <mark>+=</mark> / <mark>-=</mark> / <mark>*=</mark> /
      <mark>/=</mark> / <mark>**=</mark> / <mark>%=</mark> / <mark>//=</mark> / <mark>&=</mark> / <mark>|=</mark> /
      <mark>^=</mark> / <mark>&lt;&lt;=</mark> / <mark>&gt;&gt;=</mark> / <mark>:=</mark> </h2>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
// assignement operator ---------------------------------------------------------------
    someVar = 10 + 11
    someVar                                                                            // -> 21
    
    
// assignement arithmetic operators ---------------------------------------------------
    someVar = 10
    someVar += 11
    someVar                                                                            // -> 21
    
    someVar = 10
    someVar -= 5
    someVar                                                                            // -> 5
    
    someVar = 10
    someVar *= 3
    someVar                                                                            // -> 30
    
    someVar = 10
    someVar /= 2
    someVar                                                                            // -> 5.0
    
    someVar = 10
    someVar **= 3
    someVar                                                                            // -> 1000
    
    someVar = 10
    someVar %= 4
    someVar                                                                            // -> 2
    
    someVar = 10
    someVar //= 3
    someVar                                                                            // -> 3
    
// assignement bitwise operators ------------------------------------------------------
    someVar = 21
    someVar &= 68
    someVar                                                                            // -> 4
    
    someVar = 21
    someVar |= 68
    someVar                                                                            // -> 85
    
    someVar = 21
    someVar ^= 68
    someVar                                                                            // -> 81
    
    someVar = -152
    someVar &lt;&lt;= 7
    someVar                                                                            // -> -19456
    
    someVar = -152
    someVar &gt;&gt;= 7
    someVar                                                                            // -> -2
    
// walrus operators -------------------------------------------------------------------
    if (word_len := len(some_word)) > 1:
        print( f'word has {word_len} characters')                                      // -> 'word has 4 characters   
    
    
    def generate_numbers():
        for i in range(1, 51):
            yield i

    if (num := next((n for n in generate_numbers() if n % 2 == 0 and n % 3 == 0), None)):
        print(num)                                                                     // -> 6
    </pre>
    </details>
    <!------------------------------------------------------------------------------------>
    <hr>
    <h2 class="header"> Comparison Operators <mark>==</mark> / <mark>!=</mark> / <mark>&lt;</mark> / <mark>&lt;=</mark> /
      <mark>&gt;=</mark> </h2>
    <p> - in Python ther's no loose comparison (like in JS), if we try to compare different data types (other than number
      types) comparison operators always return <mark>False</mark> </p>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
// == / != ----------------------------------------------------------------------------
    'someStr' == 'someStr'                                                             // -> True
    'someStr' == 21                                                                    // -> False
    'someStr' != 21                                                                    // -> True
    
    myList1 = [1, 2, 3, (10, 'myStr', {4-9j})]
    myList2 = [1, 2, 3, (10, 'myStr', {4-9j})]
    myList1 == myList2                                                                 // -> True        // can compare any data type 
    
    class Test1:
        def __init__(self, a):
            self.a = a
    class Test2:
        def __init__(self, a):
            self.a = a
    
    obj1 = Test1('a')
    obj2 = Test2('a')
    obj1 == obj2                                                                       // -> False       // -! cannot compare objects (always returns <mark>False</mark>)  
    
    obj3 = obj1
    obj1 == obj3                                                                       // -> True        // for same references returns <mark>True</mark> though 
    
// &lt; / &lt;= / &gt; / &gt;= --------------------------------------------------------------------
    2 &lt; 2.1                                                                            // -> True
    'alpha' &lt; 'beta'                                                                   // -> True        // strings are compared in unicode order    
    
    10.5 &lt;= 10.5                                                                       // -> True
    'alpha' &lt;= 'alpha'                                                                 // -> True    
    
    2.1 &gt; 2                                                                            // -> True
    'beta' &gt; 'alpha'                                                                   // -> True  
    
    10.5 &gt;= 10.5                                                                       // -> True
    'alpha' &gt;= 'alpha'                                                                 // -> True    
    </pre>
    </details>
    <!------------------------------------------------------------------------------------>
    <hr>
    <h2 class="header"> Identity Operators <mark>is</mark> / <mark>is not</mark> </h2>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
    list1 = [1, 2, 3]
    list2 = [1, 2, 3]
    list3 = list1
    
// is / is not ------------------------------------------------------------------------
    list1 is list2                                                                     // -> False         // <mark>list1</mark> and <mark>list2</mark> are equal but not point to the same underlying data in memory 
    list1 is not list2                                                                 // -> True 
    
    list1 is list3                                                                     // -> True          // <mark>list1</mark> and <mark>list2</mark> point to the same underlying data in memory 
    list1 is not list3                                                                 // -> False
    
    
// is VS == ---------------------------------------------------------------------------
    list1 == list2                                                                     // -> True          // operator return <mark>True</mark> if data is equal  
    list1 == list3                                                                     // -> True          // same data is always equal 
    
    list1 is list2                                                                     // -> False         // if we want to be sure that variables point to the same data the <mark>is</mark> operator the winner!   
    list1 is list3                                                                     // -> True 
    </pre>
    </details>
    <!------------------------------------------------------------------------------------>
    <hr>
    <h2 class="header"> Logical Operators <mark>and</mark> / <mark>or</mark> / <mark>not</mark> </h2>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
// and --------------------------------------------------------------------------------
    'some string' and 21                                                               // -> 'some string'            // first expression is truty -> second expression returned 
    0 and imNeverEvaluated                                                             // -> 0                        // first expression is falsy -> first expression returned       // -! 2nd expression is never evaluated 
    
    
// or ---------------------------------------------------------------------------------
    0 or 'some string'                                                                 // -> 'some string'            // first expression is falsy -> second expression returned 
    1 + 1 or imNeverEvaluated                                                          // -> 2                        // first expression is falsy -> fist expression returned        // -! 2nd expression is never evaluated 
    
    
// not --------------------------------------------------------------------------------
    not 1 + 1                                                                          // -> False                    // returns <mark>False</mark> because the expression is truthy   
    not 10 - 10                                                                        // -> True                     // return <mark>True</mark> because the expression is falsy  
    </pre>
    </details>
    <!------------------------------------------------------------------------------------>
    <hr>
    <h2 class="header"> Bitwise Operators <mark>&</mark> / <mark>|</mark> / <mark>^</mark> / <mark>~</mark> /
      <mark>&lt;&lt;</mark> / <mark>&gt;&gt;</mark> </h2>
    <p> - Python uses two's complement to represent negative integers in binary </p>
    <p> - Python does not have <mark>>>></mark> bitwise because integers are arbitrary large </p>
    <details class="example">
      <summary> DEMO </summary>
      <pre>
// bitwise AND ------------------------------------------------------------------------
    21 & 68;                                                                           // -> 4 
        //               (Python binary representation)  
        // 21               ->   10101 
        // 68               -> 1000100 
        //  4               ->     100                                                 // sets the bits to 1 where both operands have 1 bits 
    
    -21 & -68;                                                                         // -> -88 
        //               (Python binary representation)  
        //  -21             -> 11101011                                                // -! Python uses two's complement to represent negative integers  
        //  -68             -> 10111100
        //  -88             -> 10101000
        
        
// bitwise OR -------------------------------------------------------------------------
    21 | 68;                                                                           // -> 85       
        //               (Python binary representation)  
        // 21               ->   10101 
        // 68               -> 1000100 
        // 85               -> 1010101                                                 // sets the bits to 1 where operands have 1 bits 
    
    
// bitwise XOR ------------------------------------------------------------------------           
    21 ^ 68;                                                                           // -> 81 
        //               (Python binary representation)  
        // 21               ->   10101 
        // 68               -> 1000100 
        // 81               -> 1010001                                                 // sets the bits to 1 where operands have 1 bits 
                                                                                       // sets the bits to 0 where both operands have 1 bits 
    
// bitwise NOT ------------------------------------------------------------------------  
    ~21                                                                                // -> -22 
        //               (Python binary representation)  
        //   21             ->    10101  
        //  -22             -> 11101010                                                // inverses the bits 
        
    ~68                                                                                // -> -69 
        //   68             ->  1000100                                 
        //  -69             -> 10111011                                                // inverses the bits 
    
    ~-341                                                                              // -> 340
        //  -341            -> 1010101011
        // 340              ->  101010100                                              // inverses the bits
    
    
// bitwise left shift -----------------------------------------------------------------
    21 &lt;&lt; 1;                                                                           // -> 42
        //               (Python binary representation)  
        // 21               -> 10101 
        // 42               -> 101010                                                  // shift bits to left by 1, adds 0's on the right while shifting  
    
    68 &lt;&lt; 3;                                                                           // -> 544
        // 68               -> 1000100 
        //                  -> 1000100000                                              // shift bits to left by 3, adds 0's on the right while shifting
        
    -152 &lt;&lt; 7;                                                                         // -> -195456
        //  -152            -> 101000001001
        //  -195456         -> 1010000010010000000
        
        
// bitwise right shift ----------------------------------------------------------------
    21 &gt;&gt; 1;                                                                           // -> 10
        //               (Python binary representation)  
        // 21               -> 10101 
        // 10               -> 1010                                                    // shift bits to right by 1 (basically removes 1 bit from left)
    
    68 &gt;&gt; 3;                                                                           // -> 8
        // 68               -> 1000100 
        // 8                -> 1000                                                    // shift bits to rigght by 3 (basically removes 3 bits from right)
    
    -152 &gt;&gt; 7;                                                                         // -> -2
        //  -152            -> 101101000
        //  -2              -> 10
    </pre>
    </details>

    <br><br>
  </body>

</html>