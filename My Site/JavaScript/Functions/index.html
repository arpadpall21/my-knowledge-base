<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title> Functions </title>    
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous"> 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" type="text/css" href="styles.css">
    <link rel="stylesheet" href="../../Assets/stylesPages.css"> 
    <script src="../../Assets/scriptPages.js"></script>
</head>
<body>
<h1> Functions (ver 4.0.0) </h1>
    <p> Updated: ( 2017-06-25 / 2018-01-27 / 2018-01-31 / 2018-03-14 / 2018-05-25 / 2019-04-18 / 2020-10-19)</p>
    <nav class="sitenav">
      <a href="../../index.html">MySite > </a>
      <a href="../index.html">JavaScript > </a> Functions
    </nav>
<table class="table">
    <tr>
        <th style="width:30%;"> Method </th>
        <th> Description </th>
    </tr>
    <tr class="01.01">
        <td> <strong>fn</strong>.call(<strong>targObj</strong><i>, arg, ...</i>) </td>
        <td> 
            - calls an object's method on another object  
            <span id="browserSupport" title="updated: 2021-05-19">
                <span><i class="fab fa-chrome"></i> 1 </span>
                <span><i class="fab fa-firefox"></i> 1 </span>
                <span><i class="fab fa-opera"></i> 4 </span>
                <span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 5.5 </span>
                <span><i class="fab fa-safari"></i> 1 </span>
                <span><i class="fab fa-node-js"></i> 0.10 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>fn</strong>.apply(<strong>targObj</strong><small>, [<i>arg, ...</i>]</small>) </td>
        <td> 
            - calls an object's method on another object
            <span id="browserSupport" title="updated: 2021-05-19">
                <span><i class="fab fa-chrome"></i> 1 </span>
                <span><i class="fab fa-firefox"></i> 1 </span>
                <span><i class="fab fa-opera"></i> 4 </span>
                <span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 5.5 </span>
                <span><i class="fab fa-safari"></i> 1 </span>
                <span><i class="fab fa-node-js"></i> 0.10 </span>
            </span>
        </td>
    </tr>
    <tr>
      <td>|</td>
      <td></td>
    </tr>
    <tr>
        <td> <strong>fn</strong>.bind(<strong>targObj</strong><i>, arg, ...</i>) </td>
        <td> 
            - returns a new function which is when called its <mark>this</mark> keyword is bound to the <strong>targObj</strong>
            <span id="browserSupport" title="updated: 2021-05-19">
                <span><i class="fab fa-chrome"></i> 1 </span>
                <span><i class="fab fa-firefox"></i> 1 </span>
                <span><i class="fab fa-opera"></i> 4 </span>
                <span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 5.5 </span>
                <span><i class="fab fa-safari"></i> 1 </span>
                <span><i class="fab fa-node-js"></i> 0.10 </span>
            </span>
        </td>
    </tr>
</table>
<h2 style="color:green;"><u> Notes : </u></h2>
    <details class="example" id="notes">
    <summary> Notes :</summary>
    </details>
<h2 style="color:green;"><u> Useful Links : </u></h2>
    <p><a href="https://www.w3schools.com/js/js_function_definition.asp" target="_blank">W3Schools JavaScript Function </a></p>
    <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" target="_blank"> Generator Function (developer.mozilla.org)</a></p>
<h2 style="color:green;"><u> Remember This : </u></h2>
<h2 style="color:green;"><u> Description and Demonstration : </u></h2>
    <p> - JavaScript function is a block of code executed when something invokes (calls) it</p>
    <p> - local variables are created when a function starts, and deleted when the function is completed </p>
    <p> - when a piece of code is executed in the function body without returning the value is called a <u>side effect</u></p>
    <pre class="syntax">
SYNTAX:
  <span style="color:darkgray;">// ----------------------------------------------------------------------------------</span>  <span id="browserSupport" style="color:yellow;" title="updated :2021-05-15"><span><i class="fab fa-chrome"></i> 1 </span><span><i class="fab fa-firefox"></i> 1 </span><span><i class="fab fa-opera"></i> 3 </span><span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 4 </span><span><i class="fab fa-safari"></i> 1 </span><span><i class="fab fa-node-js"></i> 0.10 </span></span>    
            function <strong>fnID</strong>(<i>arg, ...</i>) {                                                  // arguments are local variables
                this                                                                   // the <mark>this</mark> keyword refers to the object what called this function (in regular functions)   
                
                <i>// some code...</i>
                
                return <i>exp</i>                                                             // returns the expression to the caller
                <i>// omitted code...</i>                                                     // after the return keyword no code will be executed   
            }
            
            
  <span style="color:darkgray;">// <mark>Function</mark> constructor -------------------------------------------------------------</span>  <span id="browserSupport" style="color:yellow;" title="updated :2021-05-15"><span><i class="fab fa-chrome"></i> 1 </span><span><i class="fab fa-firefox"></i> 1 </span><span><i class="fab fa-opera"></i> 3 </span><span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 4 </span><span><i class="fab fa-safari"></i> 1 </span><span><i class="fab fa-node-js"></i> 0.10 </span></span>    
            new Function(<i>arg:str, ...</i>, <strong>fnBody:str</strong>)                                     // creates and returns a function (not recommended) 
            
            
  <span style="color:darkgray;">// <mark>new.target</mark> -----------------------------------------------------------------------</span>  <span id="browserSupport" style="color:yellow;" title="updated :2021-05-15"><span><i class="fab fa-chrome"></i> 46 </span><span><i class="fab fa-firefox"></i> 41 </span><span><i class="fab fa-opera"></i> 33 </span><span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 13 </span><span><i class="fab fa-safari"></i> 11 </span><span><i class="fab fa-node-js"></i> 5.0.0 </span></span>    
            <em><strong>fnId</strong>(){</em> new.target <em>}</em>                                                       // references <u>this function</u> if this function was called with the <mark>new</mark> keyword, otherwise returns <mark>undefined</mark> 
                                                                                         // used to detect if this function is called as a Constructor 
            
            
  <span style="color:darkgray;">// <mark>super</mark><strong>.prop|method</strong> ----------------------------------------------------------------</span>  <span id="browserSupport" style="color:yellow;" title="updated :2021-05-15"><span><i class="fab fa-chrome"></i> 42 </span><span><i class="fab fa-firefox"></i> 45 </span><span><i class="fab fa-opera"></i> 29 </span><span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 13 </span><span><i class="fab fa-safari"></i> 7 </span><span><i class="fab fa-node-js"></i> 6.0.0 </span></span>    
            <em>{<strong>fnId</strong>(){</em> super<strong>.prop|method</strong> <em>}}</em>                                              // references the prototype object's property|method of the current object 
                                                                                         // available only in object methods that are declared with ES6 function declaration   
                                                                                         // calling <mark>super</mark> without property|method is not allowed (trows an error)  
    </pre>  
<details class="example">
<summary> DEMO </summary>
    <pre>
    function myFunction(a, b) {
        document.write("side Effect!");                                                // -! this is a side effect (expression value is returned with the function)
        return a + b;                                                                  // expression calculated and value returned 
    }
    myFunction(5, 5);                                                                  // -> "10"                              // this is how we call a function 
    
// Function constructor --------------------------------------------------------------- 
    var myFunction = Function("a", "b", "document.write('side Effect!'); return a + b;");   // does the same as the above function definition 
    
    typeof myFunction;                                                                 // -> 'function'                        // the Function constructor returns a function not an object apparently   
    
// new.target ------------------------------------------------------------------------- 
    function MyConstructor(a) {
        this.a = a;
        new.target;                                                                    // -> undefined                         // when called by   // -! MyConstructor("val")
    }                                                                                  // -> returns this function itself      // when called by   // -! new MyConstructor("val")
    
    MyConstructor("val");                                                              // function is not called as Constructor 
    new MyConstructor("val");                                                          // function is called as Constructor
    
// super ------------------------------------------------------------------------------ 
    var protObj = {p:'parentProp', parentFN(){ return 'parentMethod' }};
    
    var myObj = {
        regularMethod:function(){ 
            // super.p1                                                                // -! would throw an error the super keyword unexpected here (not ES6 object method) 
        },
        es6Method(){
            console.log( super.p );                                                    // -> 'parentProp'       // references the prototype 'p' property    
            console.log( super.parentFN() );                                           // -> 'parentMethod'     // references the prototype 'parentFN' method    
            
            // super;                                                                  // -! would thrown an error the super keyword cannot be called alone (we cannot reference the prototype like this)
        }
    }
    
    Object.setPrototypeOf(myObj, protObj);                                             // set protObj as prototype of myObj  
    
    myObj.es6Method();    
    </pre>
</details>
<details class="example">  
<summary> Example : </summary>
<h4 style="color:darkblue;"><u> <mark>Function</mark> constructor TEST </u></h4>    
    <p id="function_constructor"></p>
<script>
    var funcCons = new Function('a', 'b', 'return a + b');
    
    document.getElementById('function_constructor').innerHTML = "Function returns = " + funcCons(4, 7);
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;p id="function_constructor"&gt;&lt;/p&gt;
&lt;script&gt;
    var funcCons = new Function('a', 'b', 'return a + b');
    
    document.getElementById('function_constructor').innerHTML = "Function returns = " + funcCons(4, 7);
&lt;/script&gt;
        </pre>
        </details>
<!----------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> <mark>new.target</mark> TEST </u></h4>
<script>
    function MyObj(a, b) {
        this.a = a;
        this.b = b;
        document.write(new.target + "<br>");
    }
    
    MyObj();                                        // when this is called the "new.target" returns "undefined" because the "new" keyword wasn't used
    new MyObj();                                    // when this is called the "new.target" references the constructor itself because we call it by using the "new" keyword 
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
&lt;script&gt;
    function MyObj(a, b) {
        this.a = a;
        this.b = b;
        document.write(new.target + "<br>");
    }
    
    MyObj();                                        // when this is called the "new.target" returns "undefined" because the "new" keyword wasn't used
    new MyObj();                                    // when this is called the "new.target" references the constructor itself because we call it by using the "new" keyword     
&lt;/script&gt;
        </pre>
        </details>
<!----------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> <mark>super</mark> TEST </u></h4>
    <p style="background-color:yellow;"> - this works only on literal object initialization, <u>and only if the method is created by <i class="fab fa-js">6</i> declaration</u></p>
<script>
/*
// this is not working because the method is NOT declared with the ES6 syntax (throws an Error) 

    let testObj1 = {prop1:"testObj1_Prot", meth:function(){return "testObj1 method fired!"}};
    let testObj2 = {prop1:"testObj2_Prot", meth:function(){return "testObj2 method fired!"}};
*/
    let testObj1 = {prop1:"testObj1_Prot", meth(){return "testObj1 method fired!"}};
    let testObj2 = {prop1:"testObj2_Prot", meth(){return super.meth()}};
    let testObj3 = {prop1:"testObj3_Prot", meth(){return super.prop1}};
    
    Object.setPrototypeOf(testObj2, testObj1);
    Object.setPrototypeOf(testObj3, testObj1);
    var isprotObj2 = testObj1.isPrototypeOf(testObj2);                       // testObj1 is the prototype of testObj2
    var isprotObj3 = testObj1.isPrototypeOf(testObj2);                       // testObj1 is the prototype of testObj3
    
    var parentMethod = testObj2.meth();                     // -> "testObj1 method fired!"      // returns the parent object's method result 
    var parentProperty = testObj3.meth();                   // -> "testObj1_Prot"               // returns the parent object's property value 
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
&lt;script&gt;
/*
// this is not working because the method is NOT declared with the ES6 syntax (throws an Error) 

    let testObj1 = {prop1:"testObj1_Prot", meth:function(){return "testObj1 method fired!"}};
    let testObj2 = {prop1:"testObj2_Prot", meth:function(){return "testObj2 method fired!"}};
*/
    let testObj1 = {prop1:"testObj1_Prot", meth(){return "testObj1 method fired!"}};
    let testObj2 = {prop1:"testObj2_Prot", meth(){return super.meth()}};
    let testObj3 = {prop1:"testObj3_Prot", meth(){return super.prop1}};
    
    Object.setPrototypeOf(testObj2, testObj1);
    Object.setPrototypeOf(testObj3, testObj1);
    var isprotObj2 = testObj1.isPrototypeOf(testObj2);                       // testObj1 is the prototype of testObj2
    var isprotObj3 = testObj1.isPrototypeOf(testObj2);                       // testObj1 is the prototype of testObj3
    
    var parentMethod = testObj2.meth();                     // -> "testObj1 method fired!"      // returns the parent object's method result 
    var parentProperty = testObj3.meth();                   // -> "testObj1_Prot"               // returns the parent object's property value 
&lt;/script&gt;
        </pre>
        </details>
</details>    
<!----------------------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue"><u> Function definition|expression VS Function declaration </u></h2>
    <p> - <u>in JavaScript declarations are always moved on the top of the scope!</u> </p>
    <p> - <u>Function Definitions</u> or <u>Function Expressions</u> are created and structured with the document workflow </p>
    <p> - <u>Function Declarations</u> <u style="color:yellow;">are Hoisted!</u> not part of the document workflow, they are automatically moved on the top of their scope </p>
    <pre class="syntax">
Example :   var <strong>funcID</strong> = function() {}                                                 // function expression | definition 

            function <strong>funcID</strong>() {}                                                       // function declaration 
    </pre>
<details class="example">
<summary> DEMO </summary>
    <pre>
// Function Definition|Expression -----------------------------------------------------
    myFunction();                                                                      // this will throw a "TypeError" because the function definition|expression does not exist here yet!
    var myFunction = function() { alert("Fired") };            
    myFunction();                                                                      // this will work because we call the function definition/expression <u>after</u> it is created!
    
// Function Declaration ---------------------------------------------------------------
    myFunction();                                                                      // this will work even if the function is declared after because the function declaration is automatically moved on the top
    function myFunction() { alert("Fired") };                 
    </pre>
</details>
<details class="example">
<summary> Example : </summary>
<h4 style="color:darkblue;"><u> TEST-1 </u></h4>
    <p id="func_ex_1"></p>
    <p id="func_ex_2"></p>
<script>
    initValue_1();                      // calling a function declaration before it is created no problem (Hoisted to the top)
    function initValue_1() {
        document.getElementById("func_ex_1").innerHTML = "Functions Declaration Fired!"
    }
    
    // initValue_2();                      // calling a function definition before it is created will result an error! (see console)
    var initValue_2 = function() {
        document.getElementById("func_ex_1").innerHTML = "Functions Definition Fired!"
    }
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;p id="func_ex_1"&gt;&lt;/p&gt;
    &lt;p id="func_ex_2"&gt;&lt;/p&gt;
&lt;script&gt;
    initValue_1();                      // calling a function declaration before it is created no problem (Hoisted to the top)
    function initValue_1() {
        document.getElementById("func_ex_1").innerHTML = "Functions Declaration Fired!"
    }
    
    // initValue_2();                      // calling a function definition before it is created will result an error! (see console)
    var initValue_2 = function() {
        document.getElementById("func_ex_1").innerHTML = "Functions Definition Fired!"
    }
&lt;/script&gt;
        </pre>
        </details>
<!--------------------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> meter and feet conversion </u></h4>
    <fieldset>
    Enter value here : <input type="number" id="inP"><span> Result = <span id="convertionResult">&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <br>
    <button onclick="toFeet()">Feet to Meter</button>
    <button onclick="toMeter()">Meter to Feet</button>
    </fieldset>
<script>
    function toMeter() {
        var meter = document.getElementById('inP').value;
        document.getElementById('convertionResult').innerHTML = meter * 3.28084 + " feet";
        
    }
    function toFeet() {
        var feet = document.getElementById('inP').value;
        document.getElementById('convertionResult').innerHTML = feet / 3.28084 + " meters";
    }
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;fieldset&gt;
    Enter value here : &lt;input type="number" id="inP"&gt;&lt;span&gt; Result = &lt;span id="convertionResult"&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;&lt;/span&gt; &lt;br&gt;
    &lt;button onclick="toFeet()">Feet to Meter&lt;/button&gt;
    &lt;button onclick="toMeter()">Meter to Feet&lt;/button&gt;
    &lt;/fieldset&gt;
&lt;script&gt;
    function toMeter() {
        var meter = document.getElementById('inP').value;
        document.getElementById('convertionResult').innerHTML = meter * 3.28084 + " feet";
        
    }
    function toFeet() {
        var feet = document.getElementById('inP').value;
        document.getElementById('convertionResult').innerHTML = feet / 3.28084 + " meters";
    }
&lt;/script&gt;
        </pre>
        </details>
</details>
<!----------------------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue"><u> Function arguments </u></h2>
    <p> - function arguments are the real values passed and received by the function </p>
    <p> - JavaScript does not perform any type checking on passed arguments and will return "undefined" on missing arguments <u>(unless an optional argument is set with the <mark>=</mark> operator)</u> </p>
    <p> - because there is no type checking <span style="color:yellow;">actions can also be passed</span> not just values </p>
    
    <pre class="syntax">
SYNTAX : 
  <span style="color:darkgray;">// default argument -----------------------------------------------------------------</span>  <span id="browserSupport" style="color:yellow;" title="updated :2021-05-15"><span><i class="fab fa-chrome"></i> 49 </span><span><i class="fab fa-firefox"></i> 15 </span><span><i class="fab fa-opera"></i> 36 </span><span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 14 </span><span><i class="fab fa-safari"></i> 10 </span><span><i class="fab fa-node-js"></i> 6.0.0 </span></span>    
            <em>function(</em><i>arg</i> = <strong>val</strong><em>) { }</em>                                                    // <i class="fab fa-js">6</i> sets a default value for the argument (in case no value is passed)    
            
            
  <span style="color:darkgray;">// <mark>arguments</mark> object -----------------------------------------------------------------</span>  <span id="browserSupport" style="color:yellow;" title="updated :2021-05-15"><span><i class="fab fa-chrome"></i> 1 </span><span><i class="fab fa-firefox"></i> 1 </span><span><i class="fab fa-opera"></i> 3 </span><span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 3 </span><span><i class="fab fa-safari"></i> 1 </span><span><i class="fab fa-node-js"></i> 0.10 </span></span>    
            <em>function <strong>fnId</strong>() {</em>
                arguments                                                              // references the passed function arguments in an Array <u>(available only inside the function body)</u>    
                                                                                         
                arguments.length                                                       // returns the number of <u>recevied arguments</u> by the function    <span id="browserSupport" style="color:yellow;" title="updated :2021-05-15"><span><i class="fab fa-chrome"></i> 1 </span><span><i class="fab fa-firefox"></i> 1 </span><span><i class="fab fa-opera"></i> 4 </span><span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 4 </span><span><i class="fab fa-safari"></i> 1 </span><span><i class="fab fa-node-js"></i> 0.10 </span></span>     
                arguments.callee                                                       // returns the parent function of the <mark>arguments</mark> object         <span id="browserSupport" style="color:yellow;" title="updated :2021-05-15"><span><i class="fab fa-chrome"></i> 1 </span><span><i class="fab fa-firefox"></i> 1 </span><span><i class="fab fa-opera"></i> 4 </span><span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 6 </span><span><i class="fab fa-safari"></i> 1 </span><span><i class="fab fa-node-js"></i> 0.10 </span></span>     
            <em>}</em>
    </pre>
<details class="example">
<summary> DEMO </summary>
    <pre>
// arguments object / optional argument -----------------------------------------------
    function myFunction(a, b, c="tarka ", d) {
        return a +                                      
        arguments[1] +                                                                 // referst the 2nd argument (b)
        c +                                                                            // because there is no 3rd argument passed the default value "tarka" kicks in 
        d;                                                                             // we did not passed a 4th argument so this will be returned as "undefined"
    }
    myFunction("kicsi ", "kutya ");                                                    // -> "kicsi kutya tarka undefined"
    
// arguments object -------------------------------------------------------------------
    function myFunction(a) {
        arguments.length;                                                              // -> 3     // number of PASSED arguments is returned 
        arguments.calle;                                                               // -> returns this function itself 
    } 
    myFunction(4, 74, 14);
    
// passing action as function argument ------------------------------------------------
    function myFunction(a) {
        a("Ta Daa I'm pirnted in console")                                             // the passed expression is executed here (side effect)
    }
    myFunction(console.log);                                                           // we pass an expression as argument 
    </pre>
</details>
<details class="example">
<summary> Example : </summary>
<h4 style="color:darkblue;"><u> <mark>arguments</mark> TEST </u></h4>
    <p id="missingParam"></p>
<script>
    function paramMiss(a, b, c) {
        if (arguments[3] === undefined) {       // bakcup value set ot the 4th parameter
            arguments[3] = "terminus";
        }
        return a + " . " + b + " . " + c + " . " + arguments[3];
    }
    
    document.getElementById('missingParam').innerHTML = paramMiss("uno", "duo");        // 3rd and 4th are missing
                                                                                        // 3rd parameter retunrs undefined but the 4th has a backup value
</script>
    <details>
    <summary> CODE : </summary>
    <pre>
    &lt;p id="missingParam"&gt;&lt;/p&gt;
&lt;script&gt;
    function paramMiss(a, b, c) {
        if (arguments[3] === undefined) {       // bakcup value set ot the 4th parameter
            arguments[3] = "terminus";
        }
        return a + " . " + b + " . " + c + " . " + arguments[3];
    }
    
    document.getElementById('missingParam').innerHTML = paramMiss("uno", "duo");        // 3rd and 4th are missing
                                                                                        // 3rd parameter retunrs undefined but the 4th has a backup value
&lt;/script&gt;
    </pre>
    </details>
<!--------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> optional argument TEST </u></h4>
    <p id="optArg"></p>
<script>
$(function(){    
    var car = function(a, b = " Germany ") {
        return a + " is made in " + b;
    }
// print
    $("#optArg").text( 
        car("Lada", "Russia") +         // the second argument is set and used by the function
            " and " +
        car("Audi")                     // the second argument is not set here, JS uses the optional "Germany" here
    );
});
</script>
        <details>
        <summary> CODE : </summary>
    <pre>
    &lt;p id="optArg"&gt;&lt;/p&gt;
&lt;script&gt;
$(function(){    
    var car = function(a, b = " Germany ") {
        return a + " is made in " + b;
    }
// print
    $("#optArg").text( 
        car("Lada", "Russia") +         // the second argument is set and used by the function
            " and " +
        car("Audi")                     // the second argument is not set here, JS uses the optional "Germany" here
    );
});
&lt;/script&gt;
    </pre>
        </details>
<!--------------------------------------------------------------------------------------------------------------------->    
<h4 style="color:darkblue;"><u> <mark>arguments</mark> TEST-2 </u></h4>
    <p id="argument_demo"></p>
<script>
    var countArg;
    var argCountMemo = "";
    var sum = 0;
    
    function testArg() {
        arguments[1] = 0;                                   // the second argument's value is set to "0" 
        
        countArg = arguments.length;                        // this returns the number of arguments in a variable
        for (var i = 0; i < arguments.length; i++) {        // this loop returns the arguments
            argCountMemo += arguments[i] + " / ";
        }
        for (var k = 0; k < arguments.length; k++) {        // addition the arguments 
            sum = sum + arguments[k];
        }
    }
    testArg(2, 4, 7);
    var memory_A = " (Arguments are = " + argCountMemo + ") (Number of arguments = " + countArg + ") (sum of arguments is = " + sum + ")";
    
    argCountMemo = "";              // reset counters! (I'm awesome!!!)
    sum = 0;
    
    testArg(5, 8, 10, 23, 5);
    var memory_B = " (Arguments are = " + argCountMemo + ") (Number of arguments = " + countArg + ") (sum of arguments is = " + sum + ")";
    
    argCountMemo = "";              // reset counters! (I'm awesome!!!)
    sum = 0;
    
    testArg(143, 74,938, 65, 345, 22, 982);
    var memory_C = " (Arguments are = " + argCountMemo + ") (Number of arguments = " + countArg + ") (sum of arguments is = " + sum + ")";
    
    document.getElementById('argument_demo').innerHTML = 
        "function Test_1 = " + memory_A + "<br>" +
        "function Test_2 = " + memory_B + "<br>" +
        "function Test_3 = " + memory_C;
</script>
    <details>
    <summary> CODE : </summary>
    <pre>
    &lt;p id="argument_demo"&gt;&lt;/p&gt;
&lt;script&gt;
    var countArg;
    var argCountMemo = "";
    var sum = 0;
    
    function testArg() {
        arguments[1] = 0;                                   // the second argument's value is set to "0" 
        
        countArg = arguments.length;                        // this returns the number of arguments in a variable
        for (var i = 0; i &lt; arguments.length; i++) {        // this loop returns the arguments
            argCountMemo += arguments[i] + " / ";
        }
        for (var k = 0; k &lt; arguments.length; k++) {        // addition the arguments 
            sum = sum + arguments[k];
        }
    }
    testArg(2, 4, 7);
    var memory_A = " (Arguments are = " + argCountMemo + ") (Number of arguments = " + countArg + ") (sum of arguments is = " + sum + ")";
    
    argCountMemo = "";              // reset counters! (I'm awesome!!!)
    sum = 0;
    
    testArg(5, 8, 10, 23, 5);
    var memory_B = " (Arguments are = " + argCountMemo + ") (Number of arguments = " + countArg + ") (sum of arguments is = " + sum + ")";
    
    argCountMemo = "";              // reset counters! (I'm awesome!!!)
    sum = 0;
    
    testArg(143, 74,938, 65, 345, 22, 982);
    var memory_C = " (Arguments are = " + argCountMemo + ") (Number of arguments = " + countArg + ") (sum of arguments is = " + sum + ")";
    
    document.getElementById('argument_demo').innerHTML = 
        "function Test_1 = " + memory_A + "&lt;br&gt;" +
        "function Test_2 = " + memory_B + "&lt;br&gt;" +
        "function Test_3 = " + memory_C;
&lt;/script&gt;
    </pre>
    </details>
</details>
<!--------------------------------------------------------------------------------------------------------------------------------->
<hr>    
<h2 style="color:darkblue;"><u> Self-Invoking function </u></h2>
    <pre class="syntax">
SYNTAX :    (<strong>fn</strong>)(<i class="openable">arg, ...<div>
                <p> - arguments to pass to the enclosed function </p>
            </div></i>)                                                            // the enclosed function calls itself (self-invoking function)
    </pre>
<details class="example">
<summary> DEMO </summary>
    <pre>
    (function(arg_A, arg_B, arg_C) {
        arg_A + " " + 
        arg_B + " a " + 
        arguments[2] + " ans ";                                                        // -> "Pityi Palko a 10 ans"
    })("Pityi", "Palko", 10);                                                          // areguments passed to the self-invoking function 
    </pre>
</details>
<details class="example">
<summary> Example : </summary>
<h4><u> TEST </u></h4>
    <p id="self-invoke"></p>
    <p id="self-invoke2"></p>
<script>
    var globalVAR = "I've called myself :)";                                                    
    (function selfInvoke() {                                                                    
        document.getElementById('self-invoke').innerHTML = globalVAR;
    })();                                              
    
    (function() {                                                                               // anonymus function
        document.getElementById('self-invoke2').innerHTML = "I've also called myself :D";
    })();
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;p id="self-invoke"&gt;&lt;/p&gt;
    &lt;p id="self-invoke2"&gt;&lt;/p&gt;
&lt;script&gt;
    var globalVAR = "I've called myself :)";                                                    
    (function selfInvoke() {                                                                    
        document.getElementById('self-invoke').innerHTML = globalVAR;
    })();                                              
    
    (function() {                                                                               // anonymus function
        document.getElementById('self-invoke2').innerHTML = "I've also called myself :D";
    })();
&lt;/script&gt;
        </pre>
        </details>
</details>
<!--------------------------------------------------------------------------------------------------------------------------------->
<hr>     
<h2 style="color:darkblue;"><u> Closures </u></h2>
    <p> - in JavaScript a closure is a function that can access to its outer function scope <u>even after the outer function has finished</u> </p>
    <p> - the closure can 'remember' and access of its outer function <u>even after the outer function has finished</u> </p>
    <pre class="syntax">
SYNTAX:     function <strong>fn</strong>(){
                <strong style="color:darkgray;">// outer function scope </strong> 
                
                function <strong>closureFn</strong>(){
                    <strong style="color:darkgray;">// has access to the outer function's scope </strong> 
                }
                
                return <strong>closureFn</strong>
            }
            
            var <strong>id</strong> = <strong>fn</strong>();                                                             // the outer function is called and finished  
            <strong>id</strong>();                                                                      // the closure has access to the outer function's scope here  
    </pre>
<details class="example">
<summary> DEMO </summary>
    <pre>
    function makeUser(user){
        let user_ = user;
        
        function getUser(){                                                            // closure 
            return user_;
        }
        
        return getUser;                                                                // returns the closure   
    }
    
    var steven = makeUser('Steven');                                                   // the parent function called and finished here 
    
    steven();                                                                          // -> 'Steven'               // the closure remembers its parent scope even when the parent function is finished     
    </pre>
    <p> - in JavaScript we can create a Module (code pattern) with closures </p>
    <pre>
    function makeClient(client){
        let client_ = client;
        let account = 0;
        
        function deposit(sum){
            account += sum;
        }
        
        function withdraw(sum){
            account -= sum
        }
        
        function getBalance(){
            return account + 'Ft';
        }
        
        return {                                                                       // an object returned with all closures  
            client: client_,
            deposit: deposit,
            withdraw: withdraw,
            getBalance: getBalance 
        }
    }
    
    var steven = makeClient('Steven');                                                 // creating the client 
    
    steven.client;                                                                     // -> 'Steven'    
    steven.getBalance();                                                               // -> '0Ft'
    
    steven.deposit(1500);
    steven.deposit(5000);
    
    steven.getBalance();                                                               // -> '6500Ft'
    
    steven.withdraw(3000);
    
    steven.getBalance();                                                               // -> '3500Ft'
    </pre>
</details>
<!--------------------------------------------------------------------------------------------------------------------------------->
<hr>     
<h2 style="color:darkblue;"><u> Callback Functions </u></h2>
    <p> - a callback function is basically a function which is passed as argument into another function </p>
    <pre class="syntax">
SYNTAX:     function <strong>someFn</strong>(){
                <span style="color:darkgray;">// do some business logic here ...</span>
            }
            
            function <strong>fn</strong>(<strong>callback</strong>){
                <span style="color:darkgray;">// do some business logic here ...</span>
                
                <strong>callback</strong>();                                                            // callback called here  
            }
            
            <strong>fn</strong>(<strong>someFn</strong>);                                                                // we pass the callback function as argument   
    </pre>
<details class="example">
<summary> DEMO </summary>
    <pre>
    function someFn(){
        return 'callback value'
    }
    
    function myFn(clb){
        return clb();
    }
    
    myFn(someFn);                                                                      // -> 'callback value'   
    </pre>
</details> 
<!--------------------------------------------------------------------------------------------------------------------------------->
<hr>     
<h2 style="color:darkblue;"><u> Arrow Function <i class="fab fa-js">6</i> <span id="browserSupport" title="updated :2021-05-15"><span><i class="fab fa-chrome"></i> 45 </span><span><i class="fab fa-firefox"></i> 22 </span><span><i class="fab fa-opera"></i> 32 </span><span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 12 </span><span><i class="fab fa-safari"></i> 10 </span><span><i class="fab fa-node-js"></i> 4.0.0 </span></span> </u></h2>
    <p> - the arrow functions is a <u>nameless functions</u> which is a shortes version of traditional functions, <u> the <mark>arguments</mark> / <mark>super()</mark> / <mark>new.target</mark> keywords are NOT available inside it</u></p>
    <p> - in normal functions the <mark>this</mark> keyword always references the object that <u>called</u> the function where the <mark>this</mark> is </p>
    <p> - in arrow functions the <mark>this</mark> keyword awlays references the value of <mark>this</mark> keyword value <u>right before the arrow function</u> </p>
    <pre class="syntax">
SYNTAX :    const <strong>fnId</strong> = (<i>arg1, arg2, ...</i>) => {<i>executedCode</i>}                           // same as below            
            const <strong>fnID</strong> = function(<i>arg1, arg2, ...</i>) {<i>executedCode</i>}
    
  <span style="color:lightgreen;">// if the curly brackets are omitted the code is returned after the arrow -----------</span>
            const <strong>fnId</strong> = (<i>arg1, arg2, ...</i>) => <i>returnedCode</i>                             // same as below   
            const <strong>fnID</strong> = function(<i>arg1, arg2, ...</i>) {return <i>returnedCode</i>}
            
  <span style="color:lightgreen;">// if we pass only 1 argument the parentheses are optional --------------------------</span>
            const <strong>fnId</strong> = <strong>arg1</strong> => <i>returnedCode</i>                                          // same as below
            const <strong>fnID</strong> = function(<strong>arg1</strong>) {return <i>returnedCode</i>}
            
  <span style="color:lightgreen;">// if no argument is passed the parentheses are required ----------------------------</span>
            const <strong>fnId</strong> = () => <i>returnedCode</i>                                            // same as below
            const <strong>fnID</strong> = function() {return <i>returnedCode</i>}
    </pre>  
<details class="example">
<summary> DEMO </summary>
    <pre>
    var arrFn1 = (a, b) => { 
        var x = "The result is " + a + b;  
        return x;
    }  
    arrFn1(5, 7);                                                                      // -> "The result is 57"        
        
// arrow function without curly brackets ----------------------------------------------
    var arrFn2 = (a, b) => "The result is " + a + b;                                   // the entire code after the arrow is returned 
    arrFn2(5, 7);                                                                      // -> "The result is 57"        
        
// arrow function without parentheses -------------------------------------------------
    var arrFn2 = a => "The result is " + a ;                                           // we can omit the parentheses if we pass only 1 argument 
    arrFn2(5);                                                                         // -> "The result is 5"
    
// arrow function without arguments ---------------------------------------------------
    var arrFn2 = () => "No passed value here";                                         // parentheses are required if no argument is passed 
    arrFn2();                                                                          // -> "No passed value here"
    
// no function declaration possible ---------------------------------------------------
    function myFn() {return "blaBla" }                                                 // function declaration 
    myFn() => "blaBal";                                                                // -! no function declaration possible with arrow functions (no hoisting)
    </pre>
    <h4 style="color:darkblue;"><u> <mark>this</mark> keyword value </u></h4>
    <pre>
    var obj1 = {
        testFn1:function(){ this },                                                    // -> obj1{}             // this keyword represents this object (obj1)
        testFn2:() => { this },                                                        // -> Window object      // this keyword represents the Window object (this value right before the arrow function)    
        testThis: this                                                                 // -> Window object 
    }
    
// ------------------------------------------------------------------------------------
    var myObj = {testFn:function(){  
            fn1 = function(){ this };                                                  // -> Window object          // (object that called his function)
            fn1();                                                                     // -! should reference the 'myObj' object this is why the regular this keyword is a bit tricky to use   
            
            fn2 = () => { this };                                                      // -> myObj{...}             // references the parent object (this value right before the arrow function)   
            fn2();
            this;                                                                      // -> myObj{...}
        }
    }
    
// ------------------------------------------------------------------------------------
    class TestClass{
        constructor(){
            obj1.fn1 = function() { console.log(this) };                               // -> obj1{}                 // the object that called this method 
            obj1.fn2 = () => { console.log(this) };                                    // -> TestClass              // this value before the arrow function (this Constructor)
            console.log( this );                                                       // -> TestClass 
        }
    }
    
    var testObj = new TestClass();
    
    obj1.fn1();
    obj1.fn2();
    </pre>
</details>
<details class="example">
<summary> Example : </summary>
<h4 style="color:darkblue;"><u> traditional JS function VS arrow function </u></h4>
    <p id="funcPrint"></p>
<script>
    $(function(){
// traditional functions 
        function average_traditional(a, b, c) {
            return (a + b + c) / 3;
        }
// arrow functions
        const average_arrow = (a, b, c) => { return (a + b + c) / 3; };

// print
        $("#funcPrint").html(
            "traditional function = " + average_traditional(3, 6, 9) + "<br>" +
            "arrow functions = " + average_arrow(3, 6, 9)
        );
    });
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;p id="funcPrint"&gt;&lt;/p&gt;
&lt;script&gt;
    $(function(){
// traditional functions 
        function average_traditional(a, b, c) {
            return (a + b + c) / 3;
        }
// arrow functions
        const average_arrow = (a, b, c) => { return (a + b + c) / 3; };

// print
        $("#funcPrint").html(
            "traditional function = " + average_traditional(3, 6, 9) + "&lt;br&gt;" +
            "arrow functions = " + average_arrow(3, 6, 9)
        );
    });
&lt;/script&gt;
        </pre>
        </details>
<hr>
<!--------------------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> callback arrow function with event handler </u></h4>
    <p id="hoverCount"> Hover Over Me! <span>0</span> </p>
<script>
    $(document).ready(function(){
        var counter = 0;
        $("#hoverCount").mousemove( 
            () => { counter++;                                  // arrow function used 
                    $("#hoverCount *:first").text(counter);     
                  }                                             // multiple expression = curly brackets needed!
        );
    });
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;p id="hoverCount"&gt; Hover Over Me! &lt;span&gt;0&lt;/span&gt; &lt;/p&gt;
&lt;script&gt;
    $(document).ready(function(){
        var counter = 0;
        $("#hoverCount").mousemove( 
            () => { counter++;                                  // arrow function used 
                    $("#hoverCount *:first").text(counter);     
                  }                                             // multiple expression = curly brackets needed!
        );
    });
&lt;/script&gt;
        </pre>
        </details>
<hr>
<!--------------------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> self-invoking arrow function </u></h4>
<script>
    (() => { document.write("Code Fired!") })();                // self-invoking arrow function
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
&lt;script&gt;
    (() => { document.write("Code Fired!") })();                // self-invoking arrow function
&lt;/script&gt;
        </pre>
        </details>
<hr>
<hr>  
<!--------------------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> arrow function as Object method (testing the <mark>this</mark> value inside an arrow function) </u></h4>
<script>
    var testObj1_ = {prop1:"val1", getThis:function() {return this}};    // the "this" value is the object itself 
    var testObj2_ = {prop1:"val2", getThis:() => {return this}};         // the "this" value is the "window" object (because of the arrow function)
    
    var thisVal_traditional = testObj1_.getThis();                       // returns the object itself ("testObj1")
    var thisVal_arrow = testObj2_.getThis();                             // returns the "window" global object 
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
&lt;script&gt;
    var testObj1_ = {prop1:"val1", getThis:function() {return this}};    // the "this" value is the object itself 
    var testObj2_ = {prop1:"val2", getThis:() =&gt; {return this}};         // the "this" value is the "window" object (because of the arrow function)
    
    var thisVal_traditional = testObj1_.getThis();                       // returns the object itself ("testObj1")
    var thisVal_arrow = testObj2_.getThis();                             // returns the "window" global object 
&lt;/script&gt;
        </pre>
        </details>
<hr>  
<!--------------------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> <mark>this</mark> keyword</u> in normal VS arrow function TEST </u></h4>
    <pre>
    var obj1 = {
        testFn1:function(){ this },                                                    // -> obj1{}             // this keyword represents this object (obj1)
        testFn2:() => { this },                                                        // -> Window object      // this keyword represents the Window object (this value right before the arrow function)    
        testThis: this                                                                 // -> Window object 
    }
    
// ------------------------------------------------------------------------------------
    var myObj = {testFn:function(){  
            fn1 = function(){ console.log(this) };                                     // -> Window object          // (object that called his function)
            fn1();                                                                     // -! should referenc the 'myObj' object this is why the regular this keyword is a bit tricky to use   
            
            fn2 = () => { console.log(this) };                                         // -> myObj{...}             // references the parent object (this value right before the arrow function)   
            fn2();
            console.log(this);                                                         // -> myObj{...}
        }
    }
    
// ------------------------------------------------------------------------------------
    class TestClass{
        constructor(){
            obj1.fn1 = function() { console.log(this) };                               // -> obj1{}                 // the object that called this method 
            obj1.fn2 = () => { console.log(this) };                                    // -> TestClass              // this value before the arrow function (this Constructor)
            console.log( this );                                                       // -> TestClass 
        }
    }
    
    var testObj = new TestClass();
    
    obj1.fn1();
    obj1.fn2();
    </pre>
</script>
</details>
<!--------------------------------------------------------------------------------------------------------------------------------->
<hr>     
<h2 style="color:darkblue;" id="genFN_"><u> Generator <mark>function*</mark> <i class="fab fa-js">6</i> <span id="browserSupport" title="updated :2021-05-15"><span><i class="fab fa-chrome"></i> 39 </span><span><i class="fab fa-firefox"></i> 26 </span><span><i class="fab fa-opera"></i> 26 </span><span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 13 </span><span><i class="fab fa-safari"></i> 10 </span><span><i class="fab fa-node-js"></i> 4.0.0 </span></span></u></h2>  
    <p> - the ES6 generator function returns an iterable object without calling the function's body </p>
    <p> - calling the <mark>next()</mark> method on the returned iterable object executes the generator function's body <u>untill the next <mark>yield</mark> keyword which evaluates its expression and returns the value to the caller <b>than pauses the function's body</b></u></p>
    <p> - every time the <mark>next()</mark> called the generator function resumes from the previously paused position and runs untill the end of the next <mark>yield</mark> keyword's expression, <u style="color:yellow;">(Run/Pause interface)</u></p>
    <p> - the <mark>for...of</mark> loop also can be used to iterate through a generator object returned by a generator function </p>
    <pre class="syntax">
SYNTAX :    <em>function</em>* <strong>fnId</strong><em>(<i>arg, ...</i>) {</em>                                                 // when called returns an iterable object <u>without invoking the function's body</u>  
                yield <i>exp;</i>                                                               // when the <mark>next()</mark> is called evalueates and returns its expression <u>then stops function body execution immediately after the expression</u>    
                
                yield* <i>iterableObj;</i>                                                      // delegates the iteration cycle to the passed iterable object    
                return <i>exp;</i>                                                              // returns the expression as last iterable object value 
            <em>}</em> 
            
            var <strong>genObj</strong> = <strong>fnId</strong>();                                                       // creates the generator object    
    
<span style="color:darkgray;">// ----------------------------------------------------------------------------------</span>
                                                                                          <span id="browserSupport" title="updated :2021-05-15" style="color:yellow;"><span><i class="fab fa-chrome"></i> 39 </span><span><i class="fab fa-firefox"></i> 26 </span><span><i class="fab fa-opera"></i> 26 </span><span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 13 </span><span><i class="fab fa-safari"></i> 10 </span><span><i class="fab fa-node-js"></i> 4.0.0 </span></span>
            <strong>genObj</strong>.next(<i class="openable">val<div>
                <p> - the called <mark>yield</mark> keyword value (excluded from the yield's expression) </p>
            </div></i>)                                                          // calls the next <mark>yield</mark> expression in the generator funtion's body and returns the value in an iterable result object (<mark>{value:val, done:bol}</mark>)    
            
                                                                                          <span id="browserSupport" title="updated :2021-05-15" style="color:yellow;"><span><i class="fab fa-chrome"></i> 50 </span><span><i class="fab fa-firefox"></i> 38 </span><span><i class="fab fa-opera"></i> 37 </span><span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 13 </span><span><i class="fab fa-safari"></i> 10 </span><span><i class="fab fa-node-js"></i> 6.0.0 </span></span>
            <strong>genObj</strong>.return(<i>val</i>)                                                         // ends the generator object and returns the passed <i>val</i> as the generator's last value    
            
                                                                                          <span id="browserSupport" title="updated :2021-05-15" style="color:yellow;"><span><i class="fab fa-chrome"></i> 39 </span><span><i class="fab fa-firefox"></i> 26 </span><span><i class="fab fa-opera"></i> 26 </span><span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 13 </span><span><i class="fab fa-safari"></i> 10 </span><span><i class="fab fa-node-js"></i> 4.0.0 </span></span>
            <strong>genObj</strong>.throw(<i>err</i>)                                                          // throw the passed <i>err</i> in the generator function then resumes execution the function body untill the end of the next <mark>yield</mark> expression, which result is returned in an iterable result object (<mark>{value:val, done:bol}</mark>)    
    </pre>
<details class="example">
<summary> DEMO </summary>
    <pre>
    function* genFn() {
            yield 1;
            yield* [2, 3];                                                             // delegates the iteration cycle to an iterable object  
            yield 4;
    };
    
    var count = genFn();
    
// next() / end() ---------------------------------------------------------------------
    count.next();                                                                      // -> {value:1, done:false}
    count.next();                                                                      // -> {value:2, done:false}
    count.next();                                                                      // -> {value:3, done:false}
    count.return('end');                                                               // -> {value:'end', done:true}   // ends the generator 
    
// for ...of (iterating through a generator object) -----------------------------------
    for(i of genObj){
        console.log( i );                                                              // -> 1 | 2 | 3 | 4 
    }
    </pre>
    <pre>
    function* genFn() {
            try { 
                yield 1; // !! Error('count fail') is thrown here when 'throw()' is called 
            }catch(err) { 
                err.message                                                            // -> 'count fail'               // caught error message
            }
            yield 2;     // !! the 'throw()' method runs the function body till here and returns the next yield '2' value  
    };
    
    var count = genFn();
    
// next() / end() ---------------------------------------------------------------------
    count.next();                                                                      // -> {value:1, done:false}
    count.throw(new Error('count fail'));                                              // -> {value:2, done:false}      // throws the error in the generator when resumes  
                                                                                                                        // then resumes till the end of the next yeld   
    </pre>
</details>
<details class="example">
    <summary> Example : </summary> 
<h4><u> generator dynamically created an iterable object </u></h4>
    <p id="printIterable"></p>
<script>
    function* countIterable(start) {        // create an Iterable Object with 3 values
        yield start;
            start++
        yield start;
            start++
        yield start;                        // values are incremented to each yield
    }
    var myCount = countIterable(4);
// print
    document.getElementById('printIterable').innerHTML = 
        myCount.next().value + " / " +      // retrived data from the iterable object
        myCount.next().value + " / " +
        myCount.next().value + " / " +
        myCount.next().value;               // iterable object is empty for the 4th call
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;p id="printIterable"&gt;&lt;/p&gt;
&lt;script&gt;
    function* countIterable(start) {        // create an Iterable Object with 3 values
        yield start;
            start++
        yield start;
            start++
        yield start;                        // values are incremented to each yield
    }
    var myCount = countIterable(4);
// print
    document.getElementById('printIterable').innerHTML = 
        myCount.next().value + " / " +      // retrived data from the iterable object
        myCount.next().value + " / " +
        myCount.next().value + " / " +
        myCount.next().value;               // iterable object is empty for the 4th call
&lt;/script&gt;
        </pre>
        </details>
<h4><u> generator with for of loop </u></h4>    
    <p id="printIt_for_of"></p>
<script>
    let itemCollector = "";
    // let iterator = function*() {
    function* iterator() {
        yield "un";
        yield "deux";
        yield "trois";
        return "quatre";            // for.. of loop does not get this value (reason why no to use return!!!)
    }
    let iteratorObj = iterator();
    
    for(let i of iteratorObj) {
        itemCollector += i + " ";
    }
// print
    document.getElementById('printIt_for_of').innerHTML = itemCollector;
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;p id="printIt_for_of"&gt;&lt;/p&gt;
&lt;script&gt;
    let itemCollector = "";
    // let iterator = function*() {
    function* iterator() {
        yield "un";
        yield "deux";
        yield "trois";
        return "quatre";            // for.. of loop does not get this value (reason why no to use return!!!)
    }
    let iteratorObj = iterator();
    
    for(let i of iteratorObj) {
        itemCollector += i + " ";
    }
// print
    document.getElementById('printIt_for_of').innerHTML = itemCollector;
&lt;/script&gt;
        </pre> 
        </details>
<h4><u> <mark>yield</mark> pause demo </u></h4>
    <p> - every click calls for the next yield until the allert is reached </p>
    <button id="fireGenerator"> Start Generator </button>
    <p id="genResult"> 0 </p>
<script>
    document.getElementById("fireGenerator").addEventListener("click", ()=>{generate()});   // event listener set
    
    let genNr = function*() {               // generator function
        yield 1;
        yield 2;                            // at the 2nd call yield is stoped here (need the 3rd call to invoke the alert below!)
        alert("Generator End Reaced!");     // this is called only after the 2nd yield!
    }
    let genNr_id = genNr();                 // generator bound to an identifier
    
    let generate = function() {             // event listener function fire on every click
        document.getElementById("genResult").innerHTML = genNr_id.next().value;
        console.log("called");
    }
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;button id="fireGenerator"&gt; Start Generator &lt;/button&gt;
    &lt;p id="genResult"&gt; 0 &lt;/p&gt;
&lt;script&gt;
    document.getElementById("fireGenerator").addEventListener("click", ()=>{generate()});   // event listener set
    
    let genNr = function*() {               // generator function
        yield 1;
        yield 2;                            // at the 2nd call yield is stoped here (need the 3rd call to invoke the alert below!)
        alert("Generator End Reaced!");     // this is called only after the 2nd yield!
    }
    let genNr_id = genNr();                 // generator bound to an identifier
    
    let generate = function() {             // event listener function fire on every click
        document.getElementById("genResult").innerHTML = genNr_id.next().value;
        console.log("called");
    }
&lt;/script&gt;    
        </pre>
        </details>
<h4><u> sending a value into the generator function with <mark>next()</mark></u></h4>    
    <p id="sendNext"></p>
<script>
// this stuff is very bizare! :/
    var sendIn = function*() {
        var x;                              // for the 1st call we cannot pas a value with the "next()" method (WTF)
        x = yield 2;            
        x = yield 3 + x;                    // the 2nd call the passed value "yield 2 + x" defines "x"
        yield 4 + x;                        // the 3rd call will set the previous "x" and will be used here
    }
    let sendGen = sendIn();
// print
    document.getElementById("sendNext").innerHTML = 
        sendGen.next().value + " / " +      // returns 2 (1st yield's value)
        sendGen.next(2).value + " / " +     // returns 5 (2nd yield's value), the passed 2 will become the previous yield's value and stored in "x"
        sendGen.next(10).value;             // return 14, passed value 10 set to the previous yield and passed here 
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;p id="sendNext"&gt;&lt;/p&gt;
&lt;script&gt;
// this stuff is very bizare! :/
    var sendIn = function*() {
        var x;                              // for the 1st call we cannot pas a value with the "next()" method (WTF)
        x = yield 2;            
        x = yield 3 + x;                    // the 2nd call the passed value will define the previous yield "yield 2"
        yield 4 + x;                        // the 3rd call will set the previous "x" and will be used here
    }
    let sendGen = sendIn();
// print
    document.getElementById("sendNext").innerHTML = 
        sendGen.next().value + " / " +      // returns 2 (1st yield's value)
        sendGen.next(2).value + " / " +     // returns 5 (2nd yield's value), the passed 2 will become the previous yield's value and stored in "x"
        sendGen.next(10).value;             // return 14, passed value 10 set to the previous yield and passed here 
&lt;/script&gt;
        </pre>
        </details>
<h4><u> test <mark>return()</mark> </u></h4>    
    <p id="return"></p>
<script>
    function* returnGen() {
        yield 1;
        yield 2;                                    // return() called here (2nd call)
        yield 3;                                        // after calling "return()" all the remaining yields are lost!
        yield 4;
    }
    var retGen = returnGen();
// print
    document.getElementById('return').innerHTML = 
        retGen.next().value + " / " +
        retGen.return("Obj Cut!").value + " / " +   // passed value "Obj Cut!" returned as last value
        retGen.next().value;                        // no further yields are reachable!
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;p id="return"&gt;&lt;/p&gt;
&lt;script&gt;
    function* returnGen() {
        yield 1;
        yield 2;                                    // return() called here (2nd call)
        yield 3;                                        // after calling "return()" all the remaining yields are lost!
        yield 4;
    }
    var retGen = returnGen();
// print
    document.getElementById('return').innerHTML = 
        retGen.next().value + " / " +
        retGen.return("Obj Cut!").value + " / " +   // passed value "Obj Cut!" returned as last value
        retGen.next().value;                        // no further yields are reachable!
&lt;/script&gt;   
        </pre>
        </details>
<h4><u> test <mark>throw()</mark> </u></h4>
    <p id="throwIt"></p>
    <p id="throwError"></p>
<script>
    var throwGenerator = function*() {
        yield 1;
        try {   
            yield 2;                                            // exception thrown is handled AFTER the 2nd call (uppon 3rd call!)
        } catch(err) {
            document.getElementById("throwError").innerHTML = err;
        }
        yield 3;                                   
        yield 4;
        yield 5;
        yield 6;
    }
    var throwGen = throwGenerator();
// print
    document.getElementById("throwIt").innerHTML = 
        throwGen.next().value + " / " +
        throwGen.next().value + " / " +
        throwGen.throw("Custom Error Thrown").value + " / " +   // error thrown between 2nd and 3rd value which is handled by the catch statement, therefore the 3rd yield is returned here
        throwGen.next().value; // + " / " +
        // throwGen.throw("Custom Error Thrown 2").value;       // if you would throw this error without handling it it will shut down you entire Generator!
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;p id="throwIt"&gt;&lt;/p&gt;
    &lt;p id="throwError"&gt;&lt;/p&gt;
&lt;script&gt;
    var throwGenerator = function*() {
        yield 1;
        try {   
            yield 2;                                            // exception thrown is handled AFTER the 2nd call (uppon 3rd call!)
        } catch(err) {
            document.getElementById("throwError").innerHTML = err;
        }
        yield 3;                                   
        yield 4;
        yield 5;
        yield 6;
    }
    var throwGen = throwGenerator();
// print
    document.getElementById("throwIt").innerHTML = 
        throwGen.next().value + " / " +
        throwGen.next().value + " / " +
        throwGen.throw("Custom Error Thrown").value + " / " +   // error thrown between 2nd and 3rd value which is handled by the catch statement, therefore the 3rd yield is returned here
        throwGen.next().value; // + " / " +
        // throwGen.throw("Custom Error Thrown 2").value;       // if you would throw this error without handling it it will shut down you entire Generator!
&lt;/script&gt;    
        </pre>
        </details>
<h4><u> delegate <mark>yield*</mark> </u></h4>    
    <p id="delegate"></p>
<script>
    function* mainGen() {
        yield "A";                              // not delegated!
        yield* Array.from(arguments);           // gets the calling arguments "B" "C"
        yield* secondaryGen();                  // delegate to another Generator
        yield* ["F", "G"];                      // Array = iterable Object
        yield* "HI";                            // String is iterable too!
    }
    var genMain = mainGen("B", "C");
    
    function* secondaryGen() {
        yield "D";
        yield "E";
    }
// print
    document.getElementById("delegate").innerHTML = 
        genMain.next().value + " / " +
        genMain.next().value + " / " +
        genMain.next().value + " / " +
        genMain.next().value + " / " +
        genMain.next().value + " / " +
        genMain.next().value + " / " +
        genMain.next().value + " / " +
        genMain.next().value + " / " +
        genMain.next().value + " / " +
        genMain.next().value;                   // "undefined" Generator.prototype is empty
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;p id="delegate"&gt;&lt;/p&gt;
&lt;script&gt;
    function* mainGen() {
        yield "A";                              // not delegated!
        yield* Array.from(arguments);           // gets the calling arguments "B" "C"
        yield* secondaryGen();                  // delegate to another Generator
        yield* ["F", "G"];                      // Array = iterable Object
        yield* "HI";                            // String is iterable too!
    }
    var genMain = mainGen("B", "C");
    
    function* secondaryGen() {
        yield "D";
        yield "E";
    }
// print
    document.getElementById("delegate").innerHTML = 
        genMain.next().value + " / " +
        genMain.next().value + " / " +
        genMain.next().value + " / " +
        genMain.next().value + " / " +
        genMain.next().value + " / " +
        genMain.next().value + " / " +
        genMain.next().value + " / " +
        genMain.next().value + " / " +
        genMain.next().value + " / " +
        genMain.next().value;                   // "undefined" Generator.prototype is empty
&lt;/script&gt;
        </pre>
        </details>
</details>
<!--------------------------------------------------------------------------------------------------------------------------------->
<hr>
<h2 class="headerExtra"><u> Methods <mark>call()</mark> / <mark>apply()</mark> / <mark>bind()</mark> </u></h2>
<details class="example">
<summary> DEMO </summary>
    <pre>
    var audi = {
        mark:"audi", 
        type:"A4", 
        year:2010, 
        allData:function(a, b) {return this.mark + " " + this.type + " " + this.year + a}
    };
    
    var mercedess = {
        mark:"mercedess", type:
        "class C", year:
        2014
    };
    
// call() / apply() ------------------------------------------------------------------- 

    audi.allData.call(mercedess, " is a nice", " car");                                // -> "mercedess class C 2014 is a nice car"    // audi.allData method called on 'mercedess' object 
    audi.allData.apply(mercedess, [" is a nice, " car"]);                              // -> "mercedess class C 2014 is a nice car"    // does the same (uses different syntax)
    
// bind() -----------------------------------------------------------------------------
    var myObj = {p1:21};
    
    var globFn = function(){
        return this;
    }
    
    globFn();                                                                          // -> Window         // references the global object (as expected)
    
    var bindTest = window.globFn.bind(myObj);                                          // the 'window.globFn' 'this' keyword is bound to the 'myObj' object and returned a new function 
    
    bindTest();                                                                        // -> 'myObj'        // the 'this' keyword is bound to the 'myObj' object when the new function is called   
    </pre>
</details>
<details class="example">
<summary> CODE : </summary>
<h4 style="color:darkblue;"><u> the <mark>call()</mark> method </u></h4>
    <p id="call_demo"></p>
<script>
    var mouse_A = {mark:"MadCatz", type:"RAT 8", wired:true, buttunNumbers:12, 
                   printData:function(a) {
                       return "mark : " + this.mark + " | type : " + this.type + " | Wired : " + this.wired + " | button Numbers : " + this.buttunNumbers + a;
                   }};
    var mouse_B = {mark:"Microsoft", type:"54 series", wired:true, buttunNumbers:4};
    var mouse_C = {mark:"Creative", type:"office 7", wired:false, buttunNumbers:7};
    var mouse_D = {mark:"Terminator", type:"T-4", wired:false, buttunNumbers:57};
    
    document.getElementById('call_demo').innerHTML = 
        mouse_A.printData(" / ") + "<br>" +
        mouse_A.printData.call(mouse_B, " / ") + "<br>" +
        mouse_A.printData.call(mouse_C, " / ") + "<br>" +
        mouse_A.printData.call(mouse_D, " / ");
</script>
    <details>
    <summary> CODE : </summary>
    <pre>
    &lt;p id="call_demo"&gt;&lt;/p&gt;
&lt;script&gt;
    var mouse_A = {mark:"MadCatz", type:"RAT 8", wired:true, buttunNumbers:12, 
                   printData:function(a) {
                       return "mark : " + this.mark + " | type : " + this.type + " | Wired : " + this.wired + " | button Numbers : " + this.buttunNumbers + a;
                   }};
    var mouse_B = {mark:"Microsoft", type:"54 series", wired:true, buttunNumbers:4};
    var mouse_C = {mark:"Creative", type:"office 7", wired:false, buttunNumbers:7};
    var mouse_D = {mark:"Terminator", type:"T-4", wired:false, buttunNumbers:57};
    
    document.getElementById('call_demo').innerHTML = 
        mouse_A.printData(" / ") + "&lt;br&gt;" +
        mouse_A.printData.call(mouse_B, " / ") + "&lt;br&gt;" +
        mouse_A.printData.call(mouse_C, " / ") + "&lt;br&gt;" +
        mouse_A.printData.call(mouse_D, " / ");
&lt;/script&gt;
    </pre>
    </details>
    <p id="greetingsCall"></p>
<script>
    var mario = {name:"Mario", 
                 greetings:function(a, b) {
                     return "Hi " + this.name + " it's " + a + " have a " + b + " day!";
                           }
                }; 
    var luigi = {name:"Luigi"};
    var mary = {name:"Mary"};
    var bobby = {name:"Bobby"};
    
    document.getElementById('greetingsCall').innerHTML = 
        mario.greetings("Arpad", "sunny") + "<br>" +
        mario.greetings.call(luigi, "Bircsy", "nice") + "<br>" +
        mario.greetings.call(mary, "Any", "smily") + "<br>" +
        mario.greetings.call(bobby, "the Lucifer", "carpy");
</script>
    <details>
    <summary> CODE : </summary>
    <pre>
    &lt;p id="greetingsCall"&gt;&lt;/p&gt;
&lt;script>
    var mario = {name:"Mario", 
                 greetings:function(a, b) {
                     return "Hi " + this.name + " it's " + a + " have a " + b + " day!";
                           }
                }; 
    var luigi = {name:"Luigi"};
    var mary = {name:"Mary"};
    var bobby = {name:"Bobby"};
    
    document.getElementById('greetingsCall').innerHTML = 
        mario.greetings("Arpad", "sunny") + "&lt;br&gt;" +
        mario.greetings.call(luigi, "Bircsy", "nice") + "&lt;br&gt;" +
        mario.greetings.call(mary, "Any", "smily") + "&lt;br&gt;" +
        mario.greetings.call(bobby, "the Lucifer", "carpy");
&lt;/script&gt;
    </pre>
    </details>
<!--------------------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> the <mark>apply()</mark> method </u></h4>
    <p id="apply_demo"></p>
<script>
(function(){
    var javaScript = {language:"JavaScript", nature:"awesome",
                     description:function() {
                        return this.language + " is " + arguments[0] + " " + this.nature + " programing language " + arguments[1]; 
                     }};
    var rubyOnRails = {language:"Ruby on Rails", nature:"sophisticated"};
    var phyton = {language:"Phyton", nature:"complex"};
    
    document.getElementById('apply_demo').innerHTML = 
        javaScript.description("an", "to learn") + "<br>" +
        javaScript.description.apply(rubyOnRails, ["a", "to have fun with"]) + "<br>" +
        javaScript.description.apply(phyton, ["a", "to play"]);
})();
</script>
    <details>
    <summary> CODE : </summary>
    <pre>
    &lt;p id="apply_demo"&gt;&lt;/p&gt;
&lt;script&gt;
(function(){
    var javaScript = {language:"JavaScript", nature:"awesome",
                     description:function() {
                        return this.language + " is " + arguments[0] + " " + this.nature + " programing language " + arguments[1]; 
                     }};
    var rubyOnRails = {language:"Ruby on Rails", nature:"sophisticated"};
    var phyton = {language:"Phyton", nature:"complex"};
    
    document.getElementById('apply_demo').innerHTML = 
        javaScript.description("an", "to learn") + "&lt;br&gt;" +
        javaScript.description.apply(rubyOnRails, ["a", "to have fun with"]) + "&lt;br&gt;" +
        javaScript.description.apply(phyton, ["a", "to play"]);
})();
&lt;/script&gt;
    </pre>
    </details>
<!--------------------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> using the <mark>apply()</mark> method with the <mark>Math</mark> object </u></h4>
    <p id="apply_with_Math"></p>
<script>
    var nrArray = [4, 74, 24, 84, 12, 54, 44];
    
    document.getElementById('apply_with_Math').innerHTML = 
        " Original Array = " + nrArray + "<br>" +
        " Largerst value = " + Math.max.apply(null, nrArray) + " / " + " Lowest value = " + Math.min.apply(null, nrArray);
                        
                    // the "apply()" method makes it possible to use an array with the "Math.min()" or "Math.max()" methods
</script>
    <details>
    <summary> CODE : </summary>
    <pre>
    &lt;p id="apply_with_Math">&lt;/p&gt;
&lt;script&gt;
    var nrArray = [4, 74, 24, 84, 12, 54, 44];
    
    document.getElementById('apply_with_Math').innerHTML = 
        " Original Array = " + nrArray + "&lt;br&gt;" +
        " Largerst value = " + Math.max.apply(null, nrArray) + " / " + " Lowest value = " + Math.min.apply(null, nrArray);
                        
                    // the "apply()" method makes it possible to use an array with the "Math.min()" or "Math.max()" methods
&lt;/script&gt;
    </pre>
    </details>
<!--------------------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> implement <mark>bind()</mark> method </u></h4>
    <p id="result_bind"></p>
<script>
// global method and variables
    var AA = 41;
    var BB = 12;
    var CC = 11;
        function additionDivide (FF) {
            return (this.AA + this.BB + this.CC) / FF;
        }
            // "window.additionDivide(2);" returns "32"
    
// object properties and method
    var numberS = {AA:41, BB:12, CC:11, additionDivide:function(FF){return (this.AA + this.BB + this.CC) / FF;}}
            // "numberS.additionDivide(2);" returns "32"
    
// implement both these methods on a different object
    var numberX = {AA:11, BB:23, CC:42};
    var additionDivide_extracted = numberS.additionDivide;      // extract the method from the object 
    
    var result_1 = additionDivide.bind(numberX, 2);             // implement the global method on the object
    var result_2 = additionDivide_extracted.bind(numberX, 2);   // implement the extracted methodn on the object
    
    document.getElementById('result_bind').innerHTML = 
        "Implement global method on the object = " + result_1() + "<br>" +
        "Implement extracted methodn on the object = " + result_2();
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;p id="result_bind"&gt;>&lt;/p&gt;
&lt;script&gt;
// global method and variables
    var AA = 41;
    var BB = 12;
    var CC = 11;
        function additionDivide (FF) {
            return (this.AA + this.BB + this.CC) / FF;
        }
            // "window.additionDivide(2);" returns "32"
    
// object properties and method
    var numberS = {AA:41, BB:12, CC:11, additionDivide:function(FF){return (this.AA + this.BB + this.CC) / FF;}}
            // "numberS.additionDivide(2);" returns "32"
    
// implement both these methods on a different object
    var numberX = {AA:11, BB:23, CC:42};
    var additionDivide_extracted = numberS.additionDivide;      // extract the method from the object 
    
    var result_1 = additionDivide.bind(numberX, 2);             // implement the global method on the object
    var result_2 = additionDivide_extracted.bind(numberX, 2);   // implement the extracted methodn on the object
    
    document.getElementById('result_bind').innerHTML = 
        "Implement global method on the object = " + result_1() + "&lt;br&gt;" +
        "Implement extracted methodn on the object = " + result_2();
&lt;/script&gt;
        </pre>
        </details>
</details>
    
    
    
</body>
</html>