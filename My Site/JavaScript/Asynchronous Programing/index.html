<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title> Async Programing </title>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../Assets/stylesPages.css">
    <script src="../../Assets/scriptPages.js"></script>
  </head>
  <body>
    <h1> Async Programing
      <span id="browserSupport" title="updated: 2019-08-06">
        <span><i class="fab fa-chrome"></i> 32 </span>
        <span><i class="fab fa-firefox"></i> 29 </span>
        <span><i class="fab fa-opera"></i> 19 </span>
        <span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 12 </span>
        <span><i class="fab fa-safari"></i> 8 </span>
        <span><i class="fab fa-node-js"></i> 0.12 </span>
      </span>
    </h1>
    <p> Updated ( 2018-08-19 / 2019-09-17 / 2020-06-01 / 2021-01-14 / 2025-03-11 )</p>
    <nav class="sitenav">
      <a href="../../index.html">MySite > </a>
      <a href="../index.html">JavaScript > </a> Async Programming
    </nav>
    <table class="table">
      <tr>
        <th style="width:30%;"> Method / Keyword </th>
        <th> Description </th>
      </tr>
      <tr>
        <td>
          <em>new</em> Promise(<strong class="openable">fn(res, rej)<div>
              <p><b> The Code here does not run asynchronously! </b></p>
              <p> - this callback should call the asynchronous API first </p>
              <p> - calling <mark>res(<strong>resData</strong>)</mark> this Promise will be resolved as <strong>resData</strong> as result </p>
              <p> - calling <mark>rej(<strong>rejData</strong>)</mark> this Promise will be rejected as <strong>resData</strong> as result </p>
            </div></strong>)
        </td>
        <td>
          - a promiswe wrapper tool over some (async) logic
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2"> Consuming Promises </td>
      </tr>
      <tr>
        <td> <strong>promise</strong>.then(<strong>fn(res)</strong><i>, fn(rej)</i>) </td>
        <td>
          - if the Promise is resolved asynchronously calls the first callback with the resolved data as argument <br>
          - returns a resolved Promise (the resolved data will be the returned data by the callback) <br>
          - if the Promise is rejected asynchronously calls the second callback with the rejected data as argument <br>
          - if the Promise is rejected and the 2nd callback is omitted returns the Promise as it is <br>
          - if the Promise is resolved and the 2nd callback is present returns a resolved Promise (the resolved data will be the returned data by the callback)
        </td>
      </tr>
      <tr>
        <td> <strong>promise</strong>.catch(<strong>fn(rej)</strong>) </td>
        <td>
          - if the Promise is rejected asynchronously calls the callback with the rejected data as argument <br>
          - returns a resolved Promise (the resolved data will be the returned data by the callback) <br>
          - if the Promise is resolved returns it as it is
        </td>
      </tr>
      <tr>
        <td> <strong>promise</strong>.finally(<strong>fn</strong>) </td>
        <td>
          - asynchronously calls the callback regardless of a resolved or rejected Promise <br>
          - returns the the Promise as it was received
          <span id="browserSupport" title="updated: 2019-08-06">
            <span><i class="fab fa-chrome"></i> 63 </span>
            <span><i class="fab fa-firefox"></i> 58 </span>
            <span><i class="fab fa-opera"></i> 50 </span>
            <span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 18 </span>
            <span><i class="fab fa-safari"></i> 11.1 </span>
            <span><i class="fab fa-node-js"></i> 10.0.0</span>
          </span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2"> Static Methods </td>
      </tr>
      <tr>
        <td> <em>Promise</em>.resolve(<strong>val:any|promise</strong>) </td>
        <td> - creates and returns a resolved Promise with the passed data
        </td>
      </tr>
      <tr>
        <td> <em>Promise</em>.reject(<strong>val:any|promise</strong>) </td>
        <td> - creates and returns a rejected Promise with the passed data
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <em>Promise</em>.all([<strong>val:any|promise</strong><i>, ...</i>]) </td>
        <td>
          - creates a resolved promise if all passed promises (or values) are resolved (resolved data is collected and returned in an Array)<br>
          - creates a rejected promise if one of the passed promise is rejected (returns the first rejected promise data)
        </td>
      </tr>
      <tr>
        <td> <em>Promise</em>.allSettled([<strong>val:any|promise</strong><i>, ...</i>]) </td>
        <td> - <i class="fab fa-js">2020</i> creates a resolved promise no matter if the passed promises are resolved or rejected (returs an object containing each passed promise data and status)
          <span id="browserSupport" title="updated: 2020-05-01">
            <span><i class="fab fa-chrome"></i> 76 </span>
            <span><i class="fab fa-firefox"></i> 71 </span>
            <span><i class="fab fa-opera"></i> 63 </span>
            <span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 79 </span>
            <span><i class="fab fa-safari"></i> 10 </span>
            <span><i class="fab fa-node-js"></i> 12.9.0 </span>
          </span>
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td></td>
      </tr>
      <tr>
        <td> <em>Promise</em>.race([<strong>val:any|promise</strong><i>, ...</i>]) </td>
        <td>
          - returns the result of the fastest resolved or rejected <strong>promise</strong> from the list
        </td>
      </tr>
      <tr>
        <td> <em>Promise</em>.any([<strong>val:any|prom</strong><i>, ...</i>]) </td>
        <td>
          - returns the result of the fastest resolved <strong>promise</strong> from the list <u>(ignores rejected promises)</u> <br>
          - if all <strong>promise</strong> are rejected returns an <mark>AggregateError</mark>
          <span id="browserSupport" title="updated: 2021-01-14">
            <span><i class="fab fa-chrome"></i> 85 </span>
            <span><i class="fab fa-firefox"></i> 79 </span>
            <span><i class="fab fa-opera"></i> 71 </span>
            <span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 85 </span>
            <span><i class="fab fa-safari"></i> 14 </span>
            <span><i class="fab fa-node-js"></i> 15 </span>
          </span>
        </td>
      </tr>
    </table>
    <br>
    <details class="example" id="notes">
      <summary> Notes :</summary>
    </details>
    <h2 style="color:green;"><u> Useful Links : </u></h2>
    <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank"> Promise (developer.mozilla.org)</a></p>
    <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank"> Async Function (developer.mozilla.org)</a></p>
    <h2 style="color:green;"><u> Remember This : </u></h2>
    <h2 style="color:green;"><u> Description and Demonstration : </u></h2>
    <img src="Async.jpg" height="400">
    <h2 class="headerExtra"><u> The <mark>Promise</mark> (async) object (new in ES6) </u></h2>
    <h2 style="color:darkblue;"><u> The <mark>then()</mark> / <mark>catch()</mark> / <mark>finally()</mark> / <mark>resolve()</mark> / <mark>reject()</mark> / <mark>all()</mark> / <mark>allSetteled()</mark> / <mark>race()</mark> / <mark>any()</mark> methods </u></h2>
    <p> - the Promise object represents the completition or failure of an asynchronous task (like the <mark>fentch()</mark> API) </p>
    <p> - the <mark>Promise()</mark> constructor can be uses as a <u>wrapper</u> for asynchronous APIs <u>(the code inside does not run asynchronously as I thought)</u>
      <p> - a Promise can have 3 states <mark>pending</mark> / <mark>resolved</mark> / <mark>rejected</mark> </p>
      <p> - the Promise API basically offers a more convenient way to handle asynchronously APIs </p>
      <details class="example">
        <summary> DEMO </summary>
        <p> - "Promisifying" asynchronous APIs </p>
        <pre>
// creating a Promise -----------------------------------------------------------------
    var timerPromise = new Promise(function(res, rej){                                 // we basically profisifying the setTimeout asynchronous API here    
        setTimeout(function(){
            res('time elapsed!')                                                       // promise will be resolved with this data 
            // rej('rejec')                                                            // this would create a rejected promise 
        }, 1000);
    });
    </pre>
        <p> - consuming Promises <u>(all <mark>then()</mark> / <mark>catch()</mark> / <mark>finally</mark> callbacks fires asynchronously!)</u> </p>
        <pre>
    var resPromise = Promise.resolve('resolved!');                                     // resolved promise 
    var rejPromise = Promise.reject('rejected!');                                      // rejected promise 
        
// then() -----------------------------------------------------------------------------
    resPromise                                                                         // resolved promise 
        .then(res => { res; return "resModified" },                                    // -> res = 'resolved'       // returns a new resolved Promise with 'resModified'  
              rej => { rej })                                                              // 2nd callback not fired 
        .then(res => { res },                                                          // -> res = 'resModified'    // returns a new resolved Promise with undefined (no return)
              rej => { rej })                                                              // 2nd callback not fired 
              
    rejPromise                                                                         // rejected promise 
        .then(res => { res },                                                              // 1st callback not fired 
              rej => { rej; return 'rejModified'})                                     // -> rej = 'rejected'       // returns a new resolved Promise with 'rejModified' 
        .then(res => { res },                                                          // -> res = 'rejModified'
              rej => { rej });
    
    rejPromise                                                                         // rejected promise 
        .then(res => { res },                                                          // 1st callback not fired    // returns the rejected Promise as it was received (no 2nd callback) 
        .then(res => { res },                                                              // 1st callback not fired 
              rej => { rej });                                                         // -> rej = 'rejected'       // -! always handle rejection   
    
// catch() ----------------------------------------------------------------------------
    resPromise                                                                         // resolved promise    
        .catch(err => { err })                                                         // callback not fired        // returns the resolved Promise as it was received 
        .then(res => { res })                                                          // -> res = 'resolved'  
    
    rejPromise                                                                         // rejected promise    
        .catch(err => { err; return 'rejModified'})                                    // -> err = 'rejected'       // returns a new resolved Promise with 'rejModified'   
        .then(res => { res })                                                          // -> res = 'rejModified'
    
// finally() --------------------------------------------------------------------------
    resPromise                                                                         // resolved promise 
        .finally(() => { })                                                            // callback fired            // returns the resolved Promise as it was received 
        .then(res => { res })                                                          // -> res = 'resolved'
    
    rejPromise                                                                         // rejected promise 
        .finally(() => { })                                                            // callback fired            // returns the rejected Promise as it was received  
        .catch(err => { err })                                                         // -> res = 'rejected'
    </pre>
        <pre>
// resolve() / reject() ---------------------------------------------------------------
    Promise.resolve("resolved");                                                       // -> Promise                // creates and returns a resolved Promise with 'resolved'    
    Promise.reject("reject");                                                          // -> Promise                // creates and returns a rejected Promise with 'reject'   
    
    
// all() / allSettle()-----------------------------------------------------------------
    Promise.all([Promise.resolve("resolved 1"), Promise.resolve("resolved 2"), Promise.resolve("resolved 3")])
        .then(res => res,                                                              // -> ["resolved 1", "resolved 2", "resolved 3"]   // all promises are resolved and their values are returned in an Array    
              rej => rej);
              
    Promise.all([Promise.resolve("resolved 1"), Promise.resolve("resolved 2"), Promise.reject("reject 3"), Promise.reject("reject 4")])
        .then(res => res, 
              rej => rej);                                                             // -> "reject 3"                                   // the first rejected promise's value is returned 
    
    
    Promise.allSettled([Promise.resolve("resolved 1"), Promise.resolve("resolved 2"), Promise.resolve("resolved 3")])
        .then(res => res,                                                              // -> [{status:'fulfilled', value:'resolved 1'}, {status:'fulfilled', value:'resolved 2'}, {status:'fulfilled',value:'resolved 3'}]   
              rej => rej);
              
    Promise.allSettled([Promise.resolve("resolved 1"), Promise.resolve("resolved 2"), Promise.reject("reject 3"), Promise.reject("reject 4")])
        .then(res => res, 
              rej => rej);                                                             // -> [{status:'fulfilled', value:'resolved 1'}, {status:'fulfilled', value:'resolved 2'}, {status:'rejected', reason:'reject 3'}, {status:'rejected', reason:'reject 4'}]    
    
// race() / any() ---------------------------------------------------------------------
    Promise.race([Promise.reject("reject 1"), Promise.resolve("resolved 2"), Promise.reject("reject 3")])                                 // returns the fastest Promise 
        .then(res => res,                                                                  
              rej => rej);                                                             // -> 'reject 1'
        
    Promise.any([Promise.reject("reject 1"), Promise.resolve("resolved 2"), Promise.reject("reject 3")])                                  // returns the fastest resolved Promise 
        .then(res => res,                                                              // -> 'resolved 2'    
              rej => rej);                                                             
              
    Promise.any([Promise.reject("reject 1"), Promise.reject("reject 2"), Promise.reject("reject 3")])
        .then(res => res,                                                              
              rej => rej);                                                             // -> 'AggregateError: All promises were rejected'
    </pre>
      </details>
      <!--------------------------------------------------------------------------------------------------------------------->
      <hr>
      <h2 id="await_" class="header"><u> The async function <mark>async</mark> / <mark>await</mark> </u></h2>
      <p> - we can use async functions to write custom promise based asynchronous APIs </p>
      <pre class="syntax">
    async function <strong>fnId</strong>() {                      // returns a Promise    
        <small>await</small> <strong>promise</strong>             // pauses the async function body utill the promise is resolved or rejected    
                                                                  // -! resolved promise = the resolved data is returned and function body continues execution</span> 
                                                                  // -! rejected promise = blocks the function body and the rejected promise is returned by the async function </span> 
                
        return <strong>promise|val:any</strong>                    // any returned data will be wrapped in a resolved promise by the async function 
                                                                    // or we can return the awaited resolved Promise simply  
        throw <strong>val:any</strong>                              // any thrown data will be wrappend in a rejected promise by the async function 
    }   
    </pre>
      <details class="example">
        <summary> DEMO </summary>
        <pre>
// async function (return / throw) ----------------------------------------------------
    async function testAsync1() { return 'resolved data'; }                            // -> Promise{resolved}  // any returned data will be returned as resolved promise value    
    
    async function testAsync2() { throw 'rejected data'; }                             // -> Promise{rejected}  // if JavaScript throws or throwing manually any data will be returned as rejected promise value    
    
    testAsync1()
        .then(res => console.log(res),                                                 // -> 'resolved data'
              rej => console.log(rej));
              
    testAsync2()
        .then(res => console.log(res), 
              rej => console.log(rej));                                                // -> 'rejected data'
    
    
// await ------------------------------------------------------------------------------
    async function asyncFunc1() {
        var promise = Promise.resolve('resolved result!');                             // resolved Promise 
        await promise;                                                                 // -> 'resolved result!' // function body pauses untill the promise is resolved, if the promise is resolved its value is retured here   
        
        // further code will execute when the promise is resolved ....
        
        return promise;                                                                // we simply return the resolved Promise here     
    }
    
    async function asyncFunc2() {
        var promise = Promise.reject('rejected result!');                              // rejected Promise    
        await promise;                                                                 // function blocked and the rejected Promise is returned by the async function 
        
        // -! no further code will be executed because the await promise is rejected 
    }
    
    
    asyncFunc1()                                                                          
        .then(res => res)                                                              // -> 'resolved result'
        .catch(rej => rej);                                               
        
    asyncFunc1()
        .then(res => res) 
        .catch(rej => rej);                                                            // -> 'rejected result'
    </pre>
      </details>

      <br><br>
    </body>
  </html>